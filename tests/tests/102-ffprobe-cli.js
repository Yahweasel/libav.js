/*
 * Copyright (C) 2023 Yahweasel and contributors
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

const libav = await h.LibAV();

// Check that ffprobe gives consistent output version to version
let hadUncached = false;
for (const file of h.files) {
    if (!/^bbb/.test(file))
        continue;

    // Capture stdout
    let stdoutParts = [];
    await libav.mkwriterdev("stdout");
    libav.onwrite = (name, pos, data) => {
        stdoutParts.push(data.slice(0));
    };

    // Run ffprobe
    await libav.ffprobe(
        "-loglevel", "0",
        "-print_format", "json",
        "-show_streams", "-show_format",
        "-o", "stdout",
        file.name);
    await libav.unlink("stdout");
    const jsonBlob = new Blob(stdoutParts);
    stdoutParts = [];
    const jsonAB = await jsonBlob.arrayBuffer();
    const jsonU8 = new Uint8Array(jsonAB);
    const td = new TextDecoder();
    const jsonText = td.decode(jsonU8);
    const json = JSON.parse(jsonText);

    // Check it
    if (!(file.name in h.data.ffprobeExpected)) {
        h.printErr(`Warning! ffprobe output for ${file.name} is not cached!`);
        hadUncached = true;
        h.data.ffprobeExpected[file.name] = json;
    } else {
        // FIXME: compare them
    }
}

if (hadUncached) {
    h.print("// Generated by 102-ffprobe-cli");
    h.print(`h.data.ffprobeExpected = ${JSON.stringify(h.data.ffprobeExpected)};`);
}
