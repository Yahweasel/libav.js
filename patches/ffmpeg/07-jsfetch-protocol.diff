Index: ffmpeg-6.0.1/libavformat/Makefile
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/Makefile
+++ ffmpeg-6.0.1/libavformat/Makefile
@@ -691,6 +691,10 @@ OBJS-$(CONFIG_UDP_PROTOCOL)
 OBJS-$(CONFIG_UDPLITE_PROTOCOL)          += udp.o ip.o
 OBJS-$(CONFIG_UNIX_PROTOCOL)             += unix.o
 
+# libav.js
+OBJS-$(CONFIG_JSFETCH_PROTOCOL)          += jsfetch.o
+# /libav.js
+
 # external library protocols
 OBJS-$(CONFIG_LIBAMQP_PROTOCOL)          += libamqp.o urldecode.o
 OBJS-$(CONFIG_LIBRIST_PROTOCOL)          += librist.o
Index: ffmpeg-6.0.1/libavformat/hls.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/hls.c
+++ ffmpeg-6.0.1/libavformat/hls.c
@@ -673,6 +673,8 @@ static int open_url(AVFormatContext *s,
         is_http = 1;
     } else if (av_strstart(proto_name, "data", NULL)) {
         ;
+    } else if (av_strstart(proto_name, "jsfetch", NULL)) {
+        ;
     } else
         return AVERROR_INVALIDDATA;
 
Index: ffmpeg-6.0.1/libavformat/jsfetch.c
===================================================================
--- /dev/null
+++ ffmpeg-6.0.1/libavformat/jsfetch.c
@@ -0,0 +1,335 @@
+/*
+ * JavaScript fetch metaprotocol for ffmpeg client
+ * Copyright (c) 2023 Yahweasel and contributors
+ *
+ * This file is part of FFmpeg in libav.js. The following license applies only
+ * to this file.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "config.h"
+#include "config_components.h"
+
+#include "libavutil/error.h"
+#include "libavutil/opt.h"
+
+#include "url.h"
+
+#include <emscripten.h>
+#include <errno.h>
+
+typedef struct JSFetchContext {
+    const AVClass *class;
+    // All of the real information is stored in a JavaScript structure
+    int idx;
+    uint64_t off, filesize;
+    int seekable;
+} JSFetchContext;
+
+static const AVOption options[] = {
+    { NULL }
+};
+
+#if CONFIG_JSFETCH_PROTOCOL
+static const AVClass jsfetch_context_class = {
+    .class_name = "jsfetch",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT
+};
+
+/**
+ * Open a fetch connection (JavaScript side).
+ */
+EM_JS(int, jsfetch_open_js, (const char *url, uint64_t start_offset), {
+    return Asyncify.handleAsync(function() {
+            url = UTF8ToString(url);
+            var fetchUrl = url.slice(0, 8) === "jsfetch:" ? url.slice(8) : url;
+        return Promise.all([]).then(function() {
+            var fetchOptions = {};
+            
+            if (start_offset > 0) {
+                fetchOptions.headers = {
+                    'Range': 'bytes=' + start_offset + '-'
+                };
+            }
+            
+            // Create AbortController for cancellation
+            var abortController = new AbortController();
+            fetchOptions.signal = abortController.signal;
+            
+            return fetch(fetchUrl, fetchOptions).then(function(response) {
+                return {response: response, abortController: abortController};
+            });
+        }).then(function(result) {
+            var response = result.response;
+            var abortController = result.abortController;
+            if (!Module.libavjsJSFetch)
+                Module.libavjsJSFetch = {ctr: 1, fetches: {}};
+            var jsf = Module.libavjsJSFetch;
+            var idx = jsf.ctr++;
+            var reader = response.body.getReader();
+            var jsfo = jsf.fetches[idx] = {
+                url: fetchUrl,
+                response: response,
+                reader: reader,
+                abortController: abortController,
+                buf: null,
+                rej: null,
+                filesize: 0,
+            };
+            
+            var contentLength = response.headers.get('Content-Length');
+            var contentRange = response.headers.get('Content-Range');
+            
+            if (contentRange) {
+                // Parse "bytes start-end/total" format
+                var match = contentRange.match(/bytes \\\\d+-\\\\d+\\\\/(\\\\d+)/);
+                if (match) {
+                    jsfo.filesize = parseInt(match[1]);
+                }
+            } else if (contentLength && start_offset === 0) {
+                jsfo.filesize = parseInt(contentLength);
+            }
+            return idx;
+        }).catch(function(ex) {
+            Module.fsThrownError = ex;
+            console.error(ex);
+            return -11 /* ECANCELED */;
+        });
+    });
+});
+
+/**
+ * Get file size from JavaScript side.
+ */
+EM_JS(uint64_t, jsfetch_get_filesize_js, (int idx), {
+    var jsfo = Module.libavjsJSFetch.fetches[idx];
+    return jsfo ? jsfo.filesize : 0;
+});
+
+/**
+ * Open a fetch connection.
+ */
+static int jsfetch_open(URLContext *h, const char *url, int flags, AVDictionary **options)
+{
+    JSFetchContext *ctx = h->priv_data;
+    ctx->off = 0;
+    ctx->seekable = -1; // probe seekability
+    ctx->idx = jsfetch_open_js(url, 0);
+    
+    if (ctx->idx > 0) {
+        ctx->filesize = jsfetch_get_filesize_js(ctx->idx);
+        // If we got a filesize, assume seekable. Otherwise keep as streaming.
+        if (ctx->filesize > 0) {
+            h->is_streamed = 0;
+            ctx->seekable = 1;
+        } else {
+            h->is_streamed = 1;
+            ctx->seekable = 0;
+        }
+        return 0;
+    }
+    return ctx->idx;
+}
+
+/**
+ * Read from a fetch connection (JavaScript side).
+ */
+EM_JS(int, jsfetch_read_js, (int idx, unsigned char *toBuf, int size), {
+      var jsfo = Module.libavjsJSFetch.fetches[idx];
+      return Asyncify.handleAsync(async function () {
+        try {
+          if (jsfo.buf && jsfo.buf.value && jsfo.buf.value.length > 0) {
+            const chunk = jsfo.buf.value;
+            const len = Math.min(size, chunk.length);
+
+            Module.HEAPU8.set(chunk.subarray(0, len), toBuf);
+            jsfo.buf.value = chunk.subarray(len);
+            if (jsfo.buf.value.length === 0) {
+              jsfo.buf = null;
+            }
+            return len;
+          }
+
+          const res = await jsfo.reader.read();
+          if (res.done) {
+            return -0x20464f45;
+          }
+
+          const chunk = res.value;
+          const len = Math.min(size, chunk.length);
+          Module.HEAPU8.set(chunk.subarray(0, len), toBuf);
+
+          if (chunk.length > len) {
+            jsfo.buf = { value: chunk.subarray(len) };
+          } else {
+            jsfo.buf = null;
+          }
+
+          return len;
+        } catch (e) {
+          console.error("jsfetch_read_js error", e);
+          Module.fsThrownError = e;
+          return -11;
+        }
+      });
+});
+
+/**
+ * Read from a fetch connection.
+ */
+static int jsfetch_read(URLContext *h, unsigned char *buf, int size)
+{
+    JSFetchContext *ctx = h->priv_data;
+    return jsfetch_read_js(ctx->idx, buf, size);
+}
+
+EM_JS(int, jsfetch_seek_js, (int old_idx, const char *url, uint64_t start_offset), {
+    return Asyncify.handleAsync(function () {
+        url = UTF8ToString(url);
+        var fetchUrl = url.slice(0, 8) === "jsfetch:" ? url.slice(8) : url;
+        return Promise.all([])
+          .then(function () {
+            var fetchOptions = {
+              headers: { Range: "bytes=" + start_offset + "-" },
+            };
+            var abortController = new AbortController();
+            fetchOptions.signal = abortController.signal;
+            return fetch(fetchUrl, fetchOptions).then(function (response) {
+              return { response: response, abortController: abortController };
+            });
+          })
+          .then(function (result) {
+            var response = result.response;
+            var abortController = result.abortController;
+            if (!Module.libavjsJSFetch)
+              Module.libavjsJSFetch = { ctr: 1, fetches: {} };
+            var jsf = Module.libavjsJSFetch;
+            if (old_idx > 0 && jsf.fetches[old_idx]) {
+              try {
+                jsf.fetches[old_idx].buf = null;
+                jsf.fetches[old_idx].reader.cancel();
+                if (jsf.fetches[old_idx].abortController) {
+                  jsf.fetches[old_idx].abortController.abort();
+                }
+              } catch (ex) {}
+              delete jsf.fetches[old_idx];
+            }
+            var idx = jsf.ctr++;
+            var reader = response.body.getReader();
+            var jsfo = (jsf.fetches[idx] = {
+              url: fetchUrl,
+              response: response,
+              reader: reader,
+              abortController: abortController,
+              buf: null,
+              rej: null,
+              filesize: 0,
+            });
+            var contentRange = response.headers.get("Content-Range");
+            if (contentRange) {
+              var match = contentRange.match(/bytes \\\\d+-\\\\d+\\\\/(\\\\d+)/);
+              if (match) {
+                jsfo.filesize = parseInt(match[1]);
+              }
+            }
+
+            return idx;
+          })
+          .catch(function (ex) {
+            Module.fsThrownError = ex;
+            console.error(ex);
+            return -11;
+          });
+      });
+});
+
+/**
+ * Close a fetch connection (JavaScript side).
+ */
+EM_JS(void, jsfetch_close_js, (int idx), {
+    var jsfo = Module.libavjsJSFetch.fetches[idx];
+    if (jsfo) {
+        try {
+            jsfo.reader.cancel();
+            if (jsfo.abortController) {
+                jsfo.abortController.abort();
+            }
+        } catch (ex) {}
+        delete Module.libavjsJSFetch.fetches[idx];
+    }
+});
+
+/**
+ * Seek to a position in the fetch stream.
+ */
+static int64_t jsfetch_seek(URLContext *h, int64_t off, int whence)
+{
+    JSFetchContext *ctx = h->priv_data;
+    int64_t old_off = ctx->off;
+    
+    if (whence == AVSEEK_SIZE)
+        return ctx->filesize;
+    else if (((whence == SEEK_CUR && off == 0) ||
+              (whence == SEEK_SET && off == ctx->off)))
+        return ctx->off;
+    else if ((ctx->filesize == UINT64_MAX && whence == SEEK_END))
+        return AVERROR(ENOSYS);
+
+    if (whence == SEEK_CUR)
+        off += ctx->off;
+    else if (whence == SEEK_END)
+        off += ctx->filesize;
+    else if (whence != SEEK_SET)
+        return AVERROR(EINVAL);
+    if (off < 0)
+        return AVERROR(EINVAL);
+    ctx->off = off;
+
+    if (ctx->off && h->is_streamed)
+        return AVERROR(ENOSYS);
+
+    int new_idx = jsfetch_seek_js(ctx->idx, h->filename, off);
+    if (new_idx < 0) {
+       ctx->off = old_off;
+       return old_off;
+    }
+    
+    ctx->idx = new_idx;
+
+    return off;
+}
+
+/**
+ * Close a fetch connection.
+ */
+static int jsfetch_close(URLContext *h)
+{
+    JSFetchContext *ctx = h->priv_data;
+    jsfetch_close_js(ctx->idx);
+    return 0;
+}
+
+const URLProtocol ff_jsfetch_protocol = {
+    .name               = "jsfetch",
+    .url_open2          = jsfetch_open,
+    .url_read           = jsfetch_read,
+    .url_seek           = jsfetch_seek,
+    .url_close          = jsfetch_close,
+    .priv_data_size     = sizeof(JSFetchContext),
+    .priv_data_class    = &jsfetch_context_class,
+    .flags              = URL_PROTOCOL_FLAG_NETWORK,
+    .default_whitelist  = "jsfetch,http,https"
+};
+#endif
Index: ffmpeg-6.0.1/libavformat/protocols.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/protocols.c
+++ ffmpeg-6.0.1/libavformat/protocols.c
@@ -76,6 +76,10 @@ extern const URLProtocol ff_libzmq_proto
 extern const URLProtocol ff_ipfs_gateway_protocol;
 extern const URLProtocol ff_ipns_gateway_protocol;
 
+/* libav.js */
+extern const URLProtocol ff_jsfetch_protocol;
+/* /libav.js */
+
 #include "libavformat/protocol_list.c"
 
 const AVClass *ff_urlcontext_child_class_iterate(void **iter)
