{
 "av_ac3_parse_header": {
  "type": "int",
  "definition": "int av_ac3_parse_header",
  "argsstring": "(const uint8_t *buf, size_t size, uint8_t *bitstream_id, uint16_t *frame_size)",
  "name": "av_ac3_parse_header",
  "param": [
   {
    "type": "const uint8_t *",
    "declname": "buf"
   },
   {
    "type": "size_t",
    "declname": "size"
   },
   {
    "type": "uint8_t *",
    "declname": "bitstream_id"
   },
   {
    "type": "uint16_t *",
    "declname": "frame_size"
   }
  ],
  "briefdescription": {
   "para": "Extract the bitstream ID and the frame size from AC-3 data."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/ac3_parser.h",
   "@_line": "32",
   "@_column": "5",
   "@_declfile": "libavcodec/ac3_parser.h",
   "@_declline": "32",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "ac3__parser_8h_1a014d5c8ce40e3cc96e6347fc7ea1d4bf",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Extract the bitstream ID and the frame size from AC-3 data.\n */"
 },
 "AVAdler": {
  "type": "uint32_t",
  "definition": "typedef uint32_t AVAdler",
  "argsstring": "",
  "name": "AVAdler",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/adler32.h",
   "@_line": "42",
   "@_column": "18",
   "@_bodyfile": "libavutil/adler32.h",
   "@_bodystart": "42",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavu__adler32_1gaa1fc34ecef1c15fc65876c3a713ae7f4",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * @defgroup lavu_adler32 Adler-32\n * @ingroup lavu_hash\n * Adler-32 hash function implementation.\n *\n * @{\n */"
 },
 "av_adler32_update": {
  "type": {
   "ref": {
    "#text": "AVAdler",
    "@_refid": "group__lavu__adler32_1gaa1fc34ecef1c15fc65876c3a713ae7f4",
    "@_kindref": "member"
   }
  },
  "definition": "AVAdler av_adler32_update",
  "argsstring": "(AVAdler adler, const uint8_t *buf, size_t len) av_pure",
  "name": "av_adler32_update",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVAdler",
      "@_refid": "group__lavu__adler32_1gaa1fc34ecef1c15fc65876c3a713ae7f4",
      "@_kindref": "member"
     }
    },
    "declname": "adler"
   },
   {
    "type": "const uint8_t *",
    "declname": "buf"
   },
   {
    "type": "size_t",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Calculate the Adler32 checksum of a buffer."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_adler32_update()",
      "@_refid": "group__lavu__adler32_1gac5c83e7d8c8cba8534f9b8ccbab072a1",
      "@_kindref": "member"
     },
     "#text": "Passing the return value to a subsequentcall allows the checksum of multiple buffers to be calculated as though they were concatenated."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "adler"
        },
        "parameterdescription": {
         "para": "initial checksum value"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "pointer to input buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "len"
        },
        "parameterdescription": {
         "para": "size of input buffer"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "updated checksum",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/adler32.h",
   "@_line": "56",
   "@_column": "9",
   "@_declfile": "libavutil/adler32.h",
   "@_declline": "56",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavu__adler32_1gac5c83e7d8c8cba8534f9b8ccbab072a1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Calculate the Adler32 checksum of a buffer.\n *\n * Passing the return value to a subsequent av_adler32_update() call\n * allows the checksum of multiple buffers to be calculated as though\n * they were concatenated.\n *\n * @param adler initial checksum value\n * @param buf   pointer to input buffer\n * @param len   size of input buffer\n * @return      updated checksum\n */"
 },
 "av_adts_header_parse": {
  "type": "int",
  "definition": "int av_adts_header_parse",
  "argsstring": "(const uint8_t *buf, uint32_t *samples, uint8_t *frames)",
  "name": "av_adts_header_parse",
  "param": [
   {
    "type": "const uint8_t *",
    "declname": "buf"
   },
   {
    "type": "uint32_t *",
    "declname": "samples"
   },
   {
    "type": "uint8_t *",
    "declname": "frames"
   }
  ],
  "briefdescription": {
   "para": "Extract the number of samples and frames from AAC data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "buf",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "pointer to AAC data buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "samples",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "Pointer to where number of samples is written"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "frames",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "Pointer to where number of frames is written"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "Returns 0 on success, error code on failure.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/adts_parser.h",
   "@_line": "34",
   "@_column": "5",
   "@_declfile": "libavcodec/adts_parser.h",
   "@_declline": "34",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "adts__parser_8h_1a43e046b9b6ae5af2bfdb32bf03ef129d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Extract the number of samples and frames from AAC data.\n * @param[in]  buf     pointer to AAC data buffer\n * @param[out] samples Pointer to where number of samples is written\n * @param[out] frames  Pointer to where number of frames is written\n * @return Returns 0 on success, error code on failure.\n */"
 },
 "av_aes_size": {
  "type": "const int",
  "definition": "const int av_aes_size",
  "argsstring": "",
  "name": "av_aes_size",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes.h",
   "@_line": "34",
   "@_column": "18",
   "@_declfile": "libavutil/aes.h",
   "@_declline": "34",
   "@_declcolumn": "18"
  },
  "@_kind": "variable",
  "@_id": "group__lavu__aes_1ga33e4afb2c0eb4d7ead8a5b0a7fed4142",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * @defgroup lavu_aes AES\n * @ingroup lavu_crypto\n * @{\n */"
 },
 "av_aes_alloc": {
  "type": "struct AVAES *",
  "definition": "struct AVAES * av_aes_alloc",
  "argsstring": "(void)",
  "name": "av_aes_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVAES context."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes.h",
   "@_line": "41",
   "@_column": "12",
   "@_declfile": "libavutil/aes.h",
   "@_declline": "41",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes_1ga4122428256b177af257a30a2438ecf25",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVAES context.\n */"
 },
 "av_aes_init": {
  "type": "int",
  "definition": "int av_aes_init",
  "argsstring": "(struct AVAES *a, const uint8_t *key, int key_bits, int decrypt)",
  "name": "av_aes_init",
  "param": [
   {
    "type": "struct AVAES *",
    "declname": "a"
   },
   {
    "type": "const uint8_t *",
    "declname": "key"
   },
   {
    "type": "int",
    "declname": "key_bits"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Initialize an AVAES context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "The AVAES context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "Pointer to the key"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key_bits"
       },
       "parameterdescription": {
        "para": "128, 192 or 256"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes.h",
   "@_line": "51",
   "@_column": "5",
   "@_declfile": "libavutil/aes.h",
   "@_declline": "51",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes_1ga54975ad71f0eab2287e3e94d561d0aa4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize an AVAES context.\n *\n * @param a The AVAES context\n * @param key Pointer to the key\n * @param key_bits 128, 192 or 256\n * @param decrypt 0 for encryption, 1 for decryption\n */"
 },
 "av_aes_crypt": {
  "type": "void",
  "definition": "void av_aes_crypt",
  "argsstring": "(struct AVAES *a, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt)",
  "name": "av_aes_crypt",
  "param": [
   {
    "type": "struct AVAES *",
    "declname": "a"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "uint8_t *",
    "declname": "iv"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypt or decrypt a buffer using a previously initialized context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "The AVAES context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of 16 byte blocks"
       }
      },
      {
       "parameternamelist": {
        "parametername": "iv"
       },
       "parameterdescription": {
        "para": "initialization vector for CBC mode, if NULL then ECB will be used"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes.h",
   "@_line": "63",
   "@_column": "6",
   "@_declfile": "libavutil/aes.h",
   "@_declline": "63",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes_1gae2572febc1bdf0b6dcb8b313da69e06f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Encrypt or decrypt a buffer using a previously initialized context.\n *\n * @param a The AVAES context\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param count number of 16 byte blocks\n * @param iv initialization vector for CBC mode, if NULL then ECB will be used\n * @param decrypt 0 for encryption, 1 for decryption\n */"
 },
 "av_aes_ctr_alloc": {
  "type": "struct AVAESCTR *",
  "definition": "struct AVAESCTR * av_aes_ctr_alloc",
  "argsstring": "(void)",
  "name": "av_aes_ctr_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVAESCTR context."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes_ctr.h",
   "@_line": "43",
   "@_column": "15",
   "@_declfile": "libavutil/aes_ctr.h",
   "@_declline": "43",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes__ctr_1ga1bb3a25bb42767fce2c4bc9ea94013a5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVAESCTR context.\n */"
 },
 "av_aes_ctr_init": {
  "type": "int",
  "definition": "int av_aes_ctr_init",
  "argsstring": "(struct AVAESCTR *a, const uint8_t *key)",
  "name": "av_aes_ctr_init",
  "param": [
   {
    "type": "struct AVAESCTR *",
    "declname": "a"
   },
   {
    "type": "const uint8_t *",
    "declname": "key"
   }
  ],
  "briefdescription": {
   "para": "Initialize an AVAESCTR context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "The AVAESCTR context to initialize"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "encryption key, must have a length of AES_CTR_KEY_SIZE"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes_ctr.h",
   "@_line": "51",
   "@_column": "5",
   "@_declfile": "libavutil/aes_ctr.h",
   "@_declline": "51",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes__ctr_1ga37ef9fcf05bf94767b2bf18edca7ffda",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize an AVAESCTR context.\n *\n * @param a The AVAESCTR context to initialize\n * @param key encryption key, must have a length of AES_CTR_KEY_SIZE\n */"
 },
 "av_aes_ctr_free": {
  "type": "void",
  "definition": "void av_aes_ctr_free",
  "argsstring": "(struct AVAESCTR *a)",
  "name": "av_aes_ctr_free",
  "param": {
   "type": "struct AVAESCTR *",
   "declname": "a"
  },
  "briefdescription": {
   "para": "Release an AVAESCTR context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "a"
      },
      "parameterdescription": {
       "para": "The AVAESCTR context"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes_ctr.h",
   "@_line": "58",
   "@_column": "6",
   "@_declfile": "libavutil/aes_ctr.h",
   "@_declline": "58",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes__ctr_1ga651580f87845fc3ba201abeecb5442e6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Release an AVAESCTR context.\n *\n * @param a The AVAESCTR context\n */"
 },
 "av_aes_ctr_crypt": {
  "type": "void",
  "definition": "void av_aes_ctr_crypt",
  "argsstring": "(struct AVAESCTR *a, uint8_t *dst, const uint8_t *src, int size)",
  "name": "av_aes_ctr_crypt",
  "param": [
   {
    "type": "struct AVAESCTR *",
    "declname": "a"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Process a buffer using a previously initialized context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "The AVAESCTR context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "the size of src and dst"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes_ctr.h",
   "@_line": "68",
   "@_column": "6",
   "@_declfile": "libavutil/aes_ctr.h",
   "@_declline": "68",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes__ctr_1ga5349eb4f428e432e09617c18195014d8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Process a buffer using a previously initialized context.\n *\n * @param a The AVAESCTR context\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param size the size of src and dst\n */"
 },
 "av_aes_ctr_get_iv": {
  "type": "const uint8_t *",
  "definition": "const uint8_t * av_aes_ctr_get_iv",
  "argsstring": "(struct AVAESCTR *a)",
  "name": "av_aes_ctr_get_iv",
  "param": {
   "type": "struct AVAESCTR *",
   "declname": "a"
  },
  "briefdescription": {
   "para": "Get the current iv."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes_ctr.h",
   "@_line": "73",
   "@_column": "15",
   "@_declfile": "libavutil/aes_ctr.h",
   "@_declline": "73",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes__ctr_1gae4bb4bb038d0afeca34904bf32c47c34",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the current iv\n */"
 },
 "av_aes_ctr_set_random_iv": {
  "type": "void",
  "definition": "void av_aes_ctr_set_random_iv",
  "argsstring": "(struct AVAESCTR *a)",
  "name": "av_aes_ctr_set_random_iv",
  "param": {
   "type": "struct AVAESCTR *",
   "declname": "a"
  },
  "briefdescription": {
   "para": "Generate a random iv."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes_ctr.h",
   "@_line": "78",
   "@_column": "6",
   "@_declfile": "libavutil/aes_ctr.h",
   "@_declline": "78",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes__ctr_1ga93eb462d10972d618f3c7a3a945240eb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Generate a random iv\n */"
 },
 "av_aes_ctr_set_iv": {
  "type": "void",
  "definition": "void av_aes_ctr_set_iv",
  "argsstring": "(struct AVAESCTR *a, const uint8_t *iv)",
  "name": "av_aes_ctr_set_iv",
  "param": [
   {
    "type": "struct AVAESCTR *",
    "declname": "a"
   },
   {
    "type": "const uint8_t *",
    "declname": "iv"
   }
  ],
  "briefdescription": {
   "para": "Forcefully change the 8-byte iv."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes_ctr.h",
   "@_line": "83",
   "@_column": "6",
   "@_declfile": "libavutil/aes_ctr.h",
   "@_declline": "83",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes__ctr_1ga1d5f73ba7cd7ea7c09b21218c39951f9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Forcefully change the 8-byte iv\n */"
 },
 "av_aes_ctr_set_full_iv": {
  "type": "void",
  "definition": "void av_aes_ctr_set_full_iv",
  "argsstring": "(struct AVAESCTR *a, const uint8_t *iv)",
  "name": "av_aes_ctr_set_full_iv",
  "param": [
   {
    "type": "struct AVAESCTR *",
    "declname": "a"
   },
   {
    "type": "const uint8_t *",
    "declname": "iv"
   }
  ],
  "briefdescription": {
   "para": "Forcefully change the \"full\" 16-byte iv, including the counter."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes_ctr.h",
   "@_line": "88",
   "@_column": "6",
   "@_declfile": "libavutil/aes_ctr.h",
   "@_declline": "88",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes__ctr_1ga5048a65b4d63738e454bd02751fe56e9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Forcefully change the \"full\" 16-byte iv, including the counter\n */"
 },
 "av_aes_ctr_increment_iv": {
  "type": "void",
  "definition": "void av_aes_ctr_increment_iv",
  "argsstring": "(struct AVAESCTR *a)",
  "name": "av_aes_ctr_increment_iv",
  "param": {
   "type": "struct AVAESCTR *",
   "declname": "a"
  },
  "briefdescription": {
   "para": "Increment the top 64 bit of the iv (performed after each frame)"
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/aes_ctr.h",
   "@_line": "93",
   "@_column": "6",
   "@_declfile": "libavutil/aes_ctr.h",
   "@_declline": "93",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__aes__ctr_1ga6c61a46cb240ef27f4c8f458255f6152",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Increment the top 64 bit of the iv (performed after each frame)\n */"
 },
 "av_ambient_viewing_environment_alloc": {
  "type": {
   "ref": {
    "#text": "AVAmbientViewingEnvironment",
    "@_refid": "structAVAmbientViewingEnvironment",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVAmbientViewingEnvironment * av_ambient_viewing_environment_alloc",
  "argsstring": "(size_t *size)",
  "name": "av_ambient_viewing_environment_alloc",
  "param": {
   "type": "size_t *",
   "declname": "size"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVAmbientViewingEnvironment",
     "@_refid": "structAVAmbientViewingEnvironment",
     "@_kindref": "compound"
    },
    "#text": "Allocate anstructure."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the newly allocated struct or NULL on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/ambient_viewing_environment.h",
   "@_line": "62",
   "@_column": "29",
   "@_declfile": "libavutil/ambient_viewing_environment.h",
   "@_declline": "62",
   "@_declcolumn": "29"
  },
  "@_kind": "function",
  "@_id": "ambient__viewing__environment_8h_1a9842e5629af5e88804738e897ff91c53",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVAmbientViewingEnvironment structure.\n *\n * @return the newly allocated struct or NULL on failure\n */"
 },
 "av_ambient_viewing_environment_create_side_data": {
  "type": {
   "ref": {
    "#text": "AVAmbientViewingEnvironment",
    "@_refid": "structAVAmbientViewingEnvironment",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVAmbientViewingEnvironment * av_ambient_viewing_environment_create_side_data",
  "argsstring": "(AVFrame *frame)",
  "name": "av_ambient_viewing_environment_create_side_data",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVAmbientViewingEnvironment",
      "@_refid": "structAVAmbientViewingEnvironment",
      "@_kindref": "compound"
     },
     {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     }
    ],
    "#text": "Allocate and add anstructure to an existingas side data."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the newly allocated struct, or NULL on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/ambient_viewing_environment.h",
   "@_line": "70",
   "@_column": "29",
   "@_declfile": "libavutil/ambient_viewing_environment.h",
   "@_declline": "70",
   "@_declcolumn": "29"
  },
  "@_kind": "function",
  "@_id": "ambient__viewing__environment_8h_1afdfd6b68548b6af7e7d70b84da61dc2c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate and add an AVAmbientViewingEnvironment structure to an existing\n * AVFrame as side data.\n *\n * @return the newly allocated struct, or NULL on failure\n */"
 },
 "AVAudioFifo": {
  "type": {
   "ref": {
    "#text": "AVAudioFifo",
    "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVAudioFifo AVAudioFifo",
  "argsstring": "",
  "name": "AVAudioFifo",
  "briefdescription": {
   "para": "Context for an Audio FIFO Buffer."
  },
  "detaileddescription": {
   "para": {
    "itemizedlist": {
     "listitem": [
      {
       "para": "Operates at the sample level rather than the byte level."
      },
      {
       "para": "Supports multiple channels with either planar or packed sample format."
      },
      {
       "para": "Automatic reallocation when writing to a full buffer."
      }
     ]
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "48",
   "@_column": "26",
   "@_bodyfile": "libavutil/audio_fifo.h",
   "@_bodystart": "48",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Context for an Audio FIFO Buffer.\n *\n * - Operates at the sample level rather than the byte level.\n * - Supports multiple channels with either planar or packed sample format.\n * - Automatic reallocation when writing to a full buffer.\n */"
 },
 "av_audio_fifo_free": {
  "type": "void",
  "definition": "void av_audio_fifo_free",
  "argsstring": "(AVAudioFifo *af)",
  "name": "av_audio_fifo_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVAudioFifo",
     "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "af"
  },
  "briefdescription": {
   "para": "Free an AVAudioFifo."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "af"
      },
      "parameterdescription": {
       "para": "AVAudioFifo to free"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "55",
   "@_column": "6",
   "@_declfile": "libavutil/audio_fifo.h",
   "@_declline": "55",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "transcode__aac_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "transcode__aac_8c",
   "@_startline": "777",
   "@_endline": "882"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audiofifo_1ga74e029e47f7aa99217ad1f315c434875",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free an AVAudioFifo.\n *\n * @param af  AVAudioFifo to free\n */"
 },
 "av_audio_fifo_alloc": {
  "type": {
   "ref": {
    "#text": "AVAudioFifo",
    "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
    "@_kindref": "member"
   },
   "#text": "*"
  },
  "definition": "AVAudioFifo * av_audio_fifo_alloc",
  "argsstring": "(enum AVSampleFormat sample_fmt, int channels, int nb_samples)",
  "name": "av_audio_fifo_alloc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "sample_fmt"
   },
   {
    "type": "int",
    "declname": "channels"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   }
  ],
  "briefdescription": {
   "para": "Allocate an AVAudioFifo."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "sample_fmt"
       },
       "parameterdescription": {
        "para": "sample format"
       }
      },
      {
       "parameternamelist": {
        "parametername": "channels"
       },
       "parameterdescription": {
        "para": "number of channels"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_samples"
       },
       "parameterdescription": {
        "para": "initial allocation size, in samples"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "newly allocated AVAudioFifo, or NULL on error",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "65",
   "@_column": "13",
   "@_declfile": "libavutil/audio_fifo.h",
   "@_declline": "65",
   "@_declcolumn": "13"
  },
  "referencedby": {
   "#text": "init_fifo",
   "@_refid": "transcode__aac_8c_1a96cd24fde0bde66e80f3141a1def94c6",
   "@_compoundref": "transcode__aac_8c",
   "@_startline": "329",
   "@_endline": "338"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audiofifo_1ga26cec528c9abdf59adb70b305304346e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVAudioFifo.\n *\n * @param sample_fmt  sample format\n * @param channels    number of channels\n * @param nb_samples  initial allocation size, in samples\n * @return            newly allocated AVAudioFifo, or NULL on error\n */"
 },
 "av_audio_fifo_realloc": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int av_audio_fifo_realloc",
  "argsstring": "(AVAudioFifo *af, int nb_samples)",
  "name": "av_audio_fifo_realloc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVAudioFifo",
      "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "af"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   }
  ],
  "briefdescription": {
   "para": "Reallocate an AVAudioFifo."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "af"
       },
       "parameterdescription": {
        "para": "AVAudioFifo to reallocate"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_samples"
       },
       "parameterdescription": {
        "para": "new allocation size, in samples"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 if OK, or negative AVERROR code on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "76",
   "@_column": "5",
   "@_declfile": "libavutil/audio_fifo.h",
   "@_declline": "76",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "add_samples_to_fifo",
   "@_refid": "transcode__aac_8c_1a1509aea4299c0261c6c3f2a7bc8971d2",
   "@_compoundref": "transcode__aac_8c",
   "@_startline": "504",
   "@_endline": "524"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audiofifo_1ga27c1e16e5f09940d6016b1971c0b5742",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reallocate an AVAudioFifo.\n *\n * @param af          AVAudioFifo to reallocate\n * @param nb_samples  new allocation size, in samples\n * @return            0 if OK, or negative AVERROR code on failure\n */"
 },
 "av_audio_fifo_write": {
  "type": "int",
  "definition": "int av_audio_fifo_write",
  "argsstring": "(AVAudioFifo *af, void *const *data, int nb_samples)",
  "name": "av_audio_fifo_write",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVAudioFifo",
      "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "af"
   },
   {
    "type": "void *const *",
    "declname": "data"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   }
  ],
  "briefdescription": {
   "para": "Write data to an AVAudioFifo."
  },
  "detaileddescription": {
   "para": [
    "The AVAudioFifo will be reallocated automatically if the available space is less than nb_samples.",
    {
     "simplesect": [
      {
       "para": {
        "ref": [
         {
          "#text": "AVSampleFormat",
          "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
          "@_kindref": "member"
         },
         {
          "#text": "AVSampleFormat",
          "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
          "@_kindref": "member"
         }
        ],
        "#text": "enumThe documentation fordescribes the data layout."
       },
       "@_kind": "see"
      },
      {
       "para": "number of samples actually written, or negative AVERROR code on failure. If successful, the number of samples actually written will always be nb_samples.",
       "@_kind": "return"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "af"
        },
        "parameterdescription": {
         "para": "AVAudioFifo to write to"
        }
       },
       {
        "parameternamelist": {
         "parametername": "data"
        },
        "parameterdescription": {
         "para": "audio data plane pointers"
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_samples"
        },
        "parameterdescription": {
         "para": "number of samples to write"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "94",
   "@_column": "5",
   "@_declfile": "libavutil/audio_fifo.h",
   "@_declline": "94",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "add_samples_to_fifo",
   "@_refid": "transcode__aac_8c_1a1509aea4299c0261c6c3f2a7bc8971d2",
   "@_compoundref": "transcode__aac_8c",
   "@_startline": "504",
   "@_endline": "524"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audiofifo_1ga51d81a165872919bbfdee3f00f6d6530",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write data to an AVAudioFifo.\n *\n * The AVAudioFifo will be reallocated automatically if the available space\n * is less than nb_samples.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param af          AVAudioFifo to write to\n * @param data        audio data plane pointers\n * @param nb_samples  number of samples to write\n * @return            number of samples actually written, or negative AVERROR\n *                    code on failure. If successful, the number of samples\n *                    actually written will always be nb_samples.\n */"
 },
 "av_audio_fifo_peek": {
  "type": "int",
  "definition": "int av_audio_fifo_peek",
  "argsstring": "(const AVAudioFifo *af, void *const *data, int nb_samples)",
  "name": "av_audio_fifo_peek",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVAudioFifo",
      "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "af"
   },
   {
    "type": "void *const *",
    "declname": "data"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   }
  ],
  "briefdescription": {
   "para": "Peek data from an AVAudioFifo."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": [
        {
         "#text": "AVSampleFormat",
         "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
         "@_kindref": "member"
        },
        {
         "#text": "AVSampleFormat",
         "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
         "@_kindref": "member"
        }
       ],
       "#text": "enumThe documentation fordescribes the data layout."
      },
      "@_kind": "see"
     },
     {
      "para": "number of samples actually peek, or negative AVERROR code on failure. The number of samples actually peek will not be greater than nb_samples, and will only be less than nb_samples if av_audio_fifo_size is less than nb_samples.",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "af"
       },
       "parameterdescription": {
        "para": "AVAudioFifo to read from"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "audio data plane pointers"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_samples"
       },
       "parameterdescription": {
        "para": "number of samples to peek"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "110",
   "@_column": "5",
   "@_declfile": "libavutil/audio_fifo.h",
   "@_declline": "110",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audiofifo_1ga0637c3f22ea0844bfd2eaf52eb1172a9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Peek data from an AVAudioFifo.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param af          AVAudioFifo to read from\n * @param data        audio data plane pointers\n * @param nb_samples  number of samples to peek\n * @return            number of samples actually peek, or negative AVERROR code\n *                    on failure. The number of samples actually peek will not\n *                    be greater than nb_samples, and will only be less than\n *                    nb_samples if av_audio_fifo_size is less than nb_samples.\n */"
 },
 "av_audio_fifo_peek_at": {
  "type": "int",
  "definition": "int av_audio_fifo_peek_at",
  "argsstring": "(const AVAudioFifo *af, void *const *data, int nb_samples, int offset)",
  "name": "av_audio_fifo_peek_at",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVAudioFifo",
      "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "af"
   },
   {
    "type": "void *const *",
    "declname": "data"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   },
   {
    "type": "int",
    "declname": "offset"
   }
  ],
  "briefdescription": {
   "para": "Peek data from an AVAudioFifo."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": [
        {
         "#text": "AVSampleFormat",
         "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
         "@_kindref": "member"
        },
        {
         "#text": "AVSampleFormat",
         "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
         "@_kindref": "member"
        }
       ],
       "#text": "enumThe documentation fordescribes the data layout."
      },
      "@_kind": "see"
     },
     {
      "para": "number of samples actually peek, or negative AVERROR code on failure. The number of samples actually peek will not be greater than nb_samples, and will only be less than nb_samples if av_audio_fifo_size is less than nb_samples.",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "af"
       },
       "parameterdescription": {
        "para": "AVAudioFifo to read from"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "audio data plane pointers"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_samples"
       },
       "parameterdescription": {
        "para": "number of samples to peek"
       }
      },
      {
       "parameternamelist": {
        "parametername": "offset"
       },
       "parameterdescription": {
        "para": "offset from current read position"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "127",
   "@_column": "5",
   "@_declfile": "libavutil/audio_fifo.h",
   "@_declline": "127",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audiofifo_1ga292151ecdbe6437f32f832cc57d33fc1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Peek data from an AVAudioFifo.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param af          AVAudioFifo to read from\n * @param data        audio data plane pointers\n * @param nb_samples  number of samples to peek\n * @param offset      offset from current read position\n * @return            number of samples actually peek, or negative AVERROR code\n *                    on failure. The number of samples actually peek will not\n *                    be greater than nb_samples, and will only be less than\n *                    nb_samples if av_audio_fifo_size is less than nb_samples.\n */"
 },
 "av_audio_fifo_read": {
  "type": "int",
  "definition": "int av_audio_fifo_read",
  "argsstring": "(AVAudioFifo *af, void *const *data, int nb_samples)",
  "name": "av_audio_fifo_read",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVAudioFifo",
      "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "af"
   },
   {
    "type": "void *const *",
    "declname": "data"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   }
  ],
  "briefdescription": {
   "para": "Read data from an AVAudioFifo."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": [
        {
         "#text": "AVSampleFormat",
         "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
         "@_kindref": "member"
        },
        {
         "#text": "AVSampleFormat",
         "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
         "@_kindref": "member"
        }
       ],
       "#text": "enumThe documentation fordescribes the data layout."
      },
      "@_kind": "see"
     },
     {
      "para": "number of samples actually read, or negative AVERROR code on failure. The number of samples actually read will not be greater than nb_samples, and will only be less than nb_samples if av_audio_fifo_size is less than nb_samples.",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "af"
       },
       "parameterdescription": {
        "para": "AVAudioFifo to read from"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "audio data plane pointers"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_samples"
       },
       "parameterdescription": {
        "para": "number of samples to read"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "144",
   "@_column": "5",
   "@_declfile": "libavutil/audio_fifo.h",
   "@_declline": "144",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "load_encode_and_write",
   "@_refid": "transcode__aac_8c_1ab4367e0049c0bbd56eec8c525cdbd6e5",
   "@_compoundref": "transcode__aac_8c",
   "@_startline": "726",
   "@_endline": "759"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audiofifo_1ga5e2c87bbeefba0d229b4109b4b755529",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read data from an AVAudioFifo.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param af          AVAudioFifo to read from\n * @param data        audio data plane pointers\n * @param nb_samples  number of samples to read\n * @return            number of samples actually read, or negative AVERROR code\n *                    on failure. The number of samples actually read will not\n *                    be greater than nb_samples, and will only be less than\n *                    nb_samples if av_audio_fifo_size is less than nb_samples.\n */"
 },
 "av_audio_fifo_drain": {
  "type": "int",
  "definition": "int av_audio_fifo_drain",
  "argsstring": "(AVAudioFifo *af, int nb_samples)",
  "name": "av_audio_fifo_drain",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVAudioFifo",
      "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "af"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   }
  ],
  "briefdescription": {
   "para": "Drain data from an AVAudioFifo."
  },
  "detaileddescription": {
   "para": [
    "Removes the data without reading it.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "af"
        },
        "parameterdescription": {
         "para": "AVAudioFifo to drain"
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_samples"
        },
        "parameterdescription": {
         "para": "number of samples to drain"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 if OK, or negative AVERROR code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "155",
   "@_column": "5",
   "@_declfile": "libavutil/audio_fifo.h",
   "@_declline": "155",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audiofifo_1gacac9b187b9c27c5a0374f6f83224a77b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Drain data from an AVAudioFifo.\n *\n * Removes the data without reading it.\n *\n * @param af          AVAudioFifo to drain\n * @param nb_samples  number of samples to drain\n * @return            0 if OK, or negative AVERROR code on failure\n */"
 },
 "av_audio_fifo_reset": {
  "type": "void",
  "definition": "void av_audio_fifo_reset",
  "argsstring": "(AVAudioFifo *af)",
  "name": "av_audio_fifo_reset",
  "param": {
   "type": {
    "ref": {
     "#text": "AVAudioFifo",
     "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "af"
  },
  "briefdescription": {
   "para": "Reset the AVAudioFifo buffer."
  },
  "detaileddescription": {
   "para": [
    "This empties all data in the buffer.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "af"
       },
       "parameterdescription": {
        "para": "AVAudioFifo to reset"
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "164",
   "@_column": "6",
   "@_declfile": "libavutil/audio_fifo.h",
   "@_declline": "164",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audiofifo_1ga3f070386d11d425302437a3b60fc5dd0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reset the AVAudioFifo buffer.\n *\n * This empties all data in the buffer.\n *\n * @param af  AVAudioFifo to reset\n */"
 },
 "av_audio_fifo_size": {
  "type": "int",
  "definition": "int av_audio_fifo_size",
  "argsstring": "(AVAudioFifo *af)",
  "name": "av_audio_fifo_size",
  "param": {
   "type": {
    "ref": {
     "#text": "AVAudioFifo",
     "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "af"
  },
  "briefdescription": {
   "para": "Get the current number of samples in the AVAudioFifo available for reading."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "af"
      },
      "parameterdescription": {
       "para": "the AVAudioFifo to query"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "number of samples available for reading",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "172",
   "@_column": "5",
   "@_declfile": "libavutil/audio_fifo.h",
   "@_declline": "172",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "add_samples_to_fifo",
    "@_refid": "transcode__aac_8c_1a1509aea4299c0261c6c3f2a7bc8971d2",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "504",
    "@_endline": "524"
   },
   {
    "#text": "load_encode_and_write",
    "@_refid": "transcode__aac_8c_1ab4367e0049c0bbd56eec8c525cdbd6e5",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "726",
    "@_endline": "759"
   },
   {
    "#text": "main",
    "@_refid": "transcode__aac_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "777",
    "@_endline": "882"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__audiofifo_1gaa0a4742ecac52a999e8b4478d27f3b9b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the current number of samples in the AVAudioFifo available for reading.\n *\n * @param af  the AVAudioFifo to query\n * @return    number of samples available for reading\n */"
 },
 "av_audio_fifo_space": {
  "type": "int",
  "definition": "int av_audio_fifo_space",
  "argsstring": "(AVAudioFifo *af)",
  "name": "av_audio_fifo_space",
  "param": {
   "type": {
    "ref": {
     "#text": "AVAudioFifo",
     "@_refid": "group__lavu__audiofifo_1ga328abb21e9abb2c455d2d9c212d5230f",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "af"
  },
  "briefdescription": {
   "para": "Get the current number of samples in the AVAudioFifo available for writing."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "af"
      },
      "parameterdescription": {
       "para": "the AVAudioFifo to query"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "number of samples available for writing",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/audio_fifo.h",
   "@_line": "180",
   "@_column": "5",
   "@_declfile": "libavutil/audio_fifo.h",
   "@_declline": "180",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audiofifo_1ga2bed2f01fe34228ee8a73617b3177d00",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the current number of samples in the AVAudioFifo available for writing.\n *\n * @param af  the AVAudioFifo to query\n * @return    number of samples available for writing\n */"
 },
 "av_assert0_fpu": {
  "type": "void",
  "definition": "void av_assert0_fpu",
  "argsstring": "(void)",
  "name": "av_assert0_fpu",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Assert that floating point operations can be executed."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "av_assert0()",
     "@_refid": "avassert_8h_1aae204192396f78cc8c5cd7ad5c57c23f",
     "@_kindref": "member"
    },
    "#text": "This willthat the cpu is not in MMX state on X86"
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avassert.h",
   "@_line": "76",
   "@_column": "6",
   "@_declfile": "libavutil/avassert.h",
   "@_declline": "76",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avassert_8h_1aa56b22f21967b9c93c954eddcf36ec13",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Assert that floating point operations can be executed.\n *\n * This will av_assert0() that the cpu is not in MMX state on X86\n */"
 },
 "avcodec_version": {
  "type": "unsigned",
  "definition": "unsigned avcodec_version",
  "argsstring": "(void)",
  "name": "avcodec_version",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the LIBAVCODEC_VERSION_INT constant."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2239",
   "@_column": "10",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2239",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gadf72cccead0dc2575adcea2dc3e1ae7c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the LIBAVCODEC_VERSION_INT constant.\n */"
 },
 "avcodec_configuration": {
  "type": "const char *",
  "definition": "const char * avcodec_configuration",
  "argsstring": "(void)",
  "name": "avcodec_configuration",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libavcodec build-time configuration."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2244",
   "@_column": "12",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2244",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gaf0804e0fb97415ec21ba6355ada8a7da",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libavcodec build-time configuration.\n */"
 },
 "avcodec_license": {
  "type": "const char *",
  "definition": "const char * avcodec_license",
  "argsstring": "(void)",
  "name": "avcodec_license",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libavcodec license."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2249",
   "@_column": "12",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2249",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gabf77271abac668264972c721cd6118ab",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libavcodec license.\n */"
 },
 "avcodec_alloc_context3": {
  "type": {
   "ref": {
    "#text": "AVCodecContext",
    "@_refid": "structAVCodecContext",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVCodecContext * avcodec_alloc_context3",
  "argsstring": "(const AVCodec *codec)",
  "name": "avcodec_alloc_context3",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodec",
     "@_refid": "structAVCodec",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "codec"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVCodecContext",
     "@_refid": "structAVCodecContext",
     "@_kindref": "compound"
    },
    "#text": "Allocate anand set its fields to default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avcodec_free_context()",
      "@_refid": "group__lavc__core_1gaf869d0829ed607cec3a4a02a1c7026b3",
      "@_kindref": "member"
     },
     "#text": "The resulting struct should be freed with."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "codec"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "avcodec_open2()",
          "@_refid": "group__lavc__core_1ga11f785a188d7d9df71621001465b0f1d",
          "@_kindref": "member"
         },
         "#text": "if non-NULL, allocate private data and initialize defaults for the given codec. It is illegal to then callwith a different codec. If NULL, then the codec-specific defaults won't be initialized, which may result in suboptimal default settings (this is important mainly for encoders, e.g. libx264)."
        }
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVCodecContext",
        "@_refid": "structAVCodecContext",
        "@_kindref": "compound"
       },
       "#text": "Anfilled with default values or NULL on failure."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2264",
   "@_column": "16",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2264",
   "@_declcolumn": "16"
  },
  "referencedby": [
   {
    "#text": "add_stream",
    "@_refid": "mux_8c_1a22968a15b922fd8c0c37b49beec06dbe",
    "@_compoundref": "mux_8c",
    "@_startline": "125",
    "@_endline": "211"
   },
   {
    "#text": "main",
    "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "106",
    "@_endline": "237"
   },
   {
    "#text": "open_codec_context",
    "@_refid": "demux__decode_8c_1ab36dcc13a13c2ae1c1fff2ea5db97616",
    "@_compoundref": "demux__decode_8c",
    "@_startline": "146",
    "@_endline": "195"
   },
   {
    "#text": "open_input_file",
    "@_refid": "decode__filter__audio_8c_1abd04bf1a933d4d2698482f4949c61fed",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "52",
    "@_endline": "88"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga3ad781acd35536a58863ed31ef94ccf0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVCodecContext and set its fields to default values. The\n * resulting struct should be freed with avcodec_free_context().\n *\n * @param codec if non-NULL, allocate private data and initialize defaults\n *              for the given codec. It is illegal to then call avcodec_open2()\n *              with a different codec.\n *              If NULL, then the codec-specific defaults won't be initialized,\n *              which may result in suboptimal default settings (this is\n *              important mainly for encoders, e.g. libx264).\n *\n * @return An AVCodecContext filled with default values or NULL on failure.\n */"
 },
 "avcodec_free_context": {
  "type": "void",
  "definition": "void avcodec_free_context",
  "argsstring": "(AVCodecContext **avctx)",
  "name": "avcodec_free_context",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecContext",
     "@_refid": "structAVCodecContext",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "avctx"
  },
  "briefdescription": {
   "para": "Free the codec context and everything associated with it and write NULL to the provided pointer."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2270",
   "@_column": "6",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2270",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "close_stream",
    "@_refid": "mux_8c_1a92d8b2751255677797d807161fae9d19",
    "@_compoundref": "mux_8c",
    "@_startline": "521",
    "@_endline": "529"
   },
   {
    "#text": "main",
    "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "106",
    "@_endline": "237"
   },
   {
    "#text": "open_input_file",
    "@_refid": "transcode__aac_8c_1a8103e36bb4cb4141ee5e25acc350bc0b",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "58",
    "@_endline": "133"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode__aac_8c_1a617f4760254c119fc7caa222f3fcbd21",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "145",
    "@_endline": "246"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__core_1gaf869d0829ed607cec3a4a02a1c7026b3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the codec context and everything associated with it and write NULL to\n * the provided pointer.\n */"
 },
 "avcodec_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * avcodec_get_class",
  "argsstring": "(void)",
  "name": "avcodec_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVClass",
      "@_refid": "structAVClass",
      "@_kindref": "compound"
     },
     {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     }
    ],
    "#text": "Get thefor."
   }
  },
  "detaileddescription": {
   "para": [
    "It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.",
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_opt_find()",
        "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
        "@_kindref": "member"
       },
       "#text": "."
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2278",
   "@_column": "15",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2278",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga21336d69f03283ce4f790be7ab2a6e9a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVClass for AVCodecContext. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */"
 },
 "avcodec_get_subtitle_rect_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * avcodec_get_subtitle_rect_class",
  "argsstring": "(void)",
  "name": "avcodec_get_subtitle_rect_class",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVClass",
      "@_refid": "structAVClass",
      "@_kindref": "compound"
     },
     {
      "#text": "AVSubtitleRect",
      "@_refid": "structAVSubtitleRect",
      "@_kindref": "compound"
     }
    ],
    "#text": "Get thefor."
   }
  },
  "detaileddescription": {
   "para": [
    "It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.",
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_opt_find()",
        "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
        "@_kindref": "member"
       },
       "#text": "."
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2286",
   "@_column": "15",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2286",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga32354137872b1b07d042748885f1c904",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVClass for AVSubtitleRect. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */"
 },
 "avcodec_parameters_from_context": {
  "type": "int",
  "definition": "int avcodec_parameters_from_context",
  "argsstring": "(struct AVCodecParameters *par, const AVCodecContext *codec)",
  "name": "avcodec_parameters_from_context",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecParameters",
      "@_refid": "structAVCodecParameters",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "par"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "codec"
   }
  ],
  "briefdescription": {
   "para": "Fill the parameters struct based on the values from the supplied codec context."
  },
  "detaileddescription": {
   "para": [
    "Any allocated fields in par are freed and replaced with duplicates of the corresponding fields in codec.",
    {
     "simplesect": {
      "para": ">= 0 on success, a negative AVERROR code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2295",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2295",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "open_audio",
    "@_refid": "mux_8c_1a5de64c6730f86a2a0c7cc3ca2bab3717",
    "@_compoundref": "mux_8c",
    "@_startline": "241",
    "@_endline": "303"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   },
   {
    "#text": "open_video",
    "@_refid": "mux_8c_1a1bc713c33e2d1937f2cbc34d83a3e303",
    "@_compoundref": "mux_8c",
    "@_startline": "404",
    "@_endline": "446"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga506c1c185ac48bb0086c61e267fc085c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill the parameters struct based on the values from the supplied codec\n * context. Any allocated fields in par are freed and replaced with duplicates\n * of the corresponding fields in codec.\n *\n * @return >= 0 on success, a negative AVERROR code on failure\n */"
 },
 "avcodec_parameters_to_context": {
  "type": "int",
  "definition": "int avcodec_parameters_to_context",
  "argsstring": "(AVCodecContext *codec, const struct AVCodecParameters *par)",
  "name": "avcodec_parameters_to_context",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "codec"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodecParameters",
      "@_refid": "structAVCodecParameters",
      "@_kindref": "compound"
     },
     "#text": "const struct*"
    },
    "declname": "par"
   }
  ],
  "briefdescription": {
   "para": "Fill the codec context based on the values from the supplied codec parameters."
  },
  "detaileddescription": {
   "para": [
    "Any allocated fields in codec that have a corresponding field in par are freed and replaced with duplicates of the corresponding field in par. Fields in codec that do not have a counterpart in par are not touched.",
    {
     "simplesect": {
      "para": ">= 0 on success, a negative AVERROR code on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2306",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2306",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "hw__decode_8c_1a0ddf1224851353fc92bfbff6f499fa97",
    "@_compoundref": "hw__decode_8c",
    "@_startline": "148",
    "@_endline": "255"
   },
   {
    "#text": "open_codec_context",
    "@_refid": "demux__decode_8c_1ab36dcc13a13c2ae1c1fff2ea5db97616",
    "@_compoundref": "demux__decode_8c",
    "@_startline": "146",
    "@_endline": "195"
   },
   {
    "#text": "open_input_file",
    "@_refid": "decode__filter__audio_8c_1abd04bf1a933d4d2698482f4949c61fed",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "52",
    "@_endline": "88"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga8a4998c9d1695abb01d379539d313227",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill the codec context based on the values from the supplied codec\n * parameters. Any allocated fields in codec that have a corresponding field in\n * par are freed and replaced with duplicates of the corresponding field in par.\n * Fields in codec that do not have a counterpart in par are not touched.\n *\n * @return >= 0 on success, a negative AVERROR code on failure.\n */"
 },
 "avcodec_open2": {
  "type": "int",
  "definition": "int avcodec_open2",
  "argsstring": "(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)",
  "name": "avcodec_open2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodec",
      "@_refid": "structAVCodec",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "codec"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     {
      "#text": "AVCodec",
      "@_refid": "structAVCodec",
      "@_kindref": "compound"
     }
    ],
    "#text": "Initialize theto use the given."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avcodec_alloc_context3()",
      "@_refid": "group__lavc__core_1ga3ad781acd35536a58863ed31ef94ccf0",
      "@_kindref": "member"
     },
     "#text": "Prior to using this function the context has to be allocated with."
    },
    {
     "ref": [
      {
       "#text": "avcodec_find_decoder_by_name()",
       "@_refid": "group__lavc__core_1ga8e72f32e219e560db6be06045e2ec32c",
       "@_kindref": "member"
      },
      {
       "#text": "avcodec_find_encoder_by_name()",
       "@_refid": "group__lavc__core_1gacde808c8f768d6ea0cceb9c6913202d0",
       "@_kindref": "member"
      },
      {
       "#text": "avcodec_find_decoder()",
       "@_refid": "group__lavc__core_1ga89204045c00a7c3216481431e0160753",
       "@_kindref": "member"
      },
      {
       "#text": "avcodec_find_encoder()",
       "@_refid": "group__lavc__core_1ga9e7a88299f4c869b03c5393aee6ebbba",
       "@_kindref": "member"
      }
     ],
     "#text": "The functions,,andprovide an easy way for retrieving a codec."
    },
    "Depending on the codec, you might need to set options in the codec context also for decoding (e.g. width, height, or the pixel or audio sample format in the case the information is not available in the bitstream, as when decoding raw audio or video).",
    {
     "ref": {
      "#text": "av_opt_set()",
      "@_refid": "group__opt__set__funcs_1ga5fd4b92bdf4f392a2847f711676a7537",
      "@_kindref": "member"
     },
     "#text": "Options in the codec context can be set either by setting them in the options AVDictionary, or by setting the values in the context itself, directly or by using theAPI before calling this function."
    },
    {
     "programlisting": {
      "codeline": [
       {
        "highlight": {
         "sp": [
          "",
          "",
          ""
         ],
         "#text": "av_dict_set(&opts,\"b\",\"2.5M\",0);",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          ""
         ],
         "#text": "codec=avcodec_find_decoder(AV_CODEC_ID_H264);",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": "",
         "#text": "if(!codec)",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          ""
         ],
         "#text": "exit(1);",
         "@_class": "normal"
        }
       },
       "",
       {
        "highlight": {
         "sp": [
          "",
          ""
         ],
         "#text": "context=avcodec_alloc_context3(codec);",
         "@_class": "normal"
        }
       },
       "",
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          "",
          ""
         ],
         "#text": "if(avcodec_open2(context,codec,opts)<0)",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          ""
         ],
         "#text": "exit(1);",
         "@_class": "normal"
        }
       }
      ]
     },
     "#text": "Example:"
    },
    {
     "ref": [
      {
       "#text": "AVCodecParameters",
       "@_refid": "structAVCodecParameters",
       "@_kindref": "compound"
      },
      {
       "#text": "AVStream",
       "@_refid": "structAVStream",
       "@_kindref": "compound"
      },
      {
       "#text": "avcodec_parameters_to_context()",
       "@_refid": "group__lavc__core_1ga8a4998c9d1695abb01d379539d313227",
       "@_kindref": "member"
      }
     ],
     "#text": "In the caseare available (e.g. when demuxing a stream using libavformat, and accessing thecontained in the demuxer), the codec parameters can be copied to the codec context using, as in the following example:"
    },
    {
     "programlisting": {
      "codeline": [
       {
        "highlight": {
         "sp": [
          "",
          "",
          ""
         ],
         "#text": "AVStream*stream=...;",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          ""
         ],
         "#text": "context=avcodec_alloc_context3(codec);",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          ""
         ],
         "#text": "if(avcodec_parameters_to_context(context,stream->codecpar)<0)",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          ""
         ],
         "#text": "exit(1);",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          "",
          ""
         ],
         "#text": "if(avcodec_open2(context,codec,NULL)<0)",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          ""
         ],
         "#text": "exit(1);",
         "@_class": "normal"
        }
       }
      ]
     }
    },
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "avcodec_receive_frame()",
         "@_refid": "group__lavc__decoding_1ga11e6542c4e66d3028668788a1a74217c",
         "@_kindref": "member"
        },
        "#text": "Always call this function before using decoding routines (such as)."
       },
       "@_kind": "note"
      },
      {
       "para": "zero on success, a negative value on error",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": [
         {
          "#text": "avcodec_alloc_context3()",
          "@_refid": "group__lavc__core_1ga3ad781acd35536a58863ed31ef94ccf0",
          "@_kindref": "member"
         },
         {
          "#text": "avcodec_find_decoder()",
          "@_refid": "group__lavc__core_1ga89204045c00a7c3216481431e0160753",
          "@_kindref": "member"
         },
         {
          "#text": "avcodec_find_encoder()",
          "@_refid": "group__lavc__core_1ga9e7a88299f4c869b03c5393aee6ebbba",
          "@_kindref": "member"
         },
         {
          "#text": "av_dict_set()",
          "@_refid": "group__lavu__dict_1ga8d9c2de72b310cef8e6a28c9cd3acbbe",
          "@_kindref": "member"
         },
         {
          "#text": "av_opt_set()",
          "@_refid": "group__opt__set__funcs_1ga5fd4b92bdf4f392a2847f711676a7537",
          "@_kindref": "member"
         },
         {
          "#text": "av_opt_find()",
          "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
          "@_kindref": "member"
         },
         {
          "#text": "avcodec_parameters_to_context()",
          "@_refid": "group__lavc__core_1ga8a4998c9d1695abb01d379539d313227",
          "@_kindref": "member"
         }
        ],
        "#text": ",,,,,,"
       },
       "@_kind": "see"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "avctx"
        },
        "parameterdescription": {
         "para": "The context to initialize."
        }
       },
       {
        "parameternamelist": {
         "parametername": "codec"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "avcodec_alloc_context3()",
           "@_refid": "group__lavc__core_1ga3ad781acd35536a58863ed31ef94ccf0",
           "@_kindref": "member"
          },
          "#text": "The codec to open this context for. If a non-NULL codec has been previously passed toor for this context, then this parameter MUST be either NULL or equal to the previously passed codec."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "options"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVCodecContext",
           "@_refid": "structAVCodecContext",
           "@_kindref": "compound"
          },
          "#text": "A dictionary filled withand codec-private options, which are set on top of the options already set in avctx, can be NULL. On return this object will be filled with options that were not found in the avctx codec context."
         }
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2370",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2370",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "106",
    "@_endline": "237"
   },
   {
    "#text": "open_audio",
    "@_refid": "mux_8c_1a5de64c6730f86a2a0c7cc3ca2bab3717",
    "@_compoundref": "mux_8c",
    "@_startline": "241",
    "@_endline": "303"
   },
   {
    "#text": "open_codec_context",
    "@_refid": "demux__decode_8c_1ab36dcc13a13c2ae1c1fff2ea5db97616",
    "@_compoundref": "demux__decode_8c",
    "@_startline": "146",
    "@_endline": "195"
   },
   {
    "#text": "open_input_file",
    "@_refid": "decode__filter__audio_8c_1abd04bf1a933d4d2698482f4949c61fed",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "52",
    "@_endline": "88"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   },
   {
    "#text": "open_video",
    "@_refid": "mux_8c_1a1bc713c33e2d1937f2cbc34d83a3e303",
    "@_compoundref": "mux_8c",
    "@_startline": "404",
    "@_endline": "446"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga11f785a188d7d9df71621001465b0f1d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize the AVCodecContext to use the given AVCodec. Prior to using this\n * function the context has to be allocated with avcodec_alloc_context3().\n *\n * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),\n * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for\n * retrieving a codec.\n *\n * Depending on the codec, you might need to set options in the codec context\n * also for decoding (e.g. width, height, or the pixel or audio sample format in\n * the case the information is not available in the bitstream, as when decoding\n * raw audio or video).\n *\n * Options in the codec context can be set either by setting them in the options\n * AVDictionary, or by setting the values in the context itself, directly or by\n * using the av_opt_set() API before calling this function.\n *\n * Example:\n * @code\n * av_dict_set(&opts, \"b\", \"2.5M\", 0);\n * codec = avcodec_find_decoder(AV_CODEC_ID_H264);\n * if (!codec)\n *     exit(1);\n *\n * context = avcodec_alloc_context3(codec);\n *\n * if (avcodec_open2(context, codec, opts) < 0)\n *     exit(1);\n * @endcode\n *\n * In the case AVCodecParameters are available (e.g. when demuxing a stream\n * using libavformat, and accessing the AVStream contained in the demuxer), the\n * codec parameters can be copied to the codec context using\n * avcodec_parameters_to_context(), as in the following example:\n *\n * @code\n * AVStream *stream = ...;\n * context = avcodec_alloc_context3(codec);\n * if (avcodec_parameters_to_context(context, stream->codecpar) < 0)\n *     exit(1);\n * if (avcodec_open2(context, codec, NULL) < 0)\n *     exit(1);\n * @endcode\n *\n * @note Always call this function before using decoding routines (such as\n * @ref avcodec_receive_frame()).\n *\n * @param avctx The context to initialize.\n * @param codec The codec to open this context for. If a non-NULL codec has been\n *              previously passed to avcodec_alloc_context3() or\n *              for this context, then this parameter MUST be either NULL or\n *              equal to the previously passed codec.\n * @param options A dictionary filled with AVCodecContext and codec-private\n *                options, which are set on top of the options already set in\n *                avctx, can be NULL. On return this object will be filled with\n *                options that were not found in the avctx codec context.\n *\n * @return zero on success, a negative value on error\n * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),\n *      av_dict_set(), av_opt_set(), av_opt_find(), avcodec_parameters_to_context()\n */"
 },
 "avcodec_close": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "attribute_deprecated int avcodec_close",
  "argsstring": "(AVCodecContext *avctx)",
  "name": "avcodec_close",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecContext",
     "@_refid": "structAVCodecContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "avctx"
  },
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     }
    ],
    "#text": "Close a givenand free all the data associated with it (but not theitself)."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "AVCodecContext",
       "@_refid": "structAVCodecContext",
       "@_kindref": "compound"
      },
      {
       "#text": "avcodec_alloc_context3()",
       "@_refid": "group__lavc__core_1ga3ad781acd35536a58863ed31ef94ccf0",
       "@_kindref": "member"
      }
     ],
     "#text": "Calling this function on anthat hasn't been opened will free the codec-specific data allocated inwith a non-NULL codec. Subsequent calls will do nothing."
    },
    {
     "xrefsect": {
      "xreftitle": "Deprecated",
      "xrefdescription": {
       "para": {
        "ref": {
         "#text": "avcodec_free_context()",
         "@_refid": "group__lavc__core_1gaf869d0829ed607cec3a4a02a1c7026b3",
         "@_kindref": "member"
        },
        "ndash": "",
        "#text": "Do not use this function. Useto destroy a codec context (either open or closed). Opening and closing a codec context multiple times is not supported anymoreuse multiple codec contexts instead."
       }
      },
      "@_id": "deprecated_1_deprecated000012"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2387",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2387",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gab7f632082a10fcb051fa3e2db7f86942",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Close a given AVCodecContext and free all the data associated with it\n * (but not the AVCodecContext itself).\n *\n * Calling this function on an AVCodecContext that hasn't been opened will free\n * the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL\n * codec. Subsequent calls will do nothing.\n *\n * @deprecated Do not use this function. Use avcodec_free_context() to destroy a\n * codec context (either open or closed). Opening and closing a codec context\n * multiple times is not supported anymore -- use multiple codec contexts\n * instead.\n */"
 },
 "avsubtitle_free": {
  "type": "void",
  "definition": "void avsubtitle_free",
  "argsstring": "(AVSubtitle *sub)",
  "name": "avsubtitle_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVSubtitle",
     "@_refid": "structAVSubtitle",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "sub"
  },
  "briefdescription": {
   "para": "Free all allocated data in the given subtitle struct."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "sub"
      },
      "parameterdescription": {
       "para": {
        "ref": {
         "#text": "AVSubtitle",
         "@_refid": "structAVSubtitle",
         "@_kindref": "compound"
        },
        "#text": "to free."
       }
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2395",
   "@_column": "6",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2395",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gaa2c3e02a761d9fc0c5c9b2340408c332",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free all allocated data in the given subtitle struct.\n *\n * @param sub AVSubtitle to free.\n */"
 },
 "avcodec_default_get_buffer2": {
  "type": "int",
  "definition": "int avcodec_default_get_buffer2",
  "argsstring": "(AVCodecContext *s, AVFrame *frame, int flags)",
  "name": "avcodec_default_get_buffer2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVCodecContext.get_buffer2()",
     "@_refid": "structAVCodecContext_1aef79333a4c6abf1628c55d75ec82bede",
     "@_kindref": "member"
    },
    "#text": "The default callback for."
   }
  },
  "detaileddescription": {
   "para": "It is made public so it can be called by custom get_buffer2() implementations for decoders without AV_CODEC_CAP_DR1 set."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2411",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2411",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__decoding_1ga09dee227d3666720eff1f6913d11699d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * The default callback for AVCodecContext.get_buffer2(). It is made public so\n * it can be called by custom get_buffer2() implementations for decoders without\n * AV_CODEC_CAP_DR1 set.\n */"
 },
 "avcodec_default_get_encode_buffer": {
  "type": "int",
  "definition": "int avcodec_default_get_encode_buffer",
  "argsstring": "(AVCodecContext *s, AVPacket *pkt, int flags)",
  "name": "avcodec_default_get_encode_buffer",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVCodecContext.get_encode_buffer()",
     "@_refid": "structAVCodecContext_1a610bca24031c26f6ac6c6f4ff11a05b4",
     "@_kindref": "member"
    },
    "#text": "The default callback for."
   }
  },
  "detaileddescription": {
   "para": "It is made public so it can be called by custom get_encode_buffer() implementations for encoders without AV_CODEC_CAP_DR1 set."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2418",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2418",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__decoding_1gad9476afa8d6c408703166b1869e28c84",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * The default callback for AVCodecContext.get_encode_buffer(). It is made public so\n * it can be called by custom get_encode_buffer() implementations for encoders without\n * AV_CODEC_CAP_DR1 set.\n */"
 },
 "avcodec_align_dimensions": {
  "type": "void",
  "definition": "void avcodec_align_dimensions",
  "argsstring": "(AVCodecContext *s, int *width, int *height)",
  "name": "avcodec_align_dimensions",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int *",
    "declname": "width"
   },
   {
    "type": "int *",
    "declname": "height"
   }
  ],
  "briefdescription": {
   "para": "Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you do not use any horizontal padding."
  },
  "detaileddescription": {
   "para": "May only be used if a codec with AV_CODEC_CAP_DR1 has been opened."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2427",
   "@_column": "6",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2427",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__decoding_1ga48432a3760eec9fce0f0ef7b298859f1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Modify width and height values so that they will result in a memory\n * buffer that is acceptable for the codec if you do not use any horizontal\n * padding.\n *\n * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.\n */"
 },
 "avcodec_align_dimensions2": {
  "type": "void",
  "definition": "void avcodec_align_dimensions2",
  "argsstring": "(AVCodecContext *s, int *width, int *height, int linesize_align[AV_NUM_DATA_POINTERS])",
  "name": "avcodec_align_dimensions2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int *",
    "declname": "width"
   },
   {
    "type": "int *",
    "declname": "height"
   },
   {
    "type": "int",
    "declname": "linesize_align",
    "array": "[AV_NUM_DATA_POINTERS]"
   }
  ],
  "briefdescription": {
   "para": "Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you also ensure that all line sizes are a multiple of the respective linesize_align[i]."
  },
  "detaileddescription": {
   "para": "May only be used if a codec with AV_CODEC_CAP_DR1 has been opened."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2436",
   "@_column": "6",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2436",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__decoding_1ga34e3269dc1b9e2c98e9371241722e7e2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Modify width and height values so that they will result in a memory\n * buffer that is acceptable for the codec if you also ensure that all\n * line sizes are a multiple of the respective linesize_align[i].\n *\n * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.\n */"
 },
 "avcodec_decode_subtitle2": {
  "type": "int",
  "definition": "int avcodec_decode_subtitle2",
  "argsstring": "(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, const AVPacket *avpkt)",
  "name": "avcodec_decode_subtitle2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSubtitle",
      "@_refid": "structAVSubtitle",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "sub"
   },
   {
    "type": "int *",
    "declname": "got_sub_ptr"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "avpkt"
   }
  ],
  "briefdescription": {
   "para": "Decode a subtitle message."
  },
  "detaileddescription": {
   "para": [
    "Return a negative value on error, otherwise return the number of bytes used. If no subtitle could be decompressed, got_sub_ptr is zero. Otherwise, the subtitle is stored in *sub. Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for simplicity, because the performance difference is expected to be negligible and reusing a get_buffer written for video codecs would probably perform badly due to a potentially very different allocation pattern.",
    "Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt->data set to NULL and avpkt->size set to 0 until it stops returning subtitles. It is safe to flush even those decoders that are not marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.",
    {
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "AVCodecContext",
         "@_refid": "structAVCodecContext",
         "@_kindref": "compound"
        },
        {
         "#text": "avcodec_open2()",
         "@_refid": "group__lavc__core_1ga11f785a188d7d9df71621001465b0f1d",
         "@_kindref": "member"
        }
       ],
       "#text": "TheMUST have been opened withbefore packets may be fed to the decoder."
      },
      "@_kind": "note"
     },
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "avctx"
        },
        "parameterdescription": {
         "para": "the codec context"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "sub",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVSubtitle",
           "@_refid": "structAVSubtitle",
           "@_kindref": "compound"
          },
          "#text": "The preallocatedin which the decoded subtitle will be stored, must be freed with avsubtitle_free if *got_sub_ptr is set."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "got_sub_ptr",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": "Zero if no subtitle could be decompressed, otherwise, it is nonzero."
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "avpkt",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVPacket",
           "@_refid": "structAVPacket",
           "@_kindref": "compound"
          },
          "#text": "The inputcontaining the input buffer."
         }
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2466",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2466",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__decoding_1ga5c30b73f0ec105f93d4e86464f541f21",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Decode a subtitle message.\n * Return a negative value on error, otherwise return the number of bytes used.\n * If no subtitle could be decompressed, got_sub_ptr is zero.\n * Otherwise, the subtitle is stored in *sub.\n * Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for\n * simplicity, because the performance difference is expected to be negligible\n * and reusing a get_buffer written for video codecs would probably perform badly\n * due to a potentially very different allocation pattern.\n *\n * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input\n * and output. This means that for some packets they will not immediately\n * produce decoded output and need to be flushed at the end of decoding to get\n * all the decoded data. Flushing is done by calling this function with packets\n * with avpkt->data set to NULL and avpkt->size set to 0 until it stops\n * returning subtitles. It is safe to flush even those decoders that are not\n * marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.\n *\n * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n * before packets may be fed to the decoder.\n *\n * @param avctx the codec context\n * @param[out] sub The preallocated AVSubtitle in which the decoded subtitle will be stored,\n *                 must be freed with avsubtitle_free if *got_sub_ptr is set.\n * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.\n * @param[in] avpkt The input AVPacket containing the input buffer.\n */"
 },
 "avcodec_send_packet": {
  "type": "int",
  "definition": "int avcodec_send_packet",
  "argsstring": "(AVCodecContext *avctx, const AVPacket *avpkt)",
  "name": "avcodec_send_packet",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "avpkt"
   }
  ],
  "briefdescription": {
   "para": "Supply raw packet data as input to a decoder."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "AVCodecContext",
       "@_refid": "structAVCodecContext",
       "@_kindref": "compound"
      },
      {
       "#text": "AVCodecContext.skip_frame",
       "@_refid": "structAVCodecContext_1af869b808363998c80adf7df6a944a5a6",
       "@_kindref": "member"
      }
     ],
     "#text": "Internally, this call will copy relevantfields, which can influence decoding per-packet, and apply them when the packet is actually decoded. (For example, which might direct the decoder to drop the frame contained by the packet sent with this function.)"
    },
    {
     "simplesect": [
      {
       "para": "The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.",
       "@_kind": "warning"
      },
      {
       "para": {
        "ref": [
         {
          "#text": "AVCodecContext",
          "@_refid": "structAVCodecContext",
          "@_kindref": "compound"
         },
         {
          "#text": "avcodec_open2()",
          "@_refid": "group__lavc__core_1ga11f785a188d7d9df71621001465b0f1d",
          "@_kindref": "member"
         }
        ],
        "#text": "TheMUST have been opened withbefore packets may be fed to the decoder."
       },
       "@_kind": "note"
      }
     ],
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "avctx"
         },
         "parameterdescription": {
          "para": "codec context"
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "#text": "avpkt",
           "@_direction": "in"
          }
         },
         "parameterdescription": {
          "para": {
           "ref": [
            {
             "#text": "AVPacket",
             "@_refid": "structAVPacket",
             "@_kindref": "compound"
            },
            {
             "#text": "avcodec_receive_frame()",
             "@_refid": "group__lavc__decoding_1ga11e6542c4e66d3028668788a1a74217c",
             "@_kindref": "member"
            },
            {
             "#text": "AVPacket",
             "@_refid": "structAVPacket",
             "@_kindref": "compound"
            }
           ],
           "#text": "The input. Usually, this will be a single video frame, or several complete audio frames. Ownership of the packet remains with the caller, and the decoder will not write to the packet. The decoder may create a reference to the packet data (or copy it if the packet is not reference-counted). Unlike with older APIs, the packet is always fully consumed, and if it contains multiple frames (e.g. some audio codecs), will require you to callmultiple times afterwards before you can send a new packet. It can be NULL (or anwith data set to NULL and size set to 0); in this case, it is considered a flush packet, which signals the end of the stream. Sending the first flush packet will return success. Subsequent ones are unnecessary and will return AVERROR_EOF. If the decoder still has frames buffered, it will return them after sending a flush packet."
          }
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": 0
         },
         "parameterdescription": {
          "para": "success"
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "ref": {
            "#text": "AVERROR(EAGAIN)",
            "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
            "@_kindref": "member"
           }
          }
         },
         "parameterdescription": {
          "para": {
           "ref": {
            "#text": "avcodec_receive_frame()",
            "@_refid": "group__lavc__decoding_1ga11e6542c4e66d3028668788a1a74217c",
            "@_kindref": "member"
           },
           "#text": "input is not accepted in the current state - user must read output with(once all output is read, the packet should be resent, and the call will not fail with EAGAIN)."
          }
         }
        },
        {
         "parameternamelist": {
          "parametername": "AVERROR_EOF"
         },
         "parameterdescription": {
          "para": "the decoder has been flushed, and no new packets can be sent to it (also returned if more than 1 flush packet is sent)"
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "ref": {
            "#text": "AVERROR(EINVAL)",
            "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
            "@_kindref": "member"
           }
          }
         },
         "parameterdescription": {
          "para": "codec not opened, it is an encoder, or requires flush"
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "ref": {
            "#text": "AVERROR(ENOMEM)",
            "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
            "@_kindref": "member"
           }
          }
         },
         "parameterdescription": {
          "para": "failed to add packet to internal queue, or similar"
         }
        },
        {
         "parameternamelist": {
          "parametername": "another negative error code"
         },
         "parameterdescription": {
          "para": "legitimate decoding errors"
         }
        }
       ],
       "@_kind": "retval"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2515",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2515",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "decode",
    "@_refid": "decode__audio_8c_1a1704ae53d7f426e1b67341785b5b2b58",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "72",
    "@_endline": "104"
   },
   {
    "#text": "decode_audio_frame",
    "@_refid": "transcode__aac_8c_1a5c320cc89448244f68daee53092da98c",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "369",
    "@_endline": "429"
   },
   {
    "#text": "decode_packet",
    "@_refid": "demux__decode_8c_1a9e3819273006eb6eb08cfe7a487c222e",
    "@_compoundref": "demux__decode_8c",
    "@_startline": "110",
    "@_endline": "144"
   },
   {
    "#text": "decode_write",
    "@_refid": "hw__decode_8c_1aa376d8bc0bb004de4856e8920e0f6217",
    "@_compoundref": "hw__decode_8c",
    "@_startline": "76",
    "@_endline": "146"
   },
   {
    "#text": "main",
    "@_refid": "decode__filter__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "217",
    "@_endline": "296"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__decoding_1ga58bc4bf1e0ac59e27362597e467efff3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Supply raw packet data as input to a decoder.\n *\n * Internally, this call will copy relevant AVCodecContext fields, which can\n * influence decoding per-packet, and apply them when the packet is actually\n * decoded. (For example AVCodecContext.skip_frame, which might direct the\n * decoder to drop the frame contained by the packet sent with this function.)\n *\n * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE\n *          larger than the actual read bytes because some optimized bitstream\n *          readers read 32 or 64 bits at once and could read over the end.\n *\n * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()\n *       before packets may be fed to the decoder.\n *\n * @param avctx codec context\n * @param[in] avpkt The input AVPacket. Usually, this will be a single video\n *                  frame, or several complete audio frames.\n *                  Ownership of the packet remains with the caller, and the\n *                  decoder will not write to the packet. The decoder may create\n *                  a reference to the packet data (or copy it if the packet is\n *                  not reference-counted).\n *                  Unlike with older APIs, the packet is always fully consumed,\n *                  and if it contains multiple frames (e.g. some audio codecs),\n *                  will require you to call avcodec_receive_frame() multiple\n *                  times afterwards before you can send a new packet.\n *                  It can be NULL (or an AVPacket with data set to NULL and\n *                  size set to 0); in this case, it is considered a flush\n *                  packet, which signals the end of the stream. Sending the\n *                  first flush packet will return success. Subsequent ones are\n *                  unnecessary and will return AVERROR_EOF. If the decoder\n *                  still has frames buffered, it will return them after sending\n *                  a flush packet.\n *\n * @retval 0                 success\n * @retval AVERROR(EAGAIN)   input is not accepted in the current state - user\n *                           must read output with avcodec_receive_frame() (once\n *                           all output is read, the packet should be resent,\n *                           and the call will not fail with EAGAIN).\n * @retval AVERROR_EOF       the decoder has been flushed, and no new packets can be\n *                           sent to it (also returned if more than 1 flush\n *                           packet is sent)\n * @retval AVERROR(EINVAL)   codec not opened, it is an encoder, or requires flush\n * @retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar\n * @retval \"another negative error code\" legitimate decoding errors\n */"
 },
 "avcodec_receive_frame": {
  "type": "int",
  "definition": "int avcodec_receive_frame",
  "argsstring": "(AVCodecContext *avctx, AVFrame *frame)",
  "name": "avcodec_receive_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AV_CODEC_FLAG_RECON_FRAME",
     "@_refid": "group__lavc__core_1gaff2b2fa4b372eae1690a0258728ea84a",
     "@_kindref": "member"
    },
    "#text": "Return decoded output data from a decoder or encoder (when theflag is used)."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": [
     {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "avctx"
        },
        "parameterdescription": {
         "para": "codec context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "frame"
        },
        "parameterdescription": {
         "para": "This will be set to a reference-counted video or audio frame (depending on the decoder type) allocated by the codec. Note that the function will always call av_frame_unref(frame) before doing anything else."
        }
       }
      ],
      "@_kind": "param"
     },
     {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": 0
        },
        "parameterdescription": {
         "para": "success, a frame was returned"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "ref": {
           "#text": "AVERROR(EAGAIN)",
           "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
           "@_kindref": "member"
          }
         }
        },
        "parameterdescription": {
         "para": "output is not available in this state - user must try to send new input"
        }
       },
       {
        "parameternamelist": {
         "parametername": "AVERROR_EOF"
        },
        "parameterdescription": {
         "para": "the codec has been fully flushed, and there will be no more output frames"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "ref": {
           "#text": "AVERROR(EINVAL)",
           "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
           "@_kindref": "member"
          }
         }
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AV_CODEC_FLAG_RECON_FRAME",
           "@_refid": "group__lavc__core_1gaff2b2fa4b372eae1690a0258728ea84a",
           "@_kindref": "member"
          },
          "#text": "codec not opened, or it is an encoder without theflag enabled"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "other negative error code"
        },
        "parameterdescription": {
         "para": "legitimate decoding errors"
        }
       }
      ],
      "@_kind": "retval"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2536",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2536",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "decode",
    "@_refid": "decode__audio_8c_1a1704ae53d7f426e1b67341785b5b2b58",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "72",
    "@_endline": "104"
   },
   {
    "#text": "decode_audio_frame",
    "@_refid": "transcode__aac_8c_1a5c320cc89448244f68daee53092da98c",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "369",
    "@_endline": "429"
   },
   {
    "#text": "decode_packet",
    "@_refid": "demux__decode_8c_1a9e3819273006eb6eb08cfe7a487c222e",
    "@_compoundref": "demux__decode_8c",
    "@_startline": "110",
    "@_endline": "144"
   },
   {
    "#text": "decode_write",
    "@_refid": "hw__decode_8c_1aa376d8bc0bb004de4856e8920e0f6217",
    "@_compoundref": "hw__decode_8c",
    "@_startline": "76",
    "@_endline": "146"
   },
   {
    "#text": "main",
    "@_refid": "decode__filter__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "217",
    "@_endline": "296"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__decoding_1ga11e6542c4e66d3028668788a1a74217c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return decoded output data from a decoder or encoder (when the\n * @ref AV_CODEC_FLAG_RECON_FRAME flag is used).\n *\n * @param avctx codec context\n * @param frame This will be set to a reference-counted video or audio\n *              frame (depending on the decoder type) allocated by the\n *              codec. Note that the function will always call\n *              av_frame_unref(frame) before doing anything else.\n *\n * @retval 0                success, a frame was returned\n * @retval AVERROR(EAGAIN)  output is not available in this state - user must\n *                          try to send new input\n * @retval AVERROR_EOF      the codec has been fully flushed, and there will be\n *                          no more output frames\n * @retval AVERROR(EINVAL)  codec not opened, or it is an encoder without the\n *                          @ref AV_CODEC_FLAG_RECON_FRAME flag enabled\n * @retval \"other negative error code\" legitimate decoding errors\n */"
 },
 "avcodec_send_frame": {
  "type": "int",
  "definition": "int avcodec_send_frame",
  "argsstring": "(AVCodecContext *avctx, const AVFrame *frame)",
  "name": "avcodec_send_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "frame"
   }
  ],
  "briefdescription": {
   "para": "Supply a raw video or audio frame to the encoder."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avcodec_receive_packet()",
      "@_refid": "group__lavc__decoding_1ga5b8eff59cf259747cf0b31563e38ded6",
      "@_kindref": "member"
     },
     "#text": "Useto retrieve buffered output packets."
    },
    {
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "avctx"
         },
         "parameterdescription": {
          "para": "codec context"
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "#text": "frame",
           "@_direction": "in"
          }
         },
         "parameterdescription": {
          "para": {
           "ref": {
            "#text": "AVFrame",
            "@_refid": "structAVFrame",
            "@_kindref": "compound"
           },
           "#text": "containing the raw audio or video frame to be encoded. Ownership of the frame remains with the caller, and the encoder will not write to the frame. The encoder may create a reference to the frame data (or copy it if the frame is not reference-counted). It can be NULL, in which case it is considered a flush packet. This signals the end of the stream. If the encoder still has packets buffered, it will return them after this call. Once flushing mode has been entered, additional flush packets are ignored, and sending frames will return AVERROR_EOF."
          }
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": 0
         },
         "parameterdescription": {
          "para": "success"
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "ref": {
            "#text": "AVERROR(EAGAIN)",
            "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
            "@_kindref": "member"
           }
          }
         },
         "parameterdescription": {
          "para": {
           "ref": {
            "#text": "avcodec_receive_packet()",
            "@_refid": "group__lavc__decoding_1ga5b8eff59cf259747cf0b31563e38ded6",
            "@_kindref": "member"
           },
           "#text": "input is not accepted in the current state - user must read output with(once all output is read, the packet should be resent, and the call will not fail with EAGAIN)."
          }
         }
        },
        {
         "parameternamelist": {
          "parametername": "AVERROR_EOF"
         },
         "parameterdescription": {
          "para": "the encoder has been flushed, and no new frames can be sent to it"
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "ref": {
            "#text": "AVERROR(EINVAL)",
            "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
            "@_kindref": "member"
           }
          }
         },
         "parameterdescription": {
          "para": "codec not opened, it is a decoder, or requires flush"
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "ref": {
            "#text": "AVERROR(ENOMEM)",
            "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
            "@_kindref": "member"
           }
          }
         },
         "parameterdescription": {
          "para": "failed to add packet to internal queue, or similar"
         }
        },
        {
         "parameternamelist": {
          "parametername": "another negative error code"
         },
         "parameterdescription": {
          "para": "legitimate encoding errors"
         }
        }
       ],
       "@_kind": "retval"
      }
     ],
     "#text": "For audio: If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame can have any number of samples. If it is not set, frame->nb_samples must be equal to avctx->frame_size for all frames except the last. The final frame may be smaller than avctx->frame_size."
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2572",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2572",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "encode",
    "@_refid": "encode__audio_8c_1a4883bd84aced552588972551e86d8575",
    "@_compoundref": "encode__audio_8c",
    "@_startline": "94",
    "@_endline": "120"
   },
   {
    "#text": "encode_audio_frame",
    "@_refid": "transcode__aac_8c_1a3d408f21612691f8c93a7aa24ea554ef",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "654",
    "@_endline": "716"
   },
   {
    "#text": "encode_write_frame",
    "@_refid": "transcode_8c_1a0911d751b11fdf9780825b79badfae91",
    "@_compoundref": "transcode_8c",
    "@_startline": "432",
    "@_endline": "471"
   },
   {
    "#text": "write_frame",
    "@_refid": "mux_8c_1a7bdbb3cdac2b8aeadf731768bb193c38",
    "@_compoundref": "mux_8c",
    "@_startline": "83",
    "@_endline": "122"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__decoding_1ga9395cb802a5febf1f00df31497779169",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()\n * to retrieve buffered output packets.\n *\n * @param avctx     codec context\n * @param[in] frame AVFrame containing the raw audio or video frame to be encoded.\n *                  Ownership of the frame remains with the caller, and the\n *                  encoder will not write to the frame. The encoder may create\n *                  a reference to the frame data (or copy it if the frame is\n *                  not reference-counted).\n *                  It can be NULL, in which case it is considered a flush\n *                  packet.  This signals the end of the stream. If the encoder\n *                  still has packets buffered, it will return them after this\n *                  call. Once flushing mode has been entered, additional flush\n *                  packets are ignored, and sending frames will return\n *                  AVERROR_EOF.\n *\n *                  For audio:\n *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame\n *                  can have any number of samples.\n *                  If it is not set, frame->nb_samples must be equal to\n *                  avctx->frame_size for all frames except the last.\n *                  The final frame may be smaller than avctx->frame_size.\n * @retval 0                 success\n * @retval AVERROR(EAGAIN)   input is not accepted in the current state - user must\n *                           read output with avcodec_receive_packet() (once all\n *                           output is read, the packet should be resent, and the\n *                           call will not fail with EAGAIN).\n * @retval AVERROR_EOF       the encoder has been flushed, and no new frames can\n *                           be sent to it\n * @retval AVERROR(EINVAL)   codec not opened, it is a decoder, or requires flush\n * @retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar\n * @retval \"another negative error code\" legitimate encoding errors\n */"
 },
 "avcodec_receive_packet": {
  "type": "int",
  "definition": "int avcodec_receive_packet",
  "argsstring": "(AVCodecContext *avctx, AVPacket *avpkt)",
  "name": "avcodec_receive_packet",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avpkt"
   }
  ],
  "briefdescription": {
   "para": "Read encoded data from the encoder."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": [
     {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "avctx"
        },
        "parameterdescription": {
         "para": "codec context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "avpkt"
        },
        "parameterdescription": {
         "para": "This will be set to a reference-counted packet allocated by the encoder. Note that the function will always call av_packet_unref(avpkt) before doing anything else."
        }
       }
      ],
      "@_kind": "param"
     },
     {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": 0
        },
        "parameterdescription": {
         "para": "success"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "ref": {
           "#text": "AVERROR(EAGAIN)",
           "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
           "@_kindref": "member"
          }
         }
        },
        "parameterdescription": {
         "para": "output is not available in the current state - user must try to send input"
        }
       },
       {
        "parameternamelist": {
         "parametername": "AVERROR_EOF"
        },
        "parameterdescription": {
         "para": "the encoder has been fully flushed, and there will be no more output packets"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "ref": {
           "#text": "AVERROR(EINVAL)",
           "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
           "@_kindref": "member"
          }
         }
        },
        "parameterdescription": {
         "para": "codec not opened, or it is a decoder"
        }
       },
       {
        "parameternamelist": {
         "parametername": "another negative error code"
        },
        "parameterdescription": {
         "para": "legitimate encoding errors"
        }
       }
      ],
      "@_kind": "retval"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2589",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2589",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "encode",
    "@_refid": "encode__audio_8c_1a4883bd84aced552588972551e86d8575",
    "@_compoundref": "encode__audio_8c",
    "@_startline": "94",
    "@_endline": "120"
   },
   {
    "#text": "encode_audio_frame",
    "@_refid": "transcode__aac_8c_1a3d408f21612691f8c93a7aa24ea554ef",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "654",
    "@_endline": "716"
   },
   {
    "#text": "encode_write_frame",
    "@_refid": "transcode_8c_1a0911d751b11fdf9780825b79badfae91",
    "@_compoundref": "transcode_8c",
    "@_startline": "432",
    "@_endline": "471"
   },
   {
    "#text": "write_frame",
    "@_refid": "mux_8c_1a7bdbb3cdac2b8aeadf731768bb193c38",
    "@_compoundref": "mux_8c",
    "@_startline": "83",
    "@_endline": "122"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__decoding_1ga5b8eff59cf259747cf0b31563e38ded6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read encoded data from the encoder.\n *\n * @param avctx codec context\n * @param avpkt This will be set to a reference-counted packet allocated by the\n *              encoder. Note that the function will always call\n *              av_packet_unref(avpkt) before doing anything else.\n * @retval 0               success\n * @retval AVERROR(EAGAIN) output is not available in the current state - user must\n *                         try to send input\n * @retval AVERROR_EOF     the encoder has been fully flushed, and there will be no\n *                         more output packets\n * @retval AVERROR(EINVAL) codec not opened, or it is a decoder\n * @retval \"another negative error code\" legitimate encoding errors\n */"
 },
 "avcodec_get_hw_frames_parameters": {
  "type": "int",
  "definition": "int avcodec_get_hw_frames_parameters",
  "argsstring": "(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)",
  "name": "avcodec_get_hw_frames_parameters",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "device_ref"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "hw_pix_fmt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "out_frames_ref"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVHWFramesContext",
     "@_refid": "structAVHWFramesContext",
     "@_kindref": "compound"
    },
    "#text": "Create and return awith values adequate for hardware decoding."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "AVHWFramesContext",
       "@_refid": "structAVHWFramesContext",
       "@_kindref": "compound"
      },
      {
       "#text": "AVCodecContext.hw_frames_ctx",
       "@_refid": "structAVCodecContext_1a3bac44bb0b016ab838780cc19ac277d6",
       "@_kindref": "member"
      }
     ],
     "#text": "This is meant to get called from the get_format callback, and is a helper for preparing afor. This API is for decoding with certain hardware acceleration modes/APIs only."
    },
    {
     "ref": [
      {
       "#text": "AVHWFramesContext",
       "@_refid": "structAVHWFramesContext",
       "@_kindref": "compound"
      },
      {
       "#text": "av_hwframe_ctx_init()",
       "@_refid": "hwcontext_8h_1a66a7e1ebc7e459ce07d3de6639ac7e38",
       "@_kindref": "member"
      }
     ],
     "#text": "The returnedis not initialized. The caller must do this with."
    },
    "Calling this function is not a requirement, but makes it simpler to avoid codec or hardware API specific details when manually allocating frames.",
    {
     "ref": [
      {
       "#text": "AVCodecContext.hw_device_ctx",
       "@_refid": "structAVCodecContext_1acf8113e490f9e7b57465e65af9c0c75c",
       "@_kindref": "member"
      },
      {
       "#text": "AVCodecContext.hw_frames_ctx",
       "@_refid": "structAVCodecContext_1a3bac44bb0b016ab838780cc19ac277d6",
       "@_kindref": "member"
      },
      {
       "#text": "AVHWFramesContext",
       "@_refid": "structAVHWFramesContext",
       "@_kindref": "compound"
      }
     ],
     "#text": "Alternatively to this, an API user can set, which sets upfully automatically, and makes it unnecessary to call this function or having to care aboutinitialization at all."
    },
    "There are a number of requirements for calling this function:",
    {
     "itemizedlist": {
      "listitem": [
       {
        "para": "It must be called from get_format with the same avctx parameter that was passed to get_format. Calling it outside of get_format is not allowed, and can trigger undefined behavior."
       },
       {
        "para": "The function is not always supported (see description of return values). Even if this function returns successfully, hwaccel initialization could fail later. (The degree to which implementations check whether the stream is actually supported varies. Some do this check only after the user's get_format callback returns.)"
       },
       {
        "para": {
         "ref": {
          "#text": "AVHWFramesContext",
          "@_refid": "structAVHWFramesContext",
          "@_kindref": "compound"
         },
         "#text": "The hw_pix_fmt must be one of the choices suggested by get_format. If the user decides to use aprepared with this API function, the user must return the same hw_pix_fmt from get_format."
        }
       },
       {
        "para": "The device_ref passed to this function must support the given hw_pix_fmt."
       },
       {
        "para": {
         "ref": [
          {
           "#text": "AVHWFramesContext",
           "@_refid": "structAVHWFramesContext",
           "@_kindref": "compound"
          },
          {
           "#text": "AVCodecContext.hw_frames_ctx",
           "@_refid": "structAVCodecContext_1a3bac44bb0b016ab838780cc19ac277d6",
           "@_kindref": "member"
          },
          {
           "#text": "AVCodecContext.hw_frames_ctx",
           "@_refid": "structAVCodecContext_1a3bac44bb0b016ab838780cc19ac277d6",
           "@_kindref": "member"
          }
         ],
         "#text": "After calling this API function, it is the user's responsibility to initialize the(returned by the out_frames_ref parameter), and to setto it. If done, this must be done before returning from get_format (this is implied by the normalAPI rules)."
        }
       },
       {
        "para": {
         "ref": [
          {
           "#text": "AVHWFramesContext",
           "@_refid": "structAVHWFramesContext",
           "@_kindref": "compound"
          },
          {
           "#text": "AVCodecContext.hw_frames_ctx",
           "@_refid": "structAVCodecContext_1a3bac44bb0b016ab838780cc19ac277d6",
           "@_kindref": "member"
          }
         ],
         "#text": "Theparameters may change every time time get_format is called. Also,is reset before get_format. So you are inherently required to go through this process again on every get_format call."
        }
       },
       {
        "para": {
         "ref": [
          {
           "#text": "AVHWFramesContext",
           "@_refid": "structAVHWFramesContext",
           "@_kindref": "compound"
          },
          {
           "#text": "AVHWFramesContext",
           "@_refid": "structAVHWFramesContext",
           "@_kindref": "compound"
          }
         ],
         "#text": "It is perfectly possible to call this function without actually using the resulting. One use-case might be trying to reuse a previously initialized, and calling this API function only to test whether the required frame parameters have changed."
        }
       },
       {
        "para": {
         "ref": [
          {
           "#text": "AVHWFramesContext.free",
           "@_refid": "structAVHWFramesContext_1aaeccab495e5027aa0402dea10bdcd166",
           "@_kindref": "member"
          },
          {
           "#text": "AVHWFramesContext.user_opaque",
           "@_refid": "structAVHWFramesContext_1a4d6e4c17632bd6770654b7627722222e",
           "@_kindref": "member"
          }
         ],
         "#text": "Fields that use dynamically allocated values of any kind must not be set by the user unless setting them is explicitly allowed by the documentation. If the user setsand, the new free callback must call the potentially set previous free callback. This API call may set any dynamically allocated fields, including the free callback."
        }
       }
      ]
     }
    },
    {
     "ref": {
      "#text": "AVHWFramesContext",
      "@_refid": "structAVHWFramesContext",
      "@_kindref": "compound"
     },
     "#text": "The function will set at least the following fields on(potentially more, depending on hwaccel API):"
    },
    {
     "itemizedlist": {
      "listitem": [
       {
        "para": {
         "ref": {
          "#text": "av_hwframe_ctx_alloc()",
          "@_refid": "hwcontext_8h_1a4ecba8a4ac10bfb324aa117f36b6be32",
          "@_kindref": "member"
         },
         "#text": "All fields set by."
        }
       },
       {
        "para": "Set the format field to hw_pix_fmt."
       },
       {
        "para": "Set the sw_format field to the most suited and most versatile format. (An implication is that this will prefer generic formats over opaque formats with arbitrary restrictions, if possible.)"
       },
       {
        "para": "Set the width/height fields to the coded frame size, rounded up to the API-specific minimum alignment."
       },
       {
        "para": {
         "emphasis": "if",
         "#text": "Onlythe hwaccel requires a pre-allocated pool: set the initial_pool_size field to the number of maximum reference surfaces possible with the codec, plus 1 surface for the user to work (meaning the user can safely reference at most 1 decoded surface at a time), plus additional buffering introduced by frame threading. If the hwaccel does not require pre-allocation, the field is left to 0, and the decoder will allocate new surfaces on demand during decoding."
        }
       },
       {
        "para": {
         "ref": {
          "#text": "AVHWFramesContext.hwctx",
          "@_refid": "structAVHWFramesContext_1a54e38c3e4355321e23e0f4c7411cb8ee",
          "@_kindref": "member"
         },
         "#text": "Possiblyfields, depending on the underlying hardware API."
        }
       }
      ]
     }
    },
    {
     "ref": {
      "#text": "av_hwframe_ctx_alloc()",
      "@_refid": "hwcontext_8h_1a4ecba8a4ac10bfb324aa117f36b6be32",
      "@_kindref": "member"
     },
     "#text": "Essentially, out_frames_ref returns the same as, but with basic frame parameters set."
    },
    {
     "ref": [
      {
       "#text": "AVCodecContext",
       "@_refid": "structAVCodecContext",
       "@_kindref": "compound"
      },
      {
       "#text": "AVHWDeviceContext",
       "@_refid": "structAVHWDeviceContext",
       "@_kindref": "compound"
      }
     ],
     "#text": "The function is stateless, and does not change theor the device_ref."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "avctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVHWFramesContext",
           "@_refid": "structAVHWFramesContext",
           "@_kindref": "compound"
          },
          "#text": "The context which is currently calling get_format, and which implicitly contains all state needed for filling the returnedproperly."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "device_ref"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVHWDeviceContext",
           "@_refid": "structAVHWDeviceContext",
           "@_kindref": "compound"
          },
          "#text": "A reference to thedescribing the device which will be used by the hardware decoder."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "hw_pix_fmt"
        },
        "parameterdescription": {
         "para": "The hwaccel format you are going to return from get_format."
        }
       },
       {
        "parameternamelist": {
         "parametername": "out_frames_ref"
        },
        "parameterdescription": {
         "para": {
          "emphasis": "uninitialized",
          "ref": {
           "#text": "AVHWFramesContext",
           "@_refid": "structAVHWFramesContext",
           "@_kindref": "compound"
          },
          "#text": "On success, set to a reference to an, created from the given device_ref. Fields will be set to values required for decoding. Not changed if an error is returned."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "AVERROR(ENOENT)",
         "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
         "@_kindref": "member"
        },
        {
         "#text": "AVCodecContext.hw_frames_ctx",
         "@_refid": "structAVCodecContext_1a3bac44bb0b016ab838780cc19ac277d6",
         "@_kindref": "member"
        },
        {
         "#text": "AVERROR(EINVAL)",
         "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
         "@_kindref": "member"
        }
       ],
       "#text": "zero on success, a negative value on error. The following error codes have special semantics:: the decoder does not support this functionality. Setup is always manual, or it is a decoder which does not support settingat all, or it is a software format.: it is known that hardware decoding is not supported for this configuration, or the device_ref is not supported for the hwaccel referenced by hw_pix_fmt."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2688",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2688",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__decoding_1ga7fc990105405e7958f8051cee81bee6b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create and return a AVHWFramesContext with values adequate for hardware\n * decoding. This is meant to get called from the get_format callback, and is\n * a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.\n * This API is for decoding with certain hardware acceleration modes/APIs only.\n *\n * The returned AVHWFramesContext is not initialized. The caller must do this\n * with av_hwframe_ctx_init().\n *\n * Calling this function is not a requirement, but makes it simpler to avoid\n * codec or hardware API specific details when manually allocating frames.\n *\n * Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,\n * which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes\n * it unnecessary to call this function or having to care about\n * AVHWFramesContext initialization at all.\n *\n * There are a number of requirements for calling this function:\n *\n * - It must be called from get_format with the same avctx parameter that was\n *   passed to get_format. Calling it outside of get_format is not allowed, and\n *   can trigger undefined behavior.\n * - The function is not always supported (see description of return values).\n *   Even if this function returns successfully, hwaccel initialization could\n *   fail later. (The degree to which implementations check whether the stream\n *   is actually supported varies. Some do this check only after the user's\n *   get_format callback returns.)\n * - The hw_pix_fmt must be one of the choices suggested by get_format. If the\n *   user decides to use a AVHWFramesContext prepared with this API function,\n *   the user must return the same hw_pix_fmt from get_format.\n * - The device_ref passed to this function must support the given hw_pix_fmt.\n * - After calling this API function, it is the user's responsibility to\n *   initialize the AVHWFramesContext (returned by the out_frames_ref parameter),\n *   and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done\n *   before returning from get_format (this is implied by the normal\n *   AVCodecContext.hw_frames_ctx API rules).\n * - The AVHWFramesContext parameters may change every time time get_format is\n *   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So\n *   you are inherently required to go through this process again on every\n *   get_format call.\n * - It is perfectly possible to call this function without actually using\n *   the resulting AVHWFramesContext. One use-case might be trying to reuse a\n *   previously initialized AVHWFramesContext, and calling this API function\n *   only to test whether the required frame parameters have changed.\n * - Fields that use dynamically allocated values of any kind must not be set\n *   by the user unless setting them is explicitly allowed by the documentation.\n *   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,\n *   the new free callback must call the potentially set previous free callback.\n *   This API call may set any dynamically allocated fields, including the free\n *   callback.\n *\n * The function will set at least the following fields on AVHWFramesContext\n * (potentially more, depending on hwaccel API):\n *\n * - All fields set by av_hwframe_ctx_alloc().\n * - Set the format field to hw_pix_fmt.\n * - Set the sw_format field to the most suited and most versatile format. (An\n *   implication is that this will prefer generic formats over opaque formats\n *   with arbitrary restrictions, if possible.)\n * - Set the width/height fields to the coded frame size, rounded up to the\n *   API-specific minimum alignment.\n * - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size\n *   field to the number of maximum reference surfaces possible with the codec,\n *   plus 1 surface for the user to work (meaning the user can safely reference\n *   at most 1 decoded surface at a time), plus additional buffering introduced\n *   by frame threading. If the hwaccel does not require pre-allocation, the\n *   field is left to 0, and the decoder will allocate new surfaces on demand\n *   during decoding.\n * - Possibly AVHWFramesContext.hwctx fields, depending on the underlying\n *   hardware API.\n *\n * Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but\n * with basic frame parameters set.\n *\n * The function is stateless, and does not change the AVCodecContext or the\n * device_ref AVHWDeviceContext.\n *\n * @param avctx The context which is currently calling get_format, and which\n *              implicitly contains all state needed for filling the returned\n *              AVHWFramesContext properly.\n * @param device_ref A reference to the AVHWDeviceContext describing the device\n *                   which will be used by the hardware decoder.\n * @param hw_pix_fmt The hwaccel format you are going to return from get_format.\n * @param out_frames_ref On success, set to a reference to an _uninitialized_\n *                       AVHWFramesContext, created from the given device_ref.\n *                       Fields will be set to values required for decoding.\n *                       Not changed if an error is returned.\n * @return zero on success, a negative value on error. The following error codes\n *         have special semantics:\n *      AVERROR(ENOENT): the decoder does not support this functionality. Setup\n *                       is always manual, or it is a decoder which does not\n *                       support setting AVCodecContext.hw_frames_ctx at all,\n *                       or it is a software format.\n *      AVERROR(EINVAL): it is known that hardware decoding is not supported for\n *                       this configuration, or the device_ref is not supported\n *                       for the hwaccel referenced by hw_pix_fmt.\n */"
 },
 "av_parser_iterate": {
  "type": {
   "ref": {
    "#text": "AVCodecParser",
    "@_refid": "structAVCodecParser",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVCodecParser * av_parser_iterate",
  "argsstring": "(void **opaque)",
  "name": "av_parser_iterate",
  "param": {
   "type": "void **",
   "declname": "opaque"
  },
  "briefdescription": {
   "para": "Iterate over all registered codec parsers."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "opaque"
      },
      "parameterdescription": {
       "para": "a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the next registered codec parser or NULL when the iteration is finished",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2889",
   "@_column": "21",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2889",
   "@_declcolumn": "21"
  },
  "@_kind": "function",
  "@_id": "group__lavc__parsing_1ga9c6109817de4bd69807cad12a029db21",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over all registered codec parsers.\n *\n * @param opaque a pointer where libavcodec will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered codec parser or NULL when the iteration is\n *         finished\n */"
 },
 "av_parser_init": {
  "type": {
   "ref": {
    "#text": "AVCodecParserContext",
    "@_refid": "structAVCodecParserContext",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVCodecParserContext * av_parser_init",
  "argsstring": "(int codec_id)",
  "name": "av_parser_init",
  "param": {
   "type": "int",
   "declname": "codec_id"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2891",
   "@_column": "22",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2891",
   "@_declcolumn": "22"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "decode__audio_8c",
   "@_startline": "106",
   "@_endline": "237"
  },
  "@_kind": "function",
  "@_id": "group__lavc__parsing_1ga716362c2dbeed1d660f9cfe0e597ef1b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over all registered codec parsers.\n *\n * @param opaque a pointer where libavcodec will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered codec parser or NULL when the iteration is\n *         finished\n */"
 },
 "av_parser_parse2": {
  "type": "int",
  "definition": "int av_parser_parse2",
  "argsstring": "(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)",
  "name": "av_parser_parse2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecParserContext",
      "@_refid": "structAVCodecParserContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": "uint8_t **",
    "declname": "poutbuf"
   },
   {
    "type": "int *",
    "declname": "poutbuf_size"
   },
   {
    "type": "const uint8_t *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buf_size"
   },
   {
    "type": "int64_t",
    "declname": "pts"
   },
   {
    "type": "int64_t",
    "declname": "dts"
   },
   {
    "type": "int64_t",
    "declname": "pos"
   }
  ],
  "briefdescription": {
   "para": "Parse a packet."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "parser context."
       }
      },
      {
       "parameternamelist": {
        "parametername": "avctx"
       },
       "parameterdescription": {
        "para": "codec context."
       }
      },
      {
       "parameternamelist": {
        "parametername": "poutbuf"
       },
       "parameterdescription": {
        "para": "set to pointer to parsed buffer or NULL if not yet finished."
       }
      },
      {
       "parameternamelist": {
        "parametername": "poutbuf_size"
       },
       "parameterdescription": {
        "para": "set to size of parsed buffer or zero if not yet finished."
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "input buffer."
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf_size"
       },
       "parameterdescription": {
        "para": "buffer size in bytes without the padding. I.e. the full buffer size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE. To signal EOF, this should be 0 (so that the last frame can be output)."
       }
      },
      {
       "parameternamelist": {
        "parametername": "pts"
       },
       "parameterdescription": {
        "para": "input presentation timestamp."
       }
      },
      {
       "parameternamelist": {
        "parametername": "dts"
       },
       "parameterdescription": {
        "para": "input decoding timestamp."
       }
      },
      {
       "parameternamelist": {
        "parametername": "pos"
       },
       "parameterdescription": {
        "para": "input byte position in stream."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the number of bytes of the input bitstream used.",
     "@_kind": "return"
    },
    "programlisting": {
     "codeline": [
      {
       "highlight": {
        "#text": "while(in_len){",
        "@_class": "normal"
       }
      },
      {
       "highlight": {
        "sp": [
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         ""
        ],
        "#text": "len=av_parser_parse2(myparser,AVCodecContext,&data,&size,",
        "@_class": "normal"
       }
      },
      {
       "highlight": {
        "sp": [
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         ""
        ],
        "#text": "in_data,in_len,",
        "@_class": "normal"
       }
      },
      {
       "highlight": {
        "sp": [
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         ""
        ],
        "#text": "pts,dts,pos);",
        "@_class": "normal"
       }
      },
      {
       "highlight": {
        "sp": [
         "",
         "",
         "",
         "",
         "",
         ""
        ],
        "#text": "in_data+=len;",
        "@_class": "normal"
       }
      },
      {
       "highlight": {
        "sp": [
         "",
         "",
         "",
         "",
         "",
         "",
         ""
        ],
        "#text": "in_len-=len;",
        "@_class": "normal"
       }
      },
      "",
      {
       "highlight": {
        "sp": [
         "",
         "",
         "",
         ""
        ],
        "#text": "if(size)",
        "@_class": "normal"
       }
      },
      {
       "highlight": {
        "sp": [
         "",
         "",
         "",
         "",
         "",
         "",
         "",
         ""
        ],
        "#text": "decode_frame(data,size);",
        "@_class": "normal"
       }
      },
      {
       "highlight": {
        "#text": "}",
        "@_class": "normal"
       }
      }
     ]
    },
    "#text": "Example:"
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2924",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2924",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "decode__audio_8c",
   "@_startline": "106",
   "@_endline": "237"
  },
  "@_kind": "function",
  "@_id": "group__lavc__parsing_1ga691ca0258e91f99297e7726f56d8c247",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse a packet.\n *\n * @param s             parser context.\n * @param avctx         codec context.\n * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.\n * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.\n * @param buf           input buffer.\n * @param buf_size      buffer size in bytes without the padding. I.e. the full buffer\n                        size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.\n                        To signal EOF, this should be 0 (so that the last frame\n                        can be output).\n * @param pts           input presentation timestamp.\n * @param dts           input decoding timestamp.\n * @param pos           input byte position in stream.\n * @return the number of bytes of the input bitstream used.\n *\n * Example:\n * @code\n *   while(in_len){\n *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,\n *                                        in_data, in_len,\n *                                        pts, dts, pos);\n *       in_data += len;\n *       in_len  -= len;\n *\n *       if(size)\n *          decode_frame(data, size);\n *   }\n * @endcode\n */"
 },
 "av_parser_close": {
  "type": "void",
  "definition": "void av_parser_close",
  "argsstring": "(AVCodecParserContext *s)",
  "name": "av_parser_close",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecParserContext",
     "@_refid": "structAVCodecParserContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2931",
   "@_column": "6",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2931",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "decode__audio_8c",
   "@_startline": "106",
   "@_endline": "237"
  },
  "@_kind": "function",
  "@_id": "group__lavc__parsing_1ga325e84c53b8c0dfcb2d933d126f76dd7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse a packet.\n *\n * @param s             parser context.\n * @param avctx         codec context.\n * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.\n * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.\n * @param buf           input buffer.\n * @param buf_size      buffer size in bytes without the padding. I.e. the full buffer\n                        size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.\n                        To signal EOF, this should be 0 (so that the last frame\n                        can be output).\n * @param pts           input presentation timestamp.\n * @param dts           input decoding timestamp.\n * @param pos           input byte position in stream.\n * @return the number of bytes of the input bitstream used.\n *\n * Example:\n * @code\n *   while(in_len){\n *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,\n *                                        in_data, in_len,\n *                                        pts, dts, pos);\n *       in_data += len;\n *       in_len  -= len;\n *\n *       if(size)\n *          decode_frame(data, size);\n *   }\n * @endcode\n */"
 },
 "avcodec_encode_subtitle": {
  "type": "int",
  "definition": "int avcodec_encode_subtitle",
  "argsstring": "(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)",
  "name": "avcodec_encode_subtitle",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": "uint8_t *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buf_size"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSubtitle",
      "@_refid": "structAVSubtitle",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "sub"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2943",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2943",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__encoding_1ga37be256d85d78f665df27ad6c8f1d65b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @addtogroup lavc_encoding\n * @{\n */"
 },
 "avcodec_pix_fmt_to_codec_tag": {
  "type": "unsigned int",
  "definition": "unsigned int avcodec_pix_fmt_to_codec_tag",
  "argsstring": "(enum AVPixelFormat pix_fmt)",
  "name": "avcodec_pix_fmt_to_codec_tag",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixelFormat",
     "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "pix_fmt"
  },
  "briefdescription": {
   "para": "Return a value representing the fourCC code associated to the pixel format pix_fmt, or 0 if no associated fourCC code can be found."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2972",
   "@_column": "14",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2972",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc__pixfmt_1ga9bb07f91a7c87cba19a44ebdcf5bde63",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return a value representing the fourCC code associated to the\n * pixel format pix_fmt, or 0 if no associated fourCC code can be\n * found.\n */"
 },
 "avcodec_find_best_pix_fmt_of_list": {
  "type": {
   "ref": {
    "#text": "AVPixelFormat",
    "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVPixelFormat avcodec_find_best_pix_fmt_of_list",
  "argsstring": "(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)",
  "name": "avcodec_find_best_pix_fmt_of_list",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "const enum*"
    },
    "declname": "pix_fmt_list"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "src_pix_fmt"
   },
   {
    "type": "int",
    "declname": "has_alpha"
   },
   {
    "type": "int *",
    "declname": "loss_ptr"
   }
  ],
  "briefdescription": {
   "para": "Find the best pixel format to convert to given a certain source pixel format."
  },
  "detaileddescription": {
   "para": [
    "When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of the given pixel formats should be used to suffer the least amount of loss. The pixel formats from which it chooses one, are determined by the pix_fmt_list parameter.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "pix_fmt_list",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "AV_PIX_FMT_NONE terminated array of pixel formats to choose from"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "src_pix_fmt",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "source pixel format"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "has_alpha",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Whether the source pixel format alpha channel is used."
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "loss_ptr",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "Combination of flags informing you what kind of losses will occur."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "The best pixel format to convert to or -1 if none was found.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2991",
   "@_column": "19",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2991",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc__pixfmt_1ga9e74b43a3433ccfe836814f0a6371aa0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find the best pixel format to convert to given a certain source pixel\n * format.  When converting from one pixel format to another, information loss\n * may occur.  For example, when converting from RGB24 to GRAY, the color\n * information will be lost. Similarly, other losses occur when converting from\n * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of\n * the given pixel formats should be used to suffer the least amount of loss.\n * The pixel formats from which it chooses one, are determined by the\n * pix_fmt_list parameter.\n *\n *\n * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from\n * @param[in] src_pix_fmt source pixel format\n * @param[in] has_alpha Whether the source pixel format alpha channel is used.\n * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.\n * @return The best pixel format to convert to or -1 if none was found.\n */"
 },
 "avcodec_default_get_format": {
  "type": {
   "ref": {
    "#text": "AVPixelFormat",
    "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVPixelFormat avcodec_default_get_format",
  "argsstring": "(struct AVCodecContext *s, const enum AVPixelFormat *fmt)",
  "name": "avcodec_default_get_format",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "const enum*"
    },
    "declname": "fmt"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "2995",
   "@_column": "19",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "2995",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc__pixfmt_1ga2d16136bf8844295b2f8ea17c386d833",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find the best pixel format to convert to given a certain source pixel\n * format.  When converting from one pixel format to another, information loss\n * may occur.  For example, when converting from RGB24 to GRAY, the color\n * information will be lost. Similarly, other losses occur when converting from\n * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of\n * the given pixel formats should be used to suffer the least amount of loss.\n * The pixel formats from which it chooses one, are determined by the\n * pix_fmt_list parameter.\n *\n *\n * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from\n * @param[in] src_pix_fmt source pixel format\n * @param[in] has_alpha Whether the source pixel format alpha channel is used.\n * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.\n * @return The best pixel format to convert to or -1 if none was found.\n */"
 },
 "avcodec_string": {
  "type": "void",
  "definition": "void avcodec_string",
  "argsstring": "(char *buf, int buf_size, AVCodecContext *enc, int encode)",
  "name": "avcodec_string",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buf_size"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "enc"
   },
   {
    "type": "int",
    "declname": "encode"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "3001",
   "@_column": "6",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "3001",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc_1ga6d4056568b5ab73d2e55800d9a5caa66",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @}\n */"
 },
 "avcodec_default_execute": {
  "type": "int",
  "definition": "int avcodec_default_execute",
  "argsstring": "(AVCodecContext *c, int(*func)(AVCodecContext *c2, void *arg2), void *arg, int *ret, int count, int size)",
  "name": "avcodec_default_execute",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "c"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "int(*)(*c2, void *arg2)"
    },
    "declname": "func"
   },
   {
    "type": "void *",
    "declname": "arg"
   },
   {
    "type": "int *",
    "declname": "ret"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "3003",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "3003",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc_1ga9ccd730ba6e891b6c61da68ab138c63f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @}\n */"
 },
 "avcodec_default_execute2": {
  "type": "int",
  "definition": "int avcodec_default_execute2",
  "argsstring": "(AVCodecContext *c, int(*func)(AVCodecContext *c2, void *arg2, int, int), void *arg, int *ret, int count)",
  "name": "avcodec_default_execute2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "c"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "int(*)(*c2, void *arg2, int, int)"
    },
    "declname": "func"
   },
   {
    "type": "void *",
    "declname": "arg"
   },
   {
    "type": "int *",
    "declname": "ret"
   },
   {
    "type": "int",
    "declname": "count"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "3004",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "3004",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc_1ga365b89d7f5b6dc9f930f07ec4078a611",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @}\n */"
 },
 "avcodec_fill_audio_frame": {
  "type": "int",
  "definition": "int avcodec_fill_audio_frame",
  "argsstring": "(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)",
  "name": "avcodec_fill_audio_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": "int",
    "declname": "nb_channels"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "sample_fmt"
   },
   {
    "type": "const uint8_t *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buf_size"
   },
   {
    "type": "int",
    "declname": "align"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "Fillaudio data and linesize pointers."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "The buffer buf must be a preallocated buffer with a size big enough to contain the specified samples amount. The filleddata pointers will point to this buffer."
    },
    {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "extended_data channel pointers are allocated if necessary for planar audio."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "frame"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVFrame",
           "@_refid": "structAVFrame",
           "@_kindref": "compound"
          },
          "#text": "theframe->nb_samples must be set prior to calling the function. This function fills in frame->data, frame->extended_data, frame->linesize[0]."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_channels"
        },
        "parameterdescription": {
         "para": "channel count"
        }
       },
       {
        "parameternamelist": {
         "parametername": "sample_fmt"
        },
        "parameterdescription": {
         "para": "sample format"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "buffer to use for frame data"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf_size"
        },
        "parameterdescription": {
         "para": "size of buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "align"
        },
        "parameterdescription": {
         "para": "plane size sample alignment (0 = default)"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">=0 on success, negative error code on failure",
      "@_kind": "return"
     },
     "xrefsect": {
      "xreftitle": "Todo",
      "xrefdescription": {
       "para": "return the size in bytes required to store the samples in case of success, at the next libavutil bump"
      },
      "@_id": "todo_1_todo000002"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "3030",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "3030",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc_1ga66b44aad56fa22a78fb8916eb8cc0516",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill AVFrame audio data and linesize pointers.\n *\n * The buffer buf must be a preallocated buffer with a size big enough\n * to contain the specified samples amount. The filled AVFrame data\n * pointers will point to this buffer.\n *\n * AVFrame extended_data channel pointers are allocated if necessary for\n * planar audio.\n *\n * @param frame       the AVFrame\n *                    frame->nb_samples must be set prior to calling the\n *                    function. This function fills in frame->data,\n *                    frame->extended_data, frame->linesize[0].\n * @param nb_channels channel count\n * @param sample_fmt  sample format\n * @param buf         buffer to use for frame data\n * @param buf_size    size of buffer\n * @param align       plane size sample alignment (0 = default)\n * @return            >=0 on success, negative error code on failure\n * @todo return the size in bytes required to store the samples in\n * case of success, at the next libavutil bump\n */"
 },
 "avcodec_flush_buffers": {
  "type": "void",
  "definition": "void avcodec_flush_buffers",
  "argsstring": "(AVCodecContext *avctx)",
  "name": "avcodec_flush_buffers",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecContext",
     "@_refid": "structAVCodecContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "avctx"
  },
  "briefdescription": {
   "para": "Reset the internal codec state / flush internal buffers."
  },
  "detaileddescription": {
   "para": [
    "Should be called e.g. when seeking or when switching to a different stream.",
    {
     "simplesect": [
      {
       "para": "for decoders, this function just releases any references the decoder might keep internally, but the caller's references remain valid.",
       "@_kind": "note"
      },
      {
       "para": "for encoders, this function will only do something if the encoder declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder will drain any remaining packets, and can then be re-used for a different stream (as opposed to sending a null frame which will leave the encoder in a permanent EOF state after draining). This can be desirable if the cost of tearing down and replacing the encoder instance is high.",
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "3048",
   "@_column": "6",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "3048",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc_1gaf60b0e076f822abcb2700eb601d352a6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reset the internal codec state / flush internal buffers. Should be called\n * e.g. when seeking or when switching to a different stream.\n *\n * @note for decoders, this function just releases any references the decoder\n * might keep internally, but the caller's references remain valid.\n *\n * @note for encoders, this function will only do something if the encoder\n * declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder\n * will drain any remaining packets, and can then be re-used for a different\n * stream (as opposed to sending a null frame which will leave the encoder\n * in a permanent EOF state after draining). This can be desirable if the\n * cost of tearing down and replacing the encoder instance is high.\n */"
 },
 "av_get_audio_frame_duration": {
  "type": "int",
  "definition": "int av_get_audio_frame_duration",
  "argsstring": "(AVCodecContext *avctx, int frame_bytes)",
  "name": "av_get_audio_frame_duration",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": "int",
    "declname": "frame_bytes"
   }
  ],
  "briefdescription": {
   "para": "Return audio frame duration."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "avctx"
       },
       "parameterdescription": {
        "para": "codec context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "frame_bytes"
       },
       "parameterdescription": {
        "para": "size of the frame, or 0 if unknown"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "frame duration, in samples, if known. 0 if not able to determine.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "3058",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "3058",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc_1ga3266a8c3df0790c62259f91afcde45a9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return audio frame duration.\n *\n * @param avctx        codec context\n * @param frame_bytes  size of the frame, or 0 if unknown\n * @return             frame duration, in samples, if known. 0 if not able to\n *                     determine.\n */"
 },
 "av_fast_padded_malloc": {
  "type": "void",
  "definition": "void av_fast_padded_malloc",
  "argsstring": "(void *ptr, unsigned int *size, size_t min_size)",
  "name": "av_fast_padded_malloc",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "unsigned int *",
    "declname": "size"
   },
   {
    "type": "size_t",
    "declname": "min_size"
   }
  ],
  "briefdescription": {
   "para": "Same behaviour av_fast_malloc but the buffer has additional AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0."
  },
  "detaileddescription": {
   "para": "In addition the whole buffer will initially and after resizes be 0-initialized so that no uninitialized data will ever appear."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "3069",
   "@_column": "6",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "3069",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc_1ga04a23a2336412504052d5c4e0c7716ee",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Same behaviour av_fast_malloc but the buffer has additional\n * AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.\n *\n * In addition the whole buffer will initially and after resizes\n * be 0-initialized so that no uninitialized data will ever appear.\n */"
 },
 "av_fast_padded_mallocz": {
  "type": "void",
  "definition": "void av_fast_padded_mallocz",
  "argsstring": "(void *ptr, unsigned int *size, size_t min_size)",
  "name": "av_fast_padded_mallocz",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "unsigned int *",
    "declname": "size"
   },
   {
    "type": "size_t",
    "declname": "min_size"
   }
  ],
  "briefdescription": {
   "para": "Same behaviour av_fast_padded_malloc except that buffer will always be 0-initialized after call."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "3075",
   "@_column": "6",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "3075",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc_1gaea5550dc9271f356631f7002772158d8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Same behaviour av_fast_padded_malloc except that buffer will always\n * be 0-initialized after call.\n */"
 },
 "avcodec_is_open": {
  "type": "int",
  "definition": "int avcodec_is_open",
  "argsstring": "(AVCodecContext *s)",
  "name": "avcodec_is_open",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecContext",
     "@_refid": "structAVCodecContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": [
       {
        "#text": "avcodec_open2()",
        "@_refid": "group__lavc__core_1ga11f785a188d7d9df71621001465b0f1d",
        "@_kindref": "member"
       },
       {
        "#text": "avcodec_close()",
        "@_refid": "group__lavc__core_1gab7f632082a10fcb051fa3e2db7f86942",
        "@_kindref": "member"
       }
      ],
      "#text": "a positive value if s is open (i.e.was called on it with no corresponding), 0 otherwise."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avcodec.h",
   "@_line": "3081",
   "@_column": "5",
   "@_declfile": "libavcodec/avcodec.h",
   "@_declline": "3081",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__misc_1ga906dda732e79eac12067c6d7ea19b630",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return a positive value if s is open (i.e. avcodec_open2() was called on it\n * with no corresponding avcodec_close()), 0 otherwise.\n */"
 },
 "avcodec_dct_alloc": {
  "type": {
   "ref": {
    "#text": "AVDCT",
    "@_refid": "structAVDCT",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDCT * avcodec_dct_alloc",
  "argsstring": "(void)",
  "name": "avcodec_dct_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVDCT",
     "@_refid": "structAVDCT",
     "@_kindref": "compound"
    },
    "#text": "Allocates acontext."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avcodec_dct_init()",
      "@_refid": "avdct_8h_1a4d987ad7fd4893904dfec30087b1a972",
      "@_kindref": "member"
     },
     "#text": "This needs to be initialized withafter optionally configuring it with AVOptions."
    },
    {
     "ref": {
      "#text": "av_free()",
      "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
      "@_kindref": "member"
     },
     "#text": "To free it use"
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avdct.h",
   "@_line": "83",
   "@_column": "7",
   "@_declfile": "libavcodec/avdct.h",
   "@_declline": "83",
   "@_declcolumn": "7"
  },
  "@_kind": "function",
  "@_id": "avdct_8h_1a213c013795f1c58f0fe16e2e968f03ba",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates a AVDCT context.\n * This needs to be initialized with avcodec_dct_init() after optionally\n * configuring it with AVOptions.\n *\n * To free it use av_free()\n */"
 },
 "avcodec_dct_init": {
  "type": "int",
  "definition": "int avcodec_dct_init",
  "argsstring": "(AVDCT *)",
  "name": "avcodec_dct_init",
  "param": {
   "type": {
    "ref": {
     "#text": "AVDCT",
     "@_refid": "structAVDCT",
     "@_kindref": "compound"
    },
    "#text": "*"
   }
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avdct.h",
   "@_line": "84",
   "@_column": "5",
   "@_declfile": "libavcodec/avdct.h",
   "@_declline": "84",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avdct_8h_1a4d987ad7fd4893904dfec30087b1a972",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates a AVDCT context.\n * This needs to be initialized with avcodec_dct_init() after optionally\n * configuring it with AVOptions.\n *\n * To free it use av_free()\n */"
 },
 "avcodec_dct_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * avcodec_dct_get_class",
  "argsstring": "(void)",
  "name": "avcodec_dct_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avdct.h",
   "@_line": "86",
   "@_column": "15",
   "@_declfile": "libavcodec/avdct.h",
   "@_declline": "86",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "avdct_8h_1a8320e5dd2dd018d3a4bb9365ff3c01a1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates a AVDCT context.\n * This needs to be initialized with avcodec_dct_init() after optionally\n * configuring it with AVOptions.\n *\n * To free it use av_free()\n */"
 },
 "avdevice_version": {
  "type": "unsigned",
  "definition": "unsigned avdevice_version",
  "argsstring": "(void)",
  "name": "avdevice_version",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the LIBAVDEVICE_VERSION_INT constant."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "62",
   "@_column": "10",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "62",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1ga6a111710c7b02c2a11d8b6c43e0dd63d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the LIBAVDEVICE_VERSION_INT constant.\n */"
 },
 "avdevice_configuration": {
  "type": "const char *",
  "definition": "const char * avdevice_configuration",
  "argsstring": "(void)",
  "name": "avdevice_configuration",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libavdevice build-time configuration."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "67",
   "@_column": "12",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "67",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1ga788d54225eca6950259630999a92dfd0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libavdevice build-time configuration.\n */"
 },
 "avdevice_license": {
  "type": "const char *",
  "definition": "const char * avdevice_license",
  "argsstring": "(void)",
  "name": "avdevice_license",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libavdevice license."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "72",
   "@_column": "12",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "72",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1gaee7745bf393a9e5dbf0959457f9a3427",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libavdevice license.\n */"
 },
 "avdevice_register_all": {
  "type": "void",
  "definition": "void avdevice_register_all",
  "argsstring": "(void)",
  "name": "avdevice_register_all",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Initialize libavdevice and register all the input and output devices."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "77",
   "@_column": "6",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "77",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1ga7c90a3585267b55941ae2f7388c006b6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize libavdevice and register all the input and output devices.\n */"
 },
 "av_input_audio_device_next": {
  "type": {
   "ref": {
    "#text": "AVInputFormat",
    "@_refid": "structAVInputFormat",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVInputFormat * av_input_audio_device_next",
  "argsstring": "(const AVInputFormat *d)",
  "name": "av_input_audio_device_next",
  "param": {
   "type": {
    "ref": {
     "#text": "AVInputFormat",
     "@_refid": "structAVInputFormat",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "d"
  },
  "briefdescription": {
   "para": "Audio input devices iterator."
  },
  "detaileddescription": {
   "para": "If d is NULL, returns the first registered input audio/video device, if d is non-NULL, returns the next registered input audio/video device after d or NULL if d is the last one."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "86",
   "@_column": "21",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "86",
   "@_declcolumn": "21"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1gad5df91268b335891110e8cf2580b65af",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Audio input devices iterator.\n *\n * If d is NULL, returns the first registered input audio/video device,\n * if d is non-NULL, returns the next registered input audio/video device after d\n * or NULL if d is the last one.\n */"
 },
 "av_input_video_device_next": {
  "type": {
   "ref": {
    "#text": "AVInputFormat",
    "@_refid": "structAVInputFormat",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVInputFormat * av_input_video_device_next",
  "argsstring": "(const AVInputFormat *d)",
  "name": "av_input_video_device_next",
  "param": {
   "type": {
    "ref": {
     "#text": "AVInputFormat",
     "@_refid": "structAVInputFormat",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "d"
  },
  "briefdescription": {
   "para": "Video input devices iterator."
  },
  "detaileddescription": {
   "para": "If d is NULL, returns the first registered input audio/video device, if d is non-NULL, returns the next registered input audio/video device after d or NULL if d is the last one."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "95",
   "@_column": "21",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "95",
   "@_declcolumn": "21"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1gab69e789f47503d54b5dc448cc8355fe9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Video input devices iterator.\n *\n * If d is NULL, returns the first registered input audio/video device,\n * if d is non-NULL, returns the next registered input audio/video device after d\n * or NULL if d is the last one.\n */"
 },
 "av_output_audio_device_next": {
  "type": {
   "ref": {
    "#text": "AVOutputFormat",
    "@_refid": "structAVOutputFormat",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVOutputFormat * av_output_audio_device_next",
  "argsstring": "(const AVOutputFormat *d)",
  "name": "av_output_audio_device_next",
  "param": {
   "type": {
    "ref": {
     "#text": "AVOutputFormat",
     "@_refid": "structAVOutputFormat",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "d"
  },
  "briefdescription": {
   "para": "Audio output devices iterator."
  },
  "detaileddescription": {
   "para": "If d is NULL, returns the first registered output audio/video device, if d is non-NULL, returns the next registered output audio/video device after d or NULL if d is the last one."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "104",
   "@_column": "22",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "104",
   "@_declcolumn": "22"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1ga408630f905799d7335f92918fe0cbed5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Audio output devices iterator.\n *\n * If d is NULL, returns the first registered output audio/video device,\n * if d is non-NULL, returns the next registered output audio/video device after d\n * or NULL if d is the last one.\n */"
 },
 "av_output_video_device_next": {
  "type": {
   "ref": {
    "#text": "AVOutputFormat",
    "@_refid": "structAVOutputFormat",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVOutputFormat * av_output_video_device_next",
  "argsstring": "(const AVOutputFormat *d)",
  "name": "av_output_video_device_next",
  "param": {
   "type": {
    "ref": {
     "#text": "AVOutputFormat",
     "@_refid": "structAVOutputFormat",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "d"
  },
  "briefdescription": {
   "para": "Video output devices iterator."
  },
  "detaileddescription": {
   "para": "If d is NULL, returns the first registered output audio/video device, if d is non-NULL, returns the next registered output audio/video device after d or NULL if d is the last one."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "113",
   "@_column": "22",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "113",
   "@_declcolumn": "22"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1ga317e8f53ee75a85ad68d87b00be331a8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Video output devices iterator.\n *\n * If d is NULL, returns the first registered output audio/video device,\n * if d is non-NULL, returns the next registered output audio/video device after d\n * or NULL if d is the last one.\n */"
 },
 "avdevice_app_to_dev_control_message": {
  "type": "int",
  "definition": "int avdevice_app_to_dev_control_message",
  "argsstring": "(struct AVFormatContext *s, enum AVAppToDevMessageType type, void *data, size_t data_size)",
  "name": "avdevice_app_to_dev_control_message",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVAppToDevMessageType",
      "@_refid": "group__lavd_1ga16d549a25f11693a06a211f00864fed8",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "void *",
    "declname": "data"
   },
   {
    "type": "size_t",
    "declname": "data_size"
   }
  ],
  "briefdescription": {
   "para": "Send control message from application to device."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "device context."
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "message type."
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "message data. Exact type depends on message type."
       }
      },
      {
       "parameternamelist": {
        "parametername": "data_size"
       },
       "parameterdescription": {
        "para": "size of message data."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVERROR(ENOSYS)",
       "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
       "@_kindref": "member"
      },
      "#text": ">= 0 on success, negative on error.when device doesn't implement handler of the message."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "312",
   "@_column": "5",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "312",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1ga62f5a22de09f0bc7fd2380d39ee1bc45",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Send control message from application to device.\n *\n * @param s         device context.\n * @param type      message type.\n * @param data      message data. Exact type depends on message type.\n * @param data_size size of message data.\n * @return >= 0 on success, negative on error.\n *         AVERROR(ENOSYS) when device doesn't implement handler of the message.\n */"
 },
 "avdevice_dev_to_app_control_message": {
  "type": "int",
  "definition": "int avdevice_dev_to_app_control_message",
  "argsstring": "(struct AVFormatContext *s, enum AVDevToAppMessageType type, void *data, size_t data_size)",
  "name": "avdevice_dev_to_app_control_message",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDevToAppMessageType",
      "@_refid": "group__lavd_1gac379d3691ce091da6387a461a158a690",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "void *",
    "declname": "data"
   },
   {
    "type": "size_t",
    "declname": "data_size"
   }
  ],
  "briefdescription": {
   "para": "Send control message from device to application."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "device context."
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "message type."
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "message data. Can be NULL."
       }
      },
      {
       "parameternamelist": {
        "parametername": "data_size"
       },
       "parameterdescription": {
        "para": "size of message data."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVERROR(ENOSYS)",
       "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
       "@_kindref": "member"
      },
      "#text": ">= 0 on success, negative on error.when application doesn't implement handler of the message."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "326",
   "@_column": "5",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "326",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1gaf426838f78fb5bcdc2095c4d3162cf6e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Send control message from device to application.\n *\n * @param s         device context.\n * @param type      message type.\n * @param data      message data. Can be NULL.\n * @param data_size size of message data.\n * @return >= 0 on success, negative on error.\n *         AVERROR(ENOSYS) when application doesn't implement handler of the message.\n */"
 },
 "avdevice_list_devices": {
  "type": "int",
  "definition": "int avdevice_list_devices",
  "argsstring": "(struct AVFormatContext *s, AVDeviceInfoList **device_list)",
  "name": "avdevice_list_devices",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDeviceInfoList",
      "@_refid": "structAVDeviceInfoList",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "device_list"
   }
  ],
  "briefdescription": {
   "para": "List devices."
  },
  "detaileddescription": {
   "para": [
    "Returns available device names and their parameters.",
    {
     "simplesect": [
      {
       "para": ": Some devices may accept system-dependent device names that cannot be autodetected. The list returned by this function cannot be assumed to be always completed.",
       "@_kind": "note"
      },
      {
       "para": "count of autodetected devices, negative on error.",
       "@_kind": "return"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "device context."
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "device_list",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "list of autodetected devices."
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "362",
   "@_column": "5",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "362",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1ga4bf9cc38ae904b9104fda1e4def71474",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * List devices.\n *\n * Returns available device names and their parameters.\n *\n * @note: Some devices may accept system-dependent device names that cannot be\n *        autodetected. The list returned by this function cannot be assumed to\n *        be always completed.\n *\n * @param s                device context.\n * @param[out] device_list list of autodetected devices.\n * @return count of autodetected devices, negative on error.\n */"
 },
 "avdevice_free_list_devices": {
  "type": "void",
  "definition": "void avdevice_free_list_devices",
  "argsstring": "(AVDeviceInfoList **device_list)",
  "name": "avdevice_free_list_devices",
  "param": {
   "type": {
    "ref": {
     "#text": "AVDeviceInfoList",
     "@_refid": "structAVDeviceInfoList",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "device_list"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "avdevice_list_devices()",
     "@_refid": "group__lavd_1ga4bf9cc38ae904b9104fda1e4def71474",
     "@_kindref": "member"
    },
    "#text": "Convenient function to free result of."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "device_list"
      },
      "parameterdescription": {
       "para": "device list to be freed."
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "369",
   "@_column": "6",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "369",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1ga52dcbb2d9ae0f33b7a89548b5a0c87bd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convenient function to free result of avdevice_list_devices().\n *\n * @param device_list device list to be freed.\n */"
 },
 "avdevice_list_input_sources": {
  "type": "int",
  "definition": "int avdevice_list_input_sources",
  "argsstring": "(const AVInputFormat *device, const char *device_name, AVDictionary *device_options, AVDeviceInfoList **device_list)",
  "name": "avdevice_list_input_sources",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVInputFormat",
      "@_refid": "structAVInputFormat",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "device"
   },
   {
    "type": "const char *",
    "declname": "device_name"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "device_options"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDeviceInfoList",
      "@_refid": "structAVDeviceInfoList",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "device_list"
   }
  ],
  "briefdescription": {
   "para": "List devices."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avdevice_list_devices()",
      "@_refid": "group__lavd_1ga4bf9cc38ae904b9104fda1e4def71474",
      "@_kindref": "member"
     },
     "#text": "Returns available device names and their parameters. These are convinient wrappers for. Device context is allocated and deallocated internally."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "device"
        },
        "parameterdescription": {
         "para": "device format. May be NULL if device name is set."
        }
       },
       {
        "parameternamelist": {
         "parametername": "device_name"
        },
        "parameterdescription": {
         "para": "device name. May be NULL if device format is set."
        }
       },
       {
        "parameternamelist": {
         "parametername": "device_options"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "avformat_write_header()",
            "@_refid": "group__lavf__encoding_1ga18b7b10bb5b94c4842de18166bc677cb",
            "@_kindref": "member"
           },
           {
            "#text": "avformat_open_input()",
            "@_refid": "group__lavf__decoding_1gac05d61a2b492ae3985c658f34622c19d",
            "@_kindref": "member"
           }
          ],
          "#text": "An AVDictionary filled with device-private options. May be NULL. The same options must be passed later tofor output devices orfor input devices, or at any other place that affects device-private options."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "device_list",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "list of autodetected devices"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "count of autodetected devices, negative on error.",
       "@_kind": "return"
      },
      {
       "para": "device argument takes precedence over device_name when both are set.",
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "388",
   "@_column": "5",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "388",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1gad15c05ace8090682b947211c76189388",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * List devices.\n *\n * Returns available device names and their parameters.\n * These are convinient wrappers for avdevice_list_devices().\n * Device context is allocated and deallocated internally.\n *\n * @param device           device format. May be NULL if device name is set.\n * @param device_name      device name. May be NULL if device format is set.\n * @param device_options   An AVDictionary filled with device-private options. May be NULL.\n *                         The same options must be passed later to avformat_write_header() for output\n *                         devices or avformat_open_input() for input devices, or at any other place\n *                         that affects device-private options.\n * @param[out] device_list list of autodetected devices\n * @return count of autodetected devices, negative on error.\n * @note device argument takes precedence over device_name when both are set.\n */"
 },
 "avdevice_list_output_sinks": {
  "type": "int",
  "definition": "int avdevice_list_output_sinks",
  "argsstring": "(const AVOutputFormat *device, const char *device_name, AVDictionary *device_options, AVDeviceInfoList **device_list)",
  "name": "avdevice_list_output_sinks",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVOutputFormat",
      "@_refid": "structAVOutputFormat",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "device"
   },
   {
    "type": "const char *",
    "declname": "device_name"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "device_options"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDeviceInfoList",
      "@_refid": "structAVDeviceInfoList",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "device_list"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavdevice/avdevice.h",
   "@_line": "390",
   "@_column": "5",
   "@_declfile": "libavdevice/avdevice.h",
   "@_declline": "390",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavd_1gac38572c5ba27b5cf6d3943cb97233309",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * List devices.\n *\n * Returns available device names and their parameters.\n * These are convinient wrappers for avdevice_list_devices().\n * Device context is allocated and deallocated internally.\n *\n * @param device           device format. May be NULL if device name is set.\n * @param device_name      device name. May be NULL if device format is set.\n * @param device_options   An AVDictionary filled with device-private options. May be NULL.\n *                         The same options must be passed later to avformat_write_header() for output\n *                         devices or avformat_open_input() for input devices, or at any other place\n *                         that affects device-private options.\n * @param[out] device_list list of autodetected devices\n * @return count of autodetected devices, negative on error.\n * @note device argument takes precedence over device_name when both are set.\n */"
 },
 "FFTSample": {
  "type": "float",
  "definition": "typedef float FFTSample",
  "argsstring": "",
  "name": "FFTSample",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "39",
   "@_column": "15",
   "@_bodyfile": "libavcodec/avfft.h",
   "@_bodystart": "39",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavc__fft_1gaa306dc16df543b25d9910debc3f76b96",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * @defgroup lavc_fft FFT functions\n * @ingroup lavc_misc\n *\n * @{\n */"
 },
 "FFTContext": {
  "type": {
   "ref": {
    "#text": "FFTContext",
    "@_refid": "group__lavc__fft_1gaac01e094370275491c7cbc580de0fe24",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct FFTContext FFTContext",
  "argsstring": "",
  "name": "FFTContext",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "45",
   "@_column": "25",
   "@_bodyfile": "libavcodec/avfft.h",
   "@_bodystart": "45",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavc__fft_1gaac01e094370275491c7cbc580de0fe24",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * @defgroup lavc_fft FFT functions\n * @ingroup lavc_misc\n *\n * @{\n */"
 },
 "RDFTContext": {
  "type": {
   "ref": {
    "#text": "RDFTContext",
    "@_refid": "group__lavc__fft_1gad6a19df0e8cfc4d67a325e4f91fd9cd9",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct RDFTContext RDFTContext",
  "argsstring": "",
  "name": "RDFTContext",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "98",
   "@_column": "26",
   "@_bodyfile": "libavcodec/avfft.h",
   "@_bodystart": "98",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavc__fft_1gad6a19df0e8cfc4d67a325e4f91fd9cd9",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/* Real Discrete Fourier Transform */"
 },
 "DCTContext": {
  "type": {
   "ref": {
    "#text": "DCTContext",
    "@_refid": "group__lavc__fft_1ga904cbe02e46b560fd98d172fdb27c845",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct DCTContext DCTContext",
  "argsstring": "",
  "name": "DCTContext",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "116",
   "@_column": "25",
   "@_bodyfile": "libavcodec/avfft.h",
   "@_bodystart": "116",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavc__fft_1ga904cbe02e46b560fd98d172fdb27c845",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/* Discrete Cosine Transform */"
 },
 "av_fft_init": {
  "type": {
   "ref": [
    {
     "#text": "attribute_deprecated",
     "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
     "@_kindref": "member"
    },
    {
     "#text": "FFTContext",
     "@_refid": "group__lavc__fft_1gaac01e094370275491c7cbc580de0fe24",
     "@_kindref": "member"
    }
   ],
   "#text": "*"
  },
  "definition": "attribute_deprecated FFTContext * av_fft_init",
  "argsstring": "(int nbits, int inverse)",
  "name": "av_fft_init",
  "param": [
   {
    "type": "int",
    "declname": "nbits"
   },
   {
    "type": "int",
    "declname": "inverse"
   }
  ],
  "briefdescription": {
   "para": "Set up a complex FFT."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "nbits"
       },
       "parameterdescription": {
        "para": "log2 of the length of the input array"
       }
      },
      {
       "parameternamelist": {
        "parametername": "inverse"
       },
       "parameterdescription": {
        "para": "if 0 perform the forward transform, if 1 perform the inverse"
       }
      }
     ],
     "@_kind": "param"
    },
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": {
       "ref": {
        "#text": "libavutil/tx.h",
        "@_refid": "tx_8h",
        "@_kindref": "compound"
       },
       "#text": "use av_tx_init fromwith a type of AV_TX_FLOAT_FFT"
      }
     },
     "@_id": "deprecated_1_deprecated000016"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "54",
   "@_column": "12",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "54",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1ga07ef89d180df17e4f64d10101a0481b6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set up a complex FFT.\n * @param nbits           log2 of the length of the input array\n * @param inverse         if 0 perform the forward transform, if 1 perform the inverse\n * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_FFT\n */"
 },
 "av_fft_permute": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_fft_permute",
  "argsstring": "(FFTContext *s, FFTComplex *z)",
  "name": "av_fft_permute",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "FFTContext",
      "@_refid": "group__lavc__fft_1gaac01e094370275491c7cbc580de0fe24",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "FFTComplex",
      "@_refid": "structFFTComplex",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "z"
   }
  ],
  "briefdescription": {
   "para": "Do the permutation needed BEFORE calling ff_fft_calc()."
  },
  "detaileddescription": {
   "para": {
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": "without replacement"
     },
     "@_id": "deprecated_1_deprecated000017"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "61",
   "@_column": "6",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "61",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1gaccb552adc6edaa1b973cc1ef6fb4f744",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Do the permutation needed BEFORE calling ff_fft_calc().\n * @deprecated without replacement\n */"
 },
 "av_fft_calc": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_fft_calc",
  "argsstring": "(FFTContext *s, FFTComplex *z)",
  "name": "av_fft_calc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "FFTContext",
      "@_refid": "group__lavc__fft_1gaac01e094370275491c7cbc580de0fe24",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "FFTComplex",
      "@_refid": "structFFTComplex",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "z"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_fft_init()",
     "@_refid": "group__lavc__fft_1ga07ef89d180df17e4f64d10101a0481b6",
     "@_kindref": "member"
    },
    "#text": "Do a complex FFT with the parameters defined in."
   }
  },
  "detaileddescription": {
   "para": {
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": "use the av_tx_fn value returned by av_tx_init, which also does permutation"
     },
     "@_id": "deprecated_1_deprecated000018"
    },
    "#text": "The input data must be permuted before. No 1.0/sqrt(n) normalization is done."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "69",
   "@_column": "6",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "69",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1ga99af31cdab15f6ad8a5d90f382f065c6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Do a complex FFT with the parameters defined in av_fft_init(). The\n * input data must be permuted before. No 1.0/sqrt(n) normalization is done.\n * @deprecated use the av_tx_fn value returned by av_tx_init, which also does permutation\n */"
 },
 "av_fft_end": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_fft_end",
  "argsstring": "(FFTContext *s)",
  "name": "av_fft_end",
  "param": {
   "type": {
    "ref": {
     "#text": "FFTContext",
     "@_refid": "group__lavc__fft_1gaac01e094370275491c7cbc580de0fe24",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "72",
   "@_column": "6",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "72",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1gaf3a26ba31cb74774f9e1a90272ea6aa2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Do a complex FFT with the parameters defined in av_fft_init(). The\n * input data must be permuted before. No 1.0/sqrt(n) normalization is done.\n * @deprecated use the av_tx_fn value returned by av_tx_init, which also does permutation\n */"
 },
 "av_mdct_init": {
  "type": {
   "ref": [
    {
     "#text": "attribute_deprecated",
     "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
     "@_kindref": "member"
    },
    {
     "#text": "FFTContext",
     "@_refid": "group__lavc__fft_1gaac01e094370275491c7cbc580de0fe24",
     "@_kindref": "member"
    }
   ],
   "#text": "*"
  },
  "definition": "attribute_deprecated FFTContext * av_mdct_init",
  "argsstring": "(int nbits, int inverse, double scale)",
  "name": "av_mdct_init",
  "param": [
   {
    "type": "int",
    "declname": "nbits"
   },
   {
    "type": "int",
    "declname": "inverse"
   },
   {
    "type": "double",
    "declname": "scale"
   }
  ],
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": {
       "ref": {
        "#text": "libavutil/tx.h",
        "@_refid": "tx_8h",
        "@_kindref": "compound"
       },
       "#text": "use av_tx_init fromwith a type of AV_TX_FLOAT_MDCT, with a flag of AV_TX_FULL_IMDCT for a replacement to av_imdct_calc."
      }
     },
     "@_id": "deprecated_1_deprecated000019"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "79",
   "@_column": "12",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "79",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1ga309aeae057a1d65d15b996e132b80a54",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_MDCT,\n * with a flag of AV_TX_FULL_IMDCT for a replacement to av_imdct_calc.\n */"
 },
 "av_imdct_calc": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_imdct_calc",
  "argsstring": "(FFTContext *s, FFTSample *output, const FFTSample *input)",
  "name": "av_imdct_calc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "FFTContext",
      "@_refid": "group__lavc__fft_1gaac01e094370275491c7cbc580de0fe24",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "FFTSample",
      "@_refid": "group__lavc__fft_1gaa306dc16df543b25d9910debc3f76b96",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "output"
   },
   {
    "type": {
     "ref": {
      "#text": "FFTSample",
      "@_refid": "group__lavc__fft_1gaa306dc16df543b25d9910debc3f76b96",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "input"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "81",
   "@_column": "6",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "81",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1ga91b8c9615d5e8a777628257fa5d92a7f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_MDCT,\n * with a flag of AV_TX_FULL_IMDCT for a replacement to av_imdct_calc.\n */"
 },
 "av_imdct_half": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_imdct_half",
  "argsstring": "(FFTContext *s, FFTSample *output, const FFTSample *input)",
  "name": "av_imdct_half",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "FFTContext",
      "@_refid": "group__lavc__fft_1gaac01e094370275491c7cbc580de0fe24",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "FFTSample",
      "@_refid": "group__lavc__fft_1gaa306dc16df543b25d9910debc3f76b96",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "output"
   },
   {
    "type": {
     "ref": {
      "#text": "FFTSample",
      "@_refid": "group__lavc__fft_1gaa306dc16df543b25d9910debc3f76b96",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "input"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "83",
   "@_column": "6",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "83",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1ga2ba8a16d90544bb96bad43da98db8473",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_MDCT,\n * with a flag of AV_TX_FULL_IMDCT for a replacement to av_imdct_calc.\n */"
 },
 "av_mdct_calc": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_mdct_calc",
  "argsstring": "(FFTContext *s, FFTSample *output, const FFTSample *input)",
  "name": "av_mdct_calc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "FFTContext",
      "@_refid": "group__lavc__fft_1gaac01e094370275491c7cbc580de0fe24",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "FFTSample",
      "@_refid": "group__lavc__fft_1gaa306dc16df543b25d9910debc3f76b96",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "output"
   },
   {
    "type": {
     "ref": {
      "#text": "FFTSample",
      "@_refid": "group__lavc__fft_1gaa306dc16df543b25d9910debc3f76b96",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "input"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "85",
   "@_column": "6",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "85",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1ga2519f00b574b325ddb585329e648118b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_MDCT,\n * with a flag of AV_TX_FULL_IMDCT for a replacement to av_imdct_calc.\n */"
 },
 "av_mdct_end": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_mdct_end",
  "argsstring": "(FFTContext *s)",
  "name": "av_mdct_end",
  "param": {
   "type": {
    "ref": {
     "#text": "FFTContext",
     "@_refid": "group__lavc__fft_1gaac01e094370275491c7cbc580de0fe24",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "87",
   "@_column": "6",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "87",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1ga9de42e20d56ea0f8e980bac49d8da306",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_MDCT,\n * with a flag of AV_TX_FULL_IMDCT for a replacement to av_imdct_calc.\n */"
 },
 "av_rdft_init": {
  "type": {
   "ref": [
    {
     "#text": "attribute_deprecated",
     "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
     "@_kindref": "member"
    },
    {
     "#text": "RDFTContext",
     "@_refid": "group__lavc__fft_1gad6a19df0e8cfc4d67a325e4f91fd9cd9",
     "@_kindref": "member"
    }
   ],
   "#text": "*"
  },
  "definition": "attribute_deprecated RDFTContext * av_rdft_init",
  "argsstring": "(int nbits, enum RDFTransformType trans)",
  "name": "av_rdft_init",
  "param": [
   {
    "type": "int",
    "declname": "nbits"
   },
   {
    "type": {
     "ref": {
      "#text": "RDFTransformType",
      "@_refid": "group__lavc__fft_1ga58a704747daba49afa3611cea218a24b",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "trans"
   }
  ],
  "briefdescription": {
   "para": "Set up a real FFT."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "nbits"
       },
       "parameterdescription": {
        "para": "log2 of the length of the input array"
       }
      },
      {
       "parameternamelist": {
        "parametername": "trans"
       },
       "parameterdescription": {
        "para": "the type of transform"
       }
      }
     ],
     "@_kind": "param"
    },
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": {
       "ref": {
        "#text": "libavutil/tx.h",
        "@_refid": "tx_8h",
        "@_kindref": "compound"
       },
       "#text": "use av_tx_init fromwith a type of AV_TX_FLOAT_RDFT"
      }
     },
     "@_id": "deprecated_1_deprecated000020"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "108",
   "@_column": "13",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "108",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1ga702dc12260292ae410e64867694367b8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set up a real FFT.\n * @param nbits           log2 of the length of the input array\n * @param trans           the type of transform\n *\n * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_RDFT\n */"
 },
 "av_rdft_calc": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_rdft_calc",
  "argsstring": "(RDFTContext *s, FFTSample *data)",
  "name": "av_rdft_calc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "RDFTContext",
      "@_refid": "group__lavc__fft_1gad6a19df0e8cfc4d67a325e4f91fd9cd9",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "FFTSample",
      "@_refid": "group__lavc__fft_1gaa306dc16df543b25d9910debc3f76b96",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "data"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "110",
   "@_column": "6",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "110",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1gaf7a672e5bda1f088707682dbfb30717b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set up a real FFT.\n * @param nbits           log2 of the length of the input array\n * @param trans           the type of transform\n *\n * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_RDFT\n */"
 },
 "av_rdft_end": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_rdft_end",
  "argsstring": "(RDFTContext *s)",
  "name": "av_rdft_end",
  "param": {
   "type": {
    "ref": {
     "#text": "RDFTContext",
     "@_refid": "group__lavc__fft_1gad6a19df0e8cfc4d67a325e4f91fd9cd9",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "112",
   "@_column": "6",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "112",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1gaaf1e5feec6bb1e0d74c39fc65e366fad",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set up a real FFT.\n * @param nbits           log2 of the length of the input array\n * @param trans           the type of transform\n *\n * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_RDFT\n */"
 },
 "av_dct_init": {
  "type": {
   "ref": [
    {
     "#text": "attribute_deprecated",
     "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
     "@_kindref": "member"
    },
    {
     "#text": "DCTContext",
     "@_refid": "group__lavc__fft_1ga904cbe02e46b560fd98d172fdb27c845",
     "@_kindref": "member"
    }
   ],
   "#text": "*"
  },
  "definition": "attribute_deprecated DCTContext * av_dct_init",
  "argsstring": "(int nbits, enum DCTTransformType type)",
  "name": "av_dct_init",
  "param": [
   {
    "type": "int",
    "declname": "nbits"
   },
   {
    "type": {
     "ref": {
      "#text": "DCTTransformType",
      "@_refid": "group__lavc__fft_1gaeeabd062332b246d19bed36e041d2df6",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   }
  ],
  "briefdescription": {
   "para": "Set up DCT."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "nbits"
       },
       "parameterdescription": {
        "para": "size of the input array: (1 << nbits) for DCT-II, DCT-III and DST-I (1 << nbits) + 1 for DCT-I"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "the type of transform"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the first element of the input of DST-I is ignored",
     "@_kind": "note"
    },
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": {
       "ref": {
        "#text": "libavutil/tx.h",
        "@_refid": "tx_8h",
        "@_kindref": "compound"
       },
       "#text": "use av_tx_init fromwith an appropriate type of AV_TX_FLOAT_DCT"
      }
     },
     "@_id": "deprecated_1_deprecated000021"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "138",
   "@_column": "12",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "138",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1gaed25ca278186f689ae22389f404947dc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set up DCT.\n *\n * @param nbits           size of the input array:\n *                        (1 << nbits)     for DCT-II, DCT-III and DST-I\n *                        (1 << nbits) + 1 for DCT-I\n * @param type            the type of transform\n *\n * @note the first element of the input of DST-I is ignored\n *\n * @deprecated use av_tx_init from libavutil/tx.h with an appropriate type of AV_TX_FLOAT_DCT\n */"
 },
 "av_dct_calc": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_dct_calc",
  "argsstring": "(DCTContext *s, FFTSample *data)",
  "name": "av_dct_calc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "DCTContext",
      "@_refid": "group__lavc__fft_1ga904cbe02e46b560fd98d172fdb27c845",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "FFTSample",
      "@_refid": "group__lavc__fft_1gaa306dc16df543b25d9910debc3f76b96",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "data"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "140",
   "@_column": "6",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "140",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1ga18a1e7ef4743f93ea9a6f11224de169f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set up DCT.\n *\n * @param nbits           size of the input array:\n *                        (1 << nbits)     for DCT-II, DCT-III and DST-I\n *                        (1 << nbits) + 1 for DCT-I\n * @param type            the type of transform\n *\n * @note the first element of the input of DST-I is ignored\n *\n * @deprecated use av_tx_init from libavutil/tx.h with an appropriate type of AV_TX_FLOAT_DCT\n */"
 },
 "av_dct_end": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_dct_end",
  "argsstring": "(DCTContext *s)",
  "name": "av_dct_end",
  "param": {
   "type": {
    "ref": {
     "#text": "DCTContext",
     "@_refid": "group__lavc__fft_1ga904cbe02e46b560fd98d172fdb27c845",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/avfft.h",
   "@_line": "142",
   "@_column": "6",
   "@_declfile": "libavcodec/avfft.h",
   "@_declline": "142",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__fft_1ga4c49d50934d5da12d6af3b2269c8425f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set up DCT.\n *\n * @param nbits           size of the input array:\n *                        (1 << nbits)     for DCT-II, DCT-III and DST-I\n *                        (1 << nbits) + 1 for DCT-I\n * @param type            the type of transform\n *\n * @note the first element of the input of DST-I is ignored\n *\n * @deprecated use av_tx_init from libavutil/tx.h with an appropriate type of AV_TX_FLOAT_DCT\n */"
 },
 "AVFilterPad": {
  "type": {
   "ref": {
    "#text": "AVFilterPad",
    "@_refid": "group__lavfi_1ga067d805667c8575b55712d728a16ce7f",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVFilterPad AVFilterPad",
  "argsstring": "",
  "name": "AVFilterPad",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "75",
   "@_column": "26",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "75",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavfi_1ga067d805667c8575b55712d728a16ce7f",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Return the libavfilter license.\n */"
 },
 "AVFilterFormats": {
  "type": {
   "ref": {
    "#text": "AVFilterFormats",
    "@_refid": "group__lavfi_1gac71769d0eb79494d0cc095ac2ad0914b",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVFilterFormats AVFilterFormats",
  "argsstring": "",
  "name": "AVFilterFormats",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "76",
   "@_column": "30",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "76",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavfi_1gac71769d0eb79494d0cc095ac2ad0914b",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Return the libavfilter license.\n */"
 },
 "AVFilterChannelLayouts": {
  "type": {
   "ref": {
    "#text": "AVFilterChannelLayouts",
    "@_refid": "group__lavfi_1ga91cf9f6128e4dd6d519322b21f6bf569",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVFilterChannelLayouts AVFilterChannelLayouts",
  "argsstring": "",
  "name": "AVFilterChannelLayouts",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "77",
   "@_column": "37",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "77",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavfi_1ga91cf9f6128e4dd6d519322b21f6bf569",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Return the libavfilter license.\n */"
 },
 "avfilter_action_func": {
  "type": "int()",
  "definition": "typedef int() avfilter_action_func(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)",
  "argsstring": "(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)",
  "name": "avfilter_action_func",
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFilterGraph::execute",
     "@_refid": "structAVFilterGraph_1abbabdacc9b11e239ec24c969549d62ec",
     "@_kindref": "member"
    },
    "#text": "A function pointer passed to thecallback to be executed multiple times, possibly in parallel."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "the filter context the job belongs to"
       }
      },
      {
       "parameternamelist": {
        "parametername": "arg"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVFilterGraph::execute",
          "@_refid": "structAVFilterGraph_1abbabdacc9b11e239ec24c969549d62ec",
          "@_kindref": "member"
         },
         "#text": "an opaque parameter passed through from"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "jobnr"
       },
       "parameterdescription": {
        "para": "the index of the job being executed"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_jobs"
       },
       "parameterdescription": {
        "para": "the total number of jobs"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative AVERROR on error",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "796",
   "@_column": "9",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "796",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavfi_1ga93b8de1d06c5d83c1a287babe32e59d4",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * A function pointer passed to the @ref AVFilterGraph.execute callback to be\n * executed multiple times, possibly in parallel.\n *\n * @param ctx the filter context the job belongs to\n * @param arg an opaque parameter passed through from @ref\n *            AVFilterGraph.execute\n * @param jobnr the index of the job being executed\n * @param nb_jobs the total number of jobs\n *\n * @return 0 on success, a negative AVERROR on error\n */"
 },
 "avfilter_execute_func": {
  "type": "int()",
  "definition": "typedef int() avfilter_execute_func(AVFilterContext *ctx, avfilter_action_func *func, void *arg, int *ret, int nb_jobs)",
  "argsstring": "(AVFilterContext *ctx, avfilter_action_func *func, void *arg, int *ret, int nb_jobs)",
  "name": "avfilter_execute_func",
  "briefdescription": {
   "para": "A function executing multiple jobs, possibly in parallel."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "the filter context to which the jobs belong"
       }
      },
      {
       "parameternamelist": {
        "parametername": "func"
       },
       "parameterdescription": {
        "para": "the function to be called multiple times"
       }
      },
      {
       "parameternamelist": {
        "parametername": "arg"
       },
       "parameterdescription": {
        "para": "the argument to be passed to func"
       }
      },
      {
       "parameternamelist": {
        "parametername": "ret"
       },
       "parameterdescription": {
        "para": "a nb_jobs-sized array to be filled with return values from each invocation of func"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_jobs"
       },
       "parameterdescription": {
        "para": "the number of jobs to execute"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative AVERROR on error",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "810",
   "@_column": "9",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "810",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavfi_1gaa110ebfed4a342f88cd86da1b0037ab7",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * A function executing multiple jobs, possibly in parallel.\n *\n * @param ctx the filter context to which the jobs belong\n * @param func the function to be called multiple times\n * @param arg the argument to be passed to func\n * @param ret a nb_jobs-sized array to be filled with return values from each\n *            invocation of func\n * @param nb_jobs the number of jobs to execute\n *\n * @return 0 on success, a negative AVERROR on error\n */"
 },
 "avfilter_version": {
  "type": "unsigned",
  "definition": "unsigned avfilter_version",
  "argsstring": "(void)",
  "name": "avfilter_version",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the LIBAVFILTER_VERSION_INT constant."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "61",
   "@_column": "10",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "61",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gab2e80a6bf5de47a81f64471e73524a6a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the LIBAVFILTER_VERSION_INT constant.\n */"
 },
 "avfilter_configuration": {
  "type": "const char *",
  "definition": "const char * avfilter_configuration",
  "argsstring": "(void)",
  "name": "avfilter_configuration",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libavfilter build-time configuration."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "66",
   "@_column": "12",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "66",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga31eacee1ca745f3f850664fd852c076a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libavfilter build-time configuration.\n */"
 },
 "avfilter_license": {
  "type": "const char *",
  "definition": "const char * avfilter_license",
  "argsstring": "(void)",
  "name": "avfilter_license",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libavfilter license."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "71",
   "@_column": "12",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "71",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga90c557ccefd4cddaccab1958db28a0f3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libavfilter license.\n */"
 },
 "avfilter_pad_get_name": {
  "type": "const char *",
  "definition": "const char * avfilter_pad_get_name",
  "argsstring": "(const AVFilterPad *pads, int pad_idx)",
  "name": "avfilter_pad_get_name",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterPad",
      "@_refid": "group__lavfi_1ga067d805667c8575b55712d728a16ce7f",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "pads"
   },
   {
    "type": "int",
    "declname": "pad_idx"
   }
  ],
  "briefdescription": {
   "para": "Get the name of an AVFilterPad."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pads"
       },
       "parameterdescription": {
        "para": "an array of AVFilterPads"
       }
      },
      {
       "parameternamelist": {
        "parametername": "pad_idx"
       },
       "parameterdescription": {
        "para": "index of the pad in the array; it is the caller's responsibility to ensure the index is valid"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "name of the pad_idx'th pad in pads",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "88",
   "@_column": "12",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "88",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga61def10b756a26a8eee41f9f5c0cc1f2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the name of an AVFilterPad.\n *\n * @param pads an array of AVFilterPads\n * @param pad_idx index of the pad in the array; it is the caller's\n *                responsibility to ensure the index is valid\n *\n * @return name of the pad_idx'th pad in pads\n */"
 },
 "avfilter_pad_get_type": {
  "type": {
   "ref": {
    "#text": "AVMediaType",
    "@_refid": "group__lavu__misc_1ga9a84bba4713dfced21a1a56163be1f48",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVMediaType avfilter_pad_get_type",
  "argsstring": "(const AVFilterPad *pads, int pad_idx)",
  "name": "avfilter_pad_get_type",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterPad",
      "@_refid": "group__lavfi_1ga067d805667c8575b55712d728a16ce7f",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "pads"
   },
   {
    "type": "int",
    "declname": "pad_idx"
   }
  ],
  "briefdescription": {
   "para": "Get the type of an AVFilterPad."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pads"
       },
       "parameterdescription": {
        "para": "an array of AVFilterPads"
       }
      },
      {
       "parameternamelist": {
        "parametername": "pad_idx"
       },
       "parameterdescription": {
        "para": "index of the pad in the array; it is the caller's responsibility to ensure the index is valid"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "type of the pad_idx'th pad in pads",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "99",
   "@_column": "17",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "99",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga2d241a0066fc3724ec3335e25bc3912e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the type of an AVFilterPad.\n *\n * @param pads an array of AVFilterPads\n * @param pad_idx index of the pad in the array; it is the caller's\n *                responsibility to ensure the index is valid\n *\n * @return type of the pad_idx'th pad in pads\n */"
 },
 "avfilter_filter_pad_count": {
  "type": "unsigned",
  "definition": "unsigned avfilter_filter_pad_count",
  "argsstring": "(const AVFilter *filter, int is_output)",
  "name": "avfilter_filter_pad_count",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilter",
      "@_refid": "structAVFilter",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "filter"
   },
   {
    "type": "int",
    "declname": "is_output"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFilter",
     "@_refid": "structAVFilter",
     "@_kindref": "compound"
    },
    "#text": "Get the number of elements in an's inputs or outputs array."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "399",
   "@_column": "10",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "399",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga54dd15771603f3406c124259595e142b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the number of elements in an AVFilter's inputs or outputs array.\n */"
 },
 "avfilter_link": {
  "type": "int",
  "definition": "int avfilter_link",
  "argsstring": "(AVFilterContext *src, unsigned srcpad, AVFilterContext *dst, unsigned dstpad)",
  "name": "avfilter_link",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "src"
   },
   {
    "type": "unsigned",
    "declname": "srcpad"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": "unsigned",
    "declname": "dstpad"
   }
  ],
  "briefdescription": {
   "para": "Link two filters together."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "the source filter"
       }
      },
      {
       "parameternamelist": {
        "parametername": "srcpad"
       },
       "parameterdescription": {
        "para": "index of the output pad on the source filter"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "the destination filter"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dstpad"
       },
       "parameterdescription": {
        "para": "index of the input pad on the destination filter"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "zero on success",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "676",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "676",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "init_filter_graph",
   "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
   "@_compoundref": "filter__audio_8c",
   "@_startline": "60",
   "@_endline": "208"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gabc6247ebae2c591e768c8555174402f1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Link two filters together.\n *\n * @param src    the source filter\n * @param srcpad index of the output pad on the source filter\n * @param dst    the destination filter\n * @param dstpad index of the input pad on the destination filter\n * @return       zero on success\n */"
 },
 "avfilter_link_free": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void avfilter_link_free",
  "argsstring": "(AVFilterLink **link)",
  "name": "avfilter_link_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterLink",
     "@_refid": "structAVFilterLink",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "link"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": "this function should never be called by users"
     },
     "@_id": "deprecated_1_deprecated000001"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "684",
   "@_column": "6",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "684",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gabc7edd01be1ea16050a0d2927a93c733",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @deprecated this function should never be called by users\n */"
 },
 "avfilter_config_links": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "attribute_deprecated int avfilter_config_links",
  "argsstring": "(AVFilterContext *filter)",
  "name": "avfilter_config_links",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "filter"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": "this function should never be called by users"
     },
     "@_id": "deprecated_1_deprecated000002"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "690",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "690",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gaf51b3288f9f07339990bcbe6ae2e79d4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @deprecated this function should never be called by users\n */"
 },
 "avfilter_process_command": {
  "type": "int",
  "definition": "int avfilter_process_command",
  "argsstring": "(AVFilterContext *filter, const char *cmd, const char *arg, char *res, int res_len, int flags)",
  "name": "avfilter_process_command",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "filter"
   },
   {
    "type": "const char *",
    "declname": "cmd"
   },
   {
    "type": "const char *",
    "declname": "arg"
   },
   {
    "type": "char *",
    "declname": "res"
   },
   {
    "type": "int",
    "declname": "res_len"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Make the filter instance process a command."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "avfilter_graph_send_command()",
     "@_refid": "group__lavfi_1gaaad7850fb5fe26d35e5d371ca75b79e1",
     "@_kindref": "member"
    },
    "#text": "It is recommended to use."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "700",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "700",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga7265908e69b4eaa69a4947a093743f26",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Make the filter instance process a command.\n * It is recommended to use avfilter_graph_send_command().\n */"
 },
 "av_filter_iterate": {
  "type": {
   "ref": {
    "#text": "AVFilter",
    "@_refid": "structAVFilter",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVFilter * av_filter_iterate",
  "argsstring": "(void **opaque)",
  "name": "av_filter_iterate",
  "param": {
   "type": "void **",
   "declname": "opaque"
  },
  "briefdescription": {
   "para": "Iterate over all registered filters."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "opaque"
      },
      "parameterdescription": {
       "para": "a pointer where libavfilter will store the iteration state. Must point to NULL to start the iteration."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the next registered filter or NULL when the iteration is finished",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "711",
   "@_column": "16",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "711",
   "@_declcolumn": "16"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga670c742e72d6a155c0513f5c57fd0e56",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over all registered filters.\n *\n * @param opaque a pointer where libavfilter will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered filter or NULL when the iteration is\n *         finished\n */"
 },
 "avfilter_get_by_name": {
  "type": {
   "ref": {
    "#text": "AVFilter",
    "@_refid": "structAVFilter",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVFilter * avfilter_get_by_name",
  "argsstring": "(const char *name)",
  "name": "avfilter_get_by_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": {
   "para": "Get a filter definition matching the given name."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "name"
      },
      "parameterdescription": {
       "para": "the filter name to find"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the filter definition, if any matching one is registered. NULL if none found.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "720",
   "@_column": "16",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "720",
   "@_declcolumn": "16"
  },
  "referencedby": [
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filter_graph",
    "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "60",
    "@_endline": "208"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavfi_1ga198251521e31686e14d9f2adb30b8c35",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a filter definition matching the given name.\n *\n * @param name the filter name to find\n * @return     the filter definition, if any matching one is registered.\n *             NULL if none found.\n */"
 },
 "avfilter_init_str": {
  "type": "int",
  "definition": "int avfilter_init_str",
  "argsstring": "(AVFilterContext *ctx, const char *args)",
  "name": "avfilter_init_str",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": "const char *",
    "declname": "args"
   }
  ],
  "briefdescription": {
   "para": "Initialize a filter with the supplied parameters."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "uninitialized filter context to initialize"
       }
      },
      {
       "parameternamelist": {
        "parametername": "args"
       },
       "parameterdescription": {
        "para": "Options to initialize the filter with. This must be a ':'-separated list of options in the 'key=value' form. May be NULL if the options have been set directly using the AVOptions API or there are no options that need to be set."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative AVERROR on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "733",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "733",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "init_filter_graph",
   "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
   "@_compoundref": "filter__audio_8c",
   "@_startline": "60",
   "@_endline": "208"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga0d21eb00b9f24213bd7c5775393a09fd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize a filter with the supplied parameters.\n *\n * @param ctx  uninitialized filter context to initialize\n * @param args Options to initialize the filter with. This must be a\n *             ':'-separated list of options in the 'key=value' form.\n *             May be NULL if the options have been set directly using the\n *             AVOptions API or there are no options that need to be set.\n * @return 0 on success, a negative AVERROR on failure\n */"
 },
 "avfilter_init_dict": {
  "type": "int",
  "definition": "int avfilter_init_dict",
  "argsstring": "(AVFilterContext *ctx, AVDictionary **options)",
  "name": "avfilter_init_dict",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": "Initialize a filter with the supplied dictionary of options."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "uninitialized filter context to initialize"
       }
      },
      {
       "parameternamelist": {
        "parametername": "options"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "avfilter_init_str()",
          "@_refid": "group__lavfi_1ga0d21eb00b9f24213bd7c5775393a09fd",
          "@_kindref": "member"
         },
         "#text": "An AVDictionary filled with options for this filter. On return this parameter will be destroyed and replaced with a dict containing options that were not found. This dictionary must be freed by the caller. May be NULL, then this function is equivalent towith the second parameter set to NULL."
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "0 on success, a negative AVERROR on failure",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": [
        {
         "#text": "avfilter_init_str()",
         "@_refid": "group__lavfi_1ga0d21eb00b9f24213bd7c5775393a09fd",
         "@_kindref": "member"
        },
        {
         "#text": "avfilter_init_str()",
         "@_refid": "group__lavfi_1ga0d21eb00b9f24213bd7c5775393a09fd",
         "@_kindref": "member"
        }
       ],
       "#text": "This function anddo essentially the same thing, the difference is in manner in which the options are passed. It is up to the calling code to choose whichever is more preferable. The two functions also behave differently when some of the provided options are not declared as supported by the filter. In such a case,will fail, but this function will leave those extra options in the options AVDictionary and continue as usual."
      },
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "755",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "755",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "init_filter_graph",
   "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
   "@_compoundref": "filter__audio_8c",
   "@_startline": "60",
   "@_endline": "208"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga8c15af28902395399fe455f6f8236848",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize a filter with the supplied dictionary of options.\n *\n * @param ctx     uninitialized filter context to initialize\n * @param options An AVDictionary filled with options for this filter. On\n *                return this parameter will be destroyed and replaced with\n *                a dict containing options that were not found. This dictionary\n *                must be freed by the caller.\n *                May be NULL, then this function is equivalent to\n *                avfilter_init_str() with the second parameter set to NULL.\n * @return 0 on success, a negative AVERROR on failure\n *\n * @note This function and avfilter_init_str() do essentially the same thing,\n * the difference is in manner in which the options are passed. It is up to the\n * calling code to choose whichever is more preferable. The two functions also\n * behave differently when some of the provided options are not declared as\n * supported by the filter. In such a case, avfilter_init_str() will fail, but\n * this function will leave those extra options in the options AVDictionary and\n * continue as usual.\n */"
 },
 "avfilter_free": {
  "type": "void",
  "definition": "void avfilter_free",
  "argsstring": "(AVFilterContext *filter)",
  "name": "avfilter_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "filter"
  },
  "briefdescription": {
   "para": "Free a filter context."
  },
  "detaileddescription": {
   "para": [
    "This will also remove the filter from its filtergraph's list of filters.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "filter"
       },
       "parameterdescription": {
        "para": "the filter to free"
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "763",
   "@_column": "6",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "763",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga0ea7664a3ce6bb677a830698d358a179",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free a filter context. This will also remove the filter from its\n * filtergraph's list of filters.\n *\n * @param filter the filter to free\n */"
 },
 "avfilter_insert_filter": {
  "type": "int",
  "definition": "int avfilter_insert_filter",
  "argsstring": "(AVFilterLink *link, AVFilterContext *filt, unsigned filt_srcpad_idx, unsigned filt_dstpad_idx)",
  "name": "avfilter_insert_filter",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterLink",
      "@_refid": "structAVFilterLink",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "link"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "filt"
   },
   {
    "type": "unsigned",
    "declname": "filt_srcpad_idx"
   },
   {
    "type": "unsigned",
    "declname": "filt_dstpad_idx"
   }
  ],
  "briefdescription": {
   "para": "Insert a filter in the middle of an existing link."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "link"
       },
       "parameterdescription": {
        "para": "the link into which the filter should be inserted"
       }
      },
      {
       "parameternamelist": {
        "parametername": "filt"
       },
       "parameterdescription": {
        "para": "the filter to be inserted"
       }
      },
      {
       "parameternamelist": {
        "parametername": "filt_srcpad_idx"
       },
       "parameterdescription": {
        "para": "the input pad on the filter to connect"
       }
      },
      {
       "parameternamelist": {
        "parametername": "filt_dstpad_idx"
       },
       "parameterdescription": {
        "para": "the output pad on the filter to connect"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "zero on success",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "774",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "774",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga0d2740a8679ff5086f680547eb0a08e0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Insert a filter in the middle of an existing link.\n *\n * @param link the link into which the filter should be inserted\n * @param filt the filter to be inserted\n * @param filt_srcpad_idx the input pad on the filter to connect\n * @param filt_dstpad_idx the output pad on the filter to connect\n * @return     zero on success\n */"
 },
 "avfilter_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * avfilter_get_class",
  "argsstring": "(void)",
  "name": "avfilter_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": [
        {
         "#text": "AVClass",
         "@_refid": "structAVClass",
         "@_kindref": "compound"
        },
        {
         "#text": "AVFilterContext",
         "@_refid": "structAVFilterContext",
         "@_kindref": "compound"
        }
       ],
       "#text": "for."
      },
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_opt_find()",
        "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
        "@_kindref": "member"
       },
       "#text": "."
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "782",
   "@_column": "15",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "782",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gac31877287e8b0bef4f2a78f246784645",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return AVClass for AVFilterContext.\n *\n * @see av_opt_find().\n */"
 },
 "avfilter_graph_alloc": {
  "type": {
   "ref": {
    "#text": "AVFilterGraph",
    "@_refid": "structAVFilterGraph",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFilterGraph * avfilter_graph_alloc",
  "argsstring": "(void)",
  "name": "avfilter_graph_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate a filter graph."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the allocated filter graph on success or NULL.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "870",
   "@_column": "15",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "870",
   "@_declcolumn": "15"
  },
  "referencedby": [
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filter_graph",
    "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "60",
    "@_endline": "208"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavfi_1gaf973363641e8f5c7db932590cc731cb1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a filter graph.\n *\n * @return the allocated filter graph on success or NULL.\n */"
 },
 "avfilter_graph_alloc_filter": {
  "type": {
   "ref": {
    "#text": "AVFilterContext",
    "@_refid": "structAVFilterContext",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFilterContext * avfilter_graph_alloc_filter",
  "argsstring": "(AVFilterGraph *graph, const AVFilter *filter, const char *name)",
  "name": "avfilter_graph_alloc_filter",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graph"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilter",
      "@_refid": "structAVFilter",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "filter"
   },
   {
    "type": "const char *",
    "declname": "name"
   }
  ],
  "briefdescription": {
   "para": "Create a new filter instance in a filter graph."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "graph"
       },
       "parameterdescription": {
        "para": "graph in which the new filter will be used"
       }
      },
      {
       "parameternamelist": {
        "parametername": "filter"
       },
       "parameterdescription": {
        "para": "the filter to create an instance of"
       }
      },
      {
       "parameternamelist": {
        "parametername": "name"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVFilterContext.name",
          "@_refid": "structAVFilterContext_1a5b22332d8ddb242c54e19cbfc4b4d353",
          "@_kindref": "member"
         },
         "#text": "Name to give to the new instance (will be copied to). This may be used by the caller to identify different filters, libavfilter itself assigns no semantics to this parameter. May be NULL."
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": [
       {
        "#text": "AVFilterGraph.filters",
        "@_refid": "structAVFilterGraph_1a1dafd3d239f7c2f5e3ac109578ef926d",
        "@_kindref": "member"
       },
       {
        "#text": "avfilter_graph_get_filter()",
        "@_refid": "group__lavfi_1ga38f9270ac7cf593d21a857bddaaa5ac6",
        "@_kindref": "member"
       }
      ],
      "#text": "the context of the newly created filter instance (note that it is also retrievable directly throughor with) on success or NULL on failure."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "886",
   "@_column": "17",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "886",
   "@_declcolumn": "17"
  },
  "referencedby": {
   "#text": "init_filter_graph",
   "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
   "@_compoundref": "filter__audio_8c",
   "@_startline": "60",
   "@_endline": "208"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga5c22522f0149ba1a6e1342084c6cef7c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create a new filter instance in a filter graph.\n *\n * @param graph graph in which the new filter will be used\n * @param filter the filter to create an instance of\n * @param name Name to give to the new instance (will be copied to\n *             AVFilterContext.name). This may be used by the caller to identify\n *             different filters, libavfilter itself assigns no semantics to\n *             this parameter. May be NULL.\n *\n * @return the context of the newly created filter instance (note that it is\n *         also retrievable directly through AVFilterGraph.filters or with\n *         avfilter_graph_get_filter()) on success or NULL on failure.\n */"
 },
 "avfilter_graph_get_filter": {
  "type": {
   "ref": {
    "#text": "AVFilterContext",
    "@_refid": "structAVFilterContext",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFilterContext * avfilter_graph_get_filter",
  "argsstring": "(AVFilterGraph *graph, const char *name)",
  "name": "avfilter_graph_get_filter",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graph"
   },
   {
    "type": "const char *",
    "declname": "name"
   }
  ],
  "briefdescription": {
   "para": "Get a filter instance identified by instance name from graph."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "graph"
       },
       "parameterdescription": {
        "para": "filter graph to search through."
       }
      },
      {
       "parameternamelist": {
        "parametername": "name"
       },
       "parameterdescription": {
        "para": "filter instance name (should be unique in the graph)."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the pointer to the found filter instance or NULL if it cannot be found.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "898",
   "@_column": "17",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "898",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga38f9270ac7cf593d21a857bddaaa5ac6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a filter instance identified by instance name from graph.\n *\n * @param graph filter graph to search through.\n * @param name filter instance name (should be unique in the graph).\n * @return the pointer to the found filter instance or NULL if it\n * cannot be found.\n */"
 },
 "avfilter_graph_create_filter": {
  "type": "int",
  "definition": "int avfilter_graph_create_filter",
  "argsstring": "(AVFilterContext **filt_ctx, const AVFilter *filt, const char *name, const char *args, void *opaque, AVFilterGraph *graph_ctx)",
  "name": "avfilter_graph_create_filter",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "filt_ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilter",
      "@_refid": "structAVFilter",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "filt"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "const char *",
    "declname": "args"
   },
   {
    "type": "void *",
    "declname": "opaque"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graph_ctx"
   }
  ],
  "briefdescription": {
   "para": "Create and add a filter instance into an existing graph."
  },
  "detaileddescription": {
   "para": [
    "The filter instance is created from the filter filt and inited with the parameter args. opaque is currently ignored.",
    "In case of success put in *filt_ctx the pointer to the created filter instance, otherwise set *filt_ctx to NULL.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "name"
        },
        "parameterdescription": {
         "para": "the instance name to give to the created filter instance"
        }
       },
       {
        "parameternamelist": {
         "parametername": "graph_ctx"
        },
        "parameterdescription": {
         "para": "the filter graph"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "a negative AVERROR error code in case of failure, a non negative value otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "913",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "913",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavfi_1gac0788a9ab6966dba9318b5d5c7524fea",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create and add a filter instance into an existing graph.\n * The filter instance is created from the filter filt and inited\n * with the parameter args. opaque is currently ignored.\n *\n * In case of success put in *filt_ctx the pointer to the created\n * filter instance, otherwise set *filt_ctx to NULL.\n *\n * @param name the instance name to give to the created filter instance\n * @param graph_ctx the filter graph\n * @return a negative AVERROR error code in case of failure, a non\n * negative value otherwise\n */"
 },
 "avfilter_graph_set_auto_convert": {
  "type": "void",
  "definition": "void avfilter_graph_set_auto_convert",
  "argsstring": "(AVFilterGraph *graph, unsigned flags)",
  "name": "avfilter_graph_set_auto_convert",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graph"
   },
   {
    "type": "unsigned",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Enable or disable automatic format conversion inside the graph."
  },
  "detaileddescription": {
   "para": [
    "Note that format conversion can still happen inside explicitly inserted scale and aresample filters.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "any of the AVFILTER_AUTO_CONVERT_* constants"
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "925",
   "@_column": "6",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "925",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gae7e75e3df70de53fae2cf7950c1247a8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Enable or disable automatic format conversion inside the graph.\n *\n * Note that format conversion can still happen inside explicitly inserted\n * scale and aresample filters.\n *\n * @param flags  any of the AVFILTER_AUTO_CONVERT_* constants\n */"
 },
 "avfilter_graph_config": {
  "type": "int",
  "definition": "int avfilter_graph_config",
  "argsstring": "(AVFilterGraph *graphctx, void *log_ctx)",
  "name": "avfilter_graph_config",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graphctx"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Check validity and configure all the links and formats in the graph."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "graphctx"
       },
       "parameterdescription": {
        "para": "the filter graph"
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_ctx"
       },
       "parameterdescription": {
        "para": "context used for logging"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 in case of success, a negative AVERROR code otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "939",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "939",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filter_graph",
    "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "60",
    "@_endline": "208"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavfi_1ga1896c46b7bc6ff1bdb1a4815faa9ad07",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check validity and configure all the links and formats in the graph.\n *\n * @param graphctx the filter graph\n * @param log_ctx context used for logging\n * @return >= 0 in case of success, a negative AVERROR code otherwise\n */"
 },
 "avfilter_graph_free": {
  "type": "void",
  "definition": "void avfilter_graph_free",
  "argsstring": "(AVFilterGraph **graph)",
  "name": "avfilter_graph_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterGraph",
     "@_refid": "structAVFilterGraph",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "graph"
  },
  "briefdescription": {
   "para": "Free a graph, destroy its links, and set *graph to NULL."
  },
  "detaileddescription": {
   "para": "If *graph is NULL, do nothing."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "945",
   "@_column": "6",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "945",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "decode__filter__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "decode__filter__audio_8c",
   "@_startline": "217",
   "@_endline": "296"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga871684449dac05050df238a18d0d493b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free a graph, destroy its links, and set *graph to NULL.\n * If *graph is NULL, do nothing.\n */"
 },
 "avfilter_inout_alloc": {
  "type": {
   "ref": {
    "#text": "AVFilterInOut",
    "@_refid": "structAVFilterInOut",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFilterInOut * avfilter_inout_alloc",
  "argsstring": "(void)",
  "name": "avfilter_inout_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFilterInOut",
     "@_refid": "structAVFilterInOut",
     "@_kindref": "compound"
    },
    "#text": "Allocate a singleentry."
   }
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "avfilter_inout_free()",
     "@_refid": "group__lavfi_1ga294500a9856260eb1552354fd9d9a6c4",
     "@_kindref": "member"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVFilterInOut",
       "@_refid": "structAVFilterInOut",
       "@_kindref": "compound"
      },
      "#text": "allocatedon success, NULL on failure."
     },
     "@_kind": "return"
    },
    "#text": "Must be freed with."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "975",
   "@_column": "15",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "975",
   "@_declcolumn": "15"
  },
  "referencedby": [
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavfi_1gaed598b086db45e36ea5d2e884ba09789",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a single AVFilterInOut entry.\n * Must be freed with avfilter_inout_free().\n * @return allocated AVFilterInOut on success, NULL on failure.\n */"
 },
 "avfilter_inout_free": {
  "type": "void",
  "definition": "void avfilter_inout_free",
  "argsstring": "(AVFilterInOut **inout)",
  "name": "avfilter_inout_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterInOut",
     "@_refid": "structAVFilterInOut",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "inout"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFilterInOut",
     "@_refid": "structAVFilterInOut",
     "@_kindref": "compound"
    },
    "#text": "Free the supplied list ofand set *inout to NULL."
   }
  },
  "detaileddescription": {
   "para": "If *inout is NULL, do nothing."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "981",
   "@_column": "6",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "981",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavfi_1ga294500a9856260eb1552354fd9d9a6c4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied list of AVFilterInOut and set *inout to NULL.\n * If *inout is NULL, do nothing.\n */"
 },
 "avfilter_graph_parse": {
  "type": "int",
  "definition": "int avfilter_graph_parse",
  "argsstring": "(AVFilterGraph *graph, const char *filters, AVFilterInOut *inputs, AVFilterInOut *outputs, void *log_ctx)",
  "name": "avfilter_graph_parse",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graph"
   },
   {
    "type": "const char *",
    "declname": "filters"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterInOut",
      "@_refid": "structAVFilterInOut",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "inputs"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterInOut",
      "@_refid": "structAVFilterInOut",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "outputs"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Add a graph described by a string to a graph."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": "The caller must provide the lists of inputs and outputs, which therefore must be known before calling the function.",
      "@_kind": "note"
     },
     {
      "para": "The inputs parameter describes inputs of the already existing part of the graph; i.e. from the point of view of the newly created part, they are outputs. Similarly the outputs parameter describes outputs of the already existing filters, which are provided as inputs to the parsed filters.",
      "@_kind": "note"
     },
     {
      "para": "zero on success, a negative AVERROR code on error",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "graph"
       },
       "parameterdescription": {
        "para": "the filter graph where to link the parsed graph context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "filters"
       },
       "parameterdescription": {
        "para": "string to be parsed"
       }
      },
      {
       "parameternamelist": {
        "parametername": "inputs"
       },
       "parameterdescription": {
        "para": "linked list to the inputs of the graph"
       }
      },
      {
       "parameternamelist": {
        "parametername": "outputs"
       },
       "parameterdescription": {
        "para": "linked list to the outputs of the graph"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1001",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1001",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gab4718e1716c0a0d9343d49ff10d542cb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a graph described by a string to a graph.\n *\n * @note The caller must provide the lists of inputs and outputs,\n * which therefore must be known before calling the function.\n *\n * @note The inputs parameter describes inputs of the already existing\n * part of the graph; i.e. from the point of view of the newly created\n * part, they are outputs. Similarly the outputs parameter describes\n * outputs of the already existing filters, which are provided as\n * inputs to the parsed filters.\n *\n * @param graph   the filter graph where to link the parsed graph context\n * @param filters string to be parsed\n * @param inputs  linked list to the inputs of the graph\n * @param outputs linked list to the outputs of the graph\n * @return zero on success, a negative AVERROR code on error\n */"
 },
 "avfilter_graph_parse_ptr": {
  "type": "int",
  "definition": "int avfilter_graph_parse_ptr",
  "argsstring": "(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)",
  "name": "avfilter_graph_parse_ptr",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graph"
   },
   {
    "type": "const char *",
    "declname": "filters"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterInOut",
      "@_refid": "structAVFilterInOut",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "inputs"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterInOut",
      "@_refid": "structAVFilterInOut",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "outputs"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Add a graph described by a string to a graph."
  },
  "detaileddescription": {
   "para": [
    "In the graph filters description, if the input label of the first filter is not specified, \"in\" is assumed; if the output label of the last filter is not specified, \"out\" is assumed.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "graph"
        },
        "parameterdescription": {
         "para": "the filter graph where to link the parsed graph context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "filters"
        },
        "parameterdescription": {
         "para": "string to be parsed"
        }
       },
       {
        "parameternamelist": {
         "parametername": "inputs"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "avfilter_inout_free()",
           "@_refid": "group__lavfi_1ga294500a9856260eb1552354fd9d9a6c4",
           "@_kindref": "member"
          },
          "#text": "pointer to a linked list to the inputs of the graph, may be NULL. If non-NULL, *inputs is updated to contain the list of open inputs after the parsing, should be freed with."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "outputs"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "avfilter_inout_free()",
           "@_refid": "group__lavfi_1ga294500a9856260eb1552354fd9d9a6c4",
           "@_kindref": "member"
          },
          "#text": "pointer to a linked list to the outputs of the graph, may be NULL. If non-NULL, *outputs is updated to contain the list of open outputs after the parsing, should be freed with."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "non negative on success, a negative AVERROR code on error",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1022",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1022",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavfi_1ga34f4ff420bd58da6747a3ff1fbedd001",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a graph described by a string to a graph.\n *\n * In the graph filters description, if the input label of the first\n * filter is not specified, \"in\" is assumed; if the output label of\n * the last filter is not specified, \"out\" is assumed.\n *\n * @param graph   the filter graph where to link the parsed graph context\n * @param filters string to be parsed\n * @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.\n *                If non-NULL, *inputs is updated to contain the list of open inputs\n *                after the parsing, should be freed with avfilter_inout_free().\n * @param outputs pointer to a linked list to the outputs of the graph, may be NULL.\n *                If non-NULL, *outputs is updated to contain the list of open outputs\n *                after the parsing, should be freed with avfilter_inout_free().\n * @return non negative on success, a negative AVERROR code on error\n */"
 },
 "avfilter_graph_parse2": {
  "type": "int",
  "definition": "int avfilter_graph_parse2",
  "argsstring": "(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs)",
  "name": "avfilter_graph_parse2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graph"
   },
   {
    "type": "const char *",
    "declname": "filters"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterInOut",
      "@_refid": "structAVFilterInOut",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "inputs"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterInOut",
      "@_refid": "structAVFilterInOut",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "outputs"
   }
  ],
  "briefdescription": {
   "para": "Add a graph described by a string to a graph."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "graph",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "the filter graph where to link the parsed graph context"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "filters",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "string to be parsed"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "inputs",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "avfilter_inout_free()",
          "@_refid": "group__lavfi_1ga294500a9856260eb1552354fd9d9a6c4",
          "@_kindref": "member"
         },
         "#text": "a linked list of all free (unlinked) inputs of the parsed graph will be returned here. It is to be freed by the caller using."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "outputs",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "avfilter_inout_free()",
          "@_refid": "group__lavfi_1ga294500a9856260eb1552354fd9d9a6c4",
          "@_kindref": "member"
         },
         "#text": "a linked list of all free (unlinked) outputs of the parsed graph will be returned here. It is to be freed by the caller using."
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "zero on success, a negative AVERROR code on error",
      "@_kind": "return"
     },
     {
      "para": "This function returns the inputs and outputs that are left unlinked after parsing the graph and the caller then deals with them.",
      "@_kind": "note"
     },
     {
      "para": "This function makes no reference whatsoever to already existing parts of the graph and the inputs parameter will on return contain inputs of the newly parsed part of the graph. Analogously the outputs parameter will contain outputs of the newly created filters.",
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1048",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1048",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga6c3c39e0861653c71a23f90d1397239d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a graph described by a string to a graph.\n *\n * @param[in]  graph   the filter graph where to link the parsed graph context\n * @param[in]  filters string to be parsed\n * @param[out] inputs  a linked list of all free (unlinked) inputs of the\n *                     parsed graph will be returned here. It is to be freed\n *                     by the caller using avfilter_inout_free().\n * @param[out] outputs a linked list of all free (unlinked) outputs of the\n *                     parsed graph will be returned here. It is to be freed by the\n *                     caller using avfilter_inout_free().\n * @return zero on success, a negative AVERROR code on error\n *\n * @note This function returns the inputs and outputs that are left\n * unlinked after parsing the graph and the caller then deals with\n * them.\n * @note This function makes no reference whatsoever to already\n * existing parts of the graph and the inputs parameter will on return\n * contain inputs of the newly parsed part of the graph.  Analogously\n * the outputs parameter will contain outputs of the newly created\n * filters.\n */"
 },
 "avfilter_graph_segment_parse": {
  "type": "int",
  "definition": "int avfilter_graph_segment_parse",
  "argsstring": "(AVFilterGraph *graph, const char *graph_str, int flags, AVFilterGraphSegment **seg)",
  "name": "avfilter_graph_segment_parse",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graph"
   },
   {
    "type": "const char *",
    "declname": "graph_str"
   },
   {
    "type": "int",
    "declname": "flags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraphSegment",
      "@_refid": "structAVFilterGraphSegment",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "seg"
   }
  ],
  "briefdescription": {
   "para": "Parse a textual filtergraph description into an intermediate form."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "AVFilterGraphSegment",
       "@_refid": "structAVFilterGraphSegment",
       "@_kindref": "compound"
      },
      {
       "#text": "avfilter_graph_segment_apply()",
       "@_refid": "group__lavfi_1gada3537e47b1e8851d9a4081a11e7519c",
       "@_kindref": "member"
      },
      {
       "#text": "AVFilterGraphSegment",
       "@_refid": "structAVFilterGraphSegment",
       "@_kindref": "compound"
      }
     ],
     "#text": "This intermediate representation is intended to be modified by the caller as described in the documentation ofand its children, and then applied to the graph either manually or with other avfilter_graph_segment_*() functions. See the documentation forfor the canonical way to apply."
    },
    {
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "graph"
         },
         "parameterdescription": {
          "para": "Filter graph the parsed segment is associated with. Will only be used for logging and similar auxiliary purposes. The graph will not be actually modified by this function - the parsing results are instead stored in seg for further processing."
         }
        },
        {
         "parameternamelist": {
          "parametername": "graph_str"
         },
         "parameterdescription": {
          "para": "a string describing the filtergraph segment"
         }
        },
        {
         "parameternamelist": {
          "parametername": "flags"
         },
         "parameterdescription": {
          "para": "reserved for future use, caller must set to 0 for now"
         }
        },
        {
         "parameternamelist": {
          "parametername": "seg"
         },
         "parameterdescription": {
          "para": {
           "ref": [
            {
             "#text": "AVFilterGraphSegment",
             "@_refid": "structAVFilterGraphSegment",
             "@_kindref": "compound"
            },
            {
             "#text": "avfilter_graph_segment_free()",
             "@_refid": "group__lavfi_1ga51283edd8f3685e1f33239f360e14ae8",
             "@_kindref": "member"
            }
           ],
           "#text": "A pointer to the newly-createdis written here on success. The graph segment is owned by the caller and must be freed withbefore graph itself is freed."
          }
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "non-negative number"
         },
         "parameterdescription": {
          "para": "success"
         }
        },
        {
         "parameternamelist": {
          "parametername": "negative error code"
         },
         "parameterdescription": {
          "para": "failure"
         }
        }
       ],
       "@_kind": "retval"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1205",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1205",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga2ecfd3667219b6cd1e37b7047cc0ef2b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse a textual filtergraph description into an intermediate form.\n *\n * This intermediate representation is intended to be modified by the caller as\n * described in the documentation of AVFilterGraphSegment and its children, and\n * then applied to the graph either manually or with other\n * avfilter_graph_segment_*() functions. See the documentation for\n * avfilter_graph_segment_apply() for the canonical way to apply\n * AVFilterGraphSegment.\n *\n * @param graph Filter graph the parsed segment is associated with. Will only be\n *              used for logging and similar auxiliary purposes. The graph will\n *              not be actually modified by this function - the parsing results\n *              are instead stored in seg for further processing.\n * @param graph_str a string describing the filtergraph segment\n * @param flags reserved for future use, caller must set to 0 for now\n * @param seg A pointer to the newly-created AVFilterGraphSegment is written\n *            here on success. The graph segment is owned by the caller and must\n *            be freed with avfilter_graph_segment_free() before graph itself is\n *            freed.\n *\n * @retval \"non-negative number\" success\n * @retval \"negative error code\" failure\n */"
 },
 "avfilter_graph_segment_create_filters": {
  "type": "int",
  "definition": "int avfilter_graph_segment_create_filters",
  "argsstring": "(AVFilterGraphSegment *seg, int flags)",
  "name": "avfilter_graph_segment_create_filters",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraphSegment",
      "@_refid": "structAVFilterGraphSegment",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "seg"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Create filters specified in a graph segment."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "AVFilterParams",
       "@_refid": "structAVFilterParams",
       "@_kindref": "compound"
      },
      {
       "#text": "AVFilterParams.filter_name",
       "@_refid": "structAVFilterParams_1a90edb3817b62f2ca70ea70001b84d001",
       "@_kindref": "member"
      },
      {
       "#text": "AVFilterParams.filter",
       "@_refid": "structAVFilterParams_1a843deab11c88a89fb9f5b68d05bfb9e2",
       "@_kindref": "member"
      },
      {
       "#text": "AVFilterParams",
       "@_refid": "structAVFilterParams",
       "@_kindref": "compound"
      }
     ],
     "#text": "Walk through the creation-pendingin the segment and create new filter instances for them. Creation-pending params are those whereis non-NULL (and henceis NULL). All otherinstances are ignored."
    },
    {
     "ref": [
      {
       "#text": "AVFilterParams.filter",
       "@_refid": "structAVFilterParams_1a843deab11c88a89fb9f5b68d05bfb9e2",
       "@_kindref": "member"
      },
      {
       "#text": "AVFilterParams.filter_name",
       "@_refid": "structAVFilterParams_1a90edb3817b62f2ca70ea70001b84d001",
       "@_kindref": "member"
      },
      {
       "#text": "AVFilterParams.instance_name",
       "@_refid": "structAVFilterParams_1a3157835725754b0cdedd7b27e4d9621a",
       "@_kindref": "member"
      }
     ],
     "#text": "For any filter created by this function, the correspondingis set to the newly-created filter context,andare freed and set to NULL."
    },
    {
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "seg"
         },
         "parameterdescription": {
          "para": "the filtergraph segment to process"
         }
        },
        {
         "parameternamelist": {
          "parametername": "flags"
         },
         "parameterdescription": {
          "para": "reserved for future use, caller must set to 0 for now"
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "non-negative number"
         },
         "parameterdescription": {
          "para": "Success, all creation-pending filters were successfully created"
         }
        },
        {
         "parameternamelist": {
          "parametername": "AVERROR_FILTER_NOT_FOUND"
         },
         "parameterdescription": {
          "para": "some filter's name did not correspond to a known filter"
         }
        },
        {
         "parameternamelist": {
          "parametername": "another negative error code"
         },
         "parameterdescription": {
          "para": "other failures"
         }
        }
       ],
       "@_kind": "retval"
      }
     ],
     "simplesect": {
      "para": "Calling this function multiple times is safe, as it is idempotent.",
      "@_kind": "note"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1233",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1233",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gae2c0bd53a27f412bad29a6378be09584",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create filters specified in a graph segment.\n *\n * Walk through the creation-pending AVFilterParams in the segment and create\n * new filter instances for them.\n * Creation-pending params are those where AVFilterParams.filter_name is\n * non-NULL (and hence AVFilterParams.filter is NULL). All other AVFilterParams\n * instances are ignored.\n *\n * For any filter created by this function, the corresponding\n * AVFilterParams.filter is set to the newly-created filter context,\n * AVFilterParams.filter_name and AVFilterParams.instance_name are freed and set\n * to NULL.\n *\n * @param seg the filtergraph segment to process\n * @param flags reserved for future use, caller must set to 0 for now\n *\n * @retval \"non-negative number\" Success, all creation-pending filters were\n *                               successfully created\n * @retval AVERROR_FILTER_NOT_FOUND some filter's name did not correspond to a\n *                                  known filter\n * @retval \"another negative error code\" other failures\n *\n * @note Calling this function multiple times is safe, as it is idempotent.\n */"
 },
 "avfilter_graph_segment_apply_opts": {
  "type": "int",
  "definition": "int avfilter_graph_segment_apply_opts",
  "argsstring": "(AVFilterGraphSegment *seg, int flags)",
  "name": "avfilter_graph_segment_apply_opts",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraphSegment",
      "@_refid": "structAVFilterGraphSegment",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "seg"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Apply parsed options to filter instances in a graph segment."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "AVFilterParams.opts",
       "@_refid": "structAVFilterParams_1a769ff8a4708ea5e39b5efab8cf26fd24",
       "@_kindref": "member"
      },
      {
       "#text": "av_opt_set_dict2()",
       "@_refid": "group__opt__write_1ga1824a600b215f1807e77b5f6cfa58586",
       "@_kindref": "member"
      }
     ],
     "#text": "Walk through all filter instances in the graph segment that have option dictionaries associated with them and apply those options with av_opt_set_dict2(..., AV_OPT_SEARCH_CHILDREN).is replaced by the dictionary output by, which should be empty (NULL) if all options were successfully applied."
    },
    "If any options could not be found, this function will continue processing all other filters and finally return AVERROR_OPTION_NOT_FOUND (unless another error happens). The calling program may then deal with unapplied options as it wishes.",
    {
     "ref": [
      {
       "#text": "avfilter_graph_segment_create_filters()",
       "@_refid": "group__lavfi_1gae2c0bd53a27f412bad29a6378be09584",
       "@_kindref": "member"
      },
      {
       "#text": "AVFilterParams",
       "@_refid": "structAVFilterParams",
       "@_kindref": "compound"
      }
     ],
     "#text": "Any creation-pending filters (see) present in the segment will cause this function to fail.with no associated filter context are simply skipped."
    },
    {
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "seg"
         },
         "parameterdescription": {
          "para": "the filtergraph segment to process"
         }
        },
        {
         "parameternamelist": {
          "parametername": "flags"
         },
         "parameterdescription": {
          "para": "reserved for future use, caller must set to 0 for now"
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "non-negative number"
         },
         "parameterdescription": {
          "para": "Success, all options were successfully applied."
         }
        },
        {
         "parameternamelist": {
          "parametername": "AVERROR_OPTION_NOT_FOUND"
         },
         "parameterdescription": {
          "para": "some options were not found in a filter"
         }
        },
        {
         "parameternamelist": {
          "parametername": "another negative error code"
         },
         "parameterdescription": {
          "para": "other failures"
         }
        }
       ],
       "@_kind": "retval"
      }
     ],
     "simplesect": {
      "para": "Calling this function multiple times is safe, as it is idempotent.",
      "@_kind": "note"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1262",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1262",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga907fa33fc5d3bbe5d6396625082bfee6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Apply parsed options to filter instances in a graph segment.\n *\n * Walk through all filter instances in the graph segment that have option\n * dictionaries associated with them and apply those options with\n * av_opt_set_dict2(..., AV_OPT_SEARCH_CHILDREN). AVFilterParams.opts is\n * replaced by the dictionary output by av_opt_set_dict2(), which should be\n * empty (NULL) if all options were successfully applied.\n *\n * If any options could not be found, this function will continue processing all\n * other filters and finally return AVERROR_OPTION_NOT_FOUND (unless another\n * error happens). The calling program may then deal with unapplied options as\n * it wishes.\n *\n * Any creation-pending filters (see avfilter_graph_segment_create_filters())\n * present in the segment will cause this function to fail. AVFilterParams with\n * no associated filter context are simply skipped.\n *\n * @param seg the filtergraph segment to process\n * @param flags reserved for future use, caller must set to 0 for now\n *\n * @retval \"non-negative number\" Success, all options were successfully applied.\n * @retval AVERROR_OPTION_NOT_FOUND some options were not found in a filter\n * @retval \"another negative error code\" other failures\n *\n * @note Calling this function multiple times is safe, as it is idempotent.\n */"
 },
 "avfilter_graph_segment_init": {
  "type": "int",
  "definition": "int avfilter_graph_segment_init",
  "argsstring": "(AVFilterGraphSegment *seg, int flags)",
  "name": "avfilter_graph_segment_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraphSegment",
      "@_refid": "structAVFilterGraphSegment",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "seg"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Initialize all filter instances in a graph segment."
  },
  "detaileddescription": {
   "para": [
    "Walk through all filter instances in the graph segment and call avfilter_init_dict(..., NULL) on those that have not been initialized yet.",
    {
     "ref": [
      {
       "#text": "avfilter_graph_segment_create_filters()",
       "@_refid": "group__lavfi_1gae2c0bd53a27f412bad29a6378be09584",
       "@_kindref": "member"
      },
      {
       "#text": "AVFilterParams",
       "@_refid": "structAVFilterParams",
       "@_kindref": "compound"
      }
     ],
     "#text": "Any creation-pending filters (see) present in the segment will cause this function to fail.with no associated filter context or whose filter context is already initialized, are simply skipped."
    },
    {
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "seg"
         },
         "parameterdescription": {
          "para": "the filtergraph segment to process"
         }
        },
        {
         "parameternamelist": {
          "parametername": "flags"
         },
         "parameterdescription": {
          "para": "reserved for future use, caller must set to 0 for now"
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "non-negative number"
         },
         "parameterdescription": {
          "para": "Success, all filter instances were successfully initialized"
         }
        },
        {
         "parameternamelist": {
          "parametername": "negative error code"
         },
         "parameterdescription": {
          "para": "failure"
         }
        }
       ],
       "@_kind": "retval"
      }
     ],
     "simplesect": {
      "para": "Calling this function multiple times is safe, as it is idempotent.",
      "@_kind": "note"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1284",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1284",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga96a90e459d3e47153fd2a47ba5f9ddb5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize all filter instances in a graph segment.\n *\n * Walk through all filter instances in the graph segment and call\n * avfilter_init_dict(..., NULL) on those that have not been initialized yet.\n *\n * Any creation-pending filters (see avfilter_graph_segment_create_filters())\n * present in the segment will cause this function to fail. AVFilterParams with\n * no associated filter context or whose filter context is already initialized,\n * are simply skipped.\n *\n * @param seg the filtergraph segment to process\n * @param flags reserved for future use, caller must set to 0 for now\n *\n * @retval \"non-negative number\" Success, all filter instances were successfully\n *                               initialized\n * @retval \"negative error code\" failure\n *\n * @note Calling this function multiple times is safe, as it is idempotent.\n */"
 },
 "avfilter_graph_segment_link": {
  "type": "int",
  "definition": "int avfilter_graph_segment_link",
  "argsstring": "(AVFilterGraphSegment *seg, int flags, AVFilterInOut **inputs, AVFilterInOut **outputs)",
  "name": "avfilter_graph_segment_link",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraphSegment",
      "@_refid": "structAVFilterGraphSegment",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "seg"
   },
   {
    "type": "int",
    "declname": "flags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterInOut",
      "@_refid": "structAVFilterInOut",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "inputs"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterInOut",
      "@_refid": "structAVFilterInOut",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "outputs"
   }
  ],
  "briefdescription": {
   "para": "Link filters in a graph segment."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avfilter_graph_segment_create_filters()",
      "@_refid": "group__lavfi_1gae2c0bd53a27f412bad29a6378be09584",
      "@_kindref": "member"
     },
     "#text": "Walk through all filter instances in the graph segment and try to link all unlinked input and output pads. Any creation-pending filters (see) present in the segment will cause this function to fail. Disabled filters and already linked pads are skipped."
    },
    {
     "ref": {
      "#text": "AVFilterPadParams",
      "@_refid": "structAVFilterPadParams",
      "@_kindref": "compound"
     },
     "itemizedlist": {
      "listitem": [
       {
        "para": "linked to the input with the matching label, if one exists;"
       },
       {
        "para": "exported in the outputs linked list otherwise, with the label preserved. Unlabeled outputs are"
       },
       {
        "para": "linked to the first unlinked unlabeled input in the next non-disabled filter in the chain, if one exists"
       },
       {
        "para": "exported in the ouputs linked list otherwise, with NULL label"
       }
      ]
     },
     "#text": "Every filter output pad that has a correspondingwith a non-NULL label is"
    },
    "Similarly, unlinked input pads are exported in the inputs linked list.",
    {
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "seg"
         },
         "parameterdescription": {
          "para": "the filtergraph segment to process"
         }
        },
        {
         "parameternamelist": {
          "parametername": "flags"
         },
         "parameterdescription": {
          "para": "reserved for future use, caller must set to 0 for now"
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "#text": "inputs",
           "@_direction": "out"
          }
         },
         "parameterdescription": {
          "para": {
           "ref": {
            "#text": "avfilter_inout_free()",
            "@_refid": "group__lavfi_1ga294500a9856260eb1552354fd9d9a6c4",
            "@_kindref": "member"
           },
           "#text": "a linked list of all free (unlinked) inputs of the filters in this graph segment will be returned here. It is to be freed by the caller using."
          }
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "#text": "outputs",
           "@_direction": "out"
          }
         },
         "parameterdescription": {
          "para": {
           "ref": {
            "#text": "avfilter_inout_free()",
            "@_refid": "group__lavfi_1ga294500a9856260eb1552354fd9d9a6c4",
            "@_kindref": "member"
           },
           "#text": "a linked list of all free (unlinked) outputs of the filters in this graph segment will be returned here. It is to be freed by the caller using."
          }
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "non-negative number"
         },
         "parameterdescription": {
          "para": "success"
         }
        },
        {
         "parameternamelist": {
          "parametername": "negative error code"
         },
         "parameterdescription": {
          "para": "failure"
         }
        }
       ],
       "@_kind": "retval"
      }
     ],
     "simplesect": {
      "para": "Calling this function multiple times is safe, as it is idempotent.",
      "@_kind": "note"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1319",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1319",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gad4e090617f168f02da40f09e3189a734",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Link filters in a graph segment.\n *\n * Walk through all filter instances in the graph segment and try to link all\n * unlinked input and output pads. Any creation-pending filters (see\n * avfilter_graph_segment_create_filters()) present in the segment will cause\n * this function to fail. Disabled filters and already linked pads are skipped.\n *\n * Every filter output pad that has a corresponding AVFilterPadParams with a\n * non-NULL label is\n * - linked to the input with the matching label, if one exists;\n * - exported in the outputs linked list otherwise, with the label preserved.\n * Unlabeled outputs are\n * - linked to the first unlinked unlabeled input in the next non-disabled\n *   filter in the chain, if one exists\n * - exported in the ouputs linked list otherwise, with NULL label\n *\n * Similarly, unlinked input pads are exported in the inputs linked list.\n *\n * @param seg the filtergraph segment to process\n * @param flags reserved for future use, caller must set to 0 for now\n * @param[out] inputs  a linked list of all free (unlinked) inputs of the\n *                     filters in this graph segment will be returned here. It\n *                     is to be freed by the caller using avfilter_inout_free().\n * @param[out] outputs a linked list of all free (unlinked) outputs of the\n *                     filters in this graph segment will be returned here. It\n *                     is to be freed by the caller using avfilter_inout_free().\n *\n * @retval \"non-negative number\" success\n * @retval \"negative error code\" failure\n *\n * @note Calling this function multiple times is safe, as it is idempotent.\n */"
 },
 "avfilter_graph_segment_apply": {
  "type": "int",
  "definition": "int avfilter_graph_segment_apply",
  "argsstring": "(AVFilterGraphSegment *seg, int flags, AVFilterInOut **inputs, AVFilterInOut **outputs)",
  "name": "avfilter_graph_segment_apply",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraphSegment",
      "@_refid": "structAVFilterGraphSegment",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "seg"
   },
   {
    "type": "int",
    "declname": "flags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterInOut",
      "@_refid": "structAVFilterInOut",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "inputs"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFilterInOut",
      "@_refid": "structAVFilterInOut",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "outputs"
   }
  ],
  "briefdescription": {
   "para": "Apply all filter/link descriptions from a graph segment to the associated filtergraph."
  },
  "detaileddescription": {
   "para": [
    {
     "itemizedlist": {
      "listitem": [
       {
        "para": {
         "ref": {
          "#text": "avfilter_graph_segment_create_filters()",
          "@_refid": "group__lavfi_1gae2c0bd53a27f412bad29a6378be09584",
          "@_kindref": "member"
         },
         "#text": ";"
        }
       },
       {
        "para": {
         "ref": {
          "#text": "avfilter_graph_segment_apply_opts()",
          "@_refid": "group__lavfi_1ga907fa33fc5d3bbe5d6396625082bfee6",
          "@_kindref": "member"
         },
         "#text": ";"
        }
       },
       {
        "para": {
         "ref": {
          "#text": "avfilter_graph_segment_init()",
          "@_refid": "group__lavfi_1ga96a90e459d3e47153fd2a47ba5f9ddb5",
          "@_kindref": "member"
         },
         "#text": ";"
        }
       },
       {
        "para": {
         "ref": {
          "#text": "avfilter_graph_segment_link()",
          "@_refid": "group__lavfi_1gad4e090617f168f02da40f09e3189a734",
          "@_kindref": "member"
         },
         "#text": "; failing if any of them fails. This list may be extended in the future."
        }
       }
      ]
     },
     "#text": "This functions is currently equivalent to calling the following in sequence:"
    },
    "Since the above functions are idempotent, the caller may call some of them manually, then do some custom processing on the filtergraph, then call this function to do the rest.",
    {
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "seg"
         },
         "parameterdescription": {
          "para": "the filtergraph segment to process"
         }
        },
        {
         "parameternamelist": {
          "parametername": "flags"
         },
         "parameterdescription": {
          "para": "reserved for future use, caller must set to 0 for now"
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "#text": "inputs",
           "@_direction": "out"
          }
         },
         "parameterdescription": {
          "para": {
           "ref": {
            "#text": "avfilter_graph_segment_link()",
            "@_refid": "group__lavfi_1gad4e090617f168f02da40f09e3189a734",
            "@_kindref": "member"
           },
           "#text": "passed to"
          }
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "#text": "outputs",
           "@_direction": "out"
          }
         },
         "parameterdescription": {
          "para": {
           "ref": {
            "#text": "avfilter_graph_segment_link()",
            "@_refid": "group__lavfi_1gad4e090617f168f02da40f09e3189a734",
            "@_kindref": "member"
           },
           "#text": "passed to"
          }
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "non-negative number"
         },
         "parameterdescription": {
          "para": "success"
         }
        },
        {
         "parameternamelist": {
          "parametername": "negative error code"
         },
         "parameterdescription": {
          "para": "failure"
         }
        }
       ],
       "@_kind": "retval"
      }
     ],
     "simplesect": {
      "para": "Calling this function multiple times is safe, as it is idempotent.",
      "@_kind": "note"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1347",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1347",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gada3537e47b1e8851d9a4081a11e7519c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Apply all filter/link descriptions from a graph segment to the associated filtergraph.\n *\n * This functions is currently equivalent to calling the following in sequence:\n * - avfilter_graph_segment_create_filters();\n * - avfilter_graph_segment_apply_opts();\n * - avfilter_graph_segment_init();\n * - avfilter_graph_segment_link();\n * failing if any of them fails. This list may be extended in the future.\n *\n * Since the above functions are idempotent, the caller may call some of them\n * manually, then do some custom processing on the filtergraph, then call this\n * function to do the rest.\n *\n * @param seg the filtergraph segment to process\n * @param flags reserved for future use, caller must set to 0 for now\n * @param[out] inputs passed to avfilter_graph_segment_link()\n * @param[out] outputs passed to avfilter_graph_segment_link()\n *\n * @retval \"non-negative number\" success\n * @retval \"negative error code\" failure\n *\n * @note Calling this function multiple times is safe, as it is idempotent.\n */"
 },
 "avfilter_graph_segment_free": {
  "type": "void",
  "definition": "void avfilter_graph_segment_free",
  "argsstring": "(AVFilterGraphSegment **seg)",
  "name": "avfilter_graph_segment_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterGraphSegment",
     "@_refid": "structAVFilterGraphSegment",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "seg"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFilterGraphSegment",
     "@_refid": "structAVFilterGraphSegment",
     "@_kindref": "compound"
    },
    "#text": "Free the providedand everything associated with it."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "seg"
      },
      "parameterdescription": {
       "para": {
        "ref": {
         "#text": "AVFilterGraphSegment",
         "@_refid": "structAVFilterGraphSegment",
         "@_kindref": "compound"
        },
        "#text": "double pointer to theto be freed. NULL will be written to this pointer on exit from this function."
       }
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": [
       {
        "#text": "AVFilterParams.filter",
        "@_refid": "structAVFilterParams_1a843deab11c88a89fb9f5b68d05bfb9e2",
        "@_kindref": "member"
       },
       {
        "#text": "AVFilterGraph",
        "@_refid": "structAVFilterGraph",
        "@_kindref": "compound"
       },
       {
        "#text": "AVFilterGraphSegment",
        "@_refid": "structAVFilterGraphSegment",
        "@_kindref": "compound"
       }
      ],
      "#text": "The filter contexts () are owned byrather than, so they are not freed."
     },
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1361",
   "@_column": "6",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1361",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga51283edd8f3685e1f33239f360e14ae8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the provided AVFilterGraphSegment and everything associated with it.\n *\n * @param seg double pointer to the AVFilterGraphSegment to be freed. NULL will\n * be written to this pointer on exit from this function.\n *\n * @note\n * The filter contexts (AVFilterParams.filter) are owned by AVFilterGraph rather\n * than AVFilterGraphSegment, so they are not freed.\n */"
 },
 "avfilter_graph_send_command": {
  "type": "int",
  "definition": "int avfilter_graph_send_command",
  "argsstring": "(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, char *res, int res_len, int flags)",
  "name": "avfilter_graph_send_command",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graph"
   },
   {
    "type": "const char *",
    "declname": "target"
   },
   {
    "type": "const char *",
    "declname": "cmd"
   },
   {
    "type": "const char *",
    "declname": "arg"
   },
   {
    "type": "char *",
    "declname": "res"
   },
   {
    "type": "int",
    "declname": "res_len"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Send a command to one or more filter instances."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "graph"
       },
       "parameterdescription": {
        "para": "the filter graph"
       }
      },
      {
       "parameternamelist": {
        "parametername": "target"
       },
       "parameterdescription": {
        "para": "the filter(s) to which the command should be sent \"all\" sends to all filters otherwise it can be a filter or filter instance name which will send the command to all matching filters."
       }
      },
      {
       "parameternamelist": {
        "parametername": "cmd"
       },
       "parameterdescription": {
        "para": "the command to send, for handling simplicity all commands must be alphanumeric only"
       }
      },
      {
       "parameternamelist": {
        "parametername": "arg"
       },
       "parameterdescription": {
        "para": "the argument for the command"
       }
      },
      {
       "parameternamelist": {
        "parametername": "res"
       },
       "parameterdescription": {
        "para": "a buffer with size res_size where the filter(s) can return a response."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVERROR(ENOSYS)",
       "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
       "@_kindref": "member"
      },
      "#text": ">=0 on success otherwise an error code.on unsupported commands"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1378",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1378",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gaaad7850fb5fe26d35e5d371ca75b79e1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Send a command to one or more filter instances.\n *\n * @param graph  the filter graph\n * @param target the filter(s) to which the command should be sent\n *               \"all\" sends to all filters\n *               otherwise it can be a filter or filter instance name\n *               which will send the command to all matching filters.\n * @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only\n * @param arg    the argument for the command\n * @param res    a buffer with size res_size where the filter(s) can return a response.\n *\n * @returns >=0 on success otherwise an error code.\n *              AVERROR(ENOSYS) on unsupported commands\n */"
 },
 "avfilter_graph_queue_command": {
  "type": "int",
  "definition": "int avfilter_graph_queue_command",
  "argsstring": "(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, int flags, double ts)",
  "name": "avfilter_graph_queue_command",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graph"
   },
   {
    "type": "const char *",
    "declname": "target"
   },
   {
    "type": "const char *",
    "declname": "cmd"
   },
   {
    "type": "const char *",
    "declname": "arg"
   },
   {
    "type": "int",
    "declname": "flags"
   },
   {
    "type": "double",
    "declname": "ts"
   }
  ],
  "briefdescription": {
   "para": "Queue a command for one or more filter instances."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "graph"
       },
       "parameterdescription": {
        "para": "the filter graph"
       }
      },
      {
       "parameternamelist": {
        "parametername": "target"
       },
       "parameterdescription": {
        "para": "the filter(s) to which the command should be sent \"all\" sends to all filters otherwise it can be a filter or filter instance name which will send the command to all matching filters."
       }
      },
      {
       "parameternamelist": {
        "parametername": "cmd"
       },
       "parameterdescription": {
        "para": "the command to sent, for handling simplicity all commands must be alphanumeric only"
       }
      },
      {
       "parameternamelist": {
        "parametername": "arg"
       },
       "parameterdescription": {
        "para": "the argument for the command"
       }
      },
      {
       "parameternamelist": {
        "parametername": "ts"
       },
       "parameterdescription": {
        "para": "time at which the command should be sent to the filter"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "As this executes commands after this function returns, no return code from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.",
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1395",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1395",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga3140b3cd7bf9a80c2dfa868dcf7ac541",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Queue a command for one or more filter instances.\n *\n * @param graph  the filter graph\n * @param target the filter(s) to which the command should be sent\n *               \"all\" sends to all filters\n *               otherwise it can be a filter or filter instance name\n *               which will send the command to all matching filters.\n * @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only\n * @param arg    the argument for the command\n * @param ts     time at which the command should be sent to the filter\n *\n * @note As this executes commands after this function returns, no return code\n *       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.\n */"
 },
 "avfilter_graph_dump": {
  "type": "char *",
  "definition": "char * avfilter_graph_dump",
  "argsstring": "(AVFilterGraph *graph, const char *options)",
  "name": "avfilter_graph_dump",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterGraph",
      "@_refid": "structAVFilterGraph",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "graph"
   },
   {
    "type": "const char *",
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": "Dump a graph into a human-readable string representation."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "graph"
       },
       "parameterdescription": {
        "para": "the graph to dump"
       }
      },
      {
       "parameternamelist": {
        "parametername": "options"
       },
       "parameterdescription": {
        "para": "formatting options; currently ignored"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "a string, or NULL in case of memory allocation failure; the string must be freed using av_free",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1406",
   "@_column": "6",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1406",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1ga1df24c543f8441afad8599d20a912221",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Dump a graph into a human-readable string representation.\n *\n * @param graph    the graph to dump\n * @param options  formatting options; currently ignored\n * @return  a string, or NULL in case of memory allocation failure;\n *          the string must be freed using av_free\n */"
 },
 "avfilter_graph_request_oldest": {
  "type": "int",
  "definition": "int avfilter_graph_request_oldest",
  "argsstring": "(AVFilterGraph *graph)",
  "name": "avfilter_graph_request_oldest",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterGraph",
     "@_refid": "structAVFilterGraph",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "graph"
  },
  "briefdescription": {
   "para": "Request a frame on the oldest sink link."
  },
  "detaileddescription": {
   "para": [
    "If the request returns AVERROR_EOF, try the next.",
    "Note that this function is not meant to be the sole scheduling mechanism of a filtergraph, only a convenience function to help drain a filtergraph in a balanced way under normal circumstances.",
    "Also note that AVERROR_EOF does not mean that frames did not arrive on some of the sinks during the process. When there are multiple sink links, in case the requested link returns an EOF, this may cause a filter to flush pending frames which are sent to another sink link, although unrequested.",
    {
     "simplesect": {
      "para": "the return value of ff_request_frame(), or AVERROR_EOF if all links returned AVERROR_EOF",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "1426",
   "@_column": "5",
   "@_declfile": "libavfilter/avfilter.h",
   "@_declline": "1426",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi_1gab20535e0685fb5f9b4f02e436412c3f0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Request a frame on the oldest sink link.\n *\n * If the request returns AVERROR_EOF, try the next.\n *\n * Note that this function is not meant to be the sole scheduling mechanism\n * of a filtergraph, only a convenience function to help drain a filtergraph\n * in a balanced way under normal circumstances.\n *\n * Also note that AVERROR_EOF does not mean that frames did not arrive on\n * some of the sinks during the process.\n * When there are multiple sink links, in case the requested link\n * returns an EOF, this may cause a filter to flush pending frames\n * which are sent to another sink link, although unrequested.\n *\n * @return  the return value of ff_request_frame(),\n *          or AVERROR_EOF if all links returned AVERROR_EOF\n */"
 },
 "av_format_control_message": {
  "type": "int(*",
  "definition": "typedef int(* av_format_control_message) (struct AVFormatContext *s, int type, void *data, size_t data_size)",
  "argsstring": ")(struct AVFormatContext *s, int type, void *data, size_t data_size)",
  "name": "av_format_control_message",
  "briefdescription": {
   "para": "Callback used by devices to communicate with application."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1225",
   "@_column": "9",
   "@_bodyfile": "libavformat/avformat.h",
   "@_bodystart": "1225",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "avformat_8h_1a80856b99bcf4373936fb4fba028b11ca",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Callback used by devices to communicate with application.\n */"
 },
 "AVOpenCallback": {
  "type": "int(*",
  "definition": "typedef int(* AVOpenCallback) (struct AVFormatContext *s, AVIOContext **pb, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)",
  "argsstring": ")(struct AVFormatContext *s, AVIOContext **pb, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)",
  "name": "AVOpenCallback",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1228",
   "@_column": "9",
   "@_bodyfile": "libavformat/avformat.h",
   "@_bodystart": "1228",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "avformat_8h_1a6f7cab62acdf2bce2883a3c82cf1a27c",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Callback used by devices to communicate with application.\n */"
 },
 "av_get_packet": {
  "type": "int",
  "definition": "int av_get_packet",
  "argsstring": "(AVIOContext *s, AVPacket *pkt, int size)",
  "name": "av_get_packet",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Allocate and read the payload of a packet and initialize its fields with default values."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "associated IO context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "desired payload size"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">0 (read size) if OK, AVERROR_xxx otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "424",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "424",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avformat_8h_1a9d2e6f22150d98c36dcc2c6c49318019",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate and read the payload of a packet and initialize its\n * fields with default values.\n *\n * @param s    associated IO context\n * @param pkt packet\n * @param size desired payload size\n * @return >0 (read size) if OK, AVERROR_xxx otherwise\n */"
 },
 "av_append_packet": {
  "type": "int",
  "definition": "int av_append_packet",
  "argsstring": "(AVIOContext *s, AVPacket *pkt, int size)",
  "name": "av_append_packet",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVPacket",
     "@_refid": "structAVPacket",
     "@_kindref": "compound"
    },
    "#text": "Read data and append it to the current content of the."
   }
  },
  "detaileddescription": {
   "para": [
    "If pkt->size is 0 this is identical to av_get_packet. Note that this uses av_grow_packet and thus involves a realloc which is inefficient. Thus this function should only be used when there is no reasonable way to know (an upper bound of) the final size.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "associated IO context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pkt"
        },
        "parameterdescription": {
         "para": "packet"
        }
       },
       {
        "parameternamelist": {
         "parametername": "size"
        },
        "parameterdescription": {
         "para": "amount of data to read"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">0 (read size) if OK, AVERROR_xxx otherwise, previous data will not be lost even if an error occurs.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "441",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "441",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avformat_8h_1a0e991213ccc3d642972b57a1decb797b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read data and append it to the current content of the AVPacket.\n * If pkt->size is 0 this is identical to av_get_packet.\n * Note that this uses av_grow_packet and thus involves a realloc\n * which is inefficient. Thus this function should only be used\n * when there is no reasonable way to know (an upper bound of)\n * the final size.\n *\n * @param s    associated IO context\n * @param pkt packet\n * @param size amount of data to read\n * @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data\n *         will not be lost even if an error occurs.\n */"
 },
 "av_disposition_from_string": {
  "type": "int",
  "definition": "int av_disposition_from_string",
  "argsstring": "(const char *disp)",
  "name": "av_disposition_from_string",
  "param": {
   "type": "const char *",
   "declname": "disp"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "The AV_DISPOSITION_* flag corresponding to disp or a negative error code if disp does not correspond to a known stream disposition.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "719",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "719",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avformat_8h_1aa68eedbbd30c0287e6032a9b6c398d01",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return The AV_DISPOSITION_* flag corresponding to disp or a negative error\n *         code if disp does not correspond to a known stream disposition.\n */"
 },
 "av_disposition_to_string": {
  "type": "const char *",
  "definition": "const char * av_disposition_to_string",
  "argsstring": "(int disposition)",
  "name": "av_disposition_to_string",
  "param": {
   "type": "int",
   "declname": "disposition"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "disposition"
      },
      "parameterdescription": {
       "para": "a combination of AV_DISPOSITION_* values"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "The string description corresponding to the lowest set bit in disposition. NULL when the lowest set bit does not correspond to a known disposition or when disposition is 0.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "727",
   "@_column": "12",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "727",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "avformat_8h_1a96898fab9ece5448ea6ca4c5d8a10efa",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @param disposition a combination of AV_DISPOSITION_* values\n * @return The string description corresponding to the lowest set bit in\n *         disposition. NULL when the lowest set bit does not correspond\n *         to a known disposition or when disposition is 0.\n */"
 },
 "av_stream_get_parser": {
  "type": {
   "ref": {
    "#text": "AVCodecParserContext",
    "@_refid": "structAVCodecParserContext",
    "@_kindref": "compound"
   },
   "#text": "struct*"
  },
  "definition": "struct AVCodecParserContext * av_stream_get_parser",
  "argsstring": "(const AVStream *s)",
  "name": "av_stream_get_parser",
  "param": {
   "type": {
    "ref": {
     "#text": "AVStream",
     "@_refid": "structAVStream",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1169",
   "@_column": "27",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1169",
   "@_declcolumn": "27"
  },
  "@_kind": "function",
  "@_id": "avformat_8h_1adeb06c597399118a52d4ac616d7c756f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "    /**\n     * Stream group disposition - a combination of AV_DISPOSITION_* flags.\n     * This field currently applies to all defined AVStreamGroupParamsType.\n     *\n     * - demuxing: set by libavformat when creating the group or in\n     *             avformat_find_stream_info().\n     * - muxing: may be set by the caller before avformat_write_header().\n     */"
 },
 "av_format_inject_global_side_data": {
  "type": "void",
  "definition": "void av_format_inject_global_side_data",
  "argsstring": "(AVFormatContext *s)",
  "name": "av_format_inject_global_side_data",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "This function will cause global side data to be injected in the next packet of each stream as well as after any subsequent seek."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": [
        {
         "#text": "AVStream",
         "@_refid": "structAVStream",
         "@_kindref": "compound"
        },
        {
         "#text": "codecpar side data",
         "@_refid": "structAVCodecParameters_1ad54da9241deabb3601e6e0e8fa832c19",
         "@_kindref": "member"
        },
        {
         "#text": "decoder's side data",
         "@_refid": "structAVCodecContext_1a0d9375d5c81895b9048644e547b33d32",
         "@_kindref": "member"
        }
       ],
       "#text": "global side data is always available in every'sarray, and in aarray if initialized with said stream's codecpar."
      },
      "@_kind": "note"
     },
     {
      "para": {
       "ref": {
        "#text": "av_packet_side_data_get()",
        "@_refid": "group__lavc__packet__side__data_1gabe0dea475f687842cf31a9e967be1692",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1883",
   "@_column": "6",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1883",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avformat_8h_1aa3a096ee52bc6b1e0f31278d26996777",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * This function will cause global side data to be injected in the next packet\n * of each stream as well as after any subsequent seek.\n *\n * @note global side data is always available in every AVStream's\n *       @ref AVCodecParameters.coded_side_data \"codecpar side data\" array, and\n *       in a @ref AVCodecContext.coded_side_data \"decoder's side data\" array if\n *       initialized with said stream's codecpar.\n * @see av_packet_side_data_get()\n */"
 },
 "av_fmt_ctx_get_duration_estimation_method": {
  "type": {
   "ref": [
    {
     "#text": "attribute_deprecated",
     "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
     "@_kindref": "member"
    },
    {
     "#text": "AVDurationEstimationMethod",
     "@_refid": "avformat_8h_1a7c2692ffa20d3e888e40e79eeda6d73b",
     "@_kindref": "member"
    }
   ],
   "#text": "enum"
  },
  "definition": "attribute_deprecated enum AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method",
  "argsstring": "(const AVFormatContext *ctx)",
  "name": "av_fmt_ctx_get_duration_estimation_method",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": {
   "para": "Returns the method used to set ctx->duration."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.",
     "@_kind": "return"
    },
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": "duration_estimation_method is public and can be read directly."
     },
     "@_id": "deprecated_1_deprecated000004"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1893",
   "@_column": "32",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1893",
   "@_declcolumn": "32"
  },
  "@_kind": "function",
  "@_id": "avformat_8h_1a93e4cbf8f1ecdd0474ff043bb25221ec",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Returns the method used to set ctx->duration.\n *\n * @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.\n * @deprecated duration_estimation_method is public and can be read directly.\n */"
 },
 "avformat_version": {
  "type": "unsigned",
  "definition": "unsigned avformat_version",
  "argsstring": "(void)",
  "name": "avformat_version",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the LIBAVFORMAT_VERSION_INT constant."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1908",
   "@_column": "10",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1908",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1gaf2d4e0fee66cef99dea2153933e6b907",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the LIBAVFORMAT_VERSION_INT constant.\n */"
 },
 "avformat_configuration": {
  "type": "const char *",
  "definition": "const char * avformat_configuration",
  "argsstring": "(void)",
  "name": "avformat_configuration",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libavformat build-time configuration."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1913",
   "@_column": "12",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1913",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga2585a302cd25efceb303645bc82d32f0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libavformat build-time configuration.\n */"
 },
 "avformat_license": {
  "type": "const char *",
  "definition": "const char * avformat_license",
  "argsstring": "(void)",
  "name": "avformat_license",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libavformat license."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1918",
   "@_column": "12",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1918",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga9af383726447472e7cd832b0ca6c7a61",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libavformat license.\n */"
 },
 "avformat_network_init": {
  "type": "int",
  "definition": "int avformat_network_init",
  "argsstring": "(void)",
  "name": "avformat_network_init",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Do global initialization of network libraries."
  },
  "detaileddescription": {
   "para": [
    "This is optional, and not recommended anymore.",
    "This functions only exists to work around thread-safety issues with older GnuTLS or OpenSSL libraries. If libavformat is linked to newer versions of those libraries, or if you do not use them, calling this function is unnecessary. Otherwise, you need to call this function before any other threads using them are started.",
    "This function will be deprecated once support for older GnuTLS and OpenSSL libraries is removed, and this function has no purpose anymore."
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1934",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1934",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "avio__list__dir_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "avio__list__dir_8c",
   "@_startline": "119",
   "@_endline": "137"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga84542023693d61e8564c5d457979c932",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Do global initialization of network libraries. This is optional,\n * and not recommended anymore.\n *\n * This functions only exists to work around thread-safety issues\n * with older GnuTLS or OpenSSL libraries. If libavformat is linked\n * to newer versions of those libraries, or if you do not use them,\n * calling this function is unnecessary. Otherwise, you need to call\n * this function before any other threads using them are started.\n *\n * This function will be deprecated once support for older GnuTLS and\n * OpenSSL libraries is removed, and this function has no purpose\n * anymore.\n */"
 },
 "avformat_network_deinit": {
  "type": "int",
  "definition": "int avformat_network_deinit",
  "argsstring": "(void)",
  "name": "avformat_network_deinit",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Undo the initialization done by avformat_network_init."
  },
  "detaileddescription": {
   "para": "Call it only once for each time you called avformat_network_init."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1940",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1940",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "avio__list__dir_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "avio__list__dir_8c",
   "@_startline": "119",
   "@_endline": "137"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga245f2875f80ce67ec3d1e0f54dacf2c4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Undo the initialization done by avformat_network_init. Call it only\n * once for each time you called avformat_network_init.\n */"
 },
 "av_muxer_iterate": {
  "type": {
   "ref": {
    "#text": "AVOutputFormat",
    "@_refid": "structAVOutputFormat",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVOutputFormat * av_muxer_iterate",
  "argsstring": "(void **opaque)",
  "name": "av_muxer_iterate",
  "param": {
   "type": "void **",
   "declname": "opaque"
  },
  "briefdescription": {
   "para": "Iterate over all registered muxers."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "opaque"
      },
      "parameterdescription": {
       "para": "a pointer where libavformat will store the iteration state. Must point to NULL to start the iteration."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the next registered muxer or NULL when the iteration is finished",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1951",
   "@_column": "22",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1951",
   "@_declcolumn": "22"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga8065a9f6d686610bd8dba40a154bfba1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over all registered muxers.\n *\n * @param opaque a pointer where libavformat will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered muxer or NULL when the iteration is\n *         finished\n */"
 },
 "av_demuxer_iterate": {
  "type": {
   "ref": {
    "#text": "AVInputFormat",
    "@_refid": "structAVInputFormat",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVInputFormat * av_demuxer_iterate",
  "argsstring": "(void **opaque)",
  "name": "av_demuxer_iterate",
  "param": {
   "type": "void **",
   "declname": "opaque"
  },
  "briefdescription": {
   "para": "Iterate over all registered demuxers."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "opaque"
      },
      "parameterdescription": {
       "para": "a pointer where libavformat will store the iteration state. Must point to NULL to start the iteration."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the next registered demuxer or NULL when the iteration is finished",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1962",
   "@_column": "21",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1962",
   "@_declcolumn": "21"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1gabbe7e591144175133299a6673b122add",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over all registered demuxers.\n *\n * @param opaque a pointer where libavformat will store the iteration state.\n *               Must point to NULL to start the iteration.\n *\n * @return the next registered demuxer or NULL when the iteration is\n *         finished\n */"
 },
 "avformat_alloc_context": {
  "type": {
   "ref": {
    "#text": "AVFormatContext",
    "@_refid": "structAVFormatContext",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFormatContext * avformat_alloc_context",
  "argsstring": "(void)",
  "name": "avformat_alloc_context",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "Allocate an."
   }
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "avformat_free_context()",
     "@_refid": "group__lavf__core_1gac2990b13b68e831a408fce8e1d0d6445",
     "@_kindref": "member"
    },
    "#text": "can be used to free the context and everything allocated by the framework within it."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1969",
   "@_column": "17",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1969",
   "@_declcolumn": "17"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "avio__read__callback_8c_1a0ddf1224851353fc92bfbff6f499fa97",
    "@_compoundref": "avio__read__callback_8c",
    "@_startline": "58",
    "@_endline": "133"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode__aac_8c_1a617f4760254c119fc7caa222f3fcbd21",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "145",
    "@_endline": "246"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__core_1gab000638c284e97ad0be2bdb11ce33c36",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVFormatContext.\n * avformat_free_context() can be used to free the context and everything\n * allocated by the framework within it.\n */"
 },
 "avformat_free_context": {
  "type": "void",
  "definition": "void avformat_free_context",
  "argsstring": "(AVFormatContext *s)",
  "name": "avformat_free_context",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "Free anand all its streams."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "s"
      },
      "parameterdescription": {
       "para": "context to free"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1975",
   "@_column": "6",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1975",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "mux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "mux_8c",
    "@_startline": "534",
    "@_endline": "643"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode__aac_8c_1a617f4760254c119fc7caa222f3fcbd21",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "145",
    "@_endline": "246"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__core_1gac2990b13b68e831a408fce8e1d0d6445",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free an AVFormatContext and all its streams.\n * @param s context to free\n */"
 },
 "avformat_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * avformat_get_class",
  "argsstring": "(void)",
  "name": "avformat_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVClass",
      "@_refid": "structAVClass",
      "@_kindref": "compound"
     },
     {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     }
    ],
    "#text": "Get thefor."
   }
  },
  "detaileddescription": {
   "para": [
    "It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.",
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_opt_find()",
        "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
        "@_kindref": "member"
       },
       "#text": "."
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1983",
   "@_column": "15",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1983",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1gaee1ff1d03f39701790ce034febf7a3b6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVClass for AVFormatContext. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */"
 },
 "av_stream_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * av_stream_get_class",
  "argsstring": "(void)",
  "name": "av_stream_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVClass",
      "@_refid": "structAVClass",
      "@_kindref": "compound"
     },
     {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     }
    ],
    "#text": "Get thefor."
   }
  },
  "detaileddescription": {
   "para": [
    "It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.",
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_opt_find()",
        "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
        "@_kindref": "member"
       },
       "#text": "."
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1991",
   "@_column": "15",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1991",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga5869af44771e0ff7b150861b6e3304f6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVClass for AVStream. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */"
 },
 "av_stream_group_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * av_stream_group_get_class",
  "argsstring": "(void)",
  "name": "av_stream_group_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVClass",
      "@_refid": "structAVClass",
      "@_kindref": "compound"
     },
     {
      "#text": "AVStreamGroup",
      "@_refid": "structAVStreamGroup",
      "@_kindref": "compound"
     }
    ],
    "#text": "Get thefor."
   }
  },
  "detaileddescription": {
   "para": [
    "It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.",
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_opt_find()",
        "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
        "@_kindref": "member"
       },
       "#text": "."
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "1999",
   "@_column": "15",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "1999",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga1e6340c32d2d765573d89266efaa8125",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVClass for AVStreamGroup. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */"
 },
 "avformat_stream_group_name": {
  "type": "const char *",
  "definition": "const char * avformat_stream_group_name",
  "argsstring": "(enum AVStreamGroupParamsType type)",
  "name": "avformat_stream_group_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVStreamGroupParamsType",
     "@_refid": "avformat_8h_1a4158f5feaf048b63ef8649ccd0d36e5c",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "type"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "a string identifying the stream group type, or NULL if unknown",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2004",
   "@_column": "12",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2004",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga28329212f73f3e1d42af71a4c704a280",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return a string identifying the stream group type, or NULL if unknown\n */"
 },
 "avformat_stream_group_create": {
  "type": {
   "ref": {
    "#text": "AVStreamGroup",
    "@_refid": "structAVStreamGroup",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVStreamGroup * avformat_stream_group_create",
  "argsstring": "(AVFormatContext *s, enum AVStreamGroupParamsType type, AVDictionary **options)",
  "name": "avformat_stream_group_create",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVStreamGroupParamsType",
      "@_refid": "avformat_8h_1a4158f5feaf048b63ef8649ccd0d36e5c",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": "Add a new empty stream group to a media file."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "read_packet()",
      "@_refid": "avio__read__callback_8c_1a3a86bff38e7cb9093d0a32316b73b29c",
      "@_kindref": "member"
     },
     "#text": "When demuxing, it may be called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in."
    },
    {
     "ref": {
      "#text": "avformat_write_header()",
      "@_refid": "group__lavf__encoding_1ga18b7b10bb5b94c4842de18166bc677cb",
      "@_kindref": "member"
     },
     "#text": "When muxing, may be called by the user before."
    },
    {
     "ref": [
      {
       "#text": "avformat_free_context()",
       "@_refid": "group__lavf__core_1gac2990b13b68e831a408fce8e1d0d6445",
       "@_kindref": "member"
      },
      {
       "#text": "avformat_stream_group_create()",
       "@_refid": "group__lavf__core_1ga393d5e94f3c964292a5e2ba9fbcda30a",
       "@_kindref": "member"
      }
     ],
     "#text": "User is required to callto clean up the allocation by."
    },
    {
     "ref": {
      "#text": "avformat_stream_group_add_stream()",
      "@_refid": "group__lavf__core_1ga71ea58a4c7ce40295a0d2e35ae48405f",
      "@_kindref": "member"
     },
     "#text": "New streams can be added to the group with."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "media file handle"
       }
      },
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "newly created group or NULL on error.",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": [
         {
          "#text": "avformat_new_stream",
          "@_refid": "group__lavf__core_1ga565f8a43c85a1dd4825075dcaa2e629f",
          "@_kindref": "member"
         },
         {
          "#text": "avformat_stream_group_add_stream",
          "@_refid": "group__lavf__core_1ga71ea58a4c7ce40295a0d2e35ae48405f",
          "@_kindref": "member"
         }
        ],
        "#text": ",."
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2025",
   "@_column": "15",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2025",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga393d5e94f3c964292a5e2ba9fbcda30a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a new empty stream group to a media file.\n *\n * When demuxing, it may be called by the demuxer in read_header(). If the\n * flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also\n * be called in read_packet().\n *\n * When muxing, may be called by the user before avformat_write_header().\n *\n * User is required to call avformat_free_context() to clean up the allocation\n * by avformat_stream_group_create().\n *\n * New streams can be added to the group with avformat_stream_group_add_stream().\n *\n * @param s media file handle\n *\n * @return newly created group or NULL on error.\n * @see avformat_new_stream, avformat_stream_group_add_stream.\n */"
 },
 "avformat_new_stream": {
  "type": {
   "ref": {
    "#text": "AVStream",
    "@_refid": "structAVStream",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVStream * avformat_new_stream",
  "argsstring": "(AVFormatContext *s, const struct AVCodec *c)",
  "name": "avformat_new_stream",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodec",
      "@_refid": "structAVCodec",
      "@_kindref": "compound"
     },
     "#text": "const struct*"
    },
    "declname": "c"
   }
  ],
  "briefdescription": {
   "para": "Add a new stream to a media file."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "read_packet()",
      "@_refid": "avio__read__callback_8c_1a3a86bff38e7cb9093d0a32316b73b29c",
      "@_kindref": "member"
     },
     "#text": "When demuxing, it is called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in."
    },
    {
     "ref": {
      "#text": "avformat_write_header()",
      "@_refid": "group__lavf__encoding_1ga18b7b10bb5b94c4842de18166bc677cb",
      "@_kindref": "member"
     },
     "#text": "When muxing, should be called by the user before."
    },
    {
     "ref": [
      {
       "#text": "avformat_free_context()",
       "@_refid": "group__lavf__core_1gac2990b13b68e831a408fce8e1d0d6445",
       "@_kindref": "member"
      },
      {
       "#text": "avformat_new_stream()",
       "@_refid": "group__lavf__core_1ga565f8a43c85a1dd4825075dcaa2e629f",
       "@_kindref": "member"
      }
     ],
     "#text": "User is required to callto clean up the allocation by."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "media file handle"
        }
       },
       {
        "parameternamelist": {
         "parametername": "c"
        },
        "parameterdescription": {
         "para": "unused, does nothing"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "newly created stream or NULL on error.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2046",
   "@_column": "10",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2046",
   "@_declcolumn": "10"
  },
  "referencedby": [
   {
    "#text": "add_stream",
    "@_refid": "mux_8c_1a22968a15b922fd8c0c37b49beec06dbe",
    "@_compoundref": "mux_8c",
    "@_startline": "125",
    "@_endline": "211"
   },
   {
    "#text": "main",
    "@_refid": "remux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "remux_8c",
    "@_startline": "46",
    "@_endline": "198"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga565f8a43c85a1dd4825075dcaa2e629f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a new stream to a media file.\n *\n * When demuxing, it is called by the demuxer in read_header(). If the\n * flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also\n * be called in read_packet().\n *\n * When muxing, should be called by the user before avformat_write_header().\n *\n * User is required to call avformat_free_context() to clean up the allocation\n * by avformat_new_stream().\n *\n * @param s media file handle\n * @param c unused, does nothing\n *\n * @return newly created stream or NULL on error.\n */"
 },
 "avformat_stream_group_add_stream": {
  "type": "int",
  "definition": "int avformat_stream_group_add_stream",
  "argsstring": "(AVStreamGroup *stg, AVStream *st)",
  "name": "avformat_stream_group_add_stream",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVStreamGroup",
      "@_refid": "structAVStreamGroup",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "stg"
   },
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "st"
   }
  ],
  "briefdescription": {
   "para": "Add an already allocated stream to a stream group."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "read_packet()",
      "@_refid": "avio__read__callback_8c_1a3a86bff38e7cb9093d0a32316b73b29c",
      "@_kindref": "member"
     },
     "#text": "When demuxing, it may be called by the demuxer in read_header(). If the flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also be called in."
    },
    {
     "ref": [
      {
       "#text": "avformat_write_header()",
       "@_refid": "group__lavf__encoding_1ga18b7b10bb5b94c4842de18166bc677cb",
       "@_kindref": "member"
      },
      {
       "#text": "avformat_stream_group_create()",
       "@_refid": "group__lavf__core_1ga393d5e94f3c964292a5e2ba9fbcda30a",
       "@_kindref": "member"
      },
      {
       "#text": "avformat_new_stream()",
       "@_refid": "group__lavf__core_1ga565f8a43c85a1dd4825075dcaa2e629f",
       "@_kindref": "member"
      }
     ],
     "#text": "When muxing, may be called by the user beforeafter having allocated a new group withand stream with."
    },
    {
     "ref": [
      {
       "#text": "avformat_free_context()",
       "@_refid": "group__lavf__core_1gac2990b13b68e831a408fce8e1d0d6445",
       "@_kindref": "member"
      },
      {
       "#text": "avformat_stream_group_add_stream()",
       "@_refid": "group__lavf__core_1ga71ea58a4c7ce40295a0d2e35ae48405f",
       "@_kindref": "member"
      }
     ],
     "#text": "User is required to callto clean up the allocation by."
    },
    {
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "stg"
         },
         "parameterdescription": {
          "para": "stream group belonging to a media file."
         }
        },
        {
         "parameternamelist": {
          "parametername": "st"
         },
         "parameterdescription": {
          "para": "stream in the media file to add to the group."
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": 0
         },
         "parameterdescription": {
          "para": "success"
         }
        },
        {
         "parameternamelist": {
          "parametername": {
           "ref": {
            "#text": "AVERROR(EEXIST)",
            "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
            "@_kindref": "member"
           }
          }
         },
         "parameterdescription": {
          "para": "the stream was already in the group"
         }
        },
        {
         "parameternamelist": {
          "parametername": "another negative error code"
         },
         "parameterdescription": {
          "para": "legitimate errors"
         }
        }
       ],
       "@_kind": "retval"
      }
     ],
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "avformat_new_stream",
         "@_refid": "group__lavf__core_1ga565f8a43c85a1dd4825075dcaa2e629f",
         "@_kindref": "member"
        },
        {
         "#text": "avformat_stream_group_create",
         "@_refid": "group__lavf__core_1ga393d5e94f3c964292a5e2ba9fbcda30a",
         "@_kindref": "member"
        }
       ],
       "#text": ",."
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2071",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2071",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga71ea58a4c7ce40295a0d2e35ae48405f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add an already allocated stream to a stream group.\n *\n * When demuxing, it may be called by the demuxer in read_header(). If the\n * flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also\n * be called in read_packet().\n *\n * When muxing, may be called by the user before avformat_write_header() after\n * having allocated a new group with avformat_stream_group_create() and stream with\n * avformat_new_stream().\n *\n * User is required to call avformat_free_context() to clean up the allocation\n * by avformat_stream_group_add_stream().\n *\n * @param stg stream group belonging to a media file.\n * @param st  stream in the media file to add to the group.\n *\n * @retval 0                 success\n * @retval AVERROR(EEXIST)   the stream was already in the group\n * @retval \"another negative error code\" legitimate errors\n *\n * @see avformat_new_stream, avformat_stream_group_create.\n */"
 },
 "av_stream_add_side_data": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "attribute_deprecated int av_stream_add_side_data",
  "argsstring": "(AVStream *st, enum AVPacketSideDataType type, uint8_t *data, size_t size)",
  "name": "av_stream_add_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "st"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideDataType",
      "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "uint8_t *",
    "declname": "data"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Wrap an existing array as stream side data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "st"
       },
       "parameterdescription": {
        "para": "stream"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "side information type"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_malloc()",
          "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
          "@_kindref": "member"
         },
         "#text": "the side data array. It must be allocated with thefamily of functions. The ownership of the data is transferred to st."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "side information size"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "zero on success, a negative AVERROR code on failure. On failure, the stream is unchanged and the data remains owned by the caller.",
     "@_kind": "return"
    },
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": {
       "ref": [
        {
         "#text": "av_packet_side_data_add()",
         "@_refid": "group__lavc__packet__side__data_1ga7a0fb092dc581c328a296281332d0c8c",
         "@_kindref": "member"
        },
        {
         "#text": "codecpar side data",
         "@_refid": "structAVCodecParameters_1ad54da9241deabb3601e6e0e8fa832c19",
         "@_kindref": "member"
        }
       ],
       "#text": "usewith the stream's"
      }
     },
     "@_id": "deprecated_1_deprecated000005"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2090",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2090",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga0550d4295b5619ece90041bdb3758735",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Wrap an existing array as stream side data.\n *\n * @param st   stream\n * @param type side information type\n * @param data the side data array. It must be allocated with the av_malloc()\n *             family of functions. The ownership of the data is transferred to\n *             st.\n * @param size side information size\n *\n * @return zero on success, a negative AVERROR code on failure. On failure,\n *         the stream is unchanged and the data remains owned by the caller.\n * @deprecated use av_packet_side_data_add() with the stream's\n *             @ref AVCodecParameters.coded_side_data \"codecpar side data\"\n */"
 },
 "av_stream_new_side_data": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "uint8_t *"
  },
  "definition": "attribute_deprecated uint8_t * av_stream_new_side_data",
  "argsstring": "(AVStream *stream, enum AVPacketSideDataType type, size_t size)",
  "name": "av_stream_new_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "stream"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideDataType",
      "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Allocate new information from stream."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "stream"
       },
       "parameterdescription": {
        "para": "stream"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "desired side information type"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "side information size"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "pointer to fresh allocated data or NULL otherwise",
     "@_kind": "return"
    },
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": {
       "ref": [
        {
         "#text": "av_packet_side_data_new()",
         "@_refid": "group__lavc__packet__side__data_1ga2219eb0b5a6ca929d564efb7d7c22a36",
         "@_kindref": "member"
        },
        {
         "#text": "codecpar side data",
         "@_refid": "structAVCodecParameters_1ad54da9241deabb3601e6e0e8fa832c19",
         "@_kindref": "member"
        }
       ],
       "#text": "usewith the stream's"
      }
     },
     "@_id": "deprecated_1_deprecated000006"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2105",
   "@_column": "9",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2105",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga7a81598767458baf60823b967b1d1909",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate new information from stream.\n *\n * @param stream stream\n * @param type   desired side information type\n * @param size   side information size\n *\n * @return pointer to fresh allocated data or NULL otherwise\n * @deprecated use av_packet_side_data_new() with the stream's\n *             @ref AVCodecParameters.coded_side_data \"codecpar side data\"\n */"
 },
 "av_stream_get_side_data": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "uint8_t *"
  },
  "definition": "attribute_deprecated uint8_t * av_stream_get_side_data",
  "argsstring": "(const AVStream *stream, enum AVPacketSideDataType type, size_t *size)",
  "name": "av_stream_get_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "stream"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideDataType",
      "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "size_t *",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Get side information from stream."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "stream"
       },
       "parameterdescription": {
        "para": "stream"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "desired side information type"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "If supplied, *size will be set to the size of the side data or to zero if the desired side data is not present."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "pointer to data if present or NULL otherwise",
     "@_kind": "return"
    },
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": {
       "ref": [
        {
         "#text": "av_packet_side_data_get()",
         "@_refid": "group__lavc__packet__side__data_1gabe0dea475f687842cf31a9e967be1692",
         "@_kindref": "member"
        },
        {
         "#text": "codecpar side data",
         "@_refid": "structAVCodecParameters_1ad54da9241deabb3601e6e0e8fa832c19",
         "@_kindref": "member"
        }
       ],
       "#text": "usewith the stream's"
      }
     },
     "@_id": "deprecated_1_deprecated000007"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2120",
   "@_column": "9",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2120",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga65bf2e916c5ebf7de9a65b43cffc608c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get side information from stream.\n *\n * @param stream stream\n * @param type   desired side information type\n * @param size   If supplied, *size will be set to the size of the side data\n *               or to zero if the desired side data is not present.\n *\n * @return pointer to data if present or NULL otherwise\n * @deprecated use av_packet_side_data_get() with the stream's\n *             @ref AVCodecParameters.coded_side_data \"codecpar side data\"\n */"
 },
 "av_new_program": {
  "type": {
   "ref": {
    "#text": "AVProgram",
    "@_refid": "structAVProgram",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVProgram * av_new_program",
  "argsstring": "(AVFormatContext *s, int id)",
  "name": "av_new_program",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "id"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2124",
   "@_column": "11",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2124",
   "@_declcolumn": "11"
  },
  "@_kind": "function",
  "@_id": "group__lavf__core_1ga32816bc1c7d8d8b09dea1a7da1867af2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get side information from stream.\n *\n * @param stream stream\n * @param type   desired side information type\n * @param size   If supplied, *size will be set to the size of the side data\n *               or to zero if the desired side data is not present.\n *\n * @return pointer to data if present or NULL otherwise\n * @deprecated use av_packet_side_data_get() with the stream's\n *             @ref AVCodecParameters.coded_side_data \"codecpar side data\"\n */"
 },
 "avformat_alloc_output_context2": {
  "type": "int",
  "definition": "int avformat_alloc_output_context2",
  "argsstring": "(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)",
  "name": "avformat_alloc_output_context2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVOutputFormat",
      "@_refid": "structAVOutputFormat",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "oformat"
   },
   {
    "type": "const char *",
    "declname": "format_name"
   },
   {
    "type": "const char *",
    "declname": "filename"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "Allocate anfor an output format."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avformat_free_context()",
      "@_refid": "group__lavf__core_1gac2990b13b68e831a408fce8e1d0d6445",
      "@_kindref": "member"
     },
     "#text": "can be used to free the context and everything allocated by the framework within it."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ctx"
        },
        "parameterdescription": {
         "para": "pointee is set to the created format context, or to NULL in case of failure"
        }
       },
       {
        "parameternamelist": {
         "parametername": "oformat"
        },
        "parameterdescription": {
         "para": "format to use for allocating the context, if NULL format_name and filename are used instead"
        }
       },
       {
        "parameternamelist": {
         "parametername": "format_name"
        },
        "parameterdescription": {
         "para": "the name of output format to use for allocating the context, if NULL filename is used instead"
        }
       },
       {
        "parameternamelist": {
         "parametername": "filename"
        },
        "parameterdescription": {
         "para": "the name of the filename to use for allocating the context, may be NULL"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">= 0 in case of success, a negative AVERROR code in case of failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2148",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2148",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "mux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "mux_8c",
    "@_startline": "534",
    "@_endline": "643"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   }
  ],
  "@_kind": "function",
  "@_id": "avformat_8h_1af5930942120e38a4766dc0bb9e4cae74",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVFormatContext for an output format.\n * avformat_free_context() can be used to free the context and\n * everything allocated by the framework within it.\n *\n * @param ctx           pointee is set to the created format context,\n *                      or to NULL in case of failure\n * @param oformat       format to use for allocating the context, if NULL\n *                      format_name and filename are used instead\n * @param format_name   the name of output format to use for allocating the\n *                      context, if NULL filename is used instead\n * @param filename      the name of the filename to use for allocating the\n *                      context, may be NULL\n *\n * @return  >= 0 in case of success, a negative AVERROR code in case of\n *          failure\n */"
 },
 "av_find_input_format": {
  "type": {
   "ref": {
    "#text": "AVInputFormat",
    "@_refid": "structAVInputFormat",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVInputFormat * av_find_input_format",
  "argsstring": "(const char *short_name)",
  "name": "av_find_input_format",
  "param": {
   "type": "const char *",
   "declname": "short_name"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVInputFormat",
     "@_refid": "structAVInputFormat",
     "@_kindref": "compound"
    },
    "#text": "Findbased on the short name of the input format."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2159",
   "@_column": "21",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2159",
   "@_declcolumn": "21"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1ga07f933625a78075ac5ba151b7755cb10",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find AVInputFormat based on the short name of the input format.\n */"
 },
 "av_probe_input_format": {
  "type": {
   "ref": {
    "#text": "AVInputFormat",
    "@_refid": "structAVInputFormat",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVInputFormat * av_probe_input_format",
  "argsstring": "(const AVProbeData *pd, int is_opened)",
  "name": "av_probe_input_format",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVProbeData",
      "@_refid": "structAVProbeData",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "pd"
   },
   {
    "type": "int",
    "declname": "is_opened"
   }
  ],
  "briefdescription": {
   "para": "Guess the file format."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pd"
       },
       "parameterdescription": {
        "para": "data to be probed"
       }
      },
      {
       "parameternamelist": {
        "parametername": "is_opened"
       },
       "parameterdescription": {
        "para": "Whether the file is already opened; determines whether demuxers with or without AVFMT_NOFILE are probed."
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2168",
   "@_column": "21",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2168",
   "@_declcolumn": "21"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1gac95cde4da95ecc46e1f8979e64f11c47",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Guess the file format.\n *\n * @param pd        data to be probed\n * @param is_opened Whether the file is already opened; determines whether\n *                  demuxers with or without AVFMT_NOFILE are probed.\n */"
 },
 "av_probe_input_format2": {
  "type": {
   "ref": {
    "#text": "AVInputFormat",
    "@_refid": "structAVInputFormat",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVInputFormat * av_probe_input_format2",
  "argsstring": "(const AVProbeData *pd, int is_opened, int *score_max)",
  "name": "av_probe_input_format2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVProbeData",
      "@_refid": "structAVProbeData",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "pd"
   },
   {
    "type": "int",
    "declname": "is_opened"
   },
   {
    "type": "int *",
    "declname": "score_max"
   }
  ],
  "briefdescription": {
   "para": "Guess the file format."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pd"
       },
       "parameterdescription": {
        "para": "data to be probed"
       }
      },
      {
       "parameternamelist": {
        "parametername": "is_opened"
       },
       "parameterdescription": {
        "para": "Whether the file is already opened; determines whether demuxers with or without AVFMT_NOFILE are probed."
       }
      },
      {
       "parameternamelist": {
        "parametername": "score_max"
       },
       "parameterdescription": {
        "para": "A probe score larger that this is required to accept a detection, the variable is set to the actual detection score afterwards. If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended to retry with a larger probe buffer."
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2182",
   "@_column": "21",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2182",
   "@_declcolumn": "21"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1gacdbc37c36c5949d0a38cd82dbca1b0c1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Guess the file format.\n *\n * @param pd        data to be probed\n * @param is_opened Whether the file is already opened; determines whether\n *                  demuxers with or without AVFMT_NOFILE are probed.\n * @param score_max A probe score larger that this is required to accept a\n *                  detection, the variable is set to the actual detection\n *                  score afterwards.\n *                  If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended\n *                  to retry with a larger probe buffer.\n */"
 },
 "av_probe_input_format3": {
  "type": {
   "ref": {
    "#text": "AVInputFormat",
    "@_refid": "structAVInputFormat",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVInputFormat * av_probe_input_format3",
  "argsstring": "(const AVProbeData *pd, int is_opened, int *score_ret)",
  "name": "av_probe_input_format3",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVProbeData",
      "@_refid": "structAVProbeData",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "pd"
   },
   {
    "type": "int",
    "declname": "is_opened"
   },
   {
    "type": "int *",
    "declname": "score_ret"
   }
  ],
  "briefdescription": {
   "para": "Guess the file format."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "is_opened"
       },
       "parameterdescription": {
        "para": "Whether the file is already opened; determines whether demuxers with or without AVFMT_NOFILE are probed."
       }
      },
      {
       "parameternamelist": {
        "parametername": "score_ret"
       },
       "parameterdescription": {
        "para": "The score of the best detection."
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2192",
   "@_column": "21",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2192",
   "@_declcolumn": "21"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1ga23e1a7f330c33db4f7ba4903551641eb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Guess the file format.\n *\n * @param is_opened Whether the file is already opened; determines whether\n *                  demuxers with or without AVFMT_NOFILE are probed.\n * @param score_ret The score of the best detection.\n */"
 },
 "av_probe_input_buffer2": {
  "type": "int",
  "definition": "int av_probe_input_buffer2",
  "argsstring": "(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)",
  "name": "av_probe_input_buffer2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pb"
   },
   {
    "type": {
     "ref": {
      "#text": "AVInputFormat",
      "@_refid": "structAVInputFormat",
      "@_kindref": "compound"
     },
     "#text": "const**"
    },
    "declname": "fmt"
   },
   {
    "type": "const char *",
    "declname": "url"
   },
   {
    "type": "void *",
    "declname": "logctx"
   },
   {
    "type": "unsigned int",
    "declname": "offset"
   },
   {
    "type": "unsigned int",
    "declname": "max_probe_size"
   }
  ],
  "briefdescription": {
   "para": "Probe a bytestream to determine the input format."
  },
  "detaileddescription": {
   "para": [
    "Each time a probe returns with a score that is too low, the probe buffer size is increased and another attempt is made. When the maximum probe size is reached, the input format with the highest score is returned.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "pb"
        },
        "parameterdescription": {
         "para": "the bytestream to probe"
        }
       },
       {
        "parameternamelist": {
         "parametername": "fmt"
        },
        "parameterdescription": {
         "para": "the input format is put here"
        }
       },
       {
        "parameternamelist": {
         "parametername": "url"
        },
        "parameterdescription": {
         "para": "the url of the stream"
        }
       },
       {
        "parameternamelist": {
         "parametername": "logctx"
        },
        "parameterdescription": {
         "para": "the log context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "offset"
        },
        "parameterdescription": {
         "para": "the offset within the bytestream to probe from"
        }
       },
       {
        "parameternamelist": {
         "parametername": "max_probe_size"
        },
        "parameterdescription": {
         "para": "the maximum probe buffer size (zero for default)"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the score in case of success, a negative value corresponding to an the maximal score is AVPROBE_SCORE_MAX AVERROR code otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2212",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2212",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1gaa71770b3d006daba1c300d505ff7ab9e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Probe a bytestream to determine the input format. Each time a probe returns\n * with a score that is too low, the probe buffer size is increased and another\n * attempt is made. When the maximum probe size is reached, the input format\n * with the highest score is returned.\n *\n * @param pb             the bytestream to probe\n * @param fmt            the input format is put here\n * @param url            the url of the stream\n * @param logctx         the log context\n * @param offset         the offset within the bytestream to probe from\n * @param max_probe_size the maximum probe buffer size (zero for default)\n *\n * @return the score in case of success, a negative value corresponding to an\n *         the maximal score is AVPROBE_SCORE_MAX\n *         AVERROR code otherwise\n */"
 },
 "av_probe_input_buffer": {
  "type": "int",
  "definition": "int av_probe_input_buffer",
  "argsstring": "(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)",
  "name": "av_probe_input_buffer",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pb"
   },
   {
    "type": {
     "ref": {
      "#text": "AVInputFormat",
      "@_refid": "structAVInputFormat",
      "@_kindref": "compound"
     },
     "#text": "const**"
    },
    "declname": "fmt"
   },
   {
    "type": "const char *",
    "declname": "url"
   },
   {
    "type": "void *",
    "declname": "logctx"
   },
   {
    "type": "unsigned int",
    "declname": "offset"
   },
   {
    "type": "unsigned int",
    "declname": "max_probe_size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_probe_input_buffer2()",
     "@_refid": "group__lavf__decoding_1gaa71770b3d006daba1c300d505ff7ab9e",
     "@_kindref": "member"
    },
    "#text": "Likebut returns 0 on success."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2219",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2219",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1ga9096bdb3ca10269a256170e706cd9f03",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Like av_probe_input_buffer2() but returns 0 on success\n */"
 },
 "avformat_open_input": {
  "type": "int",
  "definition": "int avformat_open_input",
  "argsstring": "(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)",
  "name": "avformat_open_input",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "ps"
   },
   {
    "type": "const char *",
    "declname": "url"
   },
   {
    "type": {
     "ref": {
      "#text": "AVInputFormat",
      "@_refid": "structAVInputFormat",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "fmt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": "Open an input stream and read the header."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avformat_close_input()",
      "@_refid": "group__lavf__decoding_1gae804b99aec044690162b8b9b110236a4",
      "@_kindref": "member"
     },
     "#text": "The codecs are not opened. The stream must be closed with."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ps"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "AVFormatContext",
            "@_refid": "structAVFormatContext",
            "@_kindref": "compound"
           },
           {
            "#text": "AVFormatContext",
            "@_refid": "structAVFormatContext",
            "@_kindref": "compound"
           },
           {
            "#text": "AVFormatContext",
            "@_refid": "structAVFormatContext",
            "@_kindref": "compound"
           }
          ],
          "#text": "Pointer to user-supplied(allocated by avformat_alloc_context). May be a pointer to NULL, in which case anis allocated by this function and written into ps. Note that a user-suppliedwill be freed on failure."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "url"
        },
        "parameterdescription": {
         "para": "URL of the stream to open."
        }
       },
       {
        "parameternamelist": {
         "parametername": "fmt"
        },
        "parameterdescription": {
         "para": "If non-NULL, this parameter forces a specific input format. Otherwise the format is autodetected."
        }
       },
       {
        "parameternamelist": {
         "parametername": "options"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVFormatContext",
           "@_refid": "structAVFormatContext",
           "@_kindref": "compound"
          },
          "#text": "A dictionary filled withand demuxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "0 on success, a negative AVERROR on failure.",
       "@_kind": "return"
      },
      {
       "para": "If you want to use custom IO, preallocate the format context and set its pb field.",
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2245",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2245",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "avio__read__callback_8c_1a0ddf1224851353fc92bfbff6f499fa97",
    "@_compoundref": "avio__read__callback_8c",
    "@_startline": "58",
    "@_endline": "133"
   },
   {
    "#text": "open_input_file",
    "@_refid": "decode__filter__audio_8c_1abd04bf1a933d4d2698482f4949c61fed",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "52",
    "@_endline": "88"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1gac05d61a2b492ae3985c658f34622c19d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Open an input stream and read the header. The codecs are not opened.\n * The stream must be closed with avformat_close_input().\n *\n * @param ps       Pointer to user-supplied AVFormatContext (allocated by\n *                 avformat_alloc_context). May be a pointer to NULL, in\n *                 which case an AVFormatContext is allocated by this\n *                 function and written into ps.\n *                 Note that a user-supplied AVFormatContext will be freed\n *                 on failure.\n * @param url      URL of the stream to open.\n * @param fmt      If non-NULL, this parameter forces a specific input format.\n *                 Otherwise the format is autodetected.\n * @param options  A dictionary filled with AVFormatContext and demuxer-private\n *                 options.\n *                 On return this parameter will be destroyed and replaced with\n *                 a dict containing options that were not found. May be NULL.\n *\n * @return 0 on success, a negative AVERROR on failure.\n *\n * @note If you want to use custom IO, preallocate the format context and set its pb field.\n */"
 },
 "avformat_find_stream_info": {
  "type": "int",
  "definition": "int avformat_find_stream_info",
  "argsstring": "(AVFormatContext *ic, AVDictionary **options)",
  "name": "avformat_find_stream_info",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ic"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": "Read packets of a media file to get stream information."
  },
  "detaileddescription": {
   "para": [
    "This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ic"
        },
        "parameterdescription": {
         "para": "media file handle"
        }
       },
       {
        "parameternamelist": {
         "parametername": "options"
        },
        "parameterdescription": {
         "para": "If non-NULL, an ic.nb_streams long array of pointers to dictionaries, where i-th member contains options for codec corresponding to i-th stream. On return each dictionary will be filled with options that were not found."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": ">=0 if OK, AVERROR_xxx on error",
       "@_kind": "return"
      },
      {
       "para": "this function isn't guaranteed to open all the codecs, so options being non-empty at return is a perfectly normal behavior.",
       "@_kind": "note"
      }
     ],
     "xrefsect": {
      "xreftitle": "Todo",
      "xrefdescription": {
       "para": "Let the user decide somehow what information is needed so that we do not waste time getting stuff the user does not need."
      },
      "@_id": "todo_1_todo000001"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2269",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2269",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "avio__read__callback_8c_1a0ddf1224851353fc92bfbff6f499fa97",
    "@_compoundref": "avio__read__callback_8c",
    "@_startline": "58",
    "@_endline": "133"
   },
   {
    "#text": "open_input_file",
    "@_refid": "decode__filter__audio_8c_1abd04bf1a933d4d2698482f4949c61fed",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "52",
    "@_endline": "88"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1gad42172e27cddafb81096939783b157bb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read packets of a media file to get stream information. This\n * is useful for file formats with no headers such as MPEG. This\n * function also computes the real framerate in case of MPEG-2 repeat\n * frame mode.\n * The logical file position is not changed by this function;\n * examined packets may be buffered for later processing.\n *\n * @param ic media file handle\n * @param options  If non-NULL, an ic.nb_streams long array of pointers to\n *                 dictionaries, where i-th member contains options for\n *                 codec corresponding to i-th stream.\n *                 On return each dictionary will be filled with options that were not found.\n * @return >=0 if OK, AVERROR_xxx on error\n *\n * @note this function isn't guaranteed to open all the codecs, so\n *       options being non-empty at return is a perfectly normal behavior.\n *\n * @todo Let the user decide somehow what information is needed so that\n *       we do not waste time getting stuff the user does not need.\n */"
 },
 "av_find_program_from_stream": {
  "type": {
   "ref": {
    "#text": "AVProgram",
    "@_refid": "structAVProgram",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVProgram * av_find_program_from_stream",
  "argsstring": "(AVFormatContext *ic, AVProgram *last, int s)",
  "name": "av_find_program_from_stream",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ic"
   },
   {
    "type": {
     "ref": {
      "#text": "AVProgram",
      "@_refid": "structAVProgram",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "last"
   },
   {
    "type": "int",
    "declname": "s"
   }
  ],
  "briefdescription": {
   "para": "Find the programs which belong to a given stream."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ic"
       },
       "parameterdescription": {
        "para": "media file handle"
       }
      },
      {
       "parameternamelist": {
        "parametername": "last"
       },
       "parameterdescription": {
        "para": "the last found program, the search will start after this program, or from the beginning if it is NULL"
       }
      },
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "stream index"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the next program which belongs to s, NULL if no program is found or the last program is not among the programs of ic.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2282",
   "@_column": "11",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2282",
   "@_declcolumn": "11"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1ga12a852a3717288d9eb41612315be9e6a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find the programs which belong to a given stream.\n *\n * @param ic    media file handle\n * @param last  the last found program, the search will start after this\n *              program, or from the beginning if it is NULL\n * @param s     stream index\n *\n * @return the next program which belongs to s, NULL if no program is found or\n *         the last program is not among the programs of ic.\n */"
 },
 "av_program_add_stream_index": {
  "type": "void",
  "definition": "void av_program_add_stream_index",
  "argsstring": "(AVFormatContext *ac, int progid, unsigned int idx)",
  "name": "av_program_add_stream_index",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ac"
   },
   {
    "type": "int",
    "declname": "progid"
   },
   {
    "type": "unsigned int",
    "declname": "idx"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2284",
   "@_column": "6",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2284",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1gaa59b7800da8ec11457c1e5b3fc295a20",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find the programs which belong to a given stream.\n *\n * @param ic    media file handle\n * @param last  the last found program, the search will start after this\n *              program, or from the beginning if it is NULL\n * @param s     stream index\n *\n * @return the next program which belongs to s, NULL if no program is found or\n *         the last program is not among the programs of ic.\n */"
 },
 "av_find_best_stream": {
  "type": "int",
  "definition": "int av_find_best_stream",
  "argsstring": "(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const struct AVCodec **decoder_ret, int flags)",
  "name": "av_find_best_stream",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ic"
   },
   {
    "type": {
     "ref": {
      "#text": "AVMediaType",
      "@_refid": "group__lavu__misc_1ga9a84bba4713dfced21a1a56163be1f48",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "int",
    "declname": "wanted_stream_nb"
   },
   {
    "type": "int",
    "declname": "related_stream"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodec",
      "@_refid": "structAVCodec",
      "@_kindref": "compound"
     },
     "#text": "const struct**"
    },
    "declname": "decoder_ret"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Find the \"best\" stream in the file."
  },
  "detaileddescription": {
   "para": [
    "The best stream is determined according to various heuristics as the most likely to be what the user expects. If the decoder parameter is non-NULL, av_find_best_stream will find the default decoder for the stream's codec; streams for which no decoder can be found are ignored.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ic"
        },
        "parameterdescription": {
         "para": "media file handle"
        }
       },
       {
        "parameternamelist": {
         "parametername": "type"
        },
        "parameterdescription": {
         "para": "stream type: video, audio, subtitles, etc."
        }
       },
       {
        "parameternamelist": {
         "parametername": "wanted_stream_nb"
        },
        "parameterdescription": {
         "para": "user-requested stream number, or -1 for automatic selection"
        }
       },
       {
        "parameternamelist": {
         "parametername": "related_stream"
        },
        "parameterdescription": {
         "para": "try to find a stream related (eg. in the same program) to this one, or -1 if none"
        }
       },
       {
        "parameternamelist": {
         "parametername": "decoder_ret"
        },
        "parameterdescription": {
         "para": "if non-NULL, returns the decoder for the selected stream"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "flags; none are currently defined"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "the non-negative stream number in case of success, AVERROR_STREAM_NOT_FOUND if no stream with the requested type could be found, AVERROR_DECODER_NOT_FOUND if streams were found but no decoder",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "AVCodec",
         "@_refid": "structAVCodec",
         "@_kindref": "compound"
        },
        "#text": "If av_find_best_stream returns successfully and decoder_ret is not NULL, then *decoder_ret is guaranteed to be set to a valid."
       },
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2312",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2312",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "hw__decode_8c_1a0ddf1224851353fc92bfbff6f499fa97",
    "@_compoundref": "hw__decode_8c",
    "@_startline": "148",
    "@_endline": "255"
   },
   {
    "#text": "open_codec_context",
    "@_refid": "demux__decode_8c_1ab36dcc13a13c2ae1c1fff2ea5db97616",
    "@_compoundref": "demux__decode_8c",
    "@_startline": "146",
    "@_endline": "195"
   },
   {
    "#text": "open_input_file",
    "@_refid": "decode__filter__audio_8c_1abd04bf1a933d4d2698482f4949c61fed",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "52",
    "@_endline": "88"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1ga757780d38f482deb4d809c6c521fbcc2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find the \"best\" stream in the file.\n * The best stream is determined according to various heuristics as the most\n * likely to be what the user expects.\n * If the decoder parameter is non-NULL, av_find_best_stream will find the\n * default decoder for the stream's codec; streams for which no decoder can\n * be found are ignored.\n *\n * @param ic                media file handle\n * @param type              stream type: video, audio, subtitles, etc.\n * @param wanted_stream_nb  user-requested stream number,\n *                          or -1 for automatic selection\n * @param related_stream    try to find a stream related (eg. in the same\n *                          program) to this one, or -1 if none\n * @param decoder_ret       if non-NULL, returns the decoder for the\n *                          selected stream\n * @param flags             flags; none are currently defined\n *\n * @return  the non-negative stream number in case of success,\n *          AVERROR_STREAM_NOT_FOUND if no stream with the requested type\n *          could be found,\n *          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder\n *\n * @note  If av_find_best_stream returns successfully and decoder_ret is not\n *        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.\n */"
 },
 "av_read_frame": {
  "type": "int",
  "definition": "int av_read_frame",
  "argsstring": "(AVFormatContext *s, AVPacket *pkt)",
  "name": "av_read_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   }
  ],
  "briefdescription": {
   "para": "Return the next frame of a stream."
  },
  "detaileddescription": {
   "para": [
    "This function returns what is stored in the file, and does not validate that what is there are valid frames for the decoder. It will split what is stored in the file into frames and return one for each call. It will not omit invalid data between valid frames so as to give the decoder the maximum information possible for decoding.",
    {
     "ref": {
      "#text": "av_packet_unref()",
      "@_refid": "group__lavc__packet_1ga63d5a489b419bd5d45cfd09091cbcbc2",
      "@_kindref": "member"
     },
     "#text": "On success, the returned packet is reference-counted (pkt->buf is set) and valid indefinitely. The packet must be freed withwhen it is no longer needed. For video, the packet contains exactly one frame. For audio, it contains an integer number of frames if each frame has a known fixed size (e.g. PCM or ADPCM data). If the audio frames have a variable size (e.g. MPEG audio), then it contains one frame."
    },
    {
     "ref": {
      "#text": "AVStream.time_base",
      "@_refid": "structAVStream_1a9db755451f14e2bf590d4b85d82b32e6",
      "@_kindref": "member"
     },
     "#text": "pkt->pts, pkt->dts and pkt->duration are always set to correct values inunits (and guessed if the format cannot provide them). pkt->pts can be AV_NOPTS_VALUE if the video format has B-frames, so it is better to rely on pkt->dts if you do not decompress the payload."
    },
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "av_packet_alloc()",
         "@_refid": "group__lavc__packet_1gad56057568fb51504e5b4aafcb44f9a03",
         "@_kindref": "member"
        },
        "#text": "0 if OK, < 0 on error or end of file. On error, pkt will be blank (as if it came from)."
       },
       "@_kind": "return"
      },
      {
       "para": "pkt will be initialized, so it may be uninitialized, but it must not contain data that needs to be freed.",
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2346",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2346",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "decode_audio_frame",
    "@_refid": "transcode__aac_8c_1a5c320cc89448244f68daee53092da98c",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "369",
    "@_endline": "429"
   },
   {
    "#text": "main",
    "@_refid": "decode__filter__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "217",
    "@_endline": "296"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1ga4fdb3084415a82e3810de6ee60e46a61",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the next frame of a stream.\n * This function returns what is stored in the file, and does not validate\n * that what is there are valid frames for the decoder. It will split what is\n * stored in the file into frames and return one for each call. It will not\n * omit invalid data between valid frames so as to give the decoder the maximum\n * information possible for decoding.\n *\n * On success, the returned packet is reference-counted (pkt->buf is set) and\n * valid indefinitely. The packet must be freed with av_packet_unref() when\n * it is no longer needed. For video, the packet contains exactly one frame.\n * For audio, it contains an integer number of frames if each frame has\n * a known fixed size (e.g. PCM or ADPCM data). If the audio frames have\n * a variable size (e.g. MPEG audio), then it contains one frame.\n *\n * pkt->pts, pkt->dts and pkt->duration are always set to correct\n * values in AVStream.time_base units (and guessed if the format cannot\n * provide them). pkt->pts can be AV_NOPTS_VALUE if the video format\n * has B-frames, so it is better to rely on pkt->dts if you do not\n * decompress the payload.\n *\n * @return 0 if OK, < 0 on error or end of file. On error, pkt will be blank\n *         (as if it came from av_packet_alloc()).\n *\n * @note pkt will be initialized, so it may be uninitialized, but it must not\n *       contain data that needs to be freed.\n */"
 },
 "av_seek_frame": {
  "type": "int",
  "definition": "int av_seek_frame",
  "argsstring": "(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)",
  "name": "av_seek_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "stream_index"
   },
   {
    "type": "int64_t",
    "declname": "timestamp"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Seek to the keyframe at timestamp."
  },
  "detaileddescription": {
   "para": [
    "'timestamp' in 'stream_index'.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "media file handle"
        }
       },
       {
        "parameternamelist": {
         "parametername": "stream_index"
        },
        "parameterdescription": {
         "para": "If stream_index is (-1), a default stream is selected, and timestamp is automatically converted from AV_TIME_BASE units to the stream specific time_base."
        }
       },
       {
        "parameternamelist": {
         "parametername": "timestamp"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVStream.time_base",
           "@_refid": "structAVStream_1a9db755451f14e2bf590d4b85d82b32e6",
           "@_kindref": "member"
          },
          "#text": "Timestamp inunits or, if no stream is specified, in AV_TIME_BASE units."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "flags which select direction and seeking mode"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">= 0 on success",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2362",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2362",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1gaa23f7619d8d4ea0857065d9979c75ac8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Seek to the keyframe at timestamp.\n * 'timestamp' in 'stream_index'.\n *\n * @param s            media file handle\n * @param stream_index If stream_index is (-1), a default stream is selected,\n *                     and timestamp is automatically converted from\n *                     AV_TIME_BASE units to the stream specific time_base.\n * @param timestamp    Timestamp in AVStream.time_base units or, if no stream\n *                     is specified, in AV_TIME_BASE units.\n * @param flags        flags which select direction and seeking mode\n *\n * @return >= 0 on success\n */"
 },
 "avformat_seek_file": {
  "type": "int",
  "definition": "int avformat_seek_file",
  "argsstring": "(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)",
  "name": "avformat_seek_file",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "stream_index"
   },
   {
    "type": "int64_t",
    "declname": "min_ts"
   },
   {
    "type": "int64_t",
    "declname": "ts"
   },
   {
    "type": "int64_t",
    "declname": "max_ts"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Seek to timestamp ts."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AVStream.discard",
      "@_refid": "structAVStream_1a492fcecc45dbbd8da51edd0124e9dd30",
      "@_kindref": "member"
     },
     "#text": "Seeking will be done so that the point from which all active streams can be presented successfully will be closest to ts and within min/max_ts. Active streams are all streams that have< AVDISCARD_ALL."
    },
    "If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and are the file position (this may not be supported by all demuxers). If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames in the stream with stream_index (this may not be supported by all demuxers). Otherwise all timestamps are in units of the stream selected by stream_index or if stream_index is -1, in AV_TIME_BASE units. If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as keyframes (this may not be supported by all demuxers). If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "media file handle"
        }
       },
       {
        "parameternamelist": {
         "parametername": "stream_index"
        },
        "parameterdescription": {
         "para": "index of the stream which is used as time base reference"
        }
       },
       {
        "parameternamelist": {
         "parametername": "min_ts"
        },
        "parameterdescription": {
         "para": "smallest acceptable timestamp"
        }
       },
       {
        "parameternamelist": {
         "parametername": "ts"
        },
        "parameterdescription": {
         "para": "target timestamp"
        }
       },
       {
        "parameternamelist": {
         "parametername": "max_ts"
        },
        "parameterdescription": {
         "para": "largest acceptable timestamp"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "flags"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": ">=0 on success, error code otherwise",
       "@_kind": "return"
      },
      {
       "para": "This is part of the new seek API which is still under construction.",
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2391",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2391",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1ga3b40fc8d2fda6992ae6ea2567d71ba30",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Seek to timestamp ts.\n * Seeking will be done so that the point from which all active streams\n * can be presented successfully will be closest to ts and within min/max_ts.\n * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.\n *\n * If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and\n * are the file position (this may not be supported by all demuxers).\n * If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames\n * in the stream with stream_index (this may not be supported by all demuxers).\n * Otherwise all timestamps are in units of the stream selected by stream_index\n * or if stream_index is -1, in AV_TIME_BASE units.\n * If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as\n * keyframes (this may not be supported by all demuxers).\n * If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.\n *\n * @param s            media file handle\n * @param stream_index index of the stream which is used as time base reference\n * @param min_ts       smallest acceptable timestamp\n * @param ts           target timestamp\n * @param max_ts       largest acceptable timestamp\n * @param flags        flags\n * @return >=0 on success, error code otherwise\n *\n * @note This is part of the new seek API which is still under construction.\n */"
 },
 "avformat_flush": {
  "type": "int",
  "definition": "int avformat_flush",
  "argsstring": "(AVFormatContext *s)",
  "name": "avformat_flush",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Discard all internally buffered data."
  },
  "detaileddescription": {
   "para": [
    "This can be useful when dealing with discontinuities in the byte stream. Generally works only with formats that can resync. This includes headerless formats like MPEG-TS/TS but should also work with NUT, Ogg and in a limited way AVI for example.",
    {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "The set of streams, the detected duration, stream parameters and codecs do not change when calling this function. If you want a complete reset, it's better to open a new."
    },
    {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "This does not flush the(s->pb). If necessary, call avio_flush(s->pb) before calling this function."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "media file handle"
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">=0 on success, error code otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2409",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2409",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1gaa03a82c5fd4fe3af312d229ca94cd6f3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Discard all internally buffered data. This can be useful when dealing with\n * discontinuities in the byte stream. Generally works only with formats that\n * can resync. This includes headerless formats like MPEG-TS/TS but should also\n * work with NUT, Ogg and in a limited way AVI for example.\n *\n * The set of streams, the detected duration, stream parameters and codecs do\n * not change when calling this function. If you want a complete reset, it's\n * better to open a new AVFormatContext.\n *\n * This does not flush the AVIOContext (s->pb). If necessary, call\n * avio_flush(s->pb) before calling this function.\n *\n * @param s media file handle\n * @return >=0 on success, error code otherwise\n */"
 },
 "av_read_play": {
  "type": "int",
  "definition": "int av_read_play",
  "argsstring": "(AVFormatContext *s)",
  "name": "av_read_play",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Start playing a network-based stream (e.g."
  },
  "detaileddescription": {
   "para": "RTSP stream) at the current position."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2415",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2415",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1ga7494bb63a59e79e9fe88eb1682d4d7b3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Start playing a network-based stream (e.g. RTSP stream) at the\n * current position.\n */"
 },
 "av_read_pause": {
  "type": "int",
  "definition": "int av_read_pause",
  "argsstring": "(AVFormatContext *s)",
  "name": "av_read_pause",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Pause a network-based stream (e.g."
  },
  "detaileddescription": {
   "para": [
    "RTSP stream).",
    {
     "ref": {
      "#text": "av_read_play()",
      "@_refid": "group__lavf__decoding_1ga7494bb63a59e79e9fe88eb1682d4d7b3",
      "@_kindref": "member"
     },
     "#text": "Useto resume it."
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2422",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2422",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1ga27db687592d99f25ccf81a3b3ee8da9c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Pause a network-based stream (e.g. RTSP stream).\n *\n * Use av_read_play() to resume it.\n */"
 },
 "avformat_close_input": {
  "type": "void",
  "definition": "void avformat_close_input",
  "argsstring": "(AVFormatContext **s)",
  "name": "avformat_close_input",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "Close an opened input."
   }
  },
  "detaileddescription": {
   "para": "Free it and all its contents and set *s to NULL."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2428",
   "@_column": "6",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2428",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "avio__read__callback_8c_1a0ddf1224851353fc92bfbff6f499fa97",
    "@_compoundref": "avio__read__callback_8c",
    "@_startline": "58",
    "@_endline": "133"
   },
   {
    "#text": "open_input_file",
    "@_refid": "transcode__aac_8c_1a8103e36bb4cb4141ee5e25acc350bc0b",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "58",
    "@_endline": "133"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__decoding_1gae804b99aec044690162b8b9b110236a4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Close an opened input AVFormatContext. Free it and all its contents\n * and set *s to NULL.\n */"
 },
 "avformat_write_header": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int avformat_write_header",
  "argsstring": "(AVFormatContext *s, AVDictionary **options)",
  "name": "avformat_write_header",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": "Allocate the stream private data and write the stream header to an output media file."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": [
     {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "avformat_alloc_context()",
            "@_refid": "group__lavf__core_1gab000638c284e97ad0be2bdb11ce33c36",
            "@_kindref": "member"
           },
           {
            "#text": "oformat",
            "@_refid": "structAVFormatContext_1a37ba86cd5630097cdae01afbc2b40743",
            "@_kindref": "member"
           },
           {
            "#text": "pb",
            "@_refid": "structAVFormatContext_1a1e7324262b6b78522e52064daaa7bc87",
            "@_kindref": "member"
           },
           {
            "#text": "AVIOContext",
            "@_refid": "structAVIOContext",
            "@_kindref": "compound"
           }
          ],
          "#text": "Media file handle, must be allocated with. Itsfield must be set to the desired output format; Itsfield must be set to an already opened."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "options"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "AVDictionary",
            "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
            "@_kindref": "member"
           },
           {
            "#text": "AVFormatContext",
            "@_refid": "structAVFormatContext",
            "@_kindref": "compound"
           }
          ],
          "#text": "Anfilled withand muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "AVSTREAM_INIT_IN_WRITE_HEADER"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "avformat_init_output()",
           "@_refid": "group__lavf__encoding_1ga169cfa28508e22e138c5b99be8517ea4",
           "@_kindref": "member"
          },
          "#text": "On success, if the codec had not already been fully initialized in."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "AVSTREAM_INIT_IN_INIT_OUTPUT"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "avformat_init_output()",
           "@_refid": "group__lavf__encoding_1ga169cfa28508e22e138c5b99be8517ea4",
           "@_kindref": "member"
          },
          "#text": "On success, if the codec had already been fully initialized in."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "AVERROR"
        },
        "parameterdescription": {
         "para": "A negative AVERROR on failure."
        }
       }
      ],
      "@_kind": "retval"
     }
    ],
    "simplesect": {
     "para": {
      "ref": [
       {
        "#text": "av_opt_find",
        "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
        "@_kindref": "member"
       },
       {
        "#text": "av_dict_set",
        "@_refid": "group__lavu__dict_1ga8d9c2de72b310cef8e6a28c9cd3acbbe",
        "@_kindref": "member"
       },
       {
        "#text": "avio_open",
        "@_refid": "avio_8h_1a371a670112abc5f3e15bc570da076301",
        "@_kindref": "member"
       },
       {
        "#text": "avformat_init_output",
        "@_refid": "group__lavf__encoding_1ga169cfa28508e22e138c5b99be8517ea4",
        "@_kindref": "member"
       }
      ],
      "#text": ",,, av_oformat_next,."
     },
     "@_kind": "see"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2470",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2470",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "mux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "mux_8c",
    "@_startline": "534",
    "@_endline": "643"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   },
   {
    "#text": "write_output_file_header",
    "@_refid": "transcode__aac_8c_1a717f7868fc24543151cb94b307e87420",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "345",
    "@_endline": "354"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__encoding_1ga18b7b10bb5b94c4842de18166bc677cb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate the stream private data and write the stream header to\n * an output media file.\n *\n * @param s        Media file handle, must be allocated with\n *                 avformat_alloc_context().\n *                 Its \\ref AVFormatContext.oformat \"oformat\" field must be set\n *                 to the desired output format;\n *                 Its \\ref AVFormatContext.pb \"pb\" field must be set to an\n *                 already opened ::AVIOContext.\n * @param options  An ::AVDictionary filled with AVFormatContext and\n *                 muxer-private options.\n *                 On return this parameter will be destroyed and replaced with\n *                 a dict containing options that were not found. May be NULL.\n *\n * @retval AVSTREAM_INIT_IN_WRITE_HEADER On success, if the codec had not already been\n *                                       fully initialized in avformat_init_output().\n * @retval AVSTREAM_INIT_IN_INIT_OUTPUT  On success, if the codec had already been fully\n *                                       initialized in avformat_init_output().\n * @retval AVERROR                       A negative AVERROR on failure.\n *\n * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output.\n */"
 },
 "avformat_init_output": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int avformat_init_output",
  "argsstring": "(AVFormatContext *s, AVDictionary **options)",
  "name": "avformat_init_output",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": "Allocate the stream private data and initialize the codec, but do not write the header."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "avformat_write_header()",
       "@_refid": "group__lavf__encoding_1ga18b7b10bb5b94c4842de18166bc677cb",
       "@_kindref": "member"
      },
      {
       "#text": "avformat_write_header()",
       "@_refid": "group__lavf__encoding_1ga18b7b10bb5b94c4842de18166bc677cb",
       "@_kindref": "member"
      }
     ],
     "#text": "May optionally be used beforeto initialize stream parameters before actually writing the header. If using this function, do not pass the same options to."
    },
    {
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "s"
         },
         "parameterdescription": {
          "para": {
           "ref": [
            {
             "#text": "avformat_alloc_context()",
             "@_refid": "group__lavf__core_1gab000638c284e97ad0be2bdb11ce33c36",
             "@_kindref": "member"
            },
            {
             "#text": "oformat",
             "@_refid": "structAVFormatContext_1a37ba86cd5630097cdae01afbc2b40743",
             "@_kindref": "member"
            },
            {
             "#text": "pb",
             "@_refid": "structAVFormatContext_1a1e7324262b6b78522e52064daaa7bc87",
             "@_kindref": "member"
            },
            {
             "#text": "AVIOContext",
             "@_refid": "structAVIOContext",
             "@_kindref": "compound"
            }
           ],
           "#text": "Media file handle, must be allocated with. Itsfield must be set to the desired output format; Itsfield must be set to an already opened."
          }
         }
        },
        {
         "parameternamelist": {
          "parametername": "options"
         },
         "parameterdescription": {
          "para": {
           "ref": [
            {
             "#text": "AVDictionary",
             "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
             "@_kindref": "member"
            },
            {
             "#text": "AVFormatContext",
             "@_refid": "structAVFormatContext",
             "@_kindref": "compound"
            }
           ],
           "#text": "Anfilled withand muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL."
          }
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "AVSTREAM_INIT_IN_WRITE_HEADER"
         },
         "parameterdescription": {
          "para": "On success, if the codec requires avformat_write_header to fully initialize."
         }
        },
        {
         "parameternamelist": {
          "parametername": "AVSTREAM_INIT_IN_INIT_OUTPUT"
         },
         "parameterdescription": {
          "para": "On success, if the codec has been fully initialized."
         }
        },
        {
         "parameternamelist": {
          "parametername": "AVERROR"
         },
         "parameterdescription": {
          "para": "Anegative AVERROR on failure."
         }
        }
       ],
       "@_kind": "retval"
      }
     ],
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "av_opt_find",
         "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
         "@_kindref": "member"
        },
        {
         "#text": "av_dict_set",
         "@_refid": "group__lavu__dict_1ga8d9c2de72b310cef8e6a28c9cd3acbbe",
         "@_kindref": "member"
        },
        {
         "#text": "avio_open",
         "@_refid": "avio_8h_1a371a670112abc5f3e15bc570da076301",
         "@_kindref": "member"
        },
        {
         "#text": "avformat_write_header",
         "@_refid": "group__lavf__encoding_1ga18b7b10bb5b94c4842de18166bc677cb",
         "@_kindref": "member"
        }
       ],
       "#text": ",,, av_oformat_next,."
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2498",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2498",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__encoding_1ga169cfa28508e22e138c5b99be8517ea4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate the stream private data and initialize the codec, but do not write the header.\n * May optionally be used before avformat_write_header() to initialize stream parameters\n * before actually writing the header.\n * If using this function, do not pass the same options to avformat_write_header().\n *\n * @param s        Media file handle, must be allocated with\n *                 avformat_alloc_context().\n *                 Its \\ref AVFormatContext.oformat \"oformat\" field must be set\n *                 to the desired output format;\n *                 Its \\ref AVFormatContext.pb \"pb\" field must be set to an\n *                 already opened ::AVIOContext.\n * @param options  An ::AVDictionary filled with AVFormatContext and\n *                 muxer-private options.\n *                 On return this parameter will be destroyed and replaced with\n *                 a dict containing options that were not found. May be NULL.\n *\n * @retval AVSTREAM_INIT_IN_WRITE_HEADER On success, if the codec requires\n *                                       avformat_write_header to fully initialize.\n * @retval AVSTREAM_INIT_IN_INIT_OUTPUT  On success, if the codec has been fully\n *                                       initialized.\n * @retval AVERROR                       Anegative AVERROR on failure.\n *\n * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header.\n */"
 },
 "av_write_frame": {
  "type": "int",
  "definition": "int av_write_frame",
  "argsstring": "(AVFormatContext *s, AVPacket *pkt)",
  "name": "av_write_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   }
  ],
  "briefdescription": {
   "para": "Write a packet to an output media file."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_interleaved_write_frame()",
      "@_refid": "group__lavf__encoding_1ga37352ed2c63493c38219d935e71db6c1",
      "@_kindref": "member"
     },
     "#text": "This function passes the packet directly to the muxer, without any buffering or reordering. The caller is responsible for correctly interleaving the packets if the format requires it. Callers that want libavformat to handle the interleaving should callinstead of this function."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "media file handle"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pkt"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "av_interleaved_write_frame()",
            "@_refid": "group__lavf__encoding_1ga37352ed2c63493c38219d935e71db6c1",
            "@_kindref": "member"
           },
           {
            "#text": "stream_index",
            "@_refid": "structAVPacket_1a0d1cb9b5a32b00fb6edc81ea3aae2a49",
            "@_kindref": "member"
           },
           {
            "#text": "s->streams",
            "@_refid": "structAVFormatContext_1acfefb6b6cf21e87a0dcbd1a547ba2348",
            "@_kindref": "member"
           },
           {
            "#text": "pts",
            "@_refid": "structAVPacket_1a73bde0a37f3b1efc839f11295bfbf42a",
            "@_kindref": "member"
           },
           {
            "#text": "dts",
            "@_refid": "structAVPacket_1a85dbbd306b44b02390cd91c45e6a0f76",
            "@_kindref": "member"
           },
           {
            "#text": "duration",
            "@_refid": "structAVPacket_1a622e758be29fd500aed0ffdc069550f7",
            "@_kindref": "member"
           }
          ],
          "linebreak": [
           "",
           "",
           ""
          ],
          "#text": "The packet containing the data to be written. Note that unlike, this function does not take ownership of the packet passed to it (though some muxers may make an internal reference to the input packet).This parameter can be NULL (at any time, not just at the end), in order to immediately flush data buffered within the muxer, for muxers that buffer up data internally before writing it to the output.Packet'sfield must be set to the index of the corresponding stream in.The timestamps (,) must be set to correct values in the stream's timebase (unless the output format is flagged with the AVFMT_NOTIMESTAMPS flag, then they can be set to AV_NOPTS_VALUE). The dts for subsequent packets passed to this function must be strictly increasing when compared in their respective timebases (unless the output format is flagged with the AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).) should also be set if known."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "< 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_interleaved_write_frame()",
         "@_refid": "group__lavf__encoding_1ga37352ed2c63493c38219d935e71db6c1",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2537",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2537",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "encode_audio_frame",
   "@_refid": "transcode__aac_8c_1a3d408f21612691f8c93a7aa24ea554ef",
   "@_compoundref": "transcode__aac_8c",
   "@_startline": "654",
   "@_endline": "716"
  },
  "@_kind": "function",
  "@_id": "group__lavf__encoding_1gaa85cc1774f18f306cd20a40fc50d0b36",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write a packet to an output media file.\n *\n * This function passes the packet directly to the muxer, without any buffering\n * or reordering. The caller is responsible for correctly interleaving the\n * packets if the format requires it. Callers that want libavformat to handle\n * the interleaving should call av_interleaved_write_frame() instead of this\n * function.\n *\n * @param s media file handle\n * @param pkt The packet containing the data to be written. Note that unlike\n *            av_interleaved_write_frame(), this function does not take\n *            ownership of the packet passed to it (though some muxers may make\n *            an internal reference to the input packet).\n *            <br>\n *            This parameter can be NULL (at any time, not just at the end), in\n *            order to immediately flush data buffered within the muxer, for\n *            muxers that buffer up data internally before writing it to the\n *            output.\n *            <br>\n *            Packet's @ref AVPacket.stream_index \"stream_index\" field must be\n *            set to the index of the corresponding stream in @ref\n *            AVFormatContext.streams \"s->streams\".\n *            <br>\n *            The timestamps (@ref AVPacket.pts \"pts\", @ref AVPacket.dts \"dts\")\n *            must be set to correct values in the stream's timebase (unless the\n *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then\n *            they can be set to AV_NOPTS_VALUE).\n *            The dts for subsequent packets passed to this function must be strictly\n *            increasing when compared in their respective timebases (unless the\n *            output format is flagged with the AVFMT_TS_NONSTRICT, then they\n *            merely have to be nondecreasing).  @ref AVPacket.duration\n *            \"duration\") should also be set if known.\n * @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush\n *\n * @see av_interleaved_write_frame()\n */"
 },
 "av_interleaved_write_frame": {
  "type": "int",
  "definition": "int av_interleaved_write_frame",
  "argsstring": "(AVFormatContext *s, AVPacket *pkt)",
  "name": "av_interleaved_write_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   }
  ],
  "briefdescription": {
   "para": "Write a packet to an output media file ensuring correct interleaving."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_write_frame()",
      "@_refid": "group__lavf__encoding_1gaa85cc1774f18f306cd20a40fc50d0b36",
      "@_kindref": "member"
     },
     "#text": "This function will buffer the packets internally as needed to make sure the packets in the output file are properly interleaved, usually ordered by increasing dts. Callers doing their own interleaving should callinstead of this function."
    },
    {
     "ref": {
      "#text": "av_write_frame()",
      "@_refid": "group__lavf__encoding_1gaa85cc1774f18f306cd20a40fc50d0b36",
      "@_kindref": "member"
     },
     "#text": "Using this function instead ofcan give muxers advance knowledge of future packets, improving e.g. the behaviour of the mp4 muxer for VFR content in fragmenting mode."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "media file handle"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pkt"
        },
        "parameterdescription": {
         "para": {
          "linebreak": [
           "",
           "",
           "",
           ""
          ],
          "ref": [
           {
            "#text": "av_packet_alloc()",
            "@_refid": "group__lavc__packet_1gad56057568fb51504e5b4aafcb44f9a03",
            "@_kindref": "member"
           },
           {
            "#text": "stream_index",
            "@_refid": "structAVPacket_1a0d1cb9b5a32b00fb6edc81ea3aae2a49",
            "@_kindref": "member"
           },
           {
            "#text": "s->streams",
            "@_refid": "structAVFormatContext_1acfefb6b6cf21e87a0dcbd1a547ba2348",
            "@_kindref": "member"
           },
           {
            "#text": "pts",
            "@_refid": "structAVPacket_1a73bde0a37f3b1efc839f11295bfbf42a",
            "@_kindref": "member"
           },
           {
            "#text": "dts",
            "@_refid": "structAVPacket_1a85dbbd306b44b02390cd91c45e6a0f76",
            "@_kindref": "member"
           },
           {
            "#text": "duration",
            "@_refid": "structAVPacket_1a622e758be29fd500aed0ffdc069550f7",
            "@_kindref": "member"
           }
          ],
          "#text": "The packet containing the data to be written.If the packet is reference-counted, this function will take ownership of this reference and unreference it later when it sees fit. If the packet is not reference-counted, libavformat will make a copy. The returned packet will be blank (as if returned from), even on error.This parameter can be NULL (at any time, not just at the end), to flush the interleaving queues.Packet'sfield must be set to the index of the corresponding stream in.The timestamps (,) must be set to correct values in the stream's timebase (unless the output format is flagged with the AVFMT_NOTIMESTAMPS flag, then they can be set to AV_NOPTS_VALUE). The dts for subsequent packets in one stream must be strictly increasing (unless the output format is flagged with the AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).should also be set if known."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "0 on success, a negative AVERROR on error.",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": [
         {
          "#text": "av_write_frame()",
          "@_refid": "group__lavf__encoding_1gaa85cc1774f18f306cd20a40fc50d0b36",
          "@_kindref": "member"
         },
         {
          "#text": "AVFormatContext.max_interleave_delta",
          "@_refid": "structAVFormatContext_1a00edb6b7a31f8dabfa668334ca1f92d7",
          "@_kindref": "member"
         }
        ],
        "#text": ","
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2581",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2581",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "encode_write_frame",
    "@_refid": "transcode_8c_1a0911d751b11fdf9780825b79badfae91",
    "@_compoundref": "transcode_8c",
    "@_startline": "432",
    "@_endline": "471"
   },
   {
    "#text": "main",
    "@_refid": "remux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "remux_8c",
    "@_startline": "46",
    "@_endline": "198"
   },
   {
    "#text": "write_frame",
    "@_refid": "mux_8c_1a7bdbb3cdac2b8aeadf731768bb193c38",
    "@_compoundref": "mux_8c",
    "@_startline": "83",
    "@_endline": "122"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__encoding_1ga37352ed2c63493c38219d935e71db6c1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write a packet to an output media file ensuring correct interleaving.\n *\n * This function will buffer the packets internally as needed to make sure the\n * packets in the output file are properly interleaved, usually ordered by\n * increasing dts. Callers doing their own interleaving should call\n * av_write_frame() instead of this function.\n *\n * Using this function instead of av_write_frame() can give muxers advance\n * knowledge of future packets, improving e.g. the behaviour of the mp4\n * muxer for VFR content in fragmenting mode.\n *\n * @param s media file handle\n * @param pkt The packet containing the data to be written.\n *            <br>\n *            If the packet is reference-counted, this function will take\n *            ownership of this reference and unreference it later when it sees\n *            fit. If the packet is not reference-counted, libavformat will\n *            make a copy.\n *            The returned packet will be blank (as if returned from\n *            av_packet_alloc()), even on error.\n *            <br>\n *            This parameter can be NULL (at any time, not just at the end), to\n *            flush the interleaving queues.\n *            <br>\n *            Packet's @ref AVPacket.stream_index \"stream_index\" field must be\n *            set to the index of the corresponding stream in @ref\n *            AVFormatContext.streams \"s->streams\".\n *            <br>\n *            The timestamps (@ref AVPacket.pts \"pts\", @ref AVPacket.dts \"dts\")\n *            must be set to correct values in the stream's timebase (unless the\n *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then\n *            they can be set to AV_NOPTS_VALUE).\n *            The dts for subsequent packets in one stream must be strictly\n *            increasing (unless the output format is flagged with the\n *            AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).\n *            @ref AVPacket.duration \"duration\" should also be set if known.\n *\n * @return 0 on success, a negative AVERROR on error.\n *\n * @see av_write_frame(), AVFormatContext.max_interleave_delta\n */"
 },
 "av_write_uncoded_frame": {
  "type": "int",
  "definition": "int av_write_uncoded_frame",
  "argsstring": "(AVFormatContext *s, int stream_index, struct AVFrame *frame)",
  "name": "av_write_uncoded_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "stream_index"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "frame"
   }
  ],
  "briefdescription": {
   "para": "Write an uncoded frame to an output media file."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_interleaved_write_uncoded_frame()",
      "@_refid": "group__lavf__encoding_1ga504f87e288e76ac4f72f3dbb7e35ec5f",
      "@_kindref": "member"
     },
     "#text": "The frame must be correctly interleaved according to the container specification; if not,must be used."
    },
    {
     "ref": {
      "#text": "av_interleaved_write_uncoded_frame()",
      "@_refid": "group__lavf__encoding_1ga504f87e288e76ac4f72f3dbb7e35ec5f",
      "@_kindref": "member"
     },
     "#text": "Seefor details."
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2591",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2591",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__encoding_1ga5c1d07c778698f0c9dd3b8ad2f0f46b6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write an uncoded frame to an output media file.\n *\n * The frame must be correctly interleaved according to the container\n * specification; if not, av_interleaved_write_uncoded_frame() must be used.\n *\n * See av_interleaved_write_uncoded_frame() for details.\n */"
 },
 "av_interleaved_write_uncoded_frame": {
  "type": "int",
  "definition": "int av_interleaved_write_uncoded_frame",
  "argsstring": "(AVFormatContext *s, int stream_index, struct AVFrame *frame)",
  "name": "av_interleaved_write_uncoded_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "stream_index"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "frame"
   }
  ],
  "briefdescription": {
   "para": "Write an uncoded frame to an output media file."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "If the muxer supports it, this function makes it possible to write anstructure directly, without encoding it into a packet. It is mostly useful for devices and similar special muxers that use raw video or PCM data and will not serialize it into a byte stream."
    },
    {
     "ref": {
      "#text": "av_write_uncoded_frame_query()",
      "@_refid": "group__lavf__encoding_1ga5f6bebdc8c234a5ad9740de89acb15e6",
      "@_kindref": "member"
     },
     "#text": "To test whether it is possible to use it with a given muxer and stream, use."
    },
    "The caller gives up ownership of the frame and must not access it afterwards.",
    {
     "simplesect": {
      "para": ">=0 for success, a negative code on error",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2610",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2610",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__encoding_1ga504f87e288e76ac4f72f3dbb7e35ec5f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write an uncoded frame to an output media file.\n *\n * If the muxer supports it, this function makes it possible to write an AVFrame\n * structure directly, without encoding it into a packet.\n * It is mostly useful for devices and similar special muxers that use raw\n * video or PCM data and will not serialize it into a byte stream.\n *\n * To test whether it is possible to use it with a given muxer and stream,\n * use av_write_uncoded_frame_query().\n *\n * The caller gives up ownership of the frame and must not access it\n * afterwards.\n *\n * @return  >=0 for success, a negative code on error\n */"
 },
 "av_write_uncoded_frame_query": {
  "type": "int",
  "definition": "int av_write_uncoded_frame_query",
  "argsstring": "(AVFormatContext *s, int stream_index)",
  "name": "av_write_uncoded_frame_query",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "stream_index"
   }
  ],
  "briefdescription": {
   "para": "Test whether a muxer supports uncoded frame."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": ">=0 if an uncoded frame can be written to that muxer and stream, <0 if not",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2619",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2619",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__encoding_1ga5f6bebdc8c234a5ad9740de89acb15e6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Test whether a muxer supports uncoded frame.\n *\n * @return  >=0 if an uncoded frame can be written to that muxer and stream,\n *          <0 if not\n */"
 },
 "av_write_trailer": {
  "type": "int",
  "definition": "int av_write_trailer",
  "argsstring": "(AVFormatContext *s)",
  "name": "av_write_trailer",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Write the stream trailer to an output media file and free the file private data."
  },
  "detaileddescription": {
   "para": [
    "May only be called after a successful call to avformat_write_header.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "media file handle"
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 if OK, AVERROR_xxx on error",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2630",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2630",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "mux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "mux_8c",
    "@_startline": "534",
    "@_endline": "643"
   },
   {
    "#text": "write_output_file_trailer",
    "@_refid": "transcode__aac_8c_1aea497107d8d2a7a1e5bf92422ccc6715",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "766",
    "@_endline": "775"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__encoding_1ga7f14007e7dc8f481f054b21614dfec13",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write the stream trailer to an output media file and free the\n * file private data.\n *\n * May only be called after a successful call to avformat_write_header.\n *\n * @param s media file handle\n * @return 0 if OK, AVERROR_xxx on error\n */"
 },
 "av_guess_format": {
  "type": {
   "ref": {
    "#text": "AVOutputFormat",
    "@_refid": "structAVOutputFormat",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVOutputFormat * av_guess_format",
  "argsstring": "(const char *short_name, const char *filename, const char *mime_type)",
  "name": "av_guess_format",
  "param": [
   {
    "type": "const char *",
    "declname": "short_name"
   },
   {
    "type": "const char *",
    "declname": "filename"
   },
   {
    "type": "const char *",
    "declname": "mime_type"
   }
  ],
  "briefdescription": {
   "para": "Return the output format in the list of registered output formats which best matches the provided parameters, or return NULL if there is no match."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "short_name"
       },
       "parameterdescription": {
        "para": "if non-NULL checks if short_name matches with the names of the registered formats"
       }
      },
      {
       "parameternamelist": {
        "parametername": "filename"
       },
       "parameterdescription": {
        "para": "if non-NULL checks if filename terminates with the extensions of the registered formats"
       }
      },
      {
       "parameternamelist": {
        "parametername": "mime_type"
       },
       "parameterdescription": {
        "para": "if non-NULL checks if mime_type matches with the MIME type of the registered formats"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2644",
   "@_column": "22",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2644",
   "@_declcolumn": "22"
  },
  "referencedby": {
   "#text": "open_output_file",
   "@_refid": "transcode__aac_8c_1a617f4760254c119fc7caa222f3fcbd21",
   "@_compoundref": "transcode__aac_8c",
   "@_startline": "145",
   "@_endline": "246"
  },
  "@_kind": "function",
  "@_id": "group__lavf__encoding_1ga8a557e58672434f7e42d1cfd43c98149",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the output format in the list of registered output formats\n * which best matches the provided parameters, or return NULL if\n * there is no match.\n *\n * @param short_name if non-NULL checks if short_name matches with the\n *                   names of the registered formats\n * @param filename   if non-NULL checks if filename terminates with the\n *                   extensions of the registered formats\n * @param mime_type  if non-NULL checks if mime_type matches with the\n *                   MIME type of the registered formats\n */"
 },
 "av_guess_codec": {
  "type": {
   "ref": {
    "#text": "AVCodecID",
    "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVCodecID av_guess_codec",
  "argsstring": "(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)",
  "name": "av_guess_codec",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVOutputFormat",
      "@_refid": "structAVOutputFormat",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "fmt"
   },
   {
    "type": "const char *",
    "declname": "short_name"
   },
   {
    "type": "const char *",
    "declname": "filename"
   },
   {
    "type": "const char *",
    "declname": "mime_type"
   },
   {
    "type": {
     "ref": {
      "#text": "AVMediaType",
      "@_refid": "group__lavu__misc_1ga9a84bba4713dfced21a1a56163be1f48",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   }
  ],
  "briefdescription": {
   "para": "Guess the codec ID based upon muxer and filename."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2651",
   "@_column": "15",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2651",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavf__encoding_1ga074f2d4c5b6389216b48d4a5cb5aa452",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Guess the codec ID based upon muxer and filename.\n */"
 },
 "av_get_output_timestamp": {
  "type": "int",
  "definition": "int av_get_output_timestamp",
  "argsstring": "(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)",
  "name": "av_get_output_timestamp",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "stream"
   },
   {
    "type": "int64_t *",
    "declname": "dts"
   },
   {
    "type": "int64_t *",
    "declname": "wall"
   }
  ],
  "briefdescription": {
   "para": "Get timing information for the data currently output."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": [
     {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "media file handle"
        }
       },
       {
        "parameternamelist": {
         "parametername": "stream"
        },
        "parameterdescription": {
         "para": "stream in the media file"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "dts",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "DTS of the last packet output for the stream, in stream time_base units"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "wall",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "absolute time when that packet whas output, in microsecond"
        }
       }
      ],
      "@_kind": "param"
     },
     {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": 0
        },
        "parameterdescription": {
         "para": "Success"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "ref": {
           "#text": "AVERROR(ENOSYS)",
           "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
           "@_kindref": "member"
          }
         }
        },
        "parameterdescription": {
         "para": "The format does not support it"
        }
       }
      ],
      "@_kind": "retval"
     }
    ],
    "simplesect": {
     "para": "Some formats or devices may not allow to measure dts and wall atomically.",
     "@_kind": "note"
    },
    "#text": "The exact meaning of \"currently output\" depends on the format. It is mostly relevant for devices that have an internal buffer and/or work in real time."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2672",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2672",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__encoding_1ga661ee0b2f3dbcaaef5d68f2f5d75e2d4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get timing information for the data currently output.\n * The exact meaning of \"currently output\" depends on the format.\n * It is mostly relevant for devices that have an internal buffer and/or\n * work in real time.\n * @param s          media file handle\n * @param stream     stream in the media file\n * @param[out] dts   DTS of the last packet output for the stream, in stream\n *                   time_base units\n * @param[out] wall  absolute time when that packet whas output,\n *                   in microsecond\n * @retval  0               Success\n * @retval  AVERROR(ENOSYS) The format does not support it\n *\n * @note Some formats or devices may not allow to measure dts and wall\n *       atomically.\n */"
 },
 "av_hex_dump": {
  "type": "void",
  "definition": "void av_hex_dump",
  "argsstring": "(FILE *f, const uint8_t *buf, int size)",
  "name": "av_hex_dump",
  "param": [
   {
    "type": "FILE *",
    "declname": "f"
   },
   {
    "type": "const uint8_t *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Send a nice hexadecimal dump of a buffer to the specified file stream."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "f"
       },
       "parameterdescription": {
        "para": "The file stream pointer where the dump should be sent to."
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "buffer size"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": [
       {
        "#text": "av_hex_dump_log",
        "@_refid": "group__lavf__misc_1ga56f93dbd118ff5fe833a2e39b685974c",
        "@_kindref": "member"
       },
       {
        "#text": "av_pkt_dump2",
        "@_refid": "group__lavf__misc_1ga46720b0bb28ca455246805be8969ff9e",
        "@_kindref": "member"
       },
       {
        "#text": "av_pkt_dump_log2",
        "@_refid": "group__lavf__misc_1gaab9fad988c28cc1c4dcbba24a36b6113",
        "@_kindref": "member"
       }
      ],
      "#text": ",,"
     },
     "@_kind": "see"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2699",
   "@_column": "6",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2699",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gab533a6d5d830ab90573dd035002c5bca",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Send a nice hexadecimal dump of a buffer to the specified file stream.\n *\n * @param f The file stream pointer where the dump should be sent to.\n * @param buf buffer\n * @param size buffer size\n *\n * @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2\n */"
 },
 "av_hex_dump_log": {
  "type": "void",
  "definition": "void av_hex_dump_log",
  "argsstring": "(void *avcl, int level, const uint8_t *buf, int size)",
  "name": "av_hex_dump_log",
  "param": [
   {
    "type": "void *",
    "declname": "avcl"
   },
   {
    "type": "int",
    "declname": "level"
   },
   {
    "type": "const uint8_t *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Send a nice hexadecimal dump of a buffer to the log."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "avcl"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "A pointer to an arbitrary struct of which the first field is a pointer to anstruct."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "level"
       },
       "parameterdescription": {
        "para": "The importance level of the message, lower values signifying higher importance."
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "buffer size"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": [
       {
        "#text": "av_hex_dump",
        "@_refid": "group__lavf__misc_1gab533a6d5d830ab90573dd035002c5bca",
        "@_kindref": "member"
       },
       {
        "#text": "av_pkt_dump2",
        "@_refid": "group__lavf__misc_1ga46720b0bb28ca455246805be8969ff9e",
        "@_kindref": "member"
       },
       {
        "#text": "av_pkt_dump_log2",
        "@_refid": "group__lavf__misc_1gaab9fad988c28cc1c4dcbba24a36b6113",
        "@_kindref": "member"
       }
      ],
      "#text": ",,"
     },
     "@_kind": "see"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2713",
   "@_column": "6",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2713",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga56f93dbd118ff5fe833a2e39b685974c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Send a nice hexadecimal dump of a buffer to the log.\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n * pointer to an AVClass struct.\n * @param level The importance level of the message, lower values signifying\n * higher importance.\n * @param buf buffer\n * @param size buffer size\n *\n * @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2\n */"
 },
 "av_pkt_dump2": {
  "type": "void",
  "definition": "void av_pkt_dump2",
  "argsstring": "(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)",
  "name": "av_pkt_dump2",
  "param": [
   {
    "type": "FILE *",
    "declname": "f"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "pkt"
   },
   {
    "type": "int",
    "declname": "dump_payload"
   },
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "st"
   }
  ],
  "briefdescription": {
   "para": "Send a nice dump of a packet to the specified file stream."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "f"
       },
       "parameterdescription": {
        "para": "The file stream pointer where the dump should be sent to."
       }
      },
      {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet to dump"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dump_payload"
       },
       "parameterdescription": {
        "para": "True if the payload must be displayed, too."
       }
      },
      {
       "parameternamelist": {
        "parametername": "st"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVStream",
          "@_refid": "structAVStream",
          "@_kindref": "compound"
         },
         "#text": "that the packet belongs to"
        }
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2723",
   "@_column": "6",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2723",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga46720b0bb28ca455246805be8969ff9e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Send a nice dump of a packet to the specified file stream.\n *\n * @param f The file stream pointer where the dump should be sent to.\n * @param pkt packet to dump\n * @param dump_payload True if the payload must be displayed, too.\n * @param st AVStream that the packet belongs to\n */"
 },
 "av_pkt_dump_log2": {
  "type": "void",
  "definition": "void av_pkt_dump_log2",
  "argsstring": "(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)",
  "name": "av_pkt_dump_log2",
  "param": [
   {
    "type": "void *",
    "declname": "avcl"
   },
   {
    "type": "int",
    "declname": "level"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "pkt"
   },
   {
    "type": "int",
    "declname": "dump_payload"
   },
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "st"
   }
  ],
  "briefdescription": {
   "para": "Send a nice dump of a packet to the log."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "avcl"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "A pointer to an arbitrary struct of which the first field is a pointer to anstruct."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "level"
       },
       "parameterdescription": {
        "para": "The importance level of the message, lower values signifying higher importance."
       }
      },
      {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet to dump"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dump_payload"
       },
       "parameterdescription": {
        "para": "True if the payload must be displayed, too."
       }
      },
      {
       "parameternamelist": {
        "parametername": "st"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVStream",
          "@_refid": "structAVStream",
          "@_kindref": "compound"
         },
         "#text": "that the packet belongs to"
        }
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2737",
   "@_column": "6",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2737",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gaab9fad988c28cc1c4dcbba24a36b6113",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Send a nice dump of a packet to the log.\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n * pointer to an AVClass struct.\n * @param level The importance level of the message, lower values signifying\n * higher importance.\n * @param pkt packet to dump\n * @param dump_payload True if the payload must be displayed, too.\n * @param st AVStream that the packet belongs to\n */"
 },
 "av_codec_get_id": {
  "type": {
   "ref": {
    "#text": "AVCodecID",
    "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVCodecID av_codec_get_id",
  "argsstring": "(const struct AVCodecTag *const *tags, unsigned int tag)",
  "name": "av_codec_get_id",
  "param": [
   {
    "type": "const struct AVCodecTag *const *",
    "declname": "tags"
   },
   {
    "type": "unsigned int",
    "declname": "tag"
   }
  ],
  "briefdescription": {
   "para": "Get the AVCodecID for the given codec tag tag."
  },
  "detaileddescription": {
   "para": [
    "If no codec id is found returns AV_CODEC_ID_NONE.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "tags"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "AVInputFormat.codec_tag",
            "@_refid": "structAVInputFormat_1a88738bb721c18df24fb4207aa2d4924a",
            "@_kindref": "member"
           },
           {
            "#text": "AVOutputFormat.codec_tag",
            "@_refid": "structAVOutputFormat_1ac55f4c21dd75c8c48b9de5080681eed4",
            "@_kindref": "member"
           }
          ],
          "#text": "list of supported codec_id-codec_tag pairs, as stored inand"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "tag"
        },
        "parameterdescription": {
         "para": "codec tag to match to a codec ID"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2748",
   "@_column": "15",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2748",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga27b89fa8286af6efb5a69e8db4033b09",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVCodecID for the given codec tag tag.\n * If no codec id is found returns AV_CODEC_ID_NONE.\n *\n * @param tags list of supported codec_id-codec_tag pairs, as stored\n * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n * @param tag  codec tag to match to a codec ID\n */"
 },
 "av_codec_get_tag": {
  "type": "unsigned int",
  "definition": "unsigned int av_codec_get_tag",
  "argsstring": "(const struct AVCodecTag *const *tags, enum AVCodecID id)",
  "name": "av_codec_get_tag",
  "param": [
   {
    "type": "const struct AVCodecTag *const *",
    "declname": "tags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodecID",
      "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "id"
   }
  ],
  "briefdescription": {
   "para": "Get the codec tag for the given codec id id."
  },
  "detaileddescription": {
   "para": [
    "If no codec tag is found returns 0.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "tags"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "AVInputFormat.codec_tag",
            "@_refid": "structAVInputFormat_1a88738bb721c18df24fb4207aa2d4924a",
            "@_kindref": "member"
           },
           {
            "#text": "AVOutputFormat.codec_tag",
            "@_refid": "structAVOutputFormat_1ac55f4c21dd75c8c48b9de5080681eed4",
            "@_kindref": "member"
           }
          ],
          "#text": "list of supported codec_id-codec_tag pairs, as stored inand"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "id"
        },
        "parameterdescription": {
         "para": "codec ID to match to a codec tag"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2758",
   "@_column": "14",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2758",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga126917b7ce8b4f05505098b72f4997de",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the codec tag for the given codec id id.\n * If no codec tag is found returns 0.\n *\n * @param tags list of supported codec_id-codec_tag pairs, as stored\n * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n * @param id   codec ID to match to a codec tag\n */"
 },
 "av_codec_get_tag2": {
  "type": "int",
  "definition": "int av_codec_get_tag2",
  "argsstring": "(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)",
  "name": "av_codec_get_tag2",
  "param": [
   {
    "type": "const struct AVCodecTag *const *",
    "declname": "tags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodecID",
      "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "id"
   },
   {
    "type": "unsigned int *",
    "declname": "tag"
   }
  ],
  "briefdescription": {
   "para": "Get the codec tag for the given codec id."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "tags"
       },
       "parameterdescription": {
        "para": {
         "ref": [
          {
           "#text": "AVInputFormat.codec_tag",
           "@_refid": "structAVInputFormat_1a88738bb721c18df24fb4207aa2d4924a",
           "@_kindref": "member"
          },
          {
           "#text": "AVOutputFormat.codec_tag",
           "@_refid": "structAVOutputFormat_1ac55f4c21dd75c8c48b9de5080681eed4",
           "@_kindref": "member"
          }
         ],
         "#text": "list of supported codec_id - codec_tag pairs, as stored inand"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "id"
       },
       "parameterdescription": {
        "para": "codec id that should be searched for in the list"
       }
      },
      {
       "parameternamelist": {
        "parametername": "tag"
       },
       "parameterdescription": {
        "para": "A pointer to the found tag"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 if id was not found in tags, > 0 if it was found",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2769",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2769",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gabe1a7b6824078229c69b75c71053c035",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the codec tag for the given codec id.\n *\n * @param tags list of supported codec_id - codec_tag pairs, as stored\n * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n * @param id codec id that should be searched for in the list\n * @param tag A pointer to the found tag\n * @return 0 if id was not found in tags, > 0 if it was found\n */"
 },
 "av_find_default_stream_index": {
  "type": "int",
  "definition": "int av_find_default_stream_index",
  "argsstring": "(AVFormatContext *s)",
  "name": "av_find_default_stream_index",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2772",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2772",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gaad9737492bb66aeeec37b7c7d8d90f2a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the codec tag for the given codec id.\n *\n * @param tags list of supported codec_id - codec_tag pairs, as stored\n * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag\n * @param id codec id that should be searched for in the list\n * @param tag A pointer to the found tag\n * @return 0 if id was not found in tags, > 0 if it was found\n */"
 },
 "av_index_search_timestamp": {
  "type": "int",
  "definition": "int av_index_search_timestamp",
  "argsstring": "(AVStream *st, int64_t timestamp, int flags)",
  "name": "av_index_search_timestamp",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "st"
   },
   {
    "type": "int64_t",
    "declname": "timestamp"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Get the index for a specific timestamp."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "st"
       },
       "parameterdescription": {
        "para": "stream that the timestamp belongs to"
       }
      },
      {
       "parameternamelist": {
        "parametername": "timestamp"
       },
       "parameterdescription": {
        "para": "timestamp to retrieve the index for"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "if AVSEEK_FLAG_BACKWARD then the returned index will correspond to the timestamp which is <= the requested one, if backward is 0, then it will be >= if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "< 0 if no such timestamp could be found",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2785",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2785",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gac4cabc0d681c34b2e2c6a87a55877f0d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the index for a specific timestamp.\n *\n * @param st        stream that the timestamp belongs to\n * @param timestamp timestamp to retrieve the index for\n * @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond\n *                 to the timestamp which is <= the requested one, if backward\n *                 is 0, then it will be >=\n *              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise\n * @return < 0 if no such timestamp could be found\n */"
 },
 "avformat_index_get_entries_count": {
  "type": "int",
  "definition": "int avformat_index_get_entries_count",
  "argsstring": "(const AVStream *st)",
  "name": "avformat_index_get_entries_count",
  "param": {
   "type": {
    "ref": {
     "#text": "AVStream",
     "@_refid": "structAVStream",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "st"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVStream",
     "@_refid": "structAVStream",
     "@_kindref": "compound"
    },
    "#text": "Get the index entry count for the given."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "st"
      },
      "parameterdescription": {
       "para": "stream"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the number of index entries in the stream",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2793",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2793",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga2ee823d22f7e3d5387ac6a62ba16da09",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the index entry count for the given AVStream.\n *\n * @param st stream\n * @return the number of index entries in the stream\n */"
 },
 "avformat_index_get_entry": {
  "type": {
   "ref": {
    "#text": "AVIndexEntry",
    "@_refid": "structAVIndexEntry",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVIndexEntry * avformat_index_get_entry",
  "argsstring": "(AVStream *st, int idx)",
  "name": "avformat_index_get_entry",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "st"
   },
   {
    "type": "int",
    "declname": "idx"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIndexEntry",
     "@_refid": "structAVIndexEntry",
     "@_kindref": "compound"
    },
    "#text": "Get thecorresponding to the given index."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "st"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVIndexEntry",
          "@_refid": "structAVIndexEntry",
          "@_kindref": "compound"
         },
         "#text": "Stream containing the requested."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "idx"
       },
       "parameterdescription": {
        "para": "The desired index."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "AVIndexEntry",
        "@_refid": "structAVIndexEntry",
        "@_kindref": "compound"
       },
       "#text": "A pointer to the requestedif it exists, NULL otherwise."
      },
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "AVFormatContext",
        "@_refid": "structAVFormatContext",
        "@_kindref": "compound"
       },
       "#text": "The pointer returned by this function is only guaranteed to be valid until any function that takes the stream or the parentas input argument is called."
      },
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2806",
   "@_column": "20",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2806",
   "@_declcolumn": "20"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga677a6ee137f1ac13695a6f94bf1baad9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVIndexEntry corresponding to the given index.\n *\n * @param st          Stream containing the requested AVIndexEntry.\n * @param idx         The desired index.\n * @return A pointer to the requested AVIndexEntry if it exists, NULL otherwise.\n *\n * @note The pointer returned by this function is only guaranteed to be valid\n *       until any function that takes the stream or the parent AVFormatContext\n *       as input argument is called.\n */"
 },
 "avformat_index_get_entry_from_timestamp": {
  "type": {
   "ref": {
    "#text": "AVIndexEntry",
    "@_refid": "structAVIndexEntry",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVIndexEntry * avformat_index_get_entry_from_timestamp",
  "argsstring": "(AVStream *st, int64_t wanted_timestamp, int flags)",
  "name": "avformat_index_get_entry_from_timestamp",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "st"
   },
   {
    "type": "int64_t",
    "declname": "wanted_timestamp"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIndexEntry",
     "@_refid": "structAVIndexEntry",
     "@_kindref": "compound"
    },
    "#text": "Get thecorresponding to the given timestamp."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "st"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVIndexEntry",
          "@_refid": "structAVIndexEntry",
          "@_kindref": "compound"
         },
         "#text": "Stream containing the requested."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "wanted_timestamp"
       },
       "parameterdescription": {
        "para": "Timestamp to retrieve the index entry for."
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "If AVSEEK_FLAG_BACKWARD then the returned entry will correspond to the timestamp which is <= the requested one, if backward is 0, then it will be >= if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "AVIndexEntry",
        "@_refid": "structAVIndexEntry",
        "@_kindref": "compound"
       },
       "#text": "A pointer to the requestedif it exists, NULL otherwise."
      },
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "AVFormatContext",
        "@_refid": "structAVFormatContext",
        "@_kindref": "compound"
       },
       "#text": "The pointer returned by this function is only guaranteed to be valid until any function that takes the stream or the parentas input argument is called."
      },
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2823",
   "@_column": "20",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2823",
   "@_declcolumn": "20"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gab31c7571d1e969055b08e932b98c41ef",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVIndexEntry corresponding to the given timestamp.\n *\n * @param st          Stream containing the requested AVIndexEntry.\n * @param wanted_timestamp   Timestamp to retrieve the index entry for.\n * @param flags       If AVSEEK_FLAG_BACKWARD then the returned entry will correspond\n *                    to the timestamp which is <= the requested one, if backward\n *                    is 0, then it will be >=\n *                    if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise.\n * @return A pointer to the requested AVIndexEntry if it exists, NULL otherwise.\n *\n * @note The pointer returned by this function is only guaranteed to be valid\n *       until any function that takes the stream or the parent AVFormatContext\n *       as input argument is called.\n */"
 },
 "av_add_index_entry": {
  "type": "int",
  "definition": "int av_add_index_entry",
  "argsstring": "(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)",
  "name": "av_add_index_entry",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "st"
   },
   {
    "type": "int64_t",
    "declname": "pos"
   },
   {
    "type": "int64_t",
    "declname": "timestamp"
   },
   {
    "type": "int",
    "declname": "size"
   },
   {
    "type": "int",
    "declname": "distance"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Add an index entry into a sorted list."
  },
  "detaileddescription": {
   "para": [
    "Update the entry if the list already contains it.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "timestamp"
       },
       "parameterdescription": {
        "para": "timestamp in the time base of the given stream"
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2832",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2832",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga3ed7441cb4af0bdd65a4cf51bf35088e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add an index entry into a sorted list. Update the entry if the list\n * already contains it.\n *\n * @param timestamp timestamp in the time base of the given stream\n */"
 },
 "av_url_split": {
  "type": "void",
  "definition": "void av_url_split",
  "argsstring": "(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)",
  "name": "av_url_split",
  "param": [
   {
    "type": "char *",
    "declname": "proto"
   },
   {
    "type": "int",
    "declname": "proto_size"
   },
   {
    "type": "char *",
    "declname": "authorization"
   },
   {
    "type": "int",
    "declname": "authorization_size"
   },
   {
    "type": "char *",
    "declname": "hostname"
   },
   {
    "type": "int",
    "declname": "hostname_size"
   },
   {
    "type": "int *",
    "declname": "port_ptr"
   },
   {
    "type": "char *",
    "declname": "path"
   },
   {
    "type": "int",
    "declname": "path_size"
   },
   {
    "type": "const char *",
    "declname": "url"
   }
  ],
  "briefdescription": {
   "para": "Split a URL string into components."
  },
  "detaileddescription": {
   "para": [
    "The pointers to buffers for storing individual components may be null, in order to ignore that component. Buffers for components not found are set to empty strings. If the port is not found, it is set to a negative value.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "proto"
        },
        "parameterdescription": {
         "para": "the buffer for the protocol"
        }
       },
       {
        "parameternamelist": {
         "parametername": "proto_size"
        },
        "parameterdescription": {
         "para": "the size of the proto buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "authorization"
        },
        "parameterdescription": {
         "para": "the buffer for the authorization"
        }
       },
       {
        "parameternamelist": {
         "parametername": "authorization_size"
        },
        "parameterdescription": {
         "para": "the size of the authorization buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "hostname"
        },
        "parameterdescription": {
         "para": "the buffer for the host name"
        }
       },
       {
        "parameternamelist": {
         "parametername": "hostname_size"
        },
        "parameterdescription": {
         "para": "the size of the hostname buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "port_ptr"
        },
        "parameterdescription": {
         "para": "a pointer to store the port number in"
        }
       },
       {
        "parameternamelist": {
         "parametername": "path"
        },
        "parameterdescription": {
         "para": "the buffer for the path"
        }
       },
       {
        "parameternamelist": {
         "parametername": "path_size"
        },
        "parameterdescription": {
         "para": "the size of the path buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "url"
        },
        "parameterdescription": {
         "para": "the URL to split"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2855",
   "@_column": "6",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2855",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga63a0579d6c2aa72470ac742bbbc1205d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Split a URL string into components.\n *\n * The pointers to buffers for storing individual components may be null,\n * in order to ignore that component. Buffers for components not found are\n * set to empty strings. If the port is not found, it is set to a negative\n * value.\n *\n * @param proto the buffer for the protocol\n * @param proto_size the size of the proto buffer\n * @param authorization the buffer for the authorization\n * @param authorization_size the size of the authorization buffer\n * @param hostname the buffer for the host name\n * @param hostname_size the size of the hostname buffer\n * @param port_ptr a pointer to store the port number in\n * @param path the buffer for the path\n * @param path_size the size of the path buffer\n * @param url the URL to split\n */"
 },
 "av_dump_format": {
  "type": "void",
  "definition": "void av_dump_format",
  "argsstring": "(AVFormatContext *ic, int index, const char *url, int is_output)",
  "name": "av_dump_format",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ic"
   },
   {
    "type": "int",
    "declname": "index"
   },
   {
    "type": "const char *",
    "declname": "url"
   },
   {
    "type": "int",
    "declname": "is_output"
   }
  ],
  "briefdescription": {
   "para": "Print detailed information about the input or output format, such as duration, bitrate, streams, container, programs, metadata, side data, codec and time base."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ic"
       },
       "parameterdescription": {
        "para": "the context to analyze"
       }
      },
      {
       "parameternamelist": {
        "parametername": "index"
       },
       "parameterdescription": {
        "para": "index of the stream to dump information about"
       }
      },
      {
       "parameternamelist": {
        "parametername": "url"
       },
       "parameterdescription": {
        "para": "the URL to print, such as source or destination file"
       }
      },
      {
       "parameternamelist": {
        "parametername": "is_output"
       },
       "parameterdescription": {
        "para": "Select whether the specified context is an input(0) or output(1)"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2873",
   "@_column": "6",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2873",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "avio__read__callback_8c_1a0ddf1224851353fc92bfbff6f499fa97",
    "@_compoundref": "avio__read__callback_8c",
    "@_startline": "58",
    "@_endline": "133"
   },
   {
    "#text": "open_input_file",
    "@_refid": "transcode_8c_1abd04bf1a933d4d2698482f4949c61fed",
    "@_compoundref": "transcode_8c",
    "@_startline": "61",
    "@_endline": "126"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gae2645941f2dc779c307eb6314fd39f10",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Print detailed information about the input or output format, such as\n * duration, bitrate, streams, container, programs, metadata, side data,\n * codec and time base.\n *\n * @param ic        the context to analyze\n * @param index     index of the stream to dump information about\n * @param url       the URL to print, such as source or destination file\n * @param is_output Select whether the specified context is an input(0) or output(1)\n */"
 },
 "av_get_frame_filename2": {
  "type": "int",
  "definition": "int av_get_frame_filename2",
  "argsstring": "(char *buf, int buf_size, const char *path, int number, int flags)",
  "name": "av_get_frame_filename2",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buf_size"
   },
   {
    "type": "const char *",
    "declname": "path"
   },
   {
    "type": "int",
    "declname": "number"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Return in 'buf' the path with 'd' replaced by a number."
  },
  "detaileddescription": {
   "para": [
    "Also handles the '%0nd' format where 'n' is the total number of digits and '%'.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "destination buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf_size"
        },
        "parameterdescription": {
         "para": "destination buffer size"
        }
       },
       {
        "parameternamelist": {
         "parametername": "path"
        },
        "parameterdescription": {
         "para": "numbered sequence string"
        }
       },
       {
        "parameternamelist": {
         "parametername": "number"
        },
        "parameterdescription": {
         "para": "frame number"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "AV_FRAME_FILENAME_FLAGS_*"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 if OK, -1 on format error",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2894",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2894",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga05f17637161cd79506f67b20ea8149c9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return in 'buf' the path with '%d' replaced by a number.\n *\n * Also handles the '%0nd' format where 'n' is the total number\n * of digits and '%%'.\n *\n * @param buf destination buffer\n * @param buf_size destination buffer size\n * @param path numbered sequence string\n * @param number frame number\n * @param flags AV_FRAME_FILENAME_FLAGS_*\n * @return 0 if OK, -1 on format error\n */"
 },
 "av_get_frame_filename": {
  "type": "int",
  "definition": "int av_get_frame_filename",
  "argsstring": "(char *buf, int buf_size, const char *path, int number)",
  "name": "av_get_frame_filename",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buf_size"
   },
   {
    "type": "const char *",
    "declname": "path"
   },
   {
    "type": "int",
    "declname": "number"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2897",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2897",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga90e027a5d9006148413a1387c506cd40",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return in 'buf' the path with '%d' replaced by a number.\n *\n * Also handles the '%0nd' format where 'n' is the total number\n * of digits and '%%'.\n *\n * @param buf destination buffer\n * @param buf_size destination buffer size\n * @param path numbered sequence string\n * @param number frame number\n * @param flags AV_FRAME_FILENAME_FLAGS_*\n * @return 0 if OK, -1 on format error\n */"
 },
 "av_filename_number_test": {
  "type": "int",
  "definition": "int av_filename_number_test",
  "argsstring": "(const char *filename)",
  "name": "av_filename_number_test",
  "param": {
   "type": "const char *",
   "declname": "filename"
  },
  "briefdescription": {
   "para": "Check whether filename actually is a numbered sequence generator."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "filename"
      },
      "parameterdescription": {
       "para": "possible numbered sequence string"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "1 if a valid numbered sequence string, 0 otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2906",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2906",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gac20eb319c6c46f581b5d08f5c25e763e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check whether filename actually is a numbered sequence generator.\n *\n * @param filename possible numbered sequence string\n * @return 1 if a valid numbered sequence string, 0 otherwise\n */"
 },
 "av_sdp_create": {
  "type": "int",
  "definition": "int av_sdp_create",
  "argsstring": "(AVFormatContext *ac[], int n_files, char *buf, int size)",
  "name": "av_sdp_create",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ac",
    "array": "[]"
   },
   {
    "type": "int",
    "declname": "n_files"
   },
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Generate an SDP for an RTP session."
  },
  "detaileddescription": {
   "para": [
    "Note, this overwrites the id values of AVStreams in the muxer contexts for getting unique dynamic payload types.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ac"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "AVStream",
            "@_refid": "structAVStream",
            "@_kindref": "compound"
           },
           {
            "#text": "AVCodecContext",
            "@_refid": "structAVCodecContext",
            "@_kindref": "compound"
           },
           {
            "#text": "AVStream",
            "@_refid": "structAVStream",
            "@_kindref": "compound"
           }
          ],
          "#text": "array of AVFormatContexts describing the RTP streams. If the array is composed by only one context, such context can contain multiple AVStreams (oneper RTP stream). Otherwise, all the contexts in the array (anper RTP stream) must contain only one."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "n_files"
        },
        "parameterdescription": {
         "para": "number of AVCodecContexts contained in ac"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "buffer where the SDP will be stored (must be allocated by the caller)"
        }
       },
       {
        "parameternamelist": {
         "parametername": "size"
        },
        "parameterdescription": {
         "para": "the size of the buffer"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 if OK, AVERROR_xxx on error",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2925",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2925",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gaa2a7353a6bb0c8726797abd56b176af0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Generate an SDP for an RTP session.\n *\n * Note, this overwrites the id values of AVStreams in the muxer contexts\n * for getting unique dynamic payload types.\n *\n * @param ac array of AVFormatContexts describing the RTP streams. If the\n *           array is composed by only one context, such context can contain\n *           multiple AVStreams (one AVStream per RTP stream). Otherwise,\n *           all the contexts in the array (an AVCodecContext per RTP stream)\n *           must contain only one AVStream.\n * @param n_files number of AVCodecContexts contained in ac\n * @param buf buffer where the SDP will be stored (must be allocated by\n *            the caller)\n * @param size the size of the buffer\n * @return 0 if OK, AVERROR_xxx on error\n */"
 },
 "av_match_ext": {
  "type": "int",
  "definition": "int av_match_ext",
  "argsstring": "(const char *filename, const char *extensions)",
  "name": "av_match_ext",
  "param": [
   {
    "type": "const char *",
    "declname": "filename"
   },
   {
    "type": "const char *",
    "declname": "extensions"
   }
  ],
  "briefdescription": {
   "para": "Return a positive value if the given filename has one of the given extensions, 0 otherwise."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "filename"
       },
       "parameterdescription": {
        "para": "file name to check against the given extensions"
       }
      },
      {
       "parameternamelist": {
        "parametername": "extensions"
       },
       "parameterdescription": {
        "para": "a comma-separated list of filename extensions"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2934",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2934",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga8247f49e5642dd3bd20ce6ba5a7f6466",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return a positive value if the given filename has one of the given\n * extensions, 0 otherwise.\n *\n * @param filename   file name to check against the given extensions\n * @param extensions a comma-separated list of filename extensions\n */"
 },
 "avformat_query_codec": {
  "type": "int",
  "definition": "int avformat_query_codec",
  "argsstring": "(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)",
  "name": "avformat_query_codec",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVOutputFormat",
      "@_refid": "structAVOutputFormat",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "ofmt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodecID",
      "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "codec_id"
   },
   {
    "type": "int",
    "declname": "std_compliance"
   }
  ],
  "briefdescription": {
   "para": "Test if the given container can store a codec."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ofmt"
       },
       "parameterdescription": {
        "para": "container to check for compatibility"
       }
      },
      {
       "parameternamelist": {
        "parametername": "codec_id"
       },
       "parameterdescription": {
        "para": "codec to potentially store in container"
       }
      },
      {
       "parameternamelist": {
        "parametername": "std_compliance"
       },
       "parameterdescription": {
        "para": "standards compliance level, one of FF_COMPLIANCE_*"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot. A negative number if this information is not available.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2946",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2946",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gaa90b4c72d1bbb298e11096d3a09ec7db",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Test if the given container can store a codec.\n *\n * @param ofmt           container to check for compatibility\n * @param codec_id       codec to potentially store in container\n * @param std_compliance standards compliance level, one of FF_COMPLIANCE_*\n *\n * @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.\n *         A negative number if this information is not available.\n */"
 },
 "avformat_get_riff_video_tags": {
  "type": "const struct AVCodecTag *",
  "definition": "const struct AVCodecTag * avformat_get_riff_video_tags",
  "argsstring": "(void)",
  "name": "avformat_get_riff_video_tags",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the table mapping RIFF FourCCs for video to libavcodec AVCodecID.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2964",
   "@_column": "23",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2964",
   "@_declcolumn": "23"
  },
  "@_kind": "function",
  "@_id": "group__riff__fourcc_1gaf875273bf4a35b33251cfca63e20d6d4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID.\n */"
 },
 "avformat_get_riff_audio_tags": {
  "type": "const struct AVCodecTag *",
  "definition": "const struct AVCodecTag * avformat_get_riff_audio_tags",
  "argsstring": "(void)",
  "name": "avformat_get_riff_audio_tags",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the table mapping RIFF FourCCs for audio to AVCodecID.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2968",
   "@_column": "23",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2968",
   "@_declcolumn": "23"
  },
  "@_kind": "function",
  "@_id": "group__riff__fourcc_1ga8cbb43e6d57f1692212488b98d70b505",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the table mapping RIFF FourCCs for audio to AVCodecID.\n */"
 },
 "avformat_get_mov_video_tags": {
  "type": "const struct AVCodecTag *",
  "definition": "const struct AVCodecTag * avformat_get_mov_video_tags",
  "argsstring": "(void)",
  "name": "avformat_get_mov_video_tags",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the table mapping MOV FourCCs for video to libavcodec AVCodecID.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2972",
   "@_column": "23",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2972",
   "@_declcolumn": "23"
  },
  "@_kind": "function",
  "@_id": "group__riff__fourcc_1ga96f10176e7a8028b8afb3de1a3d7476c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the table mapping MOV FourCCs for video to libavcodec AVCodecID.\n */"
 },
 "avformat_get_mov_audio_tags": {
  "type": "const struct AVCodecTag *",
  "definition": "const struct AVCodecTag * avformat_get_mov_audio_tags",
  "argsstring": "(void)",
  "name": "avformat_get_mov_audio_tags",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the table mapping MOV FourCCs for audio to AVCodecID.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2976",
   "@_column": "23",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2976",
   "@_declcolumn": "23"
  },
  "@_kind": "function",
  "@_id": "group__riff__fourcc_1ga8bee63248fe1d1dd98a03f401c3325aa",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the table mapping MOV FourCCs for audio to AVCodecID.\n */"
 },
 "av_guess_sample_aspect_ratio": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_guess_sample_aspect_ratio",
  "argsstring": "(AVFormatContext *format, AVStream *stream, struct AVFrame *frame)",
  "name": "av_guess_sample_aspect_ratio",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "format"
   },
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "stream"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "frame"
   }
  ],
  "briefdescription": {
   "para": "Guess the sample aspect ratio of a frame, based on both the stream and the frame aspect ratio."
  },
  "detaileddescription": {
   "para": [
    "Since the frame aspect ratio is set by the codec but the stream aspect ratio is set by the demuxer, these two may not be equal. This function tries to return the value that you should use if you would like to display the frame.",
    "Basic logic is to use the stream aspect ratio if it is set to something sane otherwise use the frame aspect ratio. This way a container setting, which is usually easy to modify can override the coded value in the frames.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "format"
        },
        "parameterdescription": {
         "para": "the format context which the stream is part of"
        }
       },
       {
        "parameternamelist": {
         "parametername": "stream"
        },
        "parameterdescription": {
         "para": "the stream which the frame is part of"
        }
       },
       {
        "parameternamelist": {
         "parametername": "frame"
        },
        "parameterdescription": {
         "para": "the frame with the aspect ratio to be determined"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the guessed (valid) sample_aspect_ratio, 0/1 if no idea",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "2999",
   "@_column": "12",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "2999",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gafa6fbfe5c1bf6792fd6e33475b6056bd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Guess the sample aspect ratio of a frame, based on both the stream and the\n * frame aspect ratio.\n *\n * Since the frame aspect ratio is set by the codec but the stream aspect ratio\n * is set by the demuxer, these two may not be equal. This function tries to\n * return the value that you should use if you would like to display the frame.\n *\n * Basic logic is to use the stream aspect ratio if it is set to something sane\n * otherwise use the frame aspect ratio. This way a container setting, which is\n * usually easy to modify can override the coded value in the frames.\n *\n * @param format the format context which the stream is part of\n * @param stream the stream which the frame is part of\n * @param frame the frame with the aspect ratio to be determined\n * @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea\n */"
 },
 "av_guess_frame_rate": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_guess_frame_rate",
  "argsstring": "(AVFormatContext *ctx, AVStream *stream, struct AVFrame *frame)",
  "name": "av_guess_frame_rate",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "stream"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "frame"
   }
  ],
  "briefdescription": {
   "para": "Guess the frame rate, based on both the container and codec information."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "the format context which the stream is part of"
       }
      },
      {
       "parameternamelist": {
        "parametername": "stream"
       },
       "parameterdescription": {
        "para": "the stream which the frame is part of"
       }
      },
      {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": "the frame for which the frame rate should be determined, may be NULL"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the guessed (valid) frame rate, 0/1 if no idea",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "3010",
   "@_column": "12",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "3010",
   "@_declcolumn": "12"
  },
  "referencedby": {
   "#text": "open_input_file",
   "@_refid": "transcode_8c_1abd04bf1a933d4d2698482f4949c61fed",
   "@_compoundref": "transcode_8c",
   "@_startline": "61",
   "@_endline": "126"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga698e6aa73caa9616851092e2be15875d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Guess the frame rate, based on both the container and codec information.\n *\n * @param ctx the format context which the stream is part of\n * @param stream the stream which the frame is part of\n * @param frame the frame for which the frame rate should be determined, may be NULL\n * @return the guessed (valid) frame rate, 0/1 if no idea\n */"
 },
 "avformat_match_stream_specifier": {
  "type": "int",
  "definition": "int avformat_match_stream_specifier",
  "argsstring": "(AVFormatContext *s, AVStream *st, const char *spec)",
  "name": "avformat_match_stream_specifier",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFormatContext",
      "@_refid": "structAVFormatContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "st"
   },
   {
    "type": "const char *",
    "declname": "spec"
   }
  ],
  "briefdescription": {
   "para": "Check if the stream st contained in s is matched by the stream specifier spec."
  },
  "detaileddescription": {
   "para": [
    "See the \"stream specifiers\" chapter in the documentation for the syntax of spec.",
    {
     "simplesect": [
      {
       "para": ">0 if st is matched by spec; 0 if st is not matched by spec; AVERROR code if spec is invalid",
       "@_kind": "return"
      },
      {
       "para": "A stream specifier can match several streams in the format.",
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "3026",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "3026",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga7e45597834e9ef3098ddb74bc5e1550c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if the stream st contained in s is matched by the stream specifier\n * spec.\n *\n * See the \"stream specifiers\" chapter in the documentation for the syntax\n * of spec.\n *\n * @return  >0 if st is matched by spec;\n *          0  if st is not matched by spec;\n *          AVERROR code if spec is invalid\n *\n * @note  A stream specifier can match several streams in the format.\n */"
 },
 "avformat_queue_attached_pictures": {
  "type": "int",
  "definition": "int avformat_queue_attached_pictures",
  "argsstring": "(AVFormatContext *s)",
  "name": "avformat_queue_attached_pictures",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFormatContext",
     "@_refid": "structAVFormatContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "3029",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "3029",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga501ff1b3aa357c09da90c0effb356e45",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if the stream st contained in s is matched by the stream specifier\n * spec.\n *\n * See the \"stream specifiers\" chapter in the documentation for the syntax\n * of spec.\n *\n * @return  >0 if st is matched by spec;\n *          0  if st is not matched by spec;\n *          AVERROR code if spec is invalid\n *\n * @note  A stream specifier can match several streams in the format.\n */"
 },
 "avformat_transfer_internal_stream_timing_info": {
  "type": "int",
  "definition": "int avformat_transfer_internal_stream_timing_info",
  "argsstring": "(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)",
  "name": "avformat_transfer_internal_stream_timing_info",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVOutputFormat",
      "@_refid": "structAVOutputFormat",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "ofmt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ost"
   },
   {
    "type": {
     "ref": {
      "#text": "AVStream",
      "@_refid": "structAVStream",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "ist"
   },
   {
    "type": {
     "ref": {
      "#text": "AVTimebaseSource",
      "@_refid": "group__lavf__misc_1ga67f84bb8799c8da41194f046f4b970c4",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "copy_tb"
   }
  ],
  "briefdescription": {
   "para": "Transfer internal timing information from one stream to another."
  },
  "detaileddescription": {
   "para": [
    "This function is useful when doing stream copy.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ofmt"
        },
        "parameterdescription": {
         "para": "target output format for ost"
        }
       },
       {
        "parameternamelist": {
         "parametername": "ost"
        },
        "parameterdescription": {
         "para": "output stream which needs timings copy and adjustments"
        }
       },
       {
        "parameternamelist": {
         "parametername": "ist"
        },
        "parameterdescription": {
         "para": "reference input stream to copy timings from"
        }
       },
       {
        "parameternamelist": {
         "parametername": "copy_tb"
        },
        "parameterdescription": {
         "para": "define from where the stream codec timebase needs to be imported"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "3050",
   "@_column": "5",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "3050",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1gae35832b110d26ffa3e8805b3d55e8f36",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Transfer internal timing information from one stream to another.\n *\n * This function is useful when doing stream copy.\n *\n * @param ofmt     target output format for ost\n * @param ost      output stream which needs timings copy and adjustments\n * @param ist      reference input stream to copy timings from\n * @param copy_tb  define from where the stream codec timebase needs to be imported\n */"
 },
 "av_stream_get_codec_timebase": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_stream_get_codec_timebase",
  "argsstring": "(const AVStream *st)",
  "name": "av_stream_get_codec_timebase",
  "param": {
   "type": {
    "ref": {
     "#text": "AVStream",
     "@_refid": "structAVStream",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "st"
  },
  "briefdescription": {
   "para": "Get the internal codec timebase from a stream."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "st"
      },
      "parameterdescription": {
       "para": "input stream to extract the timebase from"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avformat.h",
   "@_line": "3059",
   "@_column": "12",
   "@_declfile": "libavformat/avformat.h",
   "@_declline": "3059",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavf__misc_1ga64b609bbdda09ec7b29534a30656eb1a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the internal codec timebase from a stream.\n *\n * @param st  input stream to extract the timebase from\n */"
 },
 "avio_r8": {
  "type": "int",
  "definition": "int avio_r8",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_r8",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "574",
   "@_column": "14",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "574",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1af0d12eeb9d701134d971b91b4083bb43",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @name Functions for reading from AVIOContext\n * @{\n *\n * @note return 0 if EOF, so you cannot use it if EOF handling is\n *       necessary\n */"
 },
 "avio_rl16": {
  "type": "unsigned int",
  "definition": "unsigned int avio_rl16",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_rl16",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "575",
   "@_column": "14",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "575",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a71a15b7c123789a03115af82021698fe",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @name Functions for reading from AVIOContext\n * @{\n *\n * @note return 0 if EOF, so you cannot use it if EOF handling is\n *       necessary\n */"
 },
 "avio_rl24": {
  "type": "unsigned int",
  "definition": "unsigned int avio_rl24",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_rl24",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "576",
   "@_column": "14",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "576",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1ac3229b4447938b646e4ecbf25a594e8a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @name Functions for reading from AVIOContext\n * @{\n *\n * @note return 0 if EOF, so you cannot use it if EOF handling is\n *       necessary\n */"
 },
 "avio_rl32": {
  "type": "unsigned int",
  "definition": "unsigned int avio_rl32",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_rl32",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "577",
   "@_column": "14",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "577",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1abc91c5452c4d7b5da84021be3a9a3d70",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @name Functions for reading from AVIOContext\n * @{\n *\n * @note return 0 if EOF, so you cannot use it if EOF handling is\n *       necessary\n */"
 },
 "avio_rl64": {
  "type": "uint64_t",
  "definition": "uint64_t avio_rl64",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_rl64",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "578",
   "@_column": "14",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "578",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1af60c7d8fdabc3667ead1fffd2fac7ad5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @name Functions for reading from AVIOContext\n * @{\n *\n * @note return 0 if EOF, so you cannot use it if EOF handling is\n *       necessary\n */"
 },
 "avio_rb16": {
  "type": "unsigned int",
  "definition": "unsigned int avio_rb16",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_rb16",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "579",
   "@_column": "14",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "579",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a383f5f7f7df5b6cc9b7949713a43cb37",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @name Functions for reading from AVIOContext\n * @{\n *\n * @note return 0 if EOF, so you cannot use it if EOF handling is\n *       necessary\n */"
 },
 "avio_rb24": {
  "type": "unsigned int",
  "definition": "unsigned int avio_rb24",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_rb24",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "580",
   "@_column": "14",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "580",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1ae5f28c2379d309467db446d2fa03269b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @name Functions for reading from AVIOContext\n * @{\n *\n * @note return 0 if EOF, so you cannot use it if EOF handling is\n *       necessary\n */"
 },
 "avio_rb32": {
  "type": "unsigned int",
  "definition": "unsigned int avio_rb32",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_rb32",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "581",
   "@_column": "14",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "581",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1af089361fd70426624d19d436a10f87ad",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @name Functions for reading from AVIOContext\n * @{\n *\n * @note return 0 if EOF, so you cannot use it if EOF handling is\n *       necessary\n */"
 },
 "avio_rb64": {
  "type": "uint64_t",
  "definition": "uint64_t avio_rb64",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_rb64",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "582",
   "@_column": "14",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "582",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a14d7da25344458b5f3aad11edb0f4918",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @name Functions for reading from AVIOContext\n * @{\n *\n * @note return 0 if EOF, so you cannot use it if EOF handling is\n *       necessary\n */"
 },
 "AVIODirContext": {
  "type": {
   "ref": {
    "#text": "AVIODirContext",
    "@_refid": "avio_8h_1a4cb33c20efe97c6f8de4120b098cc8a5",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVIODirContext AVIODirContext",
  "argsstring": "",
  "name": "AVIODirContext",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "104",
   "@_column": "29",
   "@_bodyfile": "libavformat/avio.h",
   "@_bodystart": "104",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "avio_8h_1a4cb33c20efe97c6f8de4120b098cc8a5",
  "@_prot": "public",
  "@_static": "no",
  "raw": "    int64_t filemode;                     /**< Unix file mode, -1 if unknown. */"
 },
 "avio_find_protocol_name": {
  "type": "const char *",
  "definition": "const char * avio_find_protocol_name",
  "argsstring": "(const char *url)",
  "name": "avio_find_protocol_name",
  "param": {
   "type": "const char *",
   "declname": "url"
  },
  "briefdescription": {
   "para": "Return the name of the protocol that will handle the passed URL."
  },
  "detaileddescription": {
   "para": [
    "NULL is returned if no protocol could be found for the given URL.",
    {
     "simplesect": {
      "para": "Name of the protocol or NULL.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "316",
   "@_column": "12",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "316",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1af573ddecd4e932b593c3173d562d47da",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the name of the protocol that will handle the passed URL.\n *\n * NULL is returned if no protocol could be found for the given URL.\n *\n * @return Name of the protocol or NULL.\n */"
 },
 "avio_check": {
  "type": "int",
  "definition": "int avio_check",
  "argsstring": "(const char *url, int flags)",
  "name": "avio_check",
  "param": [
   {
    "type": "const char *",
    "declname": "url"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Return AVIO_FLAG_* access flags corresponding to the access permissions of the resource in url, or a negative value corresponding to an AVERROR code in case of failure."
  },
  "detaileddescription": {
   "para": [
    "The returned access flags are masked by the value in flags.",
    {
     "simplesect": {
      "para": "This function is intrinsically unsafe, in the sense that the checked resource may change its existence or permission status from one call to another. Thus you should not trust the returned value, unless you are sure that no other processes are accessing the checked resource.",
      "@_kind": "note"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "330",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "330",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1aa4006f7b803e4d104231734a23b35ab7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return AVIO_FLAG_* access flags corresponding to the access permissions\n * of the resource in url, or a negative value corresponding to an\n * AVERROR code in case of failure. The returned access flags are\n * masked by the value in flags.\n *\n * @note This function is intrinsically unsafe, in the sense that the\n * checked resource may change its existence or permission status from\n * one call to another. Thus you should not trust the returned value,\n * unless you are sure that no other processes are accessing the\n * checked resource.\n */"
 },
 "avio_open_dir": {
  "type": "int",
  "definition": "int avio_open_dir",
  "argsstring": "(AVIODirContext **s, const char *url, AVDictionary **options)",
  "name": "avio_open_dir",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIODirContext",
      "@_refid": "avio_8h_1a4cb33c20efe97c6f8de4120b098cc8a5",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "s"
   },
   {
    "type": "const char *",
    "declname": "url"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": "Open directory for reading."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "directory read context. Pointer to a NULL pointer must be passed."
       }
      },
      {
       "parameternamelist": {
        "parametername": "url"
       },
       "parameterdescription": {
        "para": "directory to be listed."
       }
      },
      {
       "parameternamelist": {
        "parametername": "options"
       },
       "parameterdescription": {
        "para": "A dictionary filled with protocol-private options. On return this parameter will be destroyed and replaced with a dictionary containing options that were not found. May be NULL."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">=0 on success or negative on error.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "342",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "342",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "list_op",
   "@_refid": "avio__list__dir_8c_1ad0826d7847655ff15d32ecb58bfc625b",
   "@_compoundref": "avio__list__dir_8c",
   "@_startline": "64",
   "@_endline": "110"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a7bb596b33ba395e488af6c0c21ca00d5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Open directory for reading.\n *\n * @param s       directory read context. Pointer to a NULL pointer must be passed.\n * @param url     directory to be listed.\n * @param options A dictionary filled with protocol-private options. On return\n *                this parameter will be destroyed and replaced with a dictionary\n *                containing options that were not found. May be NULL.\n * @return >=0 on success or negative on error.\n */"
 },
 "avio_read_dir": {
  "type": "int",
  "definition": "int avio_read_dir",
  "argsstring": "(AVIODirContext *s, AVIODirEntry **next)",
  "name": "avio_read_dir",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIODirContext",
      "@_refid": "avio_8h_1a4cb33c20efe97c6f8de4120b098cc8a5",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVIODirEntry",
      "@_refid": "structAVIODirEntry",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "next"
   }
  ],
  "briefdescription": {
   "para": "Get next directory entry."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avio_free_directory_entry()",
      "@_refid": "avio_8h_1aa0b5fe2c2243b25f770b1049a710861f",
      "@_kindref": "member"
     },
     "#text": "Returned entry must be freed with. In particular it may outlive AVIODirContext."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "directory read context."
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "next",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "next entry or NULL when no more entries."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">=0 on success or negative on error. End of list is not considered an error.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "355",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "355",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "list_op",
   "@_refid": "avio__list__dir_8c_1ad0826d7847655ff15d32ecb58bfc625b",
   "@_compoundref": "avio__list__dir_8c",
   "@_startline": "64",
   "@_endline": "110"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1addb214cfa43621ca164b14d9932af2bb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get next directory entry.\n *\n * Returned entry must be freed with avio_free_directory_entry(). In particular\n * it may outlive AVIODirContext.\n *\n * @param s         directory read context.\n * @param[out] next next entry or NULL when no more entries.\n * @return >=0 on success or negative on error. End of list is not considered an\n *             error.\n */"
 },
 "avio_close_dir": {
  "type": "int",
  "definition": "int avio_close_dir",
  "argsstring": "(AVIODirContext **s)",
  "name": "avio_close_dir",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIODirContext",
     "@_refid": "avio_8h_1a4cb33c20efe97c6f8de4120b098cc8a5",
     "@_kindref": "member"
    },
    "#text": "**"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Close directory."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": [
        {
         "#text": "avio_read_dir()",
         "@_refid": "avio_8h_1addb214cfa43621ca164b14d9932af2bb",
         "@_kindref": "member"
        },
        {
         "#text": "avio_free_directory_entry()",
         "@_refid": "avio_8h_1aa0b5fe2c2243b25f770b1049a710861f",
         "@_kindref": "member"
        }
       ],
       "#text": "Entries created usingare not deleted and must be freeded with."
      },
      "@_kind": "note"
     },
     {
      "para": ">=0 on success or negative on error.",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "s"
      },
      "parameterdescription": {
       "para": "directory read context."
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "366",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "366",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "list_op",
   "@_refid": "avio__list__dir_8c_1ad0826d7847655ff15d32ecb58bfc625b",
   "@_compoundref": "avio__list__dir_8c",
   "@_startline": "64",
   "@_endline": "110"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a62ef5c196ebb93427470e098e22268c5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Close directory.\n *\n * @note Entries created using avio_read_dir() are not deleted and must be\n * freeded with avio_free_directory_entry().\n *\n * @param s         directory read context.\n * @return >=0 on success or negative on error.\n */"
 },
 "avio_free_directory_entry": {
  "type": "void",
  "definition": "void avio_free_directory_entry",
  "argsstring": "(AVIODirEntry **entry)",
  "name": "avio_free_directory_entry",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIODirEntry",
     "@_refid": "structAVIODirEntry",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "entry"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "avio_read_dir()",
     "@_refid": "avio_8h_1addb214cfa43621ca164b14d9932af2bb",
     "@_kindref": "member"
    },
    "#text": "Free entry allocated by."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "entry"
      },
      "parameterdescription": {
       "para": "entry to be freed."
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "373",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "373",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "list_op",
   "@_refid": "avio__list__dir_8c_1ad0826d7847655ff15d32ecb58bfc625b",
   "@_compoundref": "avio__list__dir_8c",
   "@_startline": "64",
   "@_endline": "110"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1aa0b5fe2c2243b25f770b1049a710861f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free entry allocated by avio_read_dir().\n *\n * @param entry entry to be freed.\n */"
 },
 "avio_alloc_context": {
  "type": {
   "ref": {
    "#text": "AVIOContext",
    "@_refid": "structAVIOContext",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVIOContext * avio_alloc_context",
  "argsstring": "(unsigned char *buffer, int buffer_size, int write_flag, void *opaque, int(*read_packet)(void *opaque, uint8_t *buf, int buf_size), int(*write_packet)(void *opaque, const uint8_t *buf, int buf_size), int64_t(*seek)(void *opaque, int64_t offset, int whence))",
  "name": "avio_alloc_context",
  "param": [
   {
    "type": "unsigned char *",
    "declname": "buffer"
   },
   {
    "type": "int",
    "declname": "buffer_size"
   },
   {
    "type": "int",
    "declname": "write_flag"
   },
   {
    "type": "void *",
    "declname": "opaque"
   },
   {
    "type": "int(*)(void *opaque, uint8_t *buf, int buf_size)",
    "declname": "read_packet"
   },
   {
    "type": "int(*)(void *opaque, const uint8_t *buf, int buf_size)",
    "declname": "write_packet"
   },
   {
    "type": "int64_t(*)(void *opaque, int64_t offset, int whence)",
    "declname": "seek"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "Allocate and initialize anfor buffered I/O."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avio_context_free()",
      "@_refid": "avio_8h_1ad1baf8cd6711f05a45d0339cafe2d21d",
      "@_kindref": "member"
     },
     "#text": "It must be later freed with."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "buffer"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "AVIOContext",
            "@_refid": "structAVIOContext",
            "@_kindref": "compound"
           },
           {
            "#text": "av_malloc()",
            "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
            "@_kindref": "member"
           },
           {
            "#text": "AVIOContext.buffer",
            "@_refid": "structAVIOContext_1a901e8fd2b978d40957c4ed0b77c2daf0",
            "@_kindref": "member"
           },
           {
            "#text": "av_free()",
            "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
            "@_kindref": "member"
           }
          ],
          "#text": "Memory block for input/output operations via. The buffer must be allocated withand friends. It may be freed and replaced with a new buffer by libavformat.holds the buffer currently in use, which must be later freed with."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "buffer_size"
        },
        "parameterdescription": {
         "para": "The buffer size is very important for performance. For protocols with fixed blocksize it should be set to this blocksize. For others a typical size is a cache page, e.g. 4kb."
        }
       },
       {
        "parameternamelist": {
         "parametername": "write_flag"
        },
        "parameterdescription": {
         "para": "Set to 1 if the buffer should be writable, 0 otherwise."
        }
       },
       {
        "parameternamelist": {
         "parametername": "opaque"
        },
        "parameterdescription": {
         "para": "An opaque pointer to user-specific data."
        }
       },
       {
        "parameternamelist": {
         "parametername": "read_packet"
        },
        "parameterdescription": {
         "para": "A function for refilling the buffer, may be NULL. For stream protocols, must never return 0 but rather a proper AVERROR code."
        }
       },
       {
        "parameternamelist": {
         "parametername": "write_packet"
        },
        "parameterdescription": {
         "para": "A function for writing the buffer contents, may be NULL. The function may not change the input buffers content."
        }
       },
       {
        "parameternamelist": {
         "parametername": "seek"
        },
        "parameterdescription": {
         "para": "A function for seeking to specified byte position, may be NULL."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVIOContext",
        "@_refid": "structAVIOContext",
        "@_kindref": "compound"
       },
       "#text": "Allocatedor NULL on failure."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "398",
   "@_column": "13",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "398",
   "@_declcolumn": "13"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "avio__read__callback_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "avio__read__callback_8c",
   "@_startline": "58",
   "@_endline": "133"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1aa0b13300bb6b469beb1bda153d99b92b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate and initialize an AVIOContext for buffered I/O. It must be later\n * freed with avio_context_free().\n *\n * @param buffer Memory block for input/output operations via AVIOContext.\n *        The buffer must be allocated with av_malloc() and friends.\n *        It may be freed and replaced with a new buffer by libavformat.\n *        AVIOContext.buffer holds the buffer currently in use,\n *        which must be later freed with av_free().\n * @param buffer_size The buffer size is very important for performance.\n *        For protocols with fixed blocksize it should be set to this blocksize.\n *        For others a typical size is a cache page, e.g. 4kb.\n * @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.\n * @param opaque An opaque pointer to user-specific data.\n * @param read_packet  A function for refilling the buffer, may be NULL.\n *                     For stream protocols, must never return 0 but rather\n *                     a proper AVERROR code.\n * @param write_packet A function for writing the buffer contents, may be NULL.\n *        The function may not change the input buffers content.\n * @param seek A function for seeking to specified byte position, may be NULL.\n *\n * @return Allocated AVIOContext or NULL on failure.\n */"
 },
 "avio_context_free": {
  "type": "void",
  "definition": "void avio_context_free",
  "argsstring": "(AVIOContext **s)",
  "name": "avio_context_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Free the supplied IO context and everything associated with it."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "s"
      },
      "parameterdescription": {
       "para": "Double pointer to the IO context. This function will write NULL into s."
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "413",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "413",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "avio__read__callback_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "avio__read__callback_8c",
   "@_startline": "58",
   "@_endline": "133"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1ad1baf8cd6711f05a45d0339cafe2d21d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */"
 },
 "avio_w8": {
  "type": "void",
  "definition": "void avio_w8",
  "argsstring": "(AVIOContext *s, int b)",
  "name": "avio_w8",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "b"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "415",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "415",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a1dddee2b73f4dd6512ac9821cf5adc18",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */"
 },
 "avio_write": {
  "type": "void",
  "definition": "void avio_write",
  "argsstring": "(AVIOContext *s, const unsigned char *buf, int size)",
  "name": "avio_write",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "const unsigned char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "416",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "416",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1acc3626afc6aa3964b75d02811457164e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */"
 },
 "avio_wl64": {
  "type": "void",
  "definition": "void avio_wl64",
  "argsstring": "(AVIOContext *s, uint64_t val)",
  "name": "avio_wl64",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "uint64_t",
    "declname": "val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "417",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "417",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a09510d3318eda871f8b91693e2774425",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */"
 },
 "avio_wb64": {
  "type": "void",
  "definition": "void avio_wb64",
  "argsstring": "(AVIOContext *s, uint64_t val)",
  "name": "avio_wb64",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "uint64_t",
    "declname": "val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "418",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "418",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a9a88d79a1fc983c04a4e009b85361d54",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */"
 },
 "avio_wl32": {
  "type": "void",
  "definition": "void avio_wl32",
  "argsstring": "(AVIOContext *s, unsigned int val)",
  "name": "avio_wl32",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "unsigned int",
    "declname": "val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "419",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "419",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a16f2ba75f978a70f16dc55e2393f3439",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */"
 },
 "avio_wb32": {
  "type": "void",
  "definition": "void avio_wb32",
  "argsstring": "(AVIOContext *s, unsigned int val)",
  "name": "avio_wb32",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "unsigned int",
    "declname": "val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "420",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "420",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a1f2b9ee1bde6c6982072edbe929b47ea",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */"
 },
 "avio_wl24": {
  "type": "void",
  "definition": "void avio_wl24",
  "argsstring": "(AVIOContext *s, unsigned int val)",
  "name": "avio_wl24",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "unsigned int",
    "declname": "val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "421",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "421",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1aa1ceef83bd4b74280f51eba321f70273",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */"
 },
 "avio_wb24": {
  "type": "void",
  "definition": "void avio_wb24",
  "argsstring": "(AVIOContext *s, unsigned int val)",
  "name": "avio_wb24",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "unsigned int",
    "declname": "val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "422",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "422",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a81a5cfb941abfe2b83a30be4f86ad06d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */"
 },
 "avio_wl16": {
  "type": "void",
  "definition": "void avio_wl16",
  "argsstring": "(AVIOContext *s, unsigned int val)",
  "name": "avio_wl16",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "unsigned int",
    "declname": "val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "423",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "423",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a1ba843eb6d34706bbdd177a4256e71e2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */"
 },
 "avio_wb16": {
  "type": "void",
  "definition": "void avio_wb16",
  "argsstring": "(AVIOContext *s, unsigned int val)",
  "name": "avio_wb16",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "unsigned int",
    "declname": "val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "424",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "424",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a21c2d7b7ddd7f31d24d278f8b3281ec3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the supplied IO context and everything associated with it.\n *\n * @param s Double pointer to the IO context. This function will write NULL\n * into s.\n */"
 },
 "avio_put_str": {
  "type": "int",
  "definition": "int avio_put_str",
  "argsstring": "(AVIOContext *s, const char *str)",
  "name": "avio_put_str",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "const char *",
    "declname": "str"
   }
  ],
  "briefdescription": {
   "para": "Write a NULL-terminated string."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "number of bytes written.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "430",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "430",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a1d2113a3b0d7015c415897d92bd441f3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write a NULL-terminated string.\n * @return number of bytes written.\n */"
 },
 "avio_put_str16le": {
  "type": "int",
  "definition": "int avio_put_str16le",
  "argsstring": "(AVIOContext *s, const char *str)",
  "name": "avio_put_str16le",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "const char *",
    "declname": "str"
   }
  ],
  "briefdescription": {
   "para": "Convert an UTF-8 string to UTF-16LE and write it."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVIOContext",
          "@_refid": "structAVIOContext",
          "@_kindref": "compound"
         },
         "#text": "the"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "str"
       },
       "parameterdescription": {
        "para": "NULL-terminated UTF-8 string"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "number of bytes written.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "439",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "439",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a4ff718da93c106f7ba48de1cb6b010c6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert an UTF-8 string to UTF-16LE and write it.\n * @param s the AVIOContext\n * @param str NULL-terminated UTF-8 string\n *\n * @return number of bytes written.\n */"
 },
 "avio_put_str16be": {
  "type": "int",
  "definition": "int avio_put_str16be",
  "argsstring": "(AVIOContext *s, const char *str)",
  "name": "avio_put_str16be",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "const char *",
    "declname": "str"
   }
  ],
  "briefdescription": {
   "para": "Convert an UTF-8 string to UTF-16BE and write it."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVIOContext",
          "@_refid": "structAVIOContext",
          "@_kindref": "compound"
         },
         "#text": "the"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "str"
       },
       "parameterdescription": {
        "para": "NULL-terminated UTF-8 string"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "number of bytes written.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "448",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "448",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1acf3a933e43bd56dcf671a6bc0c897bda",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert an UTF-8 string to UTF-16BE and write it.\n * @param s the AVIOContext\n * @param str NULL-terminated UTF-8 string\n *\n * @return number of bytes written.\n */"
 },
 "avio_write_marker": {
  "type": "void",
  "definition": "void avio_write_marker",
  "argsstring": "(AVIOContext *s, int64_t time, enum AVIODataMarkerType type)",
  "name": "avio_write_marker",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int64_t",
    "declname": "time"
   },
   {
    "type": {
     "ref": {
      "#text": "AVIODataMarkerType",
      "@_refid": "avio_8h_1a4dbe7c0b3d5c86e46b9991ee805c5e21",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   }
  ],
  "briefdescription": {
   "para": "Mark the written bytestream as a specific type."
  },
  "detaileddescription": {
   "para": [
    "Zero-length ranges are omitted from the output.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVIOContext",
           "@_refid": "structAVIOContext",
           "@_kindref": "compound"
          },
          "#text": "the"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "time"
        },
        "parameterdescription": {
         "para": "the stream time the current bytestream pos corresponds to (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not applicable"
        }
       },
       {
        "parameternamelist": {
         "parametername": "type"
        },
        "parameterdescription": {
         "para": "the kind of data written starting at the current pos"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "461",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "461",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a03e0cde48d492b5433e136152e47cb4c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Mark the written bytestream as a specific type.\n *\n * Zero-length ranges are omitted from the output.\n *\n * @param s    the AVIOContext\n * @param time the stream time the current bytestream pos corresponds to\n *             (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not\n *             applicable\n * @param type the kind of data written starting at the current pos\n */"
 },
 "avio_seek": {
  "type": "int64_t",
  "definition": "int64_t avio_seek",
  "argsstring": "(AVIOContext *s, int64_t offset, int whence)",
  "name": "avio_seek",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int64_t",
    "declname": "offset"
   },
   {
    "type": "int",
    "declname": "whence"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "fseek() equivalent for."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "new position or AVERROR.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "482",
   "@_column": "9",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "482",
   "@_declcolumn": "9"
  },
  "referencedby": {
   "#text": "avio_tell",
   "@_refid": "avio_8h_1a63157a668f29b8f5a89f00bc24838b8e",
   "@_compoundref": "avio_8h",
   "@_startline": "494",
   "@_endline": "497"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a03e23bf0144030961c34e803c71f614f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * fseek() equivalent for AVIOContext.\n * @return new position or AVERROR.\n */"
 },
 "avio_skip": {
  "type": "int64_t",
  "definition": "int64_t avio_skip",
  "argsstring": "(AVIOContext *s, int64_t offset)",
  "name": "avio_skip",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "int64_t",
    "declname": "offset"
   }
  ],
  "briefdescription": {
   "para": "Skip given number of bytes forward."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "new position or AVERROR.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "488",
   "@_column": "9",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "488",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1aa22e02f986ea8a8dc018f9615af27eea",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Skip given number of bytes forward\n * @return new position or AVERROR.\n */"
 },
 "avio_tell": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "int64_t"
  },
  "definition": "static av_always_inline int64_t avio_tell",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_tell",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "ftell() equivalent for."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "position or AVERROR.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "494",
   "@_column": "33",
   "@_bodyfile": "libavformat/avio.h",
   "@_bodystart": "494",
   "@_bodyend": "497"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a63157a668f29b8f5a89f00bc24838b8e",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * ftell() equivalent for AVIOContext.\n * @return position or AVERROR.\n */"
 },
 "avio_size": {
  "type": "int64_t",
  "definition": "int64_t avio_size",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_size",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Get the filesize."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "filesize or AVERROR",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "503",
   "@_column": "9",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "503",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a375f057e315dd2273579555128a070fb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the filesize.\n * @return filesize or AVERROR\n */"
 },
 "avio_feof": {
  "type": "int",
  "definition": "int avio_feof",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_feof",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Similar to feof() but also returns nonzero on read errors."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "non zero if and only if at end of file or a read error happened when reading.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "509",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "509",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a4db704ed3d00a4be632dad1585d01d92",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Similar to feof() but also returns nonzero on read errors.\n * @return non zero if and only if at end of file or a read error happened when reading.\n */"
 },
 "avio_vprintf": {
  "type": "int",
  "definition": "int avio_vprintf",
  "argsstring": "(AVIOContext *s, const char *fmt, va_list ap)",
  "name": "avio_vprintf",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "va_list",
    "declname": "ap"
   }
  ],
  "briefdescription": {
   "para": "Writes a formatted string to the context taking a va_list."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "number of bytes written, < 0 on error.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "515",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "515",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a21085689eb37a62660174da27803c790",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Writes a formatted string to the context taking a va_list.\n * @return number of bytes written, < 0 on error.\n */"
 },
 "avio_printf": {
  "type": "int",
  "definition": "int avio_printf",
  "argsstring": "(AVIOContext *s, const char *fmt,...) av_printf_format(2",
  "name": "avio_printf",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "..."
   }
  ],
  "briefdescription": {
   "para": "Writes a formatted string to the context."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "number of bytes written, < 0 on error.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "521",
   "@_column": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a79127cec97b09a308b549253119ff38f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Writes a formatted string to the context.\n * @return number of bytes written, < 0 on error.\n */"
 },
 "avio_print_string_array": {
  "type": "int void",
  "definition": "int void avio_print_string_array",
  "argsstring": "(AVIOContext *s, const char *const strings[])",
  "name": "avio_print_string_array",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "const char *const",
    "declname": "strings",
    "array": "[]"
   }
  ],
  "briefdescription": {
   "para": "Write a NULL terminated array of strings to the context."
  },
  "detaileddescription": {
   "para": "Usually you don't need to use this function directly but its macro wrapper, avio_print."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "528",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "528",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a267534f263ae1923c926f3cca0e1cf16",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write a NULL terminated array of strings to the context.\n * Usually you don't need to use this function directly but its macro wrapper,\n * avio_print.\n */"
 },
 "avio_flush": {
  "type": "void",
  "definition": "void avio_flush",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_flush",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Force flushing of buffered data."
  },
  "detaileddescription": {
   "para": [
    "For write streams, force the buffered data to be immediately written to the output, without to wait to fill the internal buffer.",
    "For read streams, discard all currently buffered data, and advance the reported file position to that of the underlying stream. This does not read new data, and does not perform any seeks."
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "550",
   "@_column": "6",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "550",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1ad88b866a118c17c95663f7782b2e8946",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Force flushing of buffered data.\n *\n * For write streams, force the buffered data to be immediately written to the output,\n * without to wait to fill the internal buffer.\n *\n * For read streams, discard all currently buffered data, and advance the\n * reported file position to that of the underlying stream. This does not\n * read new data, and does not perform any seeks.\n */"
 },
 "avio_read": {
  "type": "int",
  "definition": "int avio_read",
  "argsstring": "(AVIOContext *s, unsigned char *buf, int size)",
  "name": "avio_read",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "unsigned char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "Read size bytes frominto buf."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "number of bytes read or AVERROR",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "556",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "556",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1abb4e58439be0bff0dc2e2974ee5fb6a3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read size bytes from AVIOContext into buf.\n * @return number of bytes read or AVERROR\n */"
 },
 "avio_read_partial": {
  "type": "int",
  "definition": "int avio_read_partial",
  "argsstring": "(AVIOContext *s, unsigned char *buf, int size)",
  "name": "avio_read_partial",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "unsigned char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "Read size bytes frominto buf."
   }
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "avio_read()",
     "@_refid": "avio_8h_1abb4e58439be0bff0dc2e2974ee5fb6a3",
     "@_kindref": "member"
    },
    "simplesect": {
     "para": "number of bytes read or AVERROR",
     "@_kind": "return"
    },
    "#text": "Unlike, this is allowed to read fewer bytes than requested. The missing bytes can be read in the next call. This always tries to read at least 1 byte. Useful to reduce latency in certain cases."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "565",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "565",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a53843d2cbe6282d994fcf59c03d59294",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read size bytes from AVIOContext into buf. Unlike avio_read(), this is allowed\n * to read fewer bytes than requested. The missing bytes can be read in the next\n * call. This always tries to read at least 1 byte.\n * Useful to reduce latency in certain cases.\n * @return number of bytes read or AVERROR\n */"
 },
 "avio_get_str": {
  "type": "int",
  "definition": "int avio_get_str",
  "argsstring": "(AVIOContext *pb, int maxlen, char *buf, int buflen)",
  "name": "avio_get_str",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pb"
   },
   {
    "type": "int",
    "declname": "maxlen"
   },
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buflen"
   }
  ],
  "briefdescription": {
   "para": "Read a string from pb into buf."
  },
  "detaileddescription": {
   "para": [
    "The reading will terminate when either a NULL character was encountered, maxlen bytes have been read, or nothing more can be read from pb. The result is guaranteed to be NULL-terminated, it will be truncated if buf is too small. Note that the string is not interpreted or validated in any way, it might get truncated in the middle of a sequence for multi-byte encodings.",
    {
     "simplesect": {
      "para": "number of bytes read (is always <= maxlen). If reading ends on EOF or error, the return value will be one more than bytes actually read.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "599",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "599",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1abeee0414e5f2ce5b150cf9c5694a2e4f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read a string from pb into buf. The reading will terminate when either\n * a NULL character was encountered, maxlen bytes have been read, or nothing\n * more can be read from pb. The result is guaranteed to be NULL-terminated, it\n * will be truncated if buf is too small.\n * Note that the string is not interpreted or validated in any way, it\n * might get truncated in the middle of a sequence for multi-byte encodings.\n *\n * @return number of bytes read (is always <= maxlen).\n * If reading ends on EOF or error, the return value will be one more than\n * bytes actually read.\n */"
 },
 "avio_get_str16le": {
  "type": "int",
  "definition": "int avio_get_str16le",
  "argsstring": "(AVIOContext *pb, int maxlen, char *buf, int buflen)",
  "name": "avio_get_str16le",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pb"
   },
   {
    "type": "int",
    "declname": "maxlen"
   },
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buflen"
   }
  ],
  "briefdescription": {
   "para": "Read a UTF-16 string from pb and convert it to UTF-8."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "number of bytes read (is always <= maxlen)",
     "@_kind": "return"
    },
    "#text": "The reading will terminate when either a null or invalid character was encountered or maxlen bytes have been read."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "607",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "607",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a39507bbc53328eae98ac7d683078fcf1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read a UTF-16 string from pb and convert it to UTF-8.\n * The reading will terminate when either a null or invalid character was\n * encountered or maxlen bytes have been read.\n * @return number of bytes read (is always <= maxlen)\n */"
 },
 "avio_get_str16be": {
  "type": "int",
  "definition": "int avio_get_str16be",
  "argsstring": "(AVIOContext *pb, int maxlen, char *buf, int buflen)",
  "name": "avio_get_str16be",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pb"
   },
   {
    "type": "int",
    "declname": "maxlen"
   },
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buflen"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "608",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "608",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a02be750099c47406eb68b50d75a01bdd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read a UTF-16 string from pb and convert it to UTF-8.\n * The reading will terminate when either a null or invalid character was\n * encountered or maxlen bytes have been read.\n * @return number of bytes read (is always <= maxlen)\n */"
 },
 "avio_open": {
  "type": "int",
  "definition": "int avio_open",
  "argsstring": "(AVIOContext **s, const char *url, int flags)",
  "name": "avio_open",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "s"
   },
   {
    "type": "const char *",
    "declname": "url"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "Create and initialize afor accessing the resource indicated by url."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "AVIOContext",
        "@_refid": "structAVIOContext",
        "@_kindref": "compound"
       },
       "#text": "When the resource indicated by url has been opened in read+write mode, thecan be used only for writing."
      },
      "@_kind": "note"
     },
     {
      "para": ">= 0 in case of success, a negative value corresponding to an AVERROR code in case of failure",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVIOContext",
          "@_refid": "structAVIOContext",
          "@_kindref": "compound"
         },
         "#text": "Used to return the pointer to the created. In case of failure the pointed to value is set to NULL."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "url"
       },
       "parameterdescription": {
        "para": "resource to access"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "flags which control how the resource indicated by url is to be opened"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "660",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "660",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "mux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "mux_8c",
    "@_startline": "534",
    "@_endline": "643"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   }
  ],
  "@_kind": "function",
  "@_id": "avio_8h_1a371a670112abc5f3e15bc570da076301",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create and initialize a AVIOContext for accessing the\n * resource indicated by url.\n * @note When the resource indicated by url has been opened in\n * read+write mode, the AVIOContext can be used only for writing.\n *\n * @param s Used to return the pointer to the created AVIOContext.\n * In case of failure the pointed to value is set to NULL.\n * @param url resource to access\n * @param flags flags which control how the resource indicated by url\n * is to be opened\n * @return >= 0 in case of success, a negative value corresponding to an\n * AVERROR code in case of failure\n */"
 },
 "avio_open2": {
  "type": "int",
  "definition": "int avio_open2",
  "argsstring": "(AVIOContext **s, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)",
  "name": "avio_open2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "s"
   },
   {
    "type": "const char *",
    "declname": "url"
   },
   {
    "type": "int",
    "declname": "flags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVIOInterruptCB",
      "@_refid": "structAVIOInterruptCB",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "int_cb"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "Create and initialize afor accessing the resource indicated by url."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "AVIOContext",
        "@_refid": "structAVIOContext",
        "@_kindref": "compound"
       },
       "#text": "When the resource indicated by url has been opened in read+write mode, thecan be used only for writing."
      },
      "@_kind": "note"
     },
     {
      "para": ">= 0 in case of success, a negative value corresponding to an AVERROR code in case of failure",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVIOContext",
          "@_refid": "structAVIOContext",
          "@_kindref": "compound"
         },
         "#text": "Used to return the pointer to the created. In case of failure the pointed to value is set to NULL."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "url"
       },
       "parameterdescription": {
        "para": "resource to access"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "flags which control how the resource indicated by url is to be opened"
       }
      },
      {
       "parameternamelist": {
        "parametername": "int_cb"
       },
       "parameterdescription": {
        "para": "an interrupt callback to be used at the protocols level"
       }
      },
      {
       "parameternamelist": {
        "parametername": "options"
       },
       "parameterdescription": {
        "para": "A dictionary filled with protocol-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL."
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "680",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "680",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1ade8a63980569494c99593ebf0d1e891b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create and initialize a AVIOContext for accessing the\n * resource indicated by url.\n * @note When the resource indicated by url has been opened in\n * read+write mode, the AVIOContext can be used only for writing.\n *\n * @param s Used to return the pointer to the created AVIOContext.\n * In case of failure the pointed to value is set to NULL.\n * @param url resource to access\n * @param flags flags which control how the resource indicated by url\n * is to be opened\n * @param int_cb an interrupt callback to be used at the protocols level\n * @param options  A dictionary filled with protocol-private options. On return\n * this parameter will be destroyed and replaced with a dict containing options\n * that were not found. May be NULL.\n * @return >= 0 in case of success, a negative value corresponding to an\n * AVERROR code in case of failure\n */"
 },
 "avio_close": {
  "type": "int",
  "definition": "int avio_close",
  "argsstring": "(AVIOContext *s)",
  "name": "avio_close",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "Close the resource accessed by thes and free it."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avio_open()",
      "@_refid": "avio_8h_1a371a670112abc5f3e15bc570da076301",
      "@_kindref": "member"
     },
     "#text": "This function can only be used if s was opened by."
    },
    "The internal buffer is automatically flushed before closing the resource.",
    {
     "simplesect": [
      {
       "para": "0 on success, an AVERROR < 0 on error.",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "avio_closep",
         "@_refid": "avio_8h_1ae118a1f37f1e48617609ead9910aac15",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "693",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "693",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1ad71cada104a5e4365d35d45669ea03ca",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Close the resource accessed by the AVIOContext s and free it.\n * This function can only be used if s was opened by avio_open().\n *\n * The internal buffer is automatically flushed before closing the\n * resource.\n *\n * @return 0 on success, an AVERROR < 0 on error.\n * @see avio_closep\n */"
 },
 "avio_closep": {
  "type": "int",
  "definition": "int avio_closep",
  "argsstring": "(AVIOContext **s)",
  "name": "avio_closep",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "Close the resource accessed by the*s, free it and set the pointer pointing to it to NULL."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avio_open()",
      "@_refid": "avio_8h_1a371a670112abc5f3e15bc570da076301",
      "@_kindref": "member"
     },
     "#text": "This function can only be used if s was opened by."
    },
    "The internal buffer is automatically flushed before closing the resource.",
    {
     "simplesect": [
      {
       "para": "0 on success, an AVERROR < 0 on error.",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "avio_close",
         "@_refid": "avio_8h_1ad71cada104a5e4365d35d45669ea03ca",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "706",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "706",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "mux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "mux_8c",
    "@_startline": "534",
    "@_endline": "643"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode__aac_8c_1a617f4760254c119fc7caa222f3fcbd21",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "145",
    "@_endline": "246"
   }
  ],
  "@_kind": "function",
  "@_id": "avio_8h_1ae118a1f37f1e48617609ead9910aac15",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Close the resource accessed by the AVIOContext *s, free it\n * and set the pointer pointing to it to NULL.\n * This function can only be used if s was opened by avio_open().\n *\n * The internal buffer is automatically flushed before closing the\n * resource.\n *\n * @return 0 on success, an AVERROR < 0 on error.\n * @see avio_close\n */"
 },
 "avio_open_dyn_buf": {
  "type": "int",
  "definition": "int avio_open_dyn_buf",
  "argsstring": "(AVIOContext **s)",
  "name": "avio_open_dyn_buf",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Open a write only memory stream."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "s"
      },
      "parameterdescription": {
       "para": "new IO context"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "zero if no error.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "715",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "715",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1adb5259ad07633518173eaa47fe6575e2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Open a write only memory stream.\n *\n * @param s new IO context\n * @return zero if no error.\n */"
 },
 "avio_get_dyn_buf": {
  "type": "int",
  "definition": "int avio_get_dyn_buf",
  "argsstring": "(AVIOContext *s, uint8_t **pbuffer)",
  "name": "avio_get_dyn_buf",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "uint8_t **",
    "declname": "pbuffer"
   }
  ],
  "briefdescription": {
   "para": "Return the written size and a pointer to the buffer."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "Thestream is left intact. The buffer must NOT be freed. No padding is added to the buffer."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "IO context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pbuffer"
        },
        "parameterdescription": {
         "para": "pointer to a byte buffer"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the length of the byte buffer",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "727",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "727",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1af2d626b0d21721fdc91ac20b5664cf5f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the written size and a pointer to the buffer.\n * The AVIOContext stream is left intact.\n * The buffer must NOT be freed.\n * No padding is added to the buffer.\n *\n * @param s IO context\n * @param pbuffer pointer to a byte buffer\n * @return the length of the byte buffer\n */"
 },
 "avio_close_dyn_buf": {
  "type": "int",
  "definition": "int avio_close_dyn_buf",
  "argsstring": "(AVIOContext *s, uint8_t **pbuffer)",
  "name": "avio_close_dyn_buf",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "uint8_t **",
    "declname": "pbuffer"
   }
  ],
  "briefdescription": {
   "para": "Return the written size and a pointer to the buffer."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_free()",
      "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
      "@_kindref": "member"
     },
     "#text": "The buffer must be freed with. Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "IO context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pbuffer"
        },
        "parameterdescription": {
         "para": "pointer to a byte buffer"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the length of the byte buffer",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "738",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "738",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a8faed62ce72e7411cbea2356494af8ce",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the written size and a pointer to the buffer. The buffer\n * must be freed with av_free().\n * Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.\n *\n * @param s IO context\n * @param pbuffer pointer to a byte buffer\n * @return the length of the byte buffer\n */"
 },
 "avio_enum_protocols": {
  "type": "const char *",
  "definition": "const char * avio_enum_protocols",
  "argsstring": "(void **opaque, int output)",
  "name": "avio_enum_protocols",
  "param": [
   {
    "type": "void **",
    "declname": "opaque"
   },
   {
    "type": "int",
    "declname": "output"
   }
  ],
  "briefdescription": {
   "para": "Iterate through names of available protocols."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "opaque"
       },
       "parameterdescription": {
        "para": "A private pointer representing current protocol. It must be a pointer to NULL on first iteration and will be updated by successive calls to avio_enum_protocols."
       }
      },
      {
       "parameternamelist": {
        "parametername": "output"
       },
       "parameterdescription": {
        "para": "If set to 1, iterate over output protocols, otherwise over input protocols."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "A static string containing the name of current protocol or NULL",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "751",
   "@_column": "12",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "751",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a8650292e381eb84d0c232fe50d217ef5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate through names of available protocols.\n *\n * @param opaque A private pointer representing current protocol.\n *        It must be a pointer to NULL on first iteration and will\n *        be updated by successive calls to avio_enum_protocols.\n * @param output If set to 1, iterate over output protocols,\n *               otherwise over input protocols.\n *\n * @return A static string containing the name of current protocol or NULL\n */"
 },
 "avio_protocol_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * avio_protocol_get_class",
  "argsstring": "(const char *name)",
  "name": "avio_protocol_get_class",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVClass",
     "@_refid": "structAVClass",
     "@_kindref": "compound"
    },
    "#text": "Getby names of available protocols."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVClass",
       "@_refid": "structAVClass",
       "@_kindref": "compound"
      },
      "#text": "Aof input protocol name or NULL"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "758",
   "@_column": "15",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "758",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a6a1c8839820aba4a7b726971811163f8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get AVClass by names of available protocols.\n *\n * @return A AVClass of input protocol name or NULL\n */"
 },
 "avio_pause": {
  "type": "int",
  "definition": "int avio_pause",
  "argsstring": "(AVIOContext *h, int pause)",
  "name": "avio_pause",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "h"
   },
   {
    "type": "int",
    "declname": "pause"
   }
  ],
  "briefdescription": {
   "para": "Pause and resume playing - only meaningful if using a network streaming protocol (e.g."
  },
  "detaileddescription": {
   "para": [
    "MMS).",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "h"
        },
        "parameterdescription": {
         "para": "IO context from which to call the read_pause function pointer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pause"
        },
        "parameterdescription": {
         "para": "1 for pause, 0 for resume"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "767",
   "@_column": "9",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "767",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a1ac23b54d5f5bbfee4353978d313e472",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Pause and resume playing - only meaningful if using a network streaming\n * protocol (e.g. MMS).\n *\n * @param h     IO context from which to call the read_pause function pointer\n * @param pause 1 for pause, 0 for resume\n */"
 },
 "avio_seek_time": {
  "type": "int64_t",
  "definition": "int64_t avio_seek_time",
  "argsstring": "(AVIOContext *h, int stream_index, int64_t timestamp, int flags)",
  "name": "avio_seek_time",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "h"
   },
   {
    "type": "int",
    "declname": "stream_index"
   },
   {
    "type": "int64_t",
    "declname": "timestamp"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Seek to a given timestamp relative to some component stream."
  },
  "detaileddescription": {
   "para": [
    "Only meaningful if using a network streaming protocol (e.g. MMS.).",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "h"
        },
        "parameterdescription": {
         "para": "IO context from which to call the seek function pointers"
        }
       },
       {
        "parameternamelist": {
         "parametername": "stream_index"
        },
        "parameterdescription": {
         "para": "The stream index that the timestamp is relative to. If stream_index is (-1) the timestamp should be in AV_TIME_BASE units from the beginning of the presentation. If a stream_index >= 0 is used and the protocol does not support seeking based on component streams, the call will fail."
        }
       },
       {
        "parameternamelist": {
         "parametername": "timestamp"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVStream.time_base",
           "@_refid": "structAVStream_1a9db755451f14e2bf590d4b85d82b32e6",
           "@_kindref": "member"
          },
          "#text": "timestamp inunits or if there is no stream specified then in AV_TIME_BASE units."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE and AVSEEK_FLAG_ANY. The protocol may silently ignore AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will fail if used and not supported."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": ">= 0 on success",
       "@_kind": "return"
      },
      {
       "para": "AVInputFormat::read_seek",
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "788",
   "@_column": "9",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "788",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1adbdec54e1897c66b8c8bc43ce0063187",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Seek to a given timestamp relative to some component stream.\n * Only meaningful if using a network streaming protocol (e.g. MMS.).\n *\n * @param h IO context from which to call the seek function pointers\n * @param stream_index The stream index that the timestamp is relative to.\n *        If stream_index is (-1) the timestamp should be in AV_TIME_BASE\n *        units from the beginning of the presentation.\n *        If a stream_index >= 0 is used and the protocol does not support\n *        seeking based on component streams, the call will fail.\n * @param timestamp timestamp in AVStream.time_base units\n *        or if there is no stream specified then in AV_TIME_BASE units.\n * @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE\n *        and AVSEEK_FLAG_ANY. The protocol may silently ignore\n *        AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will\n *        fail if used and not supported.\n * @return >= 0 on success\n * @see AVInputFormat::read_seek\n */"
 },
 "avio_read_to_bprint": {
  "type": "int",
  "definition": "int avio_read_to_bprint",
  "argsstring": "(AVIOContext *h, struct AVBPrint *pb, size_t max_size)",
  "name": "avio_read_to_bprint",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "h"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "pb"
   },
   {
    "type": "size_t",
    "declname": "max_size"
   }
  ],
  "briefdescription": {
   "para": "Read contents of h into print buffer, up to max_size bytes, or up to EOF."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "0 for success (max_size bytes read or EOF reached), negative error code otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "800",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "800",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1ae8ad73c8ea7e4a2a541e134f762793a6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read contents of h into print buffer, up to max_size bytes, or up to EOF.\n *\n * @return 0 for success (max_size bytes read or EOF reached), negative error\n * code otherwise\n */"
 },
 "avio_accept": {
  "type": "int",
  "definition": "int avio_accept",
  "argsstring": "(AVIOContext *s, AVIOContext **c)",
  "name": "avio_accept",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": {
     "ref": {
      "#text": "AVIOContext",
      "@_refid": "structAVIOContext",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "c"
   }
  ],
  "briefdescription": {
   "para": "Accept and allocate a client context on a server context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "the server context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "c"
       },
       "parameterdescription": {
        "para": "the client context, must be unallocated"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 on success or a negative value corresponding to an AVERROR on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "809",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "809",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a8b215e623f0bfa7222c25370fa5f25ed",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Accept and allocate a client context on a server context.\n * @param  s the server context\n * @param  c the client context, must be unallocated\n * @return   >= 0 on success or a negative value corresponding\n *           to an AVERROR on failure\n */"
 },
 "avio_handshake": {
  "type": "int",
  "definition": "int avio_handshake",
  "argsstring": "(AVIOContext *c)",
  "name": "avio_handshake",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIOContext",
     "@_refid": "structAVIOContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "c"
  },
  "briefdescription": {
   "para": "Perform one step of the protocol handshake to accept a new client."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "avio_accept()",
       "@_refid": "avio_8h_1a8b215e623f0bfa7222c25370fa5f25ed",
       "@_kindref": "member"
      },
      {
       "#text": "avio_accept()",
       "@_refid": "avio_8h_1a8b215e623f0bfa7222c25370fa5f25ed",
       "@_kindref": "member"
      },
      {
       "#text": "avio_handshake()",
       "@_refid": "avio_8h_1a0ae35a9c4eee41a0c7cdcc07252d8ed3",
       "@_kindref": "member"
      }
     ],
     "#text": "This function must be called on a client returned bybefore using it as a read/write context. It is separate frombecause it may block. A step of the handshake is defined by places where the application may decide to change the proceedings. For example, on a protocol with a request header and a reply header, each one can constitute a step because the application may use the parameters from the request to change parameters in the reply; or each individual chunk of the request can constitute a step. If the handshake is already finished,does nothing and returns 0 immediately."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "c"
       },
       "parameterdescription": {
        "para": "the client context to perform the handshake on"
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on a complete and successful handshake > 0 if the handshake progressed, but is not complete < 0 for an AVERROR code",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavformat/avio.h",
   "@_line": "830",
   "@_column": "5",
   "@_declfile": "libavformat/avio.h",
   "@_declline": "830",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "avio_8h_1a0ae35a9c4eee41a0c7cdcc07252d8ed3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Perform one step of the protocol handshake to accept a new client.\n * This function must be called on a client returned by avio_accept() before\n * using it as a read/write context.\n * It is separate from avio_accept() because it may block.\n * A step of the handshake is defined by places where the application may\n * decide to change the proceedings.\n * For example, on a protocol with a request header and a reply header, each\n * one can constitute a step because the application may use the parameters\n * from the request to change parameters in the reply; or each individual\n * chunk of the request can constitute a step.\n * If the handshake is already finished, avio_handshake() does nothing and\n * returns 0 immediately.\n *\n * @param  c the client context to perform the handshake on\n * @return   0   on a complete and successful handshake\n *           > 0 if the handshake progressed, but is not complete\n *           < 0 for an AVERROR code\n */"
 },
 "av_strstart": {
  "type": "int",
  "definition": "int av_strstart",
  "argsstring": "(const char *str, const char *pfx, const char **ptr)",
  "name": "av_strstart",
  "param": [
   {
    "type": "const char *",
    "declname": "str"
   },
   {
    "type": "const char *",
    "declname": "pfx"
   },
   {
    "type": "const char **",
    "declname": "ptr"
   }
  ],
  "briefdescription": {
   "para": "Return non-zero if pfx is a prefix of str."
  },
  "detaileddescription": {
   "para": [
    "If it is, *ptr is set to the address of the first character in str after the prefix.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "str"
        },
        "parameterdescription": {
         "para": "input string"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pfx"
        },
        "parameterdescription": {
         "para": "prefix to test"
        }
       },
       {
        "parameternamelist": {
         "parametername": "ptr"
        },
        "parameterdescription": {
         "para": "updated if the prefix is matched inside str"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "non-zero if the prefix matches, zero otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "42",
   "@_column": "5",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "42",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga6135a12628e2b6a63c8d3d9b3a742b06",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return non-zero if pfx is a prefix of str. If it is, *ptr is set to\n * the address of the first character in str after the prefix.\n *\n * @param str input string\n * @param pfx prefix to test\n * @param ptr updated if the prefix is matched inside str\n * @return non-zero if the prefix matches, zero otherwise\n */"
 },
 "av_stristart": {
  "type": "int",
  "definition": "int av_stristart",
  "argsstring": "(const char *str, const char *pfx, const char **ptr)",
  "name": "av_stristart",
  "param": [
   {
    "type": "const char *",
    "declname": "str"
   },
   {
    "type": "const char *",
    "declname": "pfx"
   },
   {
    "type": "const char **",
    "declname": "ptr"
   }
  ],
  "briefdescription": {
   "para": "Return non-zero if pfx is a prefix of str independent of case."
  },
  "detaileddescription": {
   "para": [
    "If it is, *ptr is set to the address of the first character in str after the prefix.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "str"
        },
        "parameterdescription": {
         "para": "input string"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pfx"
        },
        "parameterdescription": {
         "para": "prefix to test"
        }
       },
       {
        "parameternamelist": {
         "parametername": "ptr"
        },
        "parameterdescription": {
         "para": "updated if the prefix is matched inside str"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "non-zero if the prefix matches, zero otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "54",
   "@_column": "5",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "54",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1gacd29ff1f7e62230a113c88fa10d3f5b9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return non-zero if pfx is a prefix of str independent of case. If\n * it is, *ptr is set to the address of the first character in str\n * after the prefix.\n *\n * @param str input string\n * @param pfx prefix to test\n * @param ptr updated if the prefix is matched inside str\n * @return non-zero if the prefix matches, zero otherwise\n */"
 },
 "av_stristr": {
  "type": "char *",
  "definition": "char * av_stristr",
  "argsstring": "(const char *haystack, const char *needle)",
  "name": "av_stristr",
  "param": [
   {
    "type": "const char *",
    "declname": "haystack"
   },
   {
    "type": "const char *",
    "declname": "needle"
   }
  ],
  "briefdescription": {
   "para": "Locate the first case-independent occurrence in the string haystack of the string needle."
  },
  "detaileddescription": {
   "para": [
    "A zero-length string needle is considered to match at the start of haystack.",
    "This function is a case-insensitive version of the standard strstr().",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "haystack"
        },
        "parameterdescription": {
         "para": "string to search in"
        }
       },
       {
        "parameternamelist": {
         "parametername": "needle"
        },
        "parameterdescription": {
         "para": "string to search for"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "pointer to the located match within haystack or a null pointer if no match",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "68",
   "@_column": "6",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "68",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga212bbbe34af302a7f79015e318f68355",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Locate the first case-independent occurrence in the string haystack\n * of the string needle.  A zero-length string needle is considered to\n * match at the start of haystack.\n *\n * This function is a case-insensitive version of the standard strstr().\n *\n * @param haystack string to search in\n * @param needle   string to search for\n * @return         pointer to the located match within haystack\n *                 or a null pointer if no match\n */"
 },
 "av_strnstr": {
  "type": "char *",
  "definition": "char * av_strnstr",
  "argsstring": "(const char *haystack, const char *needle, size_t hay_length)",
  "name": "av_strnstr",
  "param": [
   {
    "type": "const char *",
    "declname": "haystack"
   },
   {
    "type": "const char *",
    "declname": "needle"
   },
   {
    "type": "size_t",
    "declname": "hay_length"
   }
  ],
  "briefdescription": {
   "para": "Locate the first occurrence of the string needle in the string haystack where not more than hay_length characters are searched."
  },
  "detaileddescription": {
   "para": [
    "A zero-length string needle is considered to match at the start of haystack.",
    "This function is a length-limited version of the standard strstr().",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "haystack"
        },
        "parameterdescription": {
         "para": "string to search in"
        }
       },
       {
        "parameternamelist": {
         "parametername": "needle"
        },
        "parameterdescription": {
         "para": "string to search for"
        }
       },
       {
        "parameternamelist": {
         "parametername": "hay_length"
        },
        "parameterdescription": {
         "para": "length of string to search in"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "pointer to the located match within haystack or a null pointer if no match",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "83",
   "@_column": "6",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "83",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga7172d42365c9a94c3323a037d36db01a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Locate the first occurrence of the string needle in the string haystack\n * where not more than hay_length characters are searched. A zero-length\n * string needle is considered to match at the start of haystack.\n *\n * This function is a length-limited version of the standard strstr().\n *\n * @param haystack   string to search in\n * @param needle     string to search for\n * @param hay_length length of string to search in\n * @return           pointer to the located match within haystack\n *                   or a null pointer if no match\n */"
 },
 "av_strlcpy": {
  "type": "size_t",
  "definition": "size_t av_strlcpy",
  "argsstring": "(char *dst, const char *src, size_t size)",
  "name": "av_strlcpy",
  "param": [
   {
    "type": "char *",
    "declname": "dst"
   },
   {
    "type": "const char *",
    "declname": "src"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Copy the string src to dst, but no more than size - 1 bytes, and null-terminate dst."
  },
  "detaileddescription": {
   "para": [
    "This function is the same as BSD strlcpy().",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "destination buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "source string"
        }
       },
       {
        "parameternamelist": {
         "parametername": "size"
        },
        "parameterdescription": {
         "para": "size of destination buffer"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "the length of src",
       "@_kind": "return"
      },
      {
       "para": {
        "emphasis": "must",
        "#text": "since the return value is the length of src, src absolutelybe a properly 0-terminated string, otherwise this will read beyond the end of the buffer and possibly crash."
       },
       "@_kind": "warning"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "100",
   "@_column": "8",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "100",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga716447ae73b612bcf3a405b9b4608f6c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy the string src to dst, but no more than size - 1 bytes, and\n * null-terminate dst.\n *\n * This function is the same as BSD strlcpy().\n *\n * @param dst destination buffer\n * @param src source string\n * @param size size of destination buffer\n * @return the length of src\n *\n * @warning since the return value is the length of src, src absolutely\n * _must_ be a properly 0-terminated string, otherwise this will read beyond\n * the end of the buffer and possibly crash.\n */"
 },
 "av_strlcat": {
  "type": "size_t",
  "definition": "size_t av_strlcat",
  "argsstring": "(char *dst, const char *src, size_t size)",
  "name": "av_strlcat",
  "param": [
   {
    "type": "char *",
    "declname": "dst"
   },
   {
    "type": "const char *",
    "declname": "src"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Append the string src to the string dst, but to a total length of no more than size - 1 bytes, and null-terminate dst."
  },
  "detaileddescription": {
   "para": [
    "This function is similar to BSD strlcat(), but differs when size <= strlen(dst).",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "destination buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "source string"
        }
       },
       {
        "parameternamelist": {
         "parametername": "size"
        },
        "parameterdescription": {
         "para": "size of destination buffer"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "the total length of src and dst",
       "@_kind": "return"
      },
      {
       "para": {
        "emphasis": "must",
        "#text": "since the return value use the length of src and dst, these absolutelybe a properly 0-terminated strings, otherwise this will read beyond the end of the buffer and possibly crash."
       },
       "@_kind": "warning"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "118",
   "@_column": "8",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "118",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga193877ba459faf314c3d285b6082cf73",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Append the string src to the string dst, but to a total length of\n * no more than size - 1 bytes, and null-terminate dst.\n *\n * This function is similar to BSD strlcat(), but differs when\n * size <= strlen(dst).\n *\n * @param dst destination buffer\n * @param src source string\n * @param size size of destination buffer\n * @return the total length of src and dst\n *\n * @warning since the return value use the length of src and dst, these\n * absolutely _must_ be a properly 0-terminated strings, otherwise this\n * will read beyond the end of the buffer and possibly crash.\n */"
 },
 "av_strlcatf": {
  "type": "size_t",
  "definition": "size_t av_strlcatf",
  "argsstring": "(char *dst, size_t size, const char *fmt,...) av_printf_format(3",
  "name": "av_strlcatf",
  "param": [
   {
    "type": "char *",
    "declname": "dst"
   },
   {
    "type": "size_t",
    "declname": "size"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "..."
   }
  ],
  "briefdescription": {
   "para": "Append output to a string, according to a format."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination buffer (string to which the output is appended)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "total size of the destination buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "fmt"
       },
       "parameterdescription": {
        "para": "printf-compatible format string, specifying how the following parameters are used"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the length of the string that would have been generated if enough space had been available",
     "@_kind": "return"
    },
    "#text": "Never write out of the destination buffer, and always put a terminating 0 within the buffer."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "132",
   "@_column": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1gae264e2caf6ad1ca830ce3f2b49abdf50",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Append output to a string, according to a format. Never write out of\n * the destination buffer, and always put a terminating 0 within\n * the buffer.\n * @param dst destination buffer (string to which the output is\n *  appended)\n * @param size total size of the destination buffer\n * @param fmt printf-compatible format string, specifying how the\n *  following parameters are used\n * @return the length of the string that would have been generated\n *  if enough space had been available\n */"
 },
 "av_strnlen": {
  "type": "size_t static size_t",
  "definition": "size_t static size_t av_strnlen",
  "argsstring": "(const char *s, size_t len)",
  "name": "av_strnlen",
  "param": [
   {
    "type": "const char *",
    "declname": "s"
   },
   {
    "type": "size_t",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Get the count of continuous non zero chars starting from the beginning."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "the string whose length to count"
       }
      },
      {
       "parameternamelist": {
        "parametername": "len"
       },
       "parameterdescription": {
        "para": "maximum number of characters to check in the string, that is the maximum value which is returned by the function"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "141",
   "@_column": "22",
   "@_bodyfile": "libavutil/avstring.h",
   "@_bodystart": "141",
   "@_bodyend": "147"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga1cb2a3929575d28a415dc02b917ecc01",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the count of continuous non zero chars starting from the beginning.\n *\n * @param s   the string whose length to count\n * @param len maximum number of characters to check in the string, that\n *            is the maximum value which is returned by the function\n */"
 },
 "av_asprintf": {
  "type": "char *",
  "definition": "char * av_asprintf",
  "argsstring": "(const char *fmt,...) av_printf_format(1",
  "name": "av_asprintf",
  "param": [
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "..."
   }
  ],
  "briefdescription": {
   "para": "Print arguments following specified format into a large enough auto allocated buffer."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "fmt"
      },
      "parameterdescription": {
       "para": "printf-compatible format string, specifying how the following parameters are used."
      }
     },
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "the allocated string",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_free()",
        "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
        "@_kindref": "member"
       },
       "#text": "You have to free the string yourself with."
      },
      "@_kind": "note"
     }
    ],
    "#text": "It is similar to GNU asprintf()."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "157",
   "@_column": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1gac3dc2ab1e5ac73e24fc7d60c0ff0a46b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Print arguments following specified format into a large enough auto\n * allocated buffer. It is similar to GNU asprintf().\n * @param fmt printf-compatible format string, specifying how the\n *            following parameters are used.\n * @return the allocated string\n * @note You have to free the string yourself with av_free().\n */"
 },
 "av_get_token": {
  "type": "char char *",
  "definition": "char char * av_get_token",
  "argsstring": "(const char **buf, const char *term)",
  "name": "av_get_token",
  "param": [
   {
    "type": "const char **",
    "declname": "buf"
   },
   {
    "type": "const char *",
    "declname": "term"
   }
  ],
  "briefdescription": {
   "para": "Unescape the given string until a non escaped terminating char, and return the token corresponding to the unescaped string."
  },
  "detaileddescription": {
   "para": [
    "The normal \\ and ' escaping is supported. Leading and trailing whitespaces are removed, unless they are escaped with '\\' or are enclosed between ''.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "the buffer to parse, buf will be updated to point to the terminating char"
        }
       },
       {
        "parameternamelist": {
         "parametername": "term"
        },
        "parameterdescription": {
         "para": "a 0-terminated list of terminating chars"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the malloced unescaped string, which must be av_freed by the user, NULL in case of allocation failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "173",
   "@_column": "6",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "173",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga9b3d11db3c18cef3f944fb28334c39cf",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Unescape the given string until a non escaped terminating char,\n * and return the token corresponding to the unescaped string.\n *\n * The normal \\ and ' escaping is supported. Leading and trailing\n * whitespaces are removed, unless they are escaped with '\\' or are\n * enclosed between ''.\n *\n * @param buf the buffer to parse, buf will be updated to point to the\n * terminating char\n * @param term a 0-terminated list of terminating chars\n * @return the malloced unescaped string, which must be av_freed by\n * the user, NULL in case of allocation failure\n */"
 },
 "av_strtok": {
  "type": "char *",
  "definition": "char * av_strtok",
  "argsstring": "(char *s, const char *delim, char **saveptr)",
  "name": "av_strtok",
  "param": [
   {
    "type": "char *",
    "declname": "s"
   },
   {
    "type": "const char *",
    "declname": "delim"
   },
   {
    "type": "char **",
    "declname": "saveptr"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_strtok()",
     "@_refid": "group__lavu__string_1ga324342ef1176b60094a1a95b3bf72965",
     "@_kindref": "member"
    },
    "#text": "Split the string into several tokens which can be accessed by successive calls to."
   }
  },
  "detaileddescription": {
   "para": [
    "A token is defined as a sequence of characters not belonging to the set specified in delim.",
    {
     "ref": {
      "#text": "av_strtok()",
      "@_refid": "group__lavu__string_1ga324342ef1176b60094a1a95b3bf72965",
      "@_kindref": "member"
     },
     "#text": "On the first call to, s should point to the string to parse, and the value of saveptr is ignored. In subsequent calls, s should be NULL, and saveptr should be unchanged since the previous call."
    },
    "This function is similar to strtok_r() defined in POSIX.1.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "the string to parse, may be NULL"
        }
       },
       {
        "parameternamelist": {
         "parametername": "delim"
        },
        "parameterdescription": {
         "para": "0-terminated list of token delimiters, must be non-NULL"
        }
       },
       {
        "parameternamelist": {
         "parametername": "saveptr"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "av_strtok()",
           "@_refid": "group__lavu__string_1ga324342ef1176b60094a1a95b3bf72965",
           "@_kindref": "member"
          },
          "#text": "user-provided pointer which points to stored information necessary forto continue scanning the same string. saveptr is updated to point to the next character after the first delimiter found, or to NULL if the string was terminated"
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the found token, or NULL when no token is found",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "197",
   "@_column": "6",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "197",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga324342ef1176b60094a1a95b3bf72965",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Split the string into several tokens which can be accessed by\n * successive calls to av_strtok().\n *\n * A token is defined as a sequence of characters not belonging to the\n * set specified in delim.\n *\n * On the first call to av_strtok(), s should point to the string to\n * parse, and the value of saveptr is ignored. In subsequent calls, s\n * should be NULL, and saveptr should be unchanged since the previous\n * call.\n *\n * This function is similar to strtok_r() defined in POSIX.1.\n *\n * @param s the string to parse, may be NULL\n * @param delim 0-terminated list of token delimiters, must be non-NULL\n * @param saveptr user-provided pointer which points to stored\n * information necessary for av_strtok() to continue scanning the same\n * string. saveptr is updated to point to the next character after the\n * first delimiter found, or to NULL if the string was terminated\n * @return the found token, or NULL when no token is found\n */"
 },
 "av_isdigit": {
  "type": {
   "ref": {
    "#text": "av_const",
    "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "static av_const int av_isdigit",
  "argsstring": "(int c)",
  "name": "av_isdigit",
  "param": {
   "type": "int",
   "declname": "c"
  },
  "briefdescription": {
   "para": "Locale-independent conversion of ASCII isdigit."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "202",
   "@_column": "28",
   "@_bodyfile": "libavutil/avstring.h",
   "@_bodystart": "202",
   "@_bodyend": "205"
  },
  "referencedby": {
   "#text": "av_isxdigit",
   "@_refid": "group__lavu__string_1ga644b6231c0c43b9e2925db980f6bfa81",
   "@_compoundref": "avstring_8h",
   "@_startline": "247",
   "@_endline": "251"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga54f9d8cb6e7f411fb145dd6ade19e939",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Locale-independent conversion of ASCII isdigit.\n */"
 },
 "av_isgraph": {
  "type": {
   "ref": {
    "#text": "av_const",
    "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "static av_const int av_isgraph",
  "argsstring": "(int c)",
  "name": "av_isgraph",
  "param": {
   "type": "int",
   "declname": "c"
  },
  "briefdescription": {
   "para": "Locale-independent conversion of ASCII isgraph."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "210",
   "@_column": "28",
   "@_bodyfile": "libavutil/avstring.h",
   "@_bodystart": "210",
   "@_bodyend": "213"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga91dbda7570409baeb62265fa5f425039",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Locale-independent conversion of ASCII isgraph.\n */"
 },
 "av_isspace": {
  "type": {
   "ref": {
    "#text": "av_const",
    "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "static av_const int av_isspace",
  "argsstring": "(int c)",
  "name": "av_isspace",
  "param": {
   "type": "int",
   "declname": "c"
  },
  "briefdescription": {
   "para": "Locale-independent conversion of ASCII isspace."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "218",
   "@_column": "28",
   "@_bodyfile": "libavutil/avstring.h",
   "@_bodystart": "218",
   "@_bodyend": "222"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga96490acc8dd8d85f2ee43bc605661ffa",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Locale-independent conversion of ASCII isspace.\n */"
 },
 "av_toupper": {
  "type": {
   "ref": {
    "#text": "av_const",
    "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "static av_const int av_toupper",
  "argsstring": "(int c)",
  "name": "av_toupper",
  "param": {
   "type": "int",
   "declname": "c"
  },
  "briefdescription": {
   "para": "Locale-independent conversion of ASCII characters to uppercase."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "227",
   "@_column": "28",
   "@_bodyfile": "libavutil/avstring.h",
   "@_bodystart": "227",
   "@_bodyend": "232"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga9c20e01cbc94a7c9996a8ce93de046b0",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Locale-independent conversion of ASCII characters to uppercase.\n */"
 },
 "av_tolower": {
  "type": {
   "ref": {
    "#text": "av_const",
    "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "static av_const int av_tolower",
  "argsstring": "(int c)",
  "name": "av_tolower",
  "param": {
   "type": "int",
   "declname": "c"
  },
  "briefdescription": {
   "para": "Locale-independent conversion of ASCII characters to lowercase."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "237",
   "@_column": "28",
   "@_bodyfile": "libavutil/avstring.h",
   "@_bodystart": "237",
   "@_bodyend": "242"
  },
  "referencedby": {
   "#text": "av_isxdigit",
   "@_refid": "group__lavu__string_1ga644b6231c0c43b9e2925db980f6bfa81",
   "@_compoundref": "avstring_8h",
   "@_startline": "247",
   "@_endline": "251"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga4586526cc16bff30163dee592ed2897c",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Locale-independent conversion of ASCII characters to lowercase.\n */"
 },
 "av_isxdigit": {
  "type": {
   "ref": {
    "#text": "av_const",
    "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "static av_const int av_isxdigit",
  "argsstring": "(int c)",
  "name": "av_isxdigit",
  "param": {
   "type": "int",
   "declname": "c"
  },
  "briefdescription": {
   "para": "Locale-independent conversion of ASCII isxdigit."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "247",
   "@_column": "28",
   "@_bodyfile": "libavutil/avstring.h",
   "@_bodystart": "247",
   "@_bodyend": "251"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga644b6231c0c43b9e2925db980f6bfa81",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Locale-independent conversion of ASCII isxdigit.\n */"
 },
 "av_strcasecmp": {
  "type": "int",
  "definition": "int av_strcasecmp",
  "argsstring": "(const char *a, const char *b)",
  "name": "av_strcasecmp",
  "param": [
   {
    "type": "const char *",
    "declname": "a"
   },
   {
    "type": "const char *",
    "declname": "b"
   }
  ],
  "briefdescription": {
   "para": "Locale-independent case-insensitive compare."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "This means only ASCII-range characters are case-insensitive",
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "257",
   "@_column": "5",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "257",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga4c60b7d4ce023a6466bc033e31c5349c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Locale-independent case-insensitive compare.\n * @note This means only ASCII-range characters are case-insensitive\n */"
 },
 "av_strncasecmp": {
  "type": "int",
  "definition": "int av_strncasecmp",
  "argsstring": "(const char *a, const char *b, size_t n)",
  "name": "av_strncasecmp",
  "param": [
   {
    "type": "const char *",
    "declname": "a"
   },
   {
    "type": "const char *",
    "declname": "b"
   },
   {
    "type": "size_t",
    "declname": "n"
   }
  ],
  "briefdescription": {
   "para": "Locale-independent case-insensitive compare."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "This means only ASCII-range characters are case-insensitive",
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "263",
   "@_column": "5",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "263",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1gaea8a7c8c2832c11e753fbfc0d1464970",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Locale-independent case-insensitive compare.\n * @note This means only ASCII-range characters are case-insensitive\n */"
 },
 "av_strireplace": {
  "type": "char *",
  "definition": "char * av_strireplace",
  "argsstring": "(const char *str, const char *from, const char *to)",
  "name": "av_strireplace",
  "param": [
   {
    "type": "const char *",
    "declname": "str"
   },
   {
    "type": "const char *",
    "declname": "from"
   },
   {
    "type": "const char *",
    "declname": "to"
   }
  ],
  "briefdescription": {
   "para": "Locale-independent strings replace."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "This means only ASCII-range characters are replaced.",
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "269",
   "@_column": "6",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "269",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1gae110142fae1ff1e46c31000dfcfa220c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Locale-independent strings replace.\n * @note This means only ASCII-range characters are replaced.\n */"
 },
 "av_basename": {
  "type": "const char *",
  "definition": "const char * av_basename",
  "argsstring": "(const char *path)",
  "name": "av_basename",
  "param": {
   "type": "const char *",
   "declname": "path"
  },
  "briefdescription": {
   "para": "Thread safe basename."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "path"
      },
      "parameterdescription": {
       "para": "the string to parse, on DOS both \\ and / are considered separators."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "pointer to the basename substring. If path does not contain a slash, the function returns a copy of path. If path is a NULL pointer or points to an empty string, a pointer to a string \".\" is returned.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "279",
   "@_column": "12",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "279",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1gabb9cf90fa867ef69f815b489cc646e8d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Thread safe basename.\n * @param path the string to parse, on DOS both \\ and / are considered separators.\n * @return pointer to the basename substring.\n * If path does not contain a slash, the function returns a copy of path.\n * If path is a NULL pointer or points to an empty string, a pointer\n * to a string \".\" is returned.\n */"
 },
 "av_dirname": {
  "type": "const char *",
  "definition": "const char * av_dirname",
  "argsstring": "(char *path)",
  "name": "av_dirname",
  "param": {
   "type": "char *",
   "declname": "path"
  },
  "briefdescription": {
   "para": "Thread safe dirname."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "path"
      },
      "parameterdescription": {
       "para": "the string to parse, on DOS both \\ and / are considered separators."
      }
     },
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "A pointer to a string that's the parent directory of path. If path is a NULL pointer or points to an empty string, a pointer to a string \".\" is returned.",
      "@_kind": "return"
     },
     {
      "para": "the function may modify the contents of the path, so copies should be passed.",
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "289",
   "@_column": "12",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "289",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga9ef2c167b775719794bb2ce1282fb16a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Thread safe dirname.\n * @param path the string to parse, on DOS both \\ and / are considered separators.\n * @return A pointer to a string that's the parent directory of path.\n * If path is a NULL pointer or points to an empty string, a pointer\n * to a string \".\" is returned.\n * @note the function may modify the contents of the path, so copies should be passed.\n */"
 },
 "av_match_name": {
  "type": "int",
  "definition": "int av_match_name",
  "argsstring": "(const char *name, const char *names)",
  "name": "av_match_name",
  "param": [
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "const char *",
    "declname": "names"
   }
  ],
  "briefdescription": {
   "para": "Match instances of a name in a comma-separated list of names."
  },
  "detaileddescription": {
   "para": [
    "List entries are checked from the start to the end of the names list, the first match ends further processing. If an entry prefixed with '-' matches, then 0 is returned. The \"ALL\" list entry is considered to match all names.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "name"
        },
        "parameterdescription": {
         "para": "Name to look for."
        }
       },
       {
        "parameternamelist": {
         "parametername": "names"
        },
        "parameterdescription": {
         "para": "List of names."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "1 on match, 0 otherwise.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "302",
   "@_column": "5",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "302",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga5883fa1071129810bccfad9b3e779371",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Match instances of a name in a comma-separated list of names.\n * List entries are checked from the start to the end of the names list,\n * the first match ends further processing. If an entry prefixed with '-'\n * matches, then 0 is returned. The \"ALL\" list entry is considered to\n * match all names.\n *\n * @param name  Name to look for.\n * @param names List of names.\n * @return 1 on match, 0 otherwise.\n */"
 },
 "av_append_path_component": {
  "type": "char *",
  "definition": "char * av_append_path_component",
  "argsstring": "(const char *path, const char *component)",
  "name": "av_append_path_component",
  "param": [
   {
    "type": "const char *",
    "declname": "path"
   },
   {
    "type": "const char *",
    "declname": "component"
   }
  ],
  "briefdescription": {
   "para": "Append path component to the existing path."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "av_free()",
     "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
     "@_kindref": "member"
    },
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "path"
       },
       "parameterdescription": {
        "para": "base path"
       }
      },
      {
       "parameternamelist": {
        "parametername": "component"
       },
       "parameterdescription": {
        "para": "component to be appended"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "new path or NULL on error.",
     "@_kind": "return"
    },
    "#text": "Path separator '/' is placed between when needed. Resulting string have to be freed with."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "312",
   "@_column": "6",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "312",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1gad00e57620f272aa0ce0d330df22fce1f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Append path component to the existing path.\n * Path separator '/' is placed between when needed.\n * Resulting string have to be freed with av_free().\n * @param path      base path\n * @param component component to be appended\n * @return new path or NULL on error.\n */"
 },
 "av_escape": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int av_escape",
  "argsstring": "(char **dst, const char *src, const char *special_chars, enum AVEscapeMode mode, int flags)",
  "name": "av_escape",
  "param": [
   {
    "type": "char **",
    "declname": "dst"
   },
   {
    "type": "const char *",
    "declname": "src"
   },
   {
    "type": "const char *",
    "declname": "special_chars"
   },
   {
    "type": {
     "ref": {
      "#text": "AVEscapeMode",
      "@_refid": "group__lavu__string_1gaef885958293f07153383f99db573ff5a",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "mode"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_free()",
     "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
     "@_kindref": "member"
    },
    "#text": "Escape string in src, and put the escaped string in an allocated string in *dst, which must be freed with."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "pointer where an allocated string is put"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "string to escape, must be non-NULL"
       }
      },
      {
       "parameternamelist": {
        "parametername": "special_chars"
       },
       "parameterdescription": {
        "para": "string containing the special characters which need to be escaped, can be NULL"
       }
      },
      {
       "parameternamelist": {
        "parametername": "mode"
       },
       "parameterdescription": {
        "para": "escape mode to employ, see AV_ESCAPE_MODE_* macros. Any unknown value for mode will be considered equivalent to AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without notice."
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "flags which control how to escape, see AV_ESCAPE_FLAG_ macros"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "the length of the allocated string, or a negative error code in case of error",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_bprint_escape()",
        "@_refid": "group__lavu__avbprint_1ga14ec58eeaa6d4a3571cd9f0ffb873e62",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "368",
   "@_column": "5",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "368",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga3c5e00d3f0575f2a3858f837656c08e9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Escape string in src, and put the escaped string in an allocated\n * string in *dst, which must be freed with av_free().\n *\n * @param dst           pointer where an allocated string is put\n * @param src           string to escape, must be non-NULL\n * @param special_chars string containing the special characters which\n *                      need to be escaped, can be NULL\n * @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.\n *                      Any unknown value for mode will be considered equivalent to\n *                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without\n *                      notice.\n * @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_ macros\n * @return the length of the allocated string, or a negative error code in case of error\n * @see av_bprint_escape()\n */"
 },
 "av_utf8_decode": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int av_utf8_decode",
  "argsstring": "(int32_t *codep, const uint8_t **bufp, const uint8_t *buf_end, unsigned int flags)",
  "name": "av_utf8_decode",
  "param": [
   {
    "type": "int32_t *",
    "declname": "codep"
   },
   {
    "type": "const uint8_t **",
    "declname": "bufp"
   },
   {
    "type": "const uint8_t *",
    "declname": "buf_end"
   },
   {
    "type": "unsigned int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Read and decode a single UTF-8 code point (character) from the buffer in *buf, and update *buf to point to the next byte to decode."
  },
  "detaileddescription": {
   "para": [
    "In case of an invalid byte sequence, the pointer will be updated to the next byte after the invalid sequence and the function will return an error code.",
    "Depending on the specified flags, the function will also fail in case the decoded code point does not belong to a valid range.",
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "GET_UTF8()",
         "@_refid": "common_8h_1a1a2fd8cd42afb00c9f69562f52b1ae4b",
         "@_kindref": "member"
        },
        "#text": "For speed-relevant code a carefully implemented use ofmay be preferred."
       },
       "@_kind": "note"
      },
      {
       "para": ">= 0 in case a sequence was successfully read, a negative value in case of invalid sequence",
       "@_kind": "return"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "codep"
        },
        "parameterdescription": {
         "para": "pointer used to return the parsed code in case of success. The value in *codep is set even in case the range check fails."
        }
       },
       {
        "parameternamelist": {
         "parametername": "bufp"
        },
        "parameterdescription": {
         "para": "pointer to the address the first byte of the sequence to decode, updated by the function to point to the byte next after the decoded sequence"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf_end"
        },
        "parameterdescription": {
         "para": "pointer to the end of the buffer, points to the next byte past the last in the buffer. This is used to avoid buffer overreads (in case of an unfinished UTF-8 sequence towards the end of the buffer)."
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "a collection of AV_UTF8_FLAG_* flags"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "408",
   "@_column": "5",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "408",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1gac6e5b8d7ba04ac2023e825222c36bee3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read and decode a single UTF-8 code point (character) from the\n * buffer in *buf, and update *buf to point to the next byte to\n * decode.\n *\n * In case of an invalid byte sequence, the pointer will be updated to\n * the next byte after the invalid sequence and the function will\n * return an error code.\n *\n * Depending on the specified flags, the function will also fail in\n * case the decoded code point does not belong to a valid range.\n *\n * @note For speed-relevant code a carefully implemented use of\n * GET_UTF8() may be preferred.\n *\n * @param codep   pointer used to return the parsed code in case of success.\n *                The value in *codep is set even in case the range check fails.\n * @param bufp    pointer to the address the first byte of the sequence\n *                to decode, updated by the function to point to the\n *                byte next after the decoded sequence\n * @param buf_end pointer to the end of the buffer, points to the next\n *                byte past the last in the buffer. This is used to\n *                avoid buffer overreads (in case of an unfinished\n *                UTF-8 sequence towards the end of the buffer).\n * @param flags   a collection of AV_UTF8_FLAG_* flags\n * @return >= 0 in case a sequence was successfully read, a negative\n * value in case of invalid sequence\n */"
 },
 "av_match_list": {
  "type": "int",
  "definition": "int av_match_list",
  "argsstring": "(const char *name, const char *list, char separator)",
  "name": "av_match_list",
  "param": [
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "const char *",
    "declname": "list"
   },
   {
    "type": "char",
    "declname": "separator"
   }
  ],
  "briefdescription": {
   "para": "Check if a name is in a list."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "0 if not found, or the 1 based index where it has been found in the list.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "416",
   "@_column": "5",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "416",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1ga9a6eb11f2b4053d6bba95d8da156da2d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if a name is in a list.\n * @returns 0 if not found, or the 1 based index where it has been found in the\n *            list.\n */"
 },
 "av_sscanf": {
  "type": "int",
  "definition": "int av_sscanf",
  "argsstring": "(const char *string, const char *format,...)",
  "name": "av_sscanf",
  "param": [
   {
    "type": "const char *",
    "declname": "string"
   },
   {
    "type": "const char *",
    "declname": "format"
   },
   {
    "type": "..."
   }
  ],
  "briefdescription": {
   "para": "See libc sscanf manual for more information."
  },
  "detaileddescription": {
   "para": "Locale-independent sscanf implementation."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avstring.h",
   "@_line": "422",
   "@_column": "5",
   "@_declfile": "libavutil/avstring.h",
   "@_declline": "422",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__string_1gaa21d05e9ef9081a5dc847cf033aad1cd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * See libc sscanf manual for more information.\n * Locale-independent sscanf implementation.\n */"
 },
 "avutil_version": {
  "type": "unsigned",
  "definition": "unsigned avutil_version",
  "argsstring": "(void)",
  "name": "avutil_version",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the LIBAVUTIL_VERSION_INT constant."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avutil.h",
   "@_line": "171",
   "@_column": "10",
   "@_declfile": "libavutil/avutil.h",
   "@_declline": "171",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavu__ver_1ga9a979c78d33d8767b51952f7f5c61541",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the LIBAVUTIL_VERSION_INT constant.\n */"
 },
 "av_version_info": {
  "type": "const char *",
  "definition": "const char * av_version_info",
  "argsstring": "(void)",
  "name": "av_version_info",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return an informative version string."
  },
  "detaileddescription": {
   "para": "This usually is the actual release version number or a git commit description. This string has no fixed format and can change any time. It should never be parsed by code."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avutil.h",
   "@_line": "178",
   "@_column": "12",
   "@_declfile": "libavutil/avutil.h",
   "@_declline": "178",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__ver_1ga1124bfdd0e7fd6ee1aeeef4ebffebca8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return an informative version string. This usually is the actual release\n * version number or a git commit description. This string has no fixed format\n * and can change any time. It should never be parsed by code.\n */"
 },
 "avutil_configuration": {
  "type": "const char *",
  "definition": "const char * avutil_configuration",
  "argsstring": "(void)",
  "name": "avutil_configuration",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libavutil build-time configuration."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avutil.h",
   "@_line": "183",
   "@_column": "12",
   "@_declfile": "libavutil/avutil.h",
   "@_declline": "183",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__ver_1ga5f1205d8bf110f597580b49ae43420c6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libavutil build-time configuration.\n */"
 },
 "avutil_license": {
  "type": "const char *",
  "definition": "const char * avutil_license",
  "argsstring": "(void)",
  "name": "avutil_license",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libavutil license."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avutil.h",
   "@_line": "188",
   "@_column": "12",
   "@_declfile": "libavutil/avutil.h",
   "@_declline": "188",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__ver_1ga1a05049e8d684432f3c399657d66f002",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libavutil license.\n */"
 },
 "av_get_media_type_string": {
  "type": "const char *",
  "definition": "const char * av_get_media_type_string",
  "argsstring": "(enum AVMediaType media_type)",
  "name": "av_get_media_type_string",
  "param": {
   "type": {
    "ref": {
     "#text": "AVMediaType",
     "@_refid": "group__lavu__misc_1ga9a84bba4713dfced21a1a56163be1f48",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "media_type"
  },
  "briefdescription": {
   "para": "Return a string describing the media_type enum, NULL if media_type is unknown."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avutil.h",
   "@_line": "213",
   "@_column": "12",
   "@_declfile": "libavutil/avutil.h",
   "@_declline": "213",
   "@_declcolumn": "12"
  },
  "referencedby": {
   "#text": "open_codec_context",
   "@_refid": "demux__decode_8c_1ab36dcc13a13c2ae1c1fff2ea5db97616",
   "@_compoundref": "demux__decode_8c",
   "@_startline": "146",
   "@_endline": "195"
  },
  "@_kind": "function",
  "@_id": "group__lavu__misc_1ga1eb76ac28a60793459c55c102dfcf816",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return a string describing the media_type enum, NULL if media_type\n * is unknown.\n */"
 },
 "av_get_picture_type_char": {
  "type": "char",
  "definition": "char av_get_picture_type_char",
  "argsstring": "(enum AVPictureType pict_type)",
  "name": "av_get_picture_type_char",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPictureType",
     "@_refid": "group__lavu__picture_1gae6cbcab1f70d8e476757f1c1f5a0a78e",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "pict_type"
  },
  "briefdescription": {
   "para": "Return a single letter to describe the given picture type pict_type."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": {
        "#text": "pict_type",
        "@_direction": "in"
       }
      },
      "parameterdescription": {
       "para": "the picture type"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "a single character representing the picture type, '?' if pict_type is unknown",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avutil.h",
   "@_line": "295",
   "@_column": "6",
   "@_declfile": "libavutil/avutil.h",
   "@_declline": "295",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1gacbf2ea8b2b89924c890ef8ec10a3d922",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return a single letter to describe the given picture type\n * pict_type.\n *\n * @param[in] pict_type the picture type @return a single character\n * representing the picture type, '?' if pict_type is unknown\n */"
 },
 "av_x_if_null": {
  "type": "void *",
  "definition": "static void * av_x_if_null",
  "argsstring": "(const void *p, const void *x)",
  "name": "av_x_if_null",
  "param": [
   {
    "type": "const void *",
    "declname": "p"
   },
   {
    "type": "const void *",
    "declname": "x"
   }
  ],
  "briefdescription": {
   "para": "Return x default pointer in case p is NULL."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avutil.h",
   "@_line": "312",
   "@_column": "20",
   "@_bodyfile": "libavutil/avutil.h",
   "@_bodystart": "312",
   "@_bodyend": "315"
  },
  "referencedby": {
   "#text": "init_filters",
   "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
   "@_compoundref": "decode__filter__audio_8c",
   "@_startline": "90",
   "@_endline": "201"
  },
  "@_kind": "function",
  "@_id": "group__lavu__misc_1gaaf7385f0b6fa2d237998d4a10416d714",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return x default pointer in case p is NULL.\n */"
 },
 "av_int_list_length_for_size": {
  "type": "unsigned",
  "definition": "unsigned av_int_list_length_for_size",
  "argsstring": "(unsigned elsize, const void *list, uint64_t term) av_pure",
  "name": "av_int_list_length_for_size",
  "param": [
   {
    "type": "unsigned",
    "declname": "elsize"
   },
   {
    "type": "const void *",
    "declname": "list"
   },
   {
    "type": "uint64_t",
    "declname": "term"
   }
  ],
  "briefdescription": {
   "para": "Compute the length of an integer list."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "elsize"
       },
       "parameterdescription": {
        "para": "size in bytes of each list element (only 1, 2, 4 or 8)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "term"
       },
       "parameterdescription": {
        "para": "list terminator (usually 0 or -1)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "list"
       },
       "parameterdescription": {
        "para": "pointer to the list"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "length of the list, in elements, not counting the terminator",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avutil.h",
   "@_line": "325",
   "@_column": "10",
   "@_declfile": "libavutil/avutil.h",
   "@_declline": "325",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavu__misc_1ga7894e9b1ec8844685bc9101779c7d533",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Compute the length of an integer list.\n *\n * @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)\n * @param term    list terminator (usually 0 or -1)\n * @param list    pointer to the list\n * @return  length of the list, in elements, not counting the terminator\n */"
 },
 "av_get_time_base_q": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_get_time_base_q",
  "argsstring": "(void)",
  "name": "av_get_time_base_q",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the fractional representation of the internal time base."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avutil.h",
   "@_line": "341",
   "@_column": "12",
   "@_declfile": "libavutil/avutil.h",
   "@_declline": "341",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__misc_1gab889104afd2e874f9dd2b3b78b04f3f2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the fractional representation of the internal time base.\n */"
 },
 "av_fourcc_make_string": {
  "type": "char *",
  "definition": "char * av_fourcc_make_string",
  "argsstring": "(char *buf, uint32_t fourcc)",
  "name": "av_fourcc_make_string",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "uint32_t",
    "declname": "fourcc"
   }
  ],
  "briefdescription": {
   "para": "Fill the provided buffer with a string containing a FourCC (four-character code) representation."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE"
       }
      },
      {
       "parameternamelist": {
        "parametername": "fourcc"
       },
       "parameterdescription": {
        "para": "the fourcc to represent"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the buffer in input",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/avutil.h",
   "@_line": "355",
   "@_column": "6",
   "@_declfile": "libavutil/avutil.h",
   "@_declline": "355",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__misc_1ga79cdcd61b8d4c275681360af4430b513",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill the provided buffer with a string containing a FourCC (four-character\n * code) representation.\n *\n * @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE\n * @param fourcc the fourcc to represent\n * @return the buffer in input\n */"
 },
 "av_base64_decode": {
  "type": "int",
  "definition": "int av_base64_decode",
  "argsstring": "(uint8_t *out, const char *in, int out_size)",
  "name": "av_base64_decode",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "out"
   },
   {
    "type": "const char *",
    "declname": "in"
   },
   {
    "type": "int",
    "declname": "out_size"
   }
  ],
  "briefdescription": {
   "para": "Decode a base64-encoded string."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "out"
       },
       "parameterdescription": {
        "para": "buffer for decoded data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "in"
       },
       "parameterdescription": {
        "para": "null-terminated input string"
       }
      },
      {
       "parameternamelist": {
        "parametername": "out_size"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AV_BASE64_DECODE_SIZE(strlen(in))",
          "@_refid": "group__lavu__base64_1ga91e6771f201fdb7bfaeb4ccb95f1b252",
          "@_kindref": "member"
         },
         "#text": "size in bytes of the out buffer, must be at least 3/4 of the length of in, that is"
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "number of bytes written, or a negative value in case of invalid input",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/base64.h",
   "@_line": "42",
   "@_column": "5",
   "@_declfile": "libavutil/base64.h",
   "@_declline": "42",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__base64_1gac8837266968329642080627f3aec9ab8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Decode a base64-encoded string.\n *\n * @param out      buffer for decoded data\n * @param in       null-terminated input string\n * @param out_size size in bytes of the out buffer, must be at\n *                 least 3/4 of the length of in, that is AV_BASE64_DECODE_SIZE(strlen(in))\n * @return         number of bytes written, or a negative value in case of\n *                 invalid input\n */"
 },
 "av_base64_encode": {
  "type": "char *",
  "definition": "char * av_base64_encode",
  "argsstring": "(char *out, int out_size, const uint8_t *in, int in_size)",
  "name": "av_base64_encode",
  "param": [
   {
    "type": "char *",
    "declname": "out"
   },
   {
    "type": "int",
    "declname": "out_size"
   },
   {
    "type": "const uint8_t *",
    "declname": "in"
   },
   {
    "type": "int",
    "declname": "in_size"
   }
  ],
  "briefdescription": {
   "para": "Encode data to base64 and null-terminate."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "out"
       },
       "parameterdescription": {
        "para": "buffer for encoded data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "out_size"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AV_BASE64_SIZE(in_size)",
          "@_refid": "group__lavu__base64_1gaa79f39ca3f737b662ae6711d2cbecd20",
          "@_kindref": "member"
         },
         "#text": "size in bytes of the out buffer (including the null terminator), must be at least"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "in"
       },
       "parameterdescription": {
        "para": "input buffer containing the data to encode"
       }
      },
      {
       "parameternamelist": {
        "parametername": "in_size"
       },
       "parameterdescription": {
        "para": "size in bytes of the in buffer"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "out or NULL in case of error",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/base64.h",
   "@_line": "60",
   "@_column": "6",
   "@_declfile": "libavutil/base64.h",
   "@_declline": "60",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__base64_1ga1be788d32678cb896ca7ec86fea324b2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Encode data to base64 and null-terminate.\n *\n * @param out      buffer for encoded data\n * @param out_size size in bytes of the out buffer (including the\n *                 null terminator), must be at least AV_BASE64_SIZE(in_size)\n * @param in       input buffer containing the data to encode\n * @param in_size  size in bytes of the in buffer\n * @return         out or NULL in case of error\n */"
 },
 "av_blowfish_alloc": {
  "type": {
   "ref": {
    "#text": "AVBlowfish",
    "@_refid": "structAVBlowfish",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVBlowfish * av_blowfish_alloc",
  "argsstring": "(void)",
  "name": "av_blowfish_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVBlowfish",
     "@_refid": "structAVBlowfish",
     "@_kindref": "compound"
    },
    "#text": "Allocate ancontext."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/blowfish.h",
   "@_line": "43",
   "@_column": "12",
   "@_declfile": "libavutil/blowfish.h",
   "@_declline": "43",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__blowfish_1gace33b53217edd238435f0d9a7b2647b0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVBlowfish context.\n */"
 },
 "av_blowfish_init": {
  "type": "void",
  "definition": "void av_blowfish_init",
  "argsstring": "(struct AVBlowfish *ctx, const uint8_t *key, int key_len)",
  "name": "av_blowfish_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBlowfish",
      "@_refid": "structAVBlowfish",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "ctx"
   },
   {
    "type": "const uint8_t *",
    "declname": "key"
   },
   {
    "type": "int",
    "declname": "key_len"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVBlowfish",
     "@_refid": "structAVBlowfish",
     "@_kindref": "compound"
    },
    "#text": "Initialize ancontext."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVBlowfish",
          "@_refid": "structAVBlowfish",
          "@_kindref": "compound"
         },
         "#text": "ancontext"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "a key"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key_len"
       },
       "parameterdescription": {
        "para": "length of the key"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/blowfish.h",
   "@_line": "52",
   "@_column": "6",
   "@_declfile": "libavutil/blowfish.h",
   "@_declline": "52",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__blowfish_1gabdeab79ba02586b6c06240eeb3472837",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize an AVBlowfish context.\n *\n * @param ctx an AVBlowfish context\n * @param key a key\n * @param key_len length of the key\n */"
 },
 "av_blowfish_crypt_ecb": {
  "type": "void",
  "definition": "void av_blowfish_crypt_ecb",
  "argsstring": "(struct AVBlowfish *ctx, uint32_t *xl, uint32_t *xr, int decrypt)",
  "name": "av_blowfish_crypt_ecb",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBlowfish",
      "@_refid": "structAVBlowfish",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "ctx"
   },
   {
    "type": "uint32_t *",
    "declname": "xl"
   },
   {
    "type": "uint32_t *",
    "declname": "xr"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypt or decrypt a buffer using a previously initialized context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVBlowfish",
          "@_refid": "structAVBlowfish",
          "@_kindref": "compound"
         },
         "#text": "ancontext"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "xl"
       },
       "parameterdescription": {
        "para": "left four bytes halves of input to be encrypted"
       }
      },
      {
       "parameternamelist": {
        "parametername": "xr"
       },
       "parameterdescription": {
        "para": "right four bytes halves of input to be encrypted"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/blowfish.h",
   "@_line": "62",
   "@_column": "6",
   "@_declfile": "libavutil/blowfish.h",
   "@_declline": "62",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__blowfish_1ga7b57de27a9aa26b67ac1f0d67fea781b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Encrypt or decrypt a buffer using a previously initialized context.\n *\n * @param ctx an AVBlowfish context\n * @param xl left four bytes halves of input to be encrypted\n * @param xr right four bytes halves of input to be encrypted\n * @param decrypt 0 for encryption, 1 for decryption\n */"
 },
 "av_blowfish_crypt": {
  "type": "void",
  "definition": "void av_blowfish_crypt",
  "argsstring": "(struct AVBlowfish *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt)",
  "name": "av_blowfish_crypt",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBlowfish",
      "@_refid": "structAVBlowfish",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "uint8_t *",
    "declname": "iv"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypt or decrypt a buffer using a previously initialized context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVBlowfish",
          "@_refid": "structAVBlowfish",
          "@_kindref": "compound"
         },
         "#text": "ancontext"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of 8 byte blocks"
       }
      },
      {
       "parameternamelist": {
        "parametername": "iv"
       },
       "parameterdescription": {
        "para": "initialization vector for CBC mode, if NULL ECB will be used"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/blowfish.h",
   "@_line": "75",
   "@_column": "6",
   "@_declfile": "libavutil/blowfish.h",
   "@_declline": "75",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__blowfish_1gaad9e1113615df7f3e883ad48e7ee764b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Encrypt or decrypt a buffer using a previously initialized context.\n *\n * @param ctx an AVBlowfish context\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param count number of 8 byte blocks\n * @param iv initialization vector for CBC mode, if NULL ECB will be used\n * @param decrypt 0 for encryption, 1 for decryption\n */"
 },
 "av_bprint_init": {
  "type": "void",
  "definition": "void av_bprint_init",
  "argsstring": "(AVBPrint *buf, unsigned size_init, unsigned size_max)",
  "name": "av_bprint_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "buf"
   },
   {
    "type": "unsigned",
    "declname": "size_init"
   },
   {
    "type": "unsigned",
    "declname": "size_max"
   }
  ],
  "briefdescription": {
   "para": "Init a print buffer."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "buffer to init"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size_init"
       },
       "parameterdescription": {
        "para": "initial size (including the final 0)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size_max"
       },
       "parameterdescription": {
        "para": {
         "itemizedlist": {
          "listitem": [
           {
            "para": {
             "computeroutput": 0,
             "#text": "means do not write anything, just count the length"
            }
           },
           {
            "para": {
             "computeroutput": 1,
             "#text": "is replaced by the maximum value for automatic storage any large value means that the internal buffer will be reallocated as needed up to that limit"
            }
           },
           {
            "para": {
             "computeroutput": [
              -1,
              "UINT_MAX",
              "AV_BPRINT_SIZE_*"
             ],
             "#text": "is converted to, the largest limit possible. Check alsomacros."
            }
           }
          ]
         },
         "#text": "maximum size;"
        }
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "141",
   "@_column": "6",
   "@_declfile": "libavutil/bprint.h",
   "@_declline": "141",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1ga26abc84daea3189592c511fc26067d66",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Init a print buffer.\n *\n * @param buf        buffer to init\n * @param size_init  initial size (including the final 0)\n * @param size_max   maximum size;\n *                   - `0` means do not write anything, just count the length\n *                   - `1` is replaced by the maximum value for automatic storage\n *                       any large value means that the internal buffer will be\n *                       reallocated as needed up to that limit\n *                   - `-1` is converted to `UINT_MAX`, the largest limit possible.\n *                   Check also `AV_BPRINT_SIZE_*` macros.\n */"
 },
 "av_bprint_init_for_buffer": {
  "type": "void",
  "definition": "void av_bprint_init_for_buffer",
  "argsstring": "(AVBPrint *buf, char *buffer, unsigned size)",
  "name": "av_bprint_init_for_buffer",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "buf"
   },
   {
    "type": "char *",
    "declname": "buffer"
   },
   {
    "type": "unsigned",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Init a print buffer using a pre-existing buffer."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "AVBPrint",
       "@_refid": "structAVBPrint",
       "@_kindref": "compound"
      },
      {
       "#text": "av_bprint_init()",
       "@_refid": "group__lavu__avbprint_1ga26abc84daea3189592c511fc26067d66",
       "@_kindref": "member"
      }
     ],
     "#text": "The buffer will not be reallocated. In case size equals zero, thewill be initialized to use the internal buffer as if using AV_BPRINT_SIZE_COUNT_ONLY with."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "buffer structure to init"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buffer"
        },
        "parameterdescription": {
         "para": "byte buffer to use for the string data"
        }
       },
       {
        "parameternamelist": {
         "parametername": "size"
        },
        "parameterdescription": {
         "para": "size of buffer"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "155",
   "@_column": "6",
   "@_declfile": "libavutil/bprint.h",
   "@_declline": "155",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1gaf70c16532f4ba50c599e4eaa67a1d63b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Init a print buffer using a pre-existing buffer.\n *\n * The buffer will not be reallocated.\n * In case size equals zero, the AVBPrint will be initialized to use\n * the internal buffer as if using AV_BPRINT_SIZE_COUNT_ONLY with\n * av_bprint_init().\n *\n * @param buf     buffer structure to init\n * @param buffer  byte buffer to use for the string data\n * @param size    size of buffer\n */"
 },
 "av_bprintf": {
  "type": "void",
  "definition": "void av_bprintf",
  "argsstring": "(AVBPrint *buf, const char *fmt,...) av_printf_format(2",
  "name": "av_bprintf",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "buf"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "..."
   }
  ],
  "briefdescription": {
   "para": "Append a formatted string to a print buffer."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "160",
   "@_column": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1gaa2e89377fd7c92db534f29caff1af209",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Append a formatted string to a print buffer.\n */"
 },
 "av_vbprintf": {
  "type": "void void",
  "definition": "void void av_vbprintf",
  "argsstring": "(AVBPrint *buf, const char *fmt, va_list vl_arg)",
  "name": "av_vbprintf",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "buf"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "va_list",
    "declname": "vl_arg"
   }
  ],
  "briefdescription": {
   "para": "Append a formatted string to a print buffer."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "165",
   "@_column": "6",
   "@_declfile": "libavutil/bprint.h",
   "@_declline": "165",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1gae24ca62b5e2ba99651636c04b61240f1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Append a formatted string to a print buffer.\n */"
 },
 "av_bprint_chars": {
  "type": "void",
  "definition": "void av_bprint_chars",
  "argsstring": "(AVBPrint *buf, char c, unsigned n)",
  "name": "av_bprint_chars",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "buf"
   },
   {
    "type": "char",
    "declname": "c"
   },
   {
    "type": "unsigned",
    "declname": "n"
   }
  ],
  "briefdescription": {
   "para": "Append char c n times to a print buffer."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "170",
   "@_column": "6",
   "@_declfile": "libavutil/bprint.h",
   "@_declline": "170",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1gaabc9a9d58de61dd824e625d59a7531bb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Append char c n times to a print buffer.\n */"
 },
 "av_bprint_append_data": {
  "type": "void",
  "definition": "void av_bprint_append_data",
  "argsstring": "(AVBPrint *buf, const char *data, unsigned size)",
  "name": "av_bprint_append_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "buf"
   },
   {
    "type": "const char *",
    "declname": "data"
   },
   {
    "type": "unsigned",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Append data to a print buffer."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "bprint buffer to use"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "pointer to data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "size of data"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "179",
   "@_column": "6",
   "@_declfile": "libavutil/bprint.h",
   "@_declline": "179",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1gaa215ba46a975d996e483cf0b9dcc85e5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Append data to a print buffer.\n *\n * @param buf  bprint buffer to use\n * @param data pointer to data\n * @param size size of data\n */"
 },
 "av_bprint_strftime": {
  "type": "void",
  "definition": "void av_bprint_strftime",
  "argsstring": "(AVBPrint *buf, const char *fmt, const struct tm *tm)",
  "name": "av_bprint_strftime",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "buf"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "const struct tm *",
    "declname": "tm"
   }
  ],
  "briefdescription": {
   "para": "Append a formatted date and time to a print buffer."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "bprint buffer to use"
       }
      },
      {
       "parameternamelist": {
        "parametername": "fmt"
       },
       "parameterdescription": {
        "para": "date and time format string, see strftime()"
       }
      },
      {
       "parameternamelist": {
        "parametername": "tm"
       },
       "parameterdescription": {
        "para": "broken-down time structure to translate"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "due to poor design of the standard strftime function, it may produce poor results if the format string expands to a very long text and the bprint buffer is near the limit stated by the size_max option.",
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "193",
   "@_column": "6",
   "@_declfile": "libavutil/bprint.h",
   "@_declline": "193",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1ga4896e4efea5b234507bcbba45ca0397b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Append a formatted date and time to a print buffer.\n *\n * @param buf  bprint buffer to use\n * @param fmt  date and time format string, see strftime()\n * @param tm   broken-down time structure to translate\n *\n * @note due to poor design of the standard strftime function, it may\n * produce poor results if the format string expands to a very long text and\n * the bprint buffer is near the limit stated by the size_max option.\n */"
 },
 "av_bprint_get_buffer": {
  "type": "void",
  "definition": "void av_bprint_get_buffer",
  "argsstring": "(AVBPrint *buf, unsigned size, unsigned char **mem, unsigned *actual_size)",
  "name": "av_bprint_get_buffer",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "buf"
   },
   {
    "type": "unsigned",
    "declname": "size"
   },
   {
    "type": "unsigned char **",
    "declname": "mem"
   },
   {
    "type": "unsigned *",
    "declname": "actual_size"
   }
  ],
  "briefdescription": {
   "para": "Allocate bytes in the buffer for external use."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "buf",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "buffer structure"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "size",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "required size"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "mem",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "pointer to the memory area"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "actual_size",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "size of the memory area after allocation; can be larger or smaller than size"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "204",
   "@_column": "6",
   "@_declfile": "libavutil/bprint.h",
   "@_declline": "204",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1ga32f3999614d90e082602d54a3c5237d6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate bytes in the buffer for external use.\n *\n * @param[in]  buf          buffer structure\n * @param[in]  size         required size\n * @param[out] mem          pointer to the memory area\n * @param[out] actual_size  size of the memory area after allocation;\n *                          can be larger or smaller than size\n */"
 },
 "av_bprint_clear": {
  "type": "void",
  "definition": "void av_bprint_clear",
  "argsstring": "(AVBPrint *buf)",
  "name": "av_bprint_clear",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBPrint",
     "@_refid": "structAVBPrint",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "buf"
  },
  "briefdescription": {
   "para": "Reset the string to \"\" but keep internal allocated data."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "210",
   "@_column": "6",
   "@_declfile": "libavutil/bprint.h",
   "@_declline": "210",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1gab1c28dbff5990dbd37e6c00e3d7c438b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reset the string to \"\" but keep internal allocated data.\n */"
 },
 "av_bprint_is_complete": {
  "type": "int",
  "definition": "static int av_bprint_is_complete",
  "argsstring": "(const AVBPrint *buf)",
  "name": "av_bprint_is_complete",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBPrint",
     "@_refid": "structAVBPrint",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "buf"
  },
  "briefdescription": {
   "para": "Test if the print buffer is complete (not truncated)."
  },
  "detaileddescription": {
   "para": "It may have been truncated due to a memory allocation failure or the size_max limit (compare size and size_max if necessary)."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "218",
   "@_column": "19",
   "@_bodyfile": "libavutil/bprint.h",
   "@_bodystart": "218",
   "@_bodyend": "221"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1ga07432f704c49a6fa636197e2aa80bac0",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Test if the print buffer is complete (not truncated).\n *\n * It may have been truncated due to a memory allocation failure\n * or the size_max limit (compare size and size_max if necessary).\n */"
 },
 "av_bprint_finalize": {
  "type": "int",
  "definition": "int av_bprint_finalize",
  "argsstring": "(AVBPrint *buf, char **ret_str)",
  "name": "av_bprint_finalize",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "buf"
   },
   {
    "type": "char **",
    "declname": "ret_str"
   }
  ],
  "briefdescription": {
   "para": "Finalize a print buffer."
  },
  "detaileddescription": {
   "para": [
    "The print buffer can no longer be used afterwards, but the len and size fields are still valid.",
    {
     "itemizedlist": {
      "listitem": {
       "para": {
        "simplesect": {
         "para": {
          "ref": {
           "#text": "AVERROR(ENOMEM)",
           "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
           "@_kindref": "member"
          },
          "#text": "0 for success or error code (probably)"
         },
         "@_kind": "return"
        },
        "#text": "[out] ret_str if not NULL, used to return a permanent copy of the buffer contents, or NULL if memory allocation fails; if NULL, the buffer is discarded and freed"
       }
      }
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "234",
   "@_column": "5",
   "@_declfile": "libavutil/bprint.h",
   "@_declline": "234",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1ga3fd45f50d9d4f7cc8fed5331a37f47ea",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finalize a print buffer.\n *\n * The print buffer can no longer be used afterwards,\n * but the len and size fields are still valid.\n *\n * @arg[out] ret_str  if not NULL, used to return a permanent copy of the\n *                    buffer contents, or NULL if memory allocation fails;\n *                    if NULL, the buffer is discarded and freed\n * @return  0 for success or error code (probably AVERROR(ENOMEM))\n */"
 },
 "av_bprint_escape": {
  "type": "void",
  "definition": "void av_bprint_escape",
  "argsstring": "(AVBPrint *dstbuf, const char *src, const char *special_chars, enum AVEscapeMode mode, int flags)",
  "name": "av_bprint_escape",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dstbuf"
   },
   {
    "type": "const char *",
    "declname": "src"
   },
   {
    "type": "const char *",
    "declname": "special_chars"
   },
   {
    "type": {
     "ref": {
      "#text": "AVEscapeMode",
      "@_refid": "group__lavu__string_1gaef885958293f07153383f99db573ff5a",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "mode"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Escape the content in src and append it to dstbuf."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "dstbuf"
       },
       "parameterdescription": {
        "para": "already inited destination bprint buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "string containing the text to escape"
       }
      },
      {
       "parameternamelist": {
        "parametername": "special_chars"
       },
       "parameterdescription": {
        "para": "string containing the special characters which need to be escaped, can be NULL"
       }
      },
      {
       "parameternamelist": {
        "parametername": "mode"
       },
       "parameterdescription": {
        "para": "escape mode to employ, see AV_ESCAPE_MODE_* macros. Any unknown value for mode will be considered equivalent to AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without notice."
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "flags which control how to escape, see AV_ESCAPE_FLAG_* macros"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bprint.h",
   "@_line": "249",
   "@_column": "6",
   "@_declfile": "libavutil/bprint.h",
   "@_declline": "249",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__avbprint_1ga14ec58eeaa6d4a3571cd9f0ffb873e62",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Escape the content in src and append it to dstbuf.\n *\n * @param dstbuf        already inited destination bprint buffer\n * @param src           string containing the text to escape\n * @param special_chars string containing the special characters which\n *                      need to be escaped, can be NULL\n * @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.\n *                      Any unknown value for mode will be considered equivalent to\n *                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without\n *                      notice.\n * @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros\n */"
 },
 "AVBSFList": {
  "type": {
   "ref": {
    "#text": "AVBSFList",
    "@_refid": "group__lavc__bsf_1gad2163db8f1a7873b51257fde434c8c04",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVBSFList AVBSFList",
  "argsstring": "",
  "name": "AVBSFList",
  "briefdescription": {
   "para": "Structure for chain/list of bitstream filters."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "av_bsf_list_alloc()",
     "@_refid": "group__lavc__bsf_1gac00b290a44a57ecfa144257b82ddbc97",
     "@_kindref": "member"
    },
    "#text": "Empty list can be allocated by."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "247",
   "@_column": "24",
   "@_bodyfile": "libavcodec/bsf.h",
   "@_bodystart": "247",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavc__bsf_1gad2163db8f1a7873b51257fde434c8c04",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Structure for chain/list of bitstream filters.\n * Empty list can be allocated by av_bsf_list_alloc().\n */"
 },
 "av_bsf_get_by_name": {
  "type": {
   "ref": {
    "#text": "AVBitStreamFilter",
    "@_refid": "structAVBitStreamFilter",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVBitStreamFilter * av_bsf_get_by_name",
  "argsstring": "(const char *name)",
  "name": "av_bsf_get_by_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "a bitstream filter with the specified name or NULL if no such bitstream filter exists.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "137",
   "@_column": "25",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "137",
   "@_declcolumn": "25"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1gaf8f648184b420406a694f1867aaab839",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return a bitstream filter with the specified name or NULL if no such\n *         bitstream filter exists.\n */"
 },
 "av_bsf_iterate": {
  "type": {
   "ref": {
    "#text": "AVBitStreamFilter",
    "@_refid": "structAVBitStreamFilter",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVBitStreamFilter * av_bsf_iterate",
  "argsstring": "(void **opaque)",
  "name": "av_bsf_iterate",
  "param": {
   "type": "void **",
   "declname": "opaque"
  },
  "briefdescription": {
   "para": "Iterate over all registered bitstream filters."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "opaque"
      },
      "parameterdescription": {
       "para": "a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the next registered bitstream filter or NULL when the iteration is finished",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "148",
   "@_column": "25",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "148",
   "@_declcolumn": "25"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1ga18b9f1195b8bc559b466dec20a9ab305",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over all registered bitstream filters.\n *\n * @param opaque a pointer where libavcodec will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered bitstream filter or NULL when the iteration is\n *         finished\n */"
 },
 "av_bsf_alloc": {
  "type": "int",
  "definition": "int av_bsf_alloc",
  "argsstring": "(const AVBitStreamFilter *filter, AVBSFContext **ctx)",
  "name": "av_bsf_alloc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBitStreamFilter",
      "@_refid": "structAVBitStreamFilter",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "filter"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBSFContext",
      "@_refid": "structAVBSFContext",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "ctx"
   }
  ],
  "briefdescription": {
   "para": "Allocate a context for a given bitstream filter."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_bsf_init()",
      "@_refid": "group__lavc__bsf_1ga242529d54013acf87e94273d298a5ff2",
      "@_kindref": "member"
     },
     "#text": "The caller must fill in the context parameters as described in the documentation and then callbefore sending any data to the filter."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "filter"
        },
        "parameterdescription": {
         "para": "the filter for which to allocate an instance."
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ctx",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "av_bsf_free()",
           "@_refid": "group__lavc__bsf_1ga08d53431e76355f88e27763b1940df4f",
           "@_kindref": "member"
          },
          "#text": "a pointer into which the pointer to the newly-allocated context will be written. It must be freed withafter the filtering is done."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, a negative AVERROR code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "162",
   "@_column": "5",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "162",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1ga7da65af303e20c9546e15ec266b182c1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a context for a given bitstream filter. The caller must fill in the\n * context parameters as described in the documentation and then call\n * av_bsf_init() before sending any data to the filter.\n *\n * @param filter the filter for which to allocate an instance.\n * @param[out] ctx a pointer into which the pointer to the newly-allocated context\n *                 will be written. It must be freed with av_bsf_free() after the\n *                 filtering is done.\n *\n * @return 0 on success, a negative AVERROR code on failure\n */"
 },
 "av_bsf_init": {
  "type": "int",
  "definition": "int av_bsf_init",
  "argsstring": "(AVBSFContext *ctx)",
  "name": "av_bsf_init",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBSFContext",
     "@_refid": "structAVBSFContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "ctx"
  },
  "briefdescription": {
   "para": "Prepare the filter for use, after all the parameters and options have been set."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "ctx"
      },
      "parameterdescription": {
       "para": {
        "ref": [
         {
          "#text": "AVBSFContext",
          "@_refid": "structAVBSFContext",
          "@_kindref": "compound"
         },
         {
          "#text": "av_bsf_alloc()",
          "@_refid": "group__lavc__bsf_1ga7da65af303e20c9546e15ec266b182c1",
          "@_kindref": "member"
         }
        ],
        "#text": "apreviously allocated with"
       }
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "170",
   "@_column": "5",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "170",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1ga242529d54013acf87e94273d298a5ff2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Prepare the filter for use, after all the parameters and options have been\n * set.\n *\n * @param ctx a AVBSFContext previously allocated with av_bsf_alloc()\n */"
 },
 "av_bsf_send_packet": {
  "type": "int",
  "definition": "int av_bsf_send_packet",
  "argsstring": "(AVBSFContext *ctx, AVPacket *pkt)",
  "name": "av_bsf_send_packet",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBSFContext",
      "@_refid": "structAVBSFContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   }
  ],
  "briefdescription": {
   "para": "Submit a packet for filtering."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "av_bsf_receive_packet()",
       "@_refid": "group__lavc__bsf_1ga7fffb6c87b91250956e7a2367af56b38",
       "@_kindref": "member"
      },
      {
       "#text": "AVERROR(EAGAIN)",
       "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
       "@_kindref": "member"
      }
     ],
     "#text": "After sending each packet, the filter must be completely drained by callingrepeatedly until it returnsor AVERROR_EOF."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVBSFContext",
           "@_refid": "structAVBSFContext",
           "@_kindref": "compound"
          },
          "#text": "an initialized"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "pkt"
        },
        "parameterdescription": {
         "para": "the packet to filter. The bitstream filter will take ownership of the packet and reset the contents of pkt. pkt is not touched if an error occurs. If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side_data_elems zero), it signals the end of the stream (i.e. no more non-empty packets will be sent; sending more empty packets does nothing) and will cause the filter to output any packets it may have buffered internally."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "itemizedlist": {
        "listitem": [
         {
          "para": "0 on success."
         },
         {
          "para": {
           "ref": [
            {
             "#text": "AVERROR(EAGAIN)",
             "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
             "@_kindref": "member"
            },
            {
             "#text": "av_bsf_receive_packet()",
             "@_refid": "group__lavc__bsf_1ga7fffb6c87b91250956e7a2367af56b38",
             "@_kindref": "member"
            }
           ],
           "#text": "if packets need to be retrieved from the filter (using) before new input can be consumed."
          }
         },
         {
          "para": "Another negative AVERROR value if an error occurs."
         }
        ]
       }
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "193",
   "@_column": "5",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "193",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1gaada9ea8f08d3dcf23c14564dbc88992c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Submit a packet for filtering.\n *\n * After sending each packet, the filter must be completely drained by calling\n * av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or\n * AVERROR_EOF.\n *\n * @param ctx an initialized AVBSFContext\n * @param pkt the packet to filter. The bitstream filter will take ownership of\n * the packet and reset the contents of pkt. pkt is not touched if an error occurs.\n * If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side_data_elems zero),\n * it signals the end of the stream (i.e. no more non-empty packets will be sent;\n * sending more empty packets does nothing) and will cause the filter to output\n * any packets it may have buffered internally.\n *\n * @return\n *  - 0 on success.\n *  - AVERROR(EAGAIN) if packets need to be retrieved from the filter (using\n *    av_bsf_receive_packet()) before new input can be consumed.\n *  - Another negative AVERROR value if an error occurs.\n */"
 },
 "av_bsf_receive_packet": {
  "type": "int",
  "definition": "int av_bsf_receive_packet",
  "argsstring": "(AVBSFContext *ctx, AVPacket *pkt)",
  "name": "av_bsf_receive_packet",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBSFContext",
      "@_refid": "structAVBSFContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   }
  ],
  "briefdescription": {
   "para": "Retrieve a filtered packet."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVBSFContext",
          "@_refid": "structAVBSFContext",
          "@_kindref": "compound"
         },
         "#text": "an initialized"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "pkt",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": {
         "ref": [
          {
           "#text": "av_packet_unref()",
           "@_refid": "group__lavc__packet_1ga63d5a489b419bd5d45cfd09091cbcbc2",
           "@_kindref": "member"
          },
          {
           "#text": "av_packet_alloc()",
           "@_refid": "group__lavc__packet_1gad56057568fb51504e5b4aafcb44f9a03",
           "@_kindref": "member"
          },
          {
           "#text": "av_packet_unref()",
           "@_refid": "group__lavc__packet_1ga63d5a489b419bd5d45cfd09091cbcbc2",
           "@_kindref": "member"
          }
         ],
         "#text": "this struct will be filled with the contents of the filtered packet. It is owned by the caller and must be freed usingwhen it is no longer needed. This parameter should be \"clean\" (i.e. freshly allocated withor unreffed with) when this function is called. If this function returns successfully, the contents of pkt will be completely overwritten by the returned data. On failure, pkt is not touched."
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": {
       "itemizedlist": {
        "listitem": [
         {
          "para": "0 on success."
         },
         {
          "para": {
           "ref": [
            {
             "#text": "AVERROR(EAGAIN)",
             "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
             "@_kindref": "member"
            },
            {
             "#text": "av_bsf_send_packet()",
             "@_refid": "group__lavc__bsf_1gaada9ea8f08d3dcf23c14564dbc88992c",
             "@_kindref": "member"
            }
           ],
           "#text": "if more packets need to be sent to the filter (using) to get more output."
          }
         },
         {
          "para": "AVERROR_EOF if there will be no further output from the filter."
         },
         {
          "para": "Another negative AVERROR value if an error occurs."
         }
        ]
       }
      },
      "@_kind": "return"
     },
     {
      "para": {
       "ref": [
        {
         "#text": "av_bsf_send_packet()",
         "@_refid": "group__lavc__bsf_1gaada9ea8f08d3dcf23c14564dbc88992c",
         "@_kindref": "member"
        },
        {
         "#text": "AVERROR(EAGAIN)",
         "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
         "@_kindref": "member"
        },
        {
         "#text": "av_bsf_send_packet()",
         "@_refid": "group__lavc__bsf_1gaada9ea8f08d3dcf23c14564dbc88992c",
         "@_kindref": "member"
        }
       ],
       "#text": "one input packet may result in several output packets, so after sending a packet with, this function needs to be called repeatedly until it stops returning 0. It is also possible for a filter to output fewer packets than were sent to it, so this function may returnimmediately after a successfulcall."
      },
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "222",
   "@_column": "5",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "222",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1ga7fffb6c87b91250956e7a2367af56b38",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Retrieve a filtered packet.\n *\n * @param ctx an initialized AVBSFContext\n * @param[out] pkt this struct will be filled with the contents of the filtered\n *                 packet. It is owned by the caller and must be freed using\n *                 av_packet_unref() when it is no longer needed.\n *                 This parameter should be \"clean\" (i.e. freshly allocated\n *                 with av_packet_alloc() or unreffed with av_packet_unref())\n *                 when this function is called. If this function returns\n *                 successfully, the contents of pkt will be completely\n *                 overwritten by the returned data. On failure, pkt is not\n *                 touched.\n *\n * @return\n *  - 0 on success.\n *  - AVERROR(EAGAIN) if more packets need to be sent to the filter (using\n *    av_bsf_send_packet()) to get more output.\n *  - AVERROR_EOF if there will be no further output from the filter.\n *  - Another negative AVERROR value if an error occurs.\n *\n * @note one input packet may result in several output packets, so after sending\n * a packet with av_bsf_send_packet(), this function needs to be called\n * repeatedly until it stops returning 0. It is also possible for a filter to\n * output fewer packets than were sent to it, so this function may return\n * AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.\n */"
 },
 "av_bsf_flush": {
  "type": "void",
  "definition": "void av_bsf_flush",
  "argsstring": "(AVBSFContext *ctx)",
  "name": "av_bsf_flush",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBSFContext",
     "@_refid": "structAVBSFContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "ctx"
  },
  "briefdescription": {
   "para": "Reset the internal bitstream filter state."
  },
  "detaileddescription": {
   "para": "Should be called e.g. when seeking."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "227",
   "@_column": "6",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "227",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1ga6e11d42d27e5525ce6525b0dbc2466e8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reset the internal bitstream filter state. Should be called e.g. when seeking.\n */"
 },
 "av_bsf_free": {
  "type": "void",
  "definition": "void av_bsf_free",
  "argsstring": "(AVBSFContext **ctx)",
  "name": "av_bsf_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBSFContext",
     "@_refid": "structAVBSFContext",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "ctx"
  },
  "briefdescription": {
   "para": "Free a bitstream filter context and everything associated with it; write NULL into the supplied pointer."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "233",
   "@_column": "6",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "233",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1ga08d53431e76355f88e27763b1940df4f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free a bitstream filter context and everything associated with it; write NULL\n * into the supplied pointer.\n */"
 },
 "av_bsf_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * av_bsf_get_class",
  "argsstring": "(void)",
  "name": "av_bsf_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVClass",
      "@_refid": "structAVClass",
      "@_kindref": "compound"
     },
     {
      "#text": "AVBSFContext",
      "@_refid": "structAVBSFContext",
      "@_kindref": "compound"
     }
    ],
    "#text": "Get thefor."
   }
  },
  "detaileddescription": {
   "para": [
    "It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.",
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_opt_find()",
        "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
        "@_kindref": "member"
       },
       "#text": "."
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "241",
   "@_column": "15",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "241",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1ga6f1c604acc591df5c723482dd5dbb5b9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVClass for AVBSFContext. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */"
 },
 "av_bsf_list_alloc": {
  "type": {
   "ref": {
    "#text": "AVBSFList",
    "@_refid": "group__lavc__bsf_1gad2163db8f1a7873b51257fde434c8c04",
    "@_kindref": "member"
   },
   "#text": "*"
  },
  "definition": "AVBSFList * av_bsf_list_alloc",
  "argsstring": "(void)",
  "name": "av_bsf_list_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate empty list of bitstream filters."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "av_bsf_list_free()",
       "@_refid": "group__lavc__bsf_1ga0e144e330612e37a23acf056db4ac220",
       "@_kindref": "member"
      },
      {
       "#text": "av_bsf_list_finalize()",
       "@_refid": "group__lavc__bsf_1gaa4f71b6265b76b23abd418b62ffaff2d",
       "@_kindref": "member"
      }
     ],
     "#text": "The list must be later freed byor finalized by."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVBSFList",
        "@_refid": "group__lavc__bsf_1gad2163db8f1a7873b51257fde434c8c04",
        "@_kindref": "member"
       },
       "#text": "Pointer toon success, NULL in case of failure"
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "256",
   "@_column": "11",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "256",
   "@_declcolumn": "11"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1gac00b290a44a57ecfa144257b82ddbc97",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate empty list of bitstream filters.\n * The list must be later freed by av_bsf_list_free()\n * or finalized by av_bsf_list_finalize().\n *\n * @return Pointer to @ref AVBSFList on success, NULL in case of failure\n */"
 },
 "av_bsf_list_free": {
  "type": "void",
  "definition": "void av_bsf_list_free",
  "argsstring": "(AVBSFList **lst)",
  "name": "av_bsf_list_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBSFList",
     "@_refid": "group__lavc__bsf_1gad2163db8f1a7873b51257fde434c8c04",
     "@_kindref": "member"
    },
    "#text": "**"
   },
   "declname": "lst"
  },
  "briefdescription": {
   "para": "Free list of bitstream filters."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "lst"
      },
      "parameterdescription": {
       "para": {
        "ref": {
         "#text": "av_bsf_list_alloc()",
         "@_refid": "group__lavc__bsf_1gac00b290a44a57ecfa144257b82ddbc97",
         "@_kindref": "member"
        },
        "#text": "Pointer to pointer returned by"
       }
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "263",
   "@_column": "6",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "263",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1ga0e144e330612e37a23acf056db4ac220",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free list of bitstream filters.\n *\n * @param lst Pointer to pointer returned by av_bsf_list_alloc()\n */"
 },
 "av_bsf_list_append": {
  "type": "int",
  "definition": "int av_bsf_list_append",
  "argsstring": "(AVBSFList *lst, AVBSFContext *bsf)",
  "name": "av_bsf_list_append",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBSFList",
      "@_refid": "group__lavc__bsf_1gad2163db8f1a7873b51257fde434c8c04",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "lst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBSFContext",
      "@_refid": "structAVBSFContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "bsf"
   }
  ],
  "briefdescription": {
   "para": "Append bitstream filter to the list of bitstream filters."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "lst"
       },
       "parameterdescription": {
        "para": "List to append to"
       }
      },
      {
       "parameternamelist": {
        "parametername": "bsf"
       },
       "parameterdescription": {
        "para": "Filter context to be appended"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">=0 on success, negative AVERROR in case of failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "273",
   "@_column": "5",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "273",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1ga51caad27662682e124796bbff590cab8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Append bitstream filter to the list of bitstream filters.\n *\n * @param lst List to append to\n * @param bsf Filter context to be appended\n *\n * @return >=0 on success, negative AVERROR in case of failure\n */"
 },
 "av_bsf_list_append2": {
  "type": "int",
  "definition": "int av_bsf_list_append2",
  "argsstring": "(AVBSFList *lst, const char *bsf_name, AVDictionary **options)",
  "name": "av_bsf_list_append2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBSFList",
      "@_refid": "group__lavc__bsf_1gad2163db8f1a7873b51257fde434c8c04",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "lst"
   },
   {
    "type": "const char *",
    "declname": "bsf_name"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": "Construct new bitstream filter context given it's name and options and append it to the list of bitstream filters."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "lst"
       },
       "parameterdescription": {
        "para": "List to append to"
       }
      },
      {
       "parameternamelist": {
        "parametername": "bsf_name"
       },
       "parameterdescription": {
        "para": "Name of the bitstream filter"
       }
      },
      {
       "parameternamelist": {
        "parametername": "options"
       },
       "parameterdescription": {
        "para": "Options for the bitstream filter, can be set to NULL"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">=0 on success, negative AVERROR in case of failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "285",
   "@_column": "5",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "285",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1gaf9085d5cf405b89e2129dc6b2ef54aeb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Construct new bitstream filter context given it's name and options\n * and append it to the list of bitstream filters.\n *\n * @param lst      List to append to\n * @param bsf_name Name of the bitstream filter\n * @param options  Options for the bitstream filter, can be set to NULL\n *\n * @return >=0 on success, negative AVERROR in case of failure\n */"
 },
 "av_bsf_list_finalize": {
  "type": "int",
  "definition": "int av_bsf_list_finalize",
  "argsstring": "(AVBSFList **lst, AVBSFContext **bsf)",
  "name": "av_bsf_list_finalize",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBSFList",
      "@_refid": "group__lavc__bsf_1gad2163db8f1a7873b51257fde434c8c04",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "lst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBSFContext",
      "@_refid": "structAVBSFContext",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "bsf"
   }
  ],
  "briefdescription": {
   "para": "Finalize list of bitstream filters."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "AVBSFList",
       "@_refid": "group__lavc__bsf_1gad2163db8f1a7873b51257fde434c8c04",
       "@_kindref": "member"
      },
      {
       "#text": "AVBSFContext",
       "@_refid": "structAVBSFContext",
       "@_kindref": "compound"
      },
      {
       "#text": "av_bsf_alloc()",
       "@_refid": "group__lavc__bsf_1ga7da65af303e20c9546e15ec266b182c1",
       "@_kindref": "member"
      },
      {
       "#text": "AVBSFList",
       "@_refid": "group__lavc__bsf_1gad2163db8f1a7873b51257fde434c8c04",
       "@_kindref": "member"
      },
      {
       "#text": "av_bsf_list_free()",
       "@_refid": "group__lavc__bsf_1ga0e144e330612e37a23acf056db4ac220",
       "@_kindref": "member"
      }
     ],
     "#text": "This function will transformto single, so the whole chain of bitstream filters can be treated as single filter freshly allocated by. If the call is successful,structure is freed and lst will be set to NULL. In case of failure, caller is responsible for freeing the structure by"
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "lst"
        },
        "parameterdescription": {
         "para": "Filter list structure to be transformed"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "bsf",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVBSFContext",
           "@_refid": "structAVBSFContext",
           "@_kindref": "compound"
          },
          "#text": "Pointer to be set to newly createdstructure representing the chain of bitstream filters"
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">=0 on success, negative AVERROR in case of failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "302",
   "@_column": "5",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "302",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1gaa4f71b6265b76b23abd418b62ffaff2d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finalize list of bitstream filters.\n *\n * This function will transform @ref AVBSFList to single @ref AVBSFContext,\n * so the whole chain of bitstream filters can be treated as single filter\n * freshly allocated by av_bsf_alloc().\n * If the call is successful, @ref AVBSFList structure is freed and lst\n * will be set to NULL. In case of failure, caller is responsible for\n * freeing the structure by av_bsf_list_free()\n *\n * @param      lst Filter list structure to be transformed\n * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure\n *                 representing the chain of bitstream filters\n *\n * @return >=0 on success, negative AVERROR in case of failure\n */"
 },
 "av_bsf_list_parse_str": {
  "type": "int",
  "definition": "int av_bsf_list_parse_str",
  "argsstring": "(const char *str, AVBSFContext **bsf)",
  "name": "av_bsf_list_parse_str",
  "param": [
   {
    "type": "const char *",
    "declname": "str"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBSFContext",
      "@_refid": "structAVBSFContext",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "bsf"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVBSFContext",
     "@_refid": "structAVBSFContext",
     "@_kindref": "compound"
    },
    "#text": "Parse string describing list of bitstream filters and create singledescribing the whole chain of bitstream filters."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "AVBSFContext",
       "@_refid": "structAVBSFContext",
       "@_kindref": "compound"
      },
      {
       "#text": "AVBSFContext",
       "@_refid": "structAVBSFContext",
       "@_kindref": "compound"
      },
      {
       "#text": "av_bsf_alloc()",
       "@_refid": "group__lavc__bsf_1ga7da65af303e20c9546e15ec266b182c1",
       "@_kindref": "member"
      }
     ],
     "#text": "Resultingcan be treated as any otherfreshly allocated by."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "str"
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "bsf1[=opt1=val1:opt2=val2][,bsf2]",
          "#text": "String describing chain of bitstream filters in format"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "bsf",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVBSFContext",
           "@_refid": "structAVBSFContext",
           "@_kindref": "compound"
          },
          "#text": "Pointer to be set to newly createdstructure representing the chain of bitstream filters"
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">=0 on success, negative AVERROR in case of failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "317",
   "@_column": "5",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "317",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1gacc7bbd4bb41b36893f6ad971fd95f7fb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse string describing list of bitstream filters and create single\n * @ref AVBSFContext describing the whole chain of bitstream filters.\n * Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly\n * allocated by av_bsf_alloc().\n *\n * @param      str String describing chain of bitstream filters in format\n *                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`\n * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure\n *                 representing the chain of bitstream filters\n *\n * @return >=0 on success, negative AVERROR in case of failure\n */"
 },
 "av_bsf_get_null_filter": {
  "type": "int",
  "definition": "int av_bsf_get_null_filter",
  "argsstring": "(AVBSFContext **bsf)",
  "name": "av_bsf_get_null_filter",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBSFContext",
     "@_refid": "structAVBSFContext",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "bsf"
  },
  "briefdescription": {
   "para": "Get null/pass-through bitstream filter."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": {
        "#text": "bsf",
        "@_direction": "out"
       }
      },
      "parameterdescription": {
       "para": "Pointer to be set to new instance of pass-through bitstream filter"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/bsf.h",
   "@_line": "326",
   "@_column": "5",
   "@_declfile": "libavcodec/bsf.h",
   "@_declline": "326",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__bsf_1gad7ef51525e9607c2d12c75f3bcbc1388",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get null/pass-through bitstream filter.\n *\n * @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter\n *\n * @return\n */"
 },
 "av_bswap16": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "uint16_t"
  },
  "definition": "static av_always_inline av_const uint16_t av_bswap16",
  "argsstring": "(uint16_t x)",
  "name": "av_bswap16",
  "param": {
   "type": "uint16_t",
   "declname": "x"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bswap.h",
   "@_line": "60",
   "@_column": "43",
   "@_bodyfile": "libavutil/bswap.h",
   "@_bodystart": "60",
   "@_bodyend": "64"
  },
  "@_kind": "function",
  "@_id": "bswap_8h_1acd93aba4dbc490bca8ed9057f6816b5a",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "#endif /* HAVE_AV_CONFIG_H */"
 },
 "av_bswap32": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "uint32_t"
  },
  "definition": "static av_always_inline av_const uint32_t av_bswap32",
  "argsstring": "(uint32_t x)",
  "name": "av_bswap32",
  "param": {
   "type": "uint32_t",
   "declname": "x"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bswap.h",
   "@_line": "68",
   "@_column": "43",
   "@_bodyfile": "libavutil/bswap.h",
   "@_bodystart": "68",
   "@_bodyend": "71"
  },
  "referencedby": {
   "#text": "av_bswap64",
   "@_refid": "bswap_8h_1a2fb2d4d0f205a1897de581749d8774dc",
   "@_compoundref": "bswap_8h",
   "@_startline": "75",
   "@_endline": "78"
  },
  "@_kind": "function",
  "@_id": "bswap_8h_1af620b9064c4d86e0c80c63de965678ae",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "#endif /* HAVE_AV_CONFIG_H */"
 },
 "av_bswap64": {
  "type": {
   "ref": {
    "#text": "av_const",
    "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
    "@_kindref": "member"
   },
   "#text": "uint64_t"
  },
  "definition": "static uint64_t av_const av_bswap64",
  "argsstring": "(uint64_t x)",
  "name": "av_bswap64",
  "param": {
   "type": "uint64_t",
   "declname": "x"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/bswap.h",
   "@_line": "75",
   "@_column": "33",
   "@_bodyfile": "libavutil/bswap.h",
   "@_bodystart": "75",
   "@_bodyend": "78"
  },
  "@_kind": "function",
  "@_id": "bswap_8h_1a2fb2d4d0f205a1897de581749d8774dc",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "#endif /* HAVE_AV_CONFIG_H */"
 },
 "AVBuffer": {
  "type": {
   "ref": {
    "#text": "AVBuffer",
    "@_refid": "group__lavu__buffer_1ga501d49df442180d584f255aa97b2549d",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVBuffer AVBuffer",
  "argsstring": "",
  "name": "AVBuffer",
  "briefdescription": {
   "para": "A reference counted buffer type."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "It is opaque and is meant to be used through references ()."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "74",
   "@_column": "23",
   "@_bodyfile": "libavutil/buffer.h",
   "@_bodystart": "74",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavu__buffer_1ga501d49df442180d584f255aa97b2549d",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * A reference counted buffer type. It is opaque and is meant to be used through\n * references (AVBufferRef).\n */"
 },
 "AVBufferPool": {
  "type": {
   "ref": {
    "#text": "AVBufferPool",
    "@_refid": "group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVBufferPool AVBufferPool",
  "argsstring": "",
  "name": "AVBufferPool",
  "briefdescription": {
   "para": "The buffer pool."
  },
  "detaileddescription": {
   "para": {
    "ref": [
     {
      "#text": "av_buffer_pool_init()",
      "@_refid": "group__lavu__bufferpool_1ga8317217c166b5411ecca1f355251afae",
      "@_kindref": "member"
     },
     {
      "#text": "av_buffer_pool_uninit()",
      "@_refid": "group__lavu__bufferpool_1ga7b76781c5944b3bb59b2e3b1a8994e4a",
      "@_kindref": "member"
     }
    ],
    "#text": "This structure is opaque and not meant to be accessed directly. It is allocated withand freed with."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "255",
   "@_column": "27",
   "@_bodyfile": "libavutil/buffer.h",
   "@_bodystart": "255",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * The buffer pool. This structure is opaque and not meant to be accessed\n * directly. It is allocated with av_buffer_pool_init() and freed with\n * av_buffer_pool_uninit().\n */"
 },
 "av_buffer_alloc": {
  "type": {
   "ref": {
    "#text": "AVBufferRef",
    "@_refid": "structAVBufferRef",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVBufferRef * av_buffer_alloc",
  "argsstring": "(size_t size)",
  "name": "av_buffer_alloc",
  "param": {
   "type": "size_t",
   "declname": "size"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_malloc()",
     "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
     "@_kindref": "member"
    },
    "#text": "Allocate an AVBuffer of the given size using."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVBufferRef",
       "@_refid": "structAVBufferRef",
       "@_kindref": "compound"
      },
      "#text": "anof given size or NULL when out of memory"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "102",
   "@_column": "13",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "102",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1gadff46eef3fe3c24e5ec13c5600b69826",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVBuffer of the given size using av_malloc().\n *\n * @return an AVBufferRef of given size or NULL when out of memory\n */"
 },
 "av_buffer_allocz": {
  "type": {
   "ref": {
    "#text": "AVBufferRef",
    "@_refid": "structAVBufferRef",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVBufferRef * av_buffer_allocz",
  "argsstring": "(size_t size)",
  "name": "av_buffer_allocz",
  "param": {
   "type": "size_t",
   "declname": "size"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_buffer_alloc()",
     "@_refid": "group__lavu__buffer_1gadff46eef3fe3c24e5ec13c5600b69826",
     "@_kindref": "member"
    },
    "#text": "Same as, except the returned buffer will be initialized to zero."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "108",
   "@_column": "13",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "108",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1ga5bd498f1a8e537c06c419c6345e061ae",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Same as av_buffer_alloc(), except the returned buffer will be initialized\n * to zero.\n */"
 },
 "av_buffer_create": {
  "type": {
   "ref": {
    "#text": "AVBufferRef",
    "@_refid": "structAVBufferRef",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVBufferRef * av_buffer_create",
  "argsstring": "(uint8_t *data, size_t size, void(*free)(void *opaque, uint8_t *data), void *opaque, int flags)",
  "name": "av_buffer_create",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "data"
   },
   {
    "type": "size_t",
    "declname": "size"
   },
   {
    "type": "void(*)(void *opaque, uint8_t *data)",
    "declname": "free"
   },
   {
    "type": "void *",
    "declname": "opaque"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Create an AVBuffer from an existing array."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "data array"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "size of data in bytes"
       }
      },
      {
       "parameternamelist": {
        "parametername": "free"
       },
       "parameterdescription": {
        "para": "a callback for freeing this buffer's data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "opaque"
       },
       "parameterdescription": {
        "para": "parameter to be got for processing or passed to free"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "a combination of AV_BUFFER_FLAG_*"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVBufferRef",
       "@_refid": "structAVBufferRef",
       "@_kindref": "compound"
      },
      "#text": "anreferring to data on success, NULL on failure."
     },
     "@_kind": "return"
    },
    "#text": "If this function is successful, data is owned by the AVBuffer. The caller may only access data through the returnedand references derived from it. If this function fails, data is left untouched."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "131",
   "@_column": "13",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "131",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1gaea0e35a6528430214f3807ce88e82c6e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create an AVBuffer from an existing array.\n *\n * If this function is successful, data is owned by the AVBuffer. The caller may\n * only access data through the returned AVBufferRef and references derived from\n * it.\n * If this function fails, data is left untouched.\n * @param data   data array\n * @param size   size of data in bytes\n * @param free   a callback for freeing this buffer's data\n * @param opaque parameter to be got for processing or passed to free\n * @param flags  a combination of AV_BUFFER_FLAG_*\n *\n * @return an AVBufferRef referring to data on success, NULL on failure.\n */"
 },
 "av_buffer_default_free": {
  "type": "void",
  "definition": "void av_buffer_default_free",
  "argsstring": "(void *opaque, uint8_t *data)",
  "name": "av_buffer_default_free",
  "param": [
   {
    "type": "void *",
    "declname": "opaque"
   },
   {
    "type": "uint8_t *",
    "declname": "data"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_free()",
     "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
     "@_kindref": "member"
    },
    "#text": "Default free callback, which callson the buffer data."
   }
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "av_buffer_create()",
     "@_refid": "group__lavu__buffer_1gaea0e35a6528430214f3807ce88e82c6e",
     "@_kindref": "member"
    },
    "#text": "This function is meant to be passed to, not called directly."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "140",
   "@_column": "6",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "140",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1ga37d620e8cfc9f2f3261c2b4c5d4adfe0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Default free callback, which calls av_free() on the buffer data.\n * This function is meant to be passed to av_buffer_create(), not called\n * directly.\n */"
 },
 "av_buffer_ref": {
  "type": {
   "ref": {
    "#text": "AVBufferRef",
    "@_refid": "structAVBufferRef",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVBufferRef * av_buffer_ref",
  "argsstring": "(const AVBufferRef *buf)",
  "name": "av_buffer_ref",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "buf"
  },
  "briefdescription": {
   "para": "Create a new reference to an AVBuffer."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVBufferRef",
       "@_refid": "structAVBufferRef",
       "@_kindref": "compound"
      },
      "#text": "a newreferring to the same AVBuffer as buf or NULL on failure."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "148",
   "@_column": "13",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "148",
   "@_declcolumn": "13"
  },
  "referencedby": {
   "#text": "hw_decoder_init",
   "@_refid": "hw__decode_8c_1a028fa118aac024a955e2a56e668624d0",
   "@_compoundref": "hw__decode_8c",
   "@_startline": "48",
   "@_endline": "60"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1ga8a684b77a72519dd1e907457898626f1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create a new reference to an AVBuffer.\n *\n * @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on\n * failure.\n */"
 },
 "av_buffer_unref": {
  "type": "void",
  "definition": "void av_buffer_unref",
  "argsstring": "(AVBufferRef **buf)",
  "name": "av_buffer_unref",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "buf"
  },
  "briefdescription": {
   "para": "Free a given reference and automatically free the buffer if there are no more references to it."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "buf"
      },
      "parameterdescription": {
       "para": "the reference to be freed. The pointer is set to NULL on return."
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "156",
   "@_column": "6",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "156",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "hw__decode_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "hw__decode_8c",
   "@_startline": "148",
   "@_endline": "255"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1ga135e9e929b5033bb8f68322497b2effc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free a given reference and automatically free the buffer if there are no more\n * references to it.\n *\n * @param buf the reference to be freed. The pointer is set to NULL on return.\n */"
 },
 "av_buffer_is_writable": {
  "type": "int",
  "definition": "int av_buffer_is_writable",
  "argsstring": "(const AVBufferRef *buf)",
  "name": "av_buffer_is_writable",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "buf"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "av_buffer_ref()",
       "@_refid": "group__lavu__buffer_1ga8a684b77a72519dd1e907457898626f1",
       "@_kindref": "member"
      },
      "#text": "1 if the caller may write to the data referred to by buf (which is true if and only if buf is the only reference to the underlying AVBuffer). Return 0 otherwise. A positive answer is valid untilis called on buf."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "164",
   "@_column": "5",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "164",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1ga060be34ace567ae378fd0a786e847053",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return 1 if the caller may write to the data referred to by buf (which is\n * true if and only if buf is the only reference to the underlying AVBuffer).\n * Return 0 otherwise.\n * A positive answer is valid until av_buffer_ref() is called on buf.\n */"
 },
 "av_buffer_get_opaque": {
  "type": "void *",
  "definition": "void * av_buffer_get_opaque",
  "argsstring": "(const AVBufferRef *buf)",
  "name": "av_buffer_get_opaque",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "buf"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the opaque parameter set by av_buffer_create.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "169",
   "@_column": "6",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "169",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1gaa68265370a808d3b9f55a518a958ba3c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the opaque parameter set by av_buffer_create.\n */"
 },
 "av_buffer_get_ref_count": {
  "type": "int",
  "definition": "int av_buffer_get_ref_count",
  "argsstring": "(const AVBufferRef *buf)",
  "name": "av_buffer_get_ref_count",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "buf"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "171",
   "@_column": "5",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "171",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1ga7b16c3976dc555f71d0843bbd023dfcd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the opaque parameter set by av_buffer_create.\n */"
 },
 "av_buffer_make_writable": {
  "type": "int",
  "definition": "int av_buffer_make_writable",
  "argsstring": "(AVBufferRef **buf)",
  "name": "av_buffer_make_writable",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "buf"
  },
  "briefdescription": {
   "para": "Create a writable reference from a given buffer reference, avoiding data copy if possible."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "buf"
      },
      "parameterdescription": {
       "para": {
        "ref": {
         "#text": "AVBufferRef",
         "@_refid": "structAVBufferRef",
         "@_kindref": "compound"
        },
        "#text": "buffer reference to make writable. On success, buf is either left untouched, or it is unreferenced and a new writableis written in its place. On failure, buf is left untouched."
       }
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative AVERROR on failure.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "182",
   "@_column": "5",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "182",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1ga9c2a1be1b7bb80eec8613fdb62a19074",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create a writable reference from a given buffer reference, avoiding data copy\n * if possible.\n *\n * @param buf buffer reference to make writable. On success, buf is either left\n *            untouched, or it is unreferenced and a new writable AVBufferRef is\n *            written in its place. On failure, buf is left untouched.\n * @return 0 on success, a negative AVERROR on failure.\n */"
 },
 "av_buffer_realloc": {
  "type": "int",
  "definition": "int av_buffer_realloc",
  "argsstring": "(AVBufferRef **buf, size_t size)",
  "name": "av_buffer_realloc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "buf"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Reallocate a given buffer."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "a buffer reference to reallocate. On success, buf will be unreferenced and a new reference with the required size will be written in its place. On failure buf will be left untouched. *buf may be NULL, then a new buffer is allocated."
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "required new buffer size."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "0 on success, a negative AVERROR on failure.",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_realloc()",
        "@_refid": "group__lavu__mem__funcs_1ga45fc6fd08120d07ddf4ed39f597f31b4",
        "@_kindref": "member"
       },
       "#text": "the buffer is actually reallocated withonly if it was initially allocated through av_buffer_realloc(NULL) and there is only one reference to it (i.e. the one passed to this function). In all other cases a new buffer is allocated and the data is copied."
      },
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "199",
   "@_column": "5",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "199",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1ga20c1c0e1b0c606451fb2e12ef27d65f3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reallocate a given buffer.\n *\n * @param buf  a buffer reference to reallocate. On success, buf will be\n *             unreferenced and a new reference with the required size will be\n *             written in its place. On failure buf will be left untouched. *buf\n *             may be NULL, then a new buffer is allocated.\n * @param size required new buffer size.\n * @return 0 on success, a negative AVERROR on failure.\n *\n * @note the buffer is actually reallocated with av_realloc() only if it was\n * initially allocated through av_buffer_realloc(NULL) and there is only one\n * reference to it (i.e. the one passed to this function). In all other cases\n * a new buffer is allocated and the data is copied.\n */"
 },
 "av_buffer_replace": {
  "type": "int",
  "definition": "int av_buffer_replace",
  "argsstring": "(AVBufferRef **dst, const AVBufferRef *src)",
  "name": "av_buffer_replace",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Ensure dst refers to the same data as src."
  },
  "detaileddescription": {
   "para": [
    "When *dst is already equivalent to src, do nothing. Otherwise unreference dst and replace it with a new reference to src.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "Pointer to either a valid buffer reference or NULL. On success, this will point to a buffer reference equivalent to src. On failure, dst will be left untouched."
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "A buffer reference to replace dst with. May be NULL, then this function is equivalent to av_buffer_unref(dst)."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVERROR(ENOMEM)",
        "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
        "@_kindref": "member"
       },
       "#text": "0 on successon memory allocation failure."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "215",
   "@_column": "5",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "215",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__buffer_1ga8029fa24636791cc93cc05ad8f7ee44b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Ensure dst refers to the same data as src.\n *\n * When *dst is already equivalent to src, do nothing. Otherwise unreference dst\n * and replace it with a new reference to src.\n *\n * @param dst Pointer to either a valid buffer reference or NULL. On success,\n *            this will point to a buffer reference equivalent to src. On\n *            failure, dst will be left untouched.\n * @param src A buffer reference to replace dst with. May be NULL, then this\n *            function is equivalent to av_buffer_unref(dst).\n * @return 0 on success\n *         AVERROR(ENOMEM) on memory allocation failure.\n */"
 },
 "av_buffer_pool_init": {
  "type": {
   "ref": {
    "#text": "AVBufferPool",
    "@_refid": "group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6",
    "@_kindref": "member"
   },
   "#text": "*"
  },
  "definition": "AVBufferPool * av_buffer_pool_init",
  "argsstring": "(size_t size, AVBufferRef *(*alloc)(size_t size))",
  "name": "av_buffer_pool_init",
  "param": [
   {
    "type": "size_t",
    "declname": "size"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "*(*)(size_t size)"
    },
    "declname": "alloc"
   }
  ],
  "briefdescription": {
   "para": "Allocate and initialize a buffer pool."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "size of each buffer in this pool"
       }
      },
      {
       "parameternamelist": {
        "parametername": "alloc"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_buffer_alloc()",
          "@_refid": "group__lavu__buffer_1gadff46eef3fe3c24e5ec13c5600b69826",
          "@_kindref": "member"
         },
         "#text": "a function that will be used to allocate new buffers when the pool is empty. May be NULL, then the default allocator will be used ()."
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "newly created buffer pool on success, NULL on error.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "266",
   "@_column": "14",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "266",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "group__lavu__bufferpool_1ga8317217c166b5411ecca1f355251afae",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate and initialize a buffer pool.\n *\n * @param size size of each buffer in this pool\n * @param alloc a function that will be used to allocate new buffers when the\n * pool is empty. May be NULL, then the default allocator will be used\n * (av_buffer_alloc()).\n * @return newly created buffer pool on success, NULL on error.\n */"
 },
 "av_buffer_pool_init2": {
  "type": {
   "ref": {
    "#text": "AVBufferPool",
    "@_refid": "group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6",
    "@_kindref": "member"
   },
   "#text": "*"
  },
  "definition": "AVBufferPool * av_buffer_pool_init2",
  "argsstring": "(size_t size, void *opaque, AVBufferRef *(*alloc)(void *opaque, size_t size), void(*pool_free)(void *opaque))",
  "name": "av_buffer_pool_init2",
  "param": [
   {
    "type": "size_t",
    "declname": "size"
   },
   {
    "type": "void *",
    "declname": "opaque"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "*(*)(void *opaque, size_t size)"
    },
    "declname": "alloc"
   },
   {
    "type": "void(*)(void *opaque)",
    "declname": "pool_free"
   }
  ],
  "briefdescription": {
   "para": "Allocate and initialize a buffer pool with a more complex allocator."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "size of each buffer in this pool"
       }
      },
      {
       "parameternamelist": {
        "parametername": "opaque"
       },
       "parameterdescription": {
        "para": "arbitrary user data used by the allocator"
       }
      },
      {
       "parameternamelist": {
        "parametername": "alloc"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_buffer_alloc()",
          "@_refid": "group__lavu__buffer_1gadff46eef3fe3c24e5ec13c5600b69826",
          "@_kindref": "member"
         },
         "#text": "a function that will be used to allocate new buffers when the pool is empty. May be NULL, then the default allocator will be used ()."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "pool_free"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_buffer_pool_uninit()",
          "@_refid": "group__lavu__bufferpool_1ga7b76781c5944b3bb59b2e3b1a8994e4a",
          "@_kindref": "member"
         },
         "#text": "a function that will be called immediately before the pool is freed. I.e. afteris called by the caller and all the frames are returned to the pool and freed. It is intended to uninitialize the user opaque data. May be NULL."
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "newly created buffer pool on success, NULL on error.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "283",
   "@_column": "14",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "283",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "group__lavu__bufferpool_1gabe67d225e59399d5265381f58fb77896",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate and initialize a buffer pool with a more complex allocator.\n *\n * @param size size of each buffer in this pool\n * @param opaque arbitrary user data used by the allocator\n * @param alloc a function that will be used to allocate new buffers when the\n *              pool is empty. May be NULL, then the default allocator will be\n *              used (av_buffer_alloc()).\n * @param pool_free a function that will be called immediately before the pool\n *                  is freed. I.e. after av_buffer_pool_uninit() is called\n *                  by the caller and all the frames are returned to the pool\n *                  and freed. It is intended to uninitialize the user opaque\n *                  data. May be NULL.\n * @return newly created buffer pool on success, NULL on error.\n */"
 },
 "av_buffer_pool_uninit": {
  "type": "void",
  "definition": "void av_buffer_pool_uninit",
  "argsstring": "(AVBufferPool **pool)",
  "name": "av_buffer_pool_uninit",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferPool",
     "@_refid": "group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6",
     "@_kindref": "member"
    },
    "#text": "**"
   },
   "declname": "pool"
  },
  "briefdescription": {
   "para": "Mark the pool as being available for freeing."
  },
  "detaileddescription": {
   "para": [
    "It will actually be freed only once all the allocated buffers associated with the pool are released. Thus it is safe to call this function while some of the allocated buffers are still in use.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "pool"
       },
       "parameterdescription": {
        "para": "pointer to the pool to be freed. It will be set to NULL."
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "295",
   "@_column": "6",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "295",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__bufferpool_1ga7b76781c5944b3bb59b2e3b1a8994e4a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Mark the pool as being available for freeing. It will actually be freed only\n * once all the allocated buffers associated with the pool are released. Thus it\n * is safe to call this function while some of the allocated buffers are still\n * in use.\n *\n * @param pool pointer to the pool to be freed. It will be set to NULL.\n */"
 },
 "av_buffer_pool_get": {
  "type": {
   "ref": {
    "#text": "AVBufferRef",
    "@_refid": "structAVBufferRef",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVBufferRef * av_buffer_pool_get",
  "argsstring": "(AVBufferPool *pool)",
  "name": "av_buffer_pool_get",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferPool",
     "@_refid": "group__lavu__bufferpool_1ga13bc8038952b61bae4d591f30c7421f6",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "pool"
  },
  "briefdescription": {
   "para": "Allocate a new AVBuffer, reusing an old buffer from the pool when available."
  },
  "detaileddescription": {
   "para": [
    "This function may be called simultaneously from multiple threads.",
    {
     "simplesect": {
      "para": "a reference to the new buffer on success, NULL on error.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "303",
   "@_column": "13",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "303",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "group__lavu__bufferpool_1gabba08793f113e887e0693ff1ec0cb75f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a new AVBuffer, reusing an old buffer from the pool when available.\n * This function may be called simultaneously from multiple threads.\n *\n * @return a reference to the new buffer on success, NULL on error.\n */"
 },
 "av_buffer_pool_buffer_get_opaque": {
  "type": "void *",
  "definition": "void * av_buffer_pool_buffer_get_opaque",
  "argsstring": "(const AVBufferRef *ref)",
  "name": "av_buffer_pool_buffer_get_opaque",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ref"
  },
  "briefdescription": {
   "para": "Query the original opaque parameter of an allocated buffer in the pool."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "ref"
      },
      "parameterdescription": {
       "para": "a buffer reference to a buffer returned by av_buffer_pool_get."
      }
     },
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "the opaque parameter set by the buffer allocator function of the buffer pool.",
      "@_kind": "return"
     },
     {
      "para": "the opaque parameter of ref is used by the buffer pool implementation, therefore you have to use this function to access the original opaque parameter of an allocated buffer.",
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/buffer.h",
   "@_line": "316",
   "@_column": "6",
   "@_declfile": "libavutil/buffer.h",
   "@_declline": "316",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__bufferpool_1ga27fc679dbb39e3fb2953bded0f4ee404",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Query the original opaque parameter of an allocated buffer in the pool.\n *\n * @param ref a buffer reference to a buffer returned by av_buffer_pool_get.\n * @return the opaque parameter set by the buffer allocator function of the\n *         buffer pool.\n *\n * @note the opaque parameter of ref is used by the buffer pool implementation,\n * therefore you have to use this function to access the original opaque\n * parameter of an allocated buffer.\n */"
 },
 "av_buffersink_get_frame_flags": {
  "type": "int",
  "definition": "int av_buffersink_get_frame_flags",
  "argsstring": "(AVFilterContext *ctx, AVFrame *frame, int flags)",
  "name": "av_buffersink_get_frame_flags",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Get a frame with filtered data from sink and put it in frame."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "pointer to a buffersink or abuffersink filter context."
       }
      },
      {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": {
         "ref": [
          {
           "#text": "av_frame_unref()",
           "@_refid": "group__lavu__frame_1ga0a2b687f9c1c5ed0089b01fd61227108",
           "@_kindref": "member"
          },
          {
           "#text": "av_frame_free()",
           "@_refid": "group__lavu__frame_1ga979d73f3228814aee56aeca0636e37cc",
           "@_kindref": "member"
          }
         ],
         "#text": "pointer to an allocated frame that will be filled with data. The data must be freed using/"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "a combination of AV_BUFFERSINK_FLAG_* flags"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 in for success, a negative AVERROR code for failure.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "83",
   "@_column": "5",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "83",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink_1ga71ae9c529c8da51681e12faa37d1a395",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a frame with filtered data from sink and put it in frame.\n *\n * @param ctx    pointer to a buffersink or abuffersink filter context.\n * @param frame  pointer to an allocated frame that will be filled with data.\n *               The data must be freed using av_frame_unref() / av_frame_free()\n * @param flags  a combination of AV_BUFFERSINK_FLAG_* flags\n *\n * @return  >= 0 in for success, a negative AVERROR code for failure.\n */"
 },
 "av_buffersink_set_frame_size": {
  "type": "void",
  "definition": "void av_buffersink_set_frame_size",
  "argsstring": "(AVFilterContext *ctx, unsigned frame_size)",
  "name": "av_buffersink_set_frame_size",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": "unsigned",
    "declname": "frame_size"
   }
  ],
  "briefdescription": {
   "para": "Set the frame size for an audio buffer sink."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "AVERROR(EAGAIN)",
     "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
     "@_kindref": "member"
    },
    "#text": "All calls to av_buffersink_get_buffer_ref will return a buffer with exactly the specified number of samples, orif there is not enough. The last buffer at EOF will be padded with 0."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "106",
   "@_column": "6",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "106",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink_1ga359d7d1e42c27ca14c07559d4e9adba7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set the frame size for an audio buffer sink.\n *\n * All calls to av_buffersink_get_buffer_ref will return a buffer with\n * exactly the specified number of samples, or AVERROR(EAGAIN) if there is\n * not enough. The last buffer at EOF will be padded with 0.\n */"
 },
 "av_buffersink_get_type": {
  "type": {
   "ref": {
    "#text": "AVMediaType",
    "@_refid": "group__lavu__misc_1ga9a84bba4713dfced21a1a56163be1f48",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVMediaType av_buffersink_get_type",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_type",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "114",
   "@_column": "17",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "114",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1ga1eb8bbf583ffb7cc29aaa1944b1e699c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_time_base": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_buffersink_get_time_base",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_time_base",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "115",
   "@_column": "18",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "115",
   "@_declcolumn": "18"
  },
  "referencedby": {
   "#text": "filter_encode_write_frame",
   "@_refid": "transcode_8c_1a255192428438daf73b9f8060c0815712",
   "@_compoundref": "transcode_8c",
   "@_startline": "473",
   "@_endline": "511"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1gabc82f65ec7f4fa47c5216260639258a1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_format": {
  "type": "int",
  "definition": "int av_buffersink_get_format",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_format",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "116",
   "@_column": "18",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "116",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1ga402ddbef6f7347869725696846ac81eb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_frame_rate": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_buffersink_get_frame_rate",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_frame_rate",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "118",
   "@_column": "18",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "118",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1ga55614fd28de2fa05b04f427390061d5b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_w": {
  "type": "int",
  "definition": "int av_buffersink_get_w",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_w",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "119",
   "@_column": "18",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "119",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1gac8c86515d2ef56090395dfd74854c835",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_h": {
  "type": "int",
  "definition": "int av_buffersink_get_h",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_h",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "120",
   "@_column": "18",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "120",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1ga955ecf3680e71e10429d7500343be25c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_sample_aspect_ratio": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_buffersink_get_sample_aspect_ratio",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_sample_aspect_ratio",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "121",
   "@_column": "18",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "121",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1gaa38ee33e1c7f6f7cb190bd2330e5f848",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_colorspace": {
  "type": {
   "ref": {
    "#text": "AVColorSpace",
    "@_refid": "pixfmt_8h_1aff71a069509a1ad3ff54d53a1c894c85",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVColorSpace av_buffersink_get_colorspace",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_colorspace",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "122",
   "@_column": "18",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "122",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1gaad817cdcf5493c385126e8e17c5717f2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_color_range": {
  "type": {
   "ref": {
    "#text": "AVColorRange",
    "@_refid": "pixfmt_8h_1a3da0bf691418bc22c4bcbe6583ad589a",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVColorRange av_buffersink_get_color_range",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_color_range",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "123",
   "@_column": "18",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "123",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1gab80976e506ab88d23d94bb6d7a4051bd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_channels": {
  "type": "int",
  "definition": "int av_buffersink_get_channels",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_channels",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "125",
   "@_column": "18",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "125",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1gace78881c41bf449527826b95d21279a2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_ch_layout": {
  "type": "int",
  "definition": "int av_buffersink_get_ch_layout",
  "argsstring": "(const AVFilterContext *ctx, AVChannelLayout *ch_layout)",
  "name": "av_buffersink_get_ch_layout",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ch_layout"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "126",
   "@_column": "18",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "126",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1gaad918036937648701c09f9612f42706e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_sample_rate": {
  "type": "int",
  "definition": "int av_buffersink_get_sample_rate",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_sample_rate",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "128",
   "@_column": "18",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "128",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1ga2af714e82f48759551acdbc4488ded4a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_hw_frames_ctx": {
  "type": {
   "ref": {
    "#text": "AVBufferRef",
    "@_refid": "structAVBufferRef",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVBufferRef * av_buffersink_get_hw_frames_ctx",
  "argsstring": "(const AVFilterContext *ctx)",
  "name": "av_buffersink_get_hw_frames_ctx",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "130",
   "@_column": "17",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "130",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink__accessors_1ga0e34e0529da6906449524ca1be706794",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup lavfi_buffersink_accessors Buffer sink accessors\n * Get the properties of the stream\n * @{\n */"
 },
 "av_buffersink_get_frame": {
  "type": "int",
  "definition": "int av_buffersink_get_frame",
  "argsstring": "(AVFilterContext *ctx, AVFrame *frame)",
  "name": "av_buffersink_get_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   }
  ],
  "briefdescription": {
   "para": "Get a frame with filtered data from sink and put it in frame."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVFilter",
          "@_refid": "structAVFilter",
          "@_kindref": "compound"
         },
         "#text": "pointer to a context of a buffersink or abuffersink."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": {
         "ref": [
          {
           "#text": "av_frame_unref()",
           "@_refid": "group__lavu__frame_1ga0a2b687f9c1c5ed0089b01fd61227108",
           "@_kindref": "member"
          },
          {
           "#text": "av_frame_free()",
           "@_refid": "group__lavu__frame_1ga979d73f3228814aee56aeca0636e37cc",
           "@_kindref": "member"
          }
         ],
         "#text": "pointer to an allocated frame that will be filled with data. The data must be freed using/"
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "itemizedlist": {
       "listitem": [
        {
         "para": ">= 0 if a frame was successfully returned."
        },
        {
         "para": {
          "ref": {
           "#text": "AVERROR(EAGAIN)",
           "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
           "@_kindref": "member"
          },
          "#text": "if no frames are available at this point; more input frames must be added to the filtergraph to get more output."
         }
        },
        {
         "para": "AVERROR_EOF if there will be no more output frames on this sink."
        },
        {
         "para": "A different negative AVERROR code in other failure cases."
        }
       ]
      }
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "148",
   "@_column": "5",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "148",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "filter_encode_write_frame",
    "@_refid": "transcode_8c_1a255192428438daf73b9f8060c0815712",
    "@_compoundref": "transcode_8c",
    "@_startline": "473",
    "@_endline": "511"
   },
   {
    "#text": "main",
    "@_refid": "decode__filter__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "217",
    "@_endline": "296"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink_1ga653228f4cbca427c654d844a5fc59cfa",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a frame with filtered data from sink and put it in frame.\n *\n * @param ctx pointer to a context of a buffersink or abuffersink AVFilter.\n * @param frame pointer to an allocated frame that will be filled with data.\n *              The data must be freed using av_frame_unref() / av_frame_free()\n *\n * @return\n *         - >= 0 if a frame was successfully returned.\n *         - AVERROR(EAGAIN) if no frames are available at this point; more\n *           input frames must be added to the filtergraph to get more output.\n *         - AVERROR_EOF if there will be no more output frames on this sink.\n *         - A different negative AVERROR code in other failure cases.\n */"
 },
 "av_buffersink_get_samples": {
  "type": "int",
  "definition": "int av_buffersink_get_samples",
  "argsstring": "(AVFilterContext *ctx, AVFrame *frame, int nb_samples)",
  "name": "av_buffersink_get_samples",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_buffersink_get_frame()",
     "@_refid": "group__lavfi__buffersink_1ga653228f4cbca427c654d844a5fc59cfa",
     "@_kindref": "member"
    },
    "#text": "Same as, but with the ability to specify the number of samples read."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_buffersink_get_frame()",
      "@_refid": "group__lavfi__buffersink_1ga653228f4cbca427c654d844a5fc59cfa",
      "@_kindref": "member"
     },
     "#text": "This function is less efficient than, because it copies the data around."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVFilter",
           "@_refid": "structAVFilter",
           "@_kindref": "compound"
          },
          "#text": "pointer to a context of the abuffersink."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "frame"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "av_frame_unref()",
            "@_refid": "group__lavu__frame_1ga0a2b687f9c1c5ed0089b01fd61227108",
            "@_kindref": "member"
           },
           {
            "#text": "av_frame_free()",
            "@_refid": "group__lavu__frame_1ga979d73f3228814aee56aeca0636e37cc",
            "@_kindref": "member"
           }
          ],
          "#text": "pointer to an allocated frame that will be filled with data. The data must be freed using/frame will contain exactly nb_samples audio samples, except at the end of stream, when it can contain less than nb_samples."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "av_buffersink_get_frame()",
         "@_refid": "group__lavfi__buffersink_1ga653228f4cbca427c654d844a5fc59cfa",
         "@_kindref": "member"
        },
        "#text": "The return codes have the same meaning as for."
       },
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_buffersink_get_frame()",
         "@_refid": "group__lavfi__buffersink_1ga653228f4cbca427c654d844a5fc59cfa",
         "@_kindref": "member"
        },
        "#text": "do not mix this function with. Use only one or the other with a single sink, not both."
       },
       "@_kind": "warning"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersink.h",
   "@_line": "167",
   "@_column": "5",
   "@_declfile": "libavfilter/buffersink.h",
   "@_declline": "167",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersink_1ga9c06b3744579f165cc032160c154828a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Same as av_buffersink_get_frame(), but with the ability to specify the number\n * of samples read. This function is less efficient than\n * av_buffersink_get_frame(), because it copies the data around.\n *\n * @param ctx pointer to a context of the abuffersink AVFilter.\n * @param frame pointer to an allocated frame that will be filled with data.\n *              The data must be freed using av_frame_unref() / av_frame_free()\n *              frame will contain exactly nb_samples audio samples, except at\n *              the end of stream, when it can contain less than nb_samples.\n *\n * @return The return codes have the same meaning as for\n *         av_buffersink_get_frame().\n *\n * @warning do not mix this function with av_buffersink_get_frame(). Use only one or\n * the other with a single sink, not both.\n */"
 },
 "av_buffersrc_get_nb_failed_requests": {
  "type": "unsigned",
  "definition": "unsigned av_buffersrc_get_nb_failed_requests",
  "argsstring": "(AVFilterContext *buffer_src)",
  "name": "av_buffersrc_get_nb_failed_requests",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFilterContext",
     "@_refid": "structAVFilterContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "buffer_src"
  },
  "briefdescription": {
   "para": "Get the number of failed requests."
  },
  "detaileddescription": {
   "para": "A failed request is when the request_frame method is called while no frame is present in the buffer. The number is reset when a frame is added."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersrc.h",
   "@_line": "64",
   "@_column": "10",
   "@_declfile": "libavfilter/buffersrc.h",
   "@_declline": "64",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersrc_1ga996e96007a0fda870549ac3c4e1e0967",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the number of failed requests.\n *\n * A failed request is when the request_frame method is called while no\n * frame is present in the buffer.\n * The number is reset when a frame is added.\n */"
 },
 "av_buffersrc_parameters_alloc": {
  "type": {
   "ref": {
    "#text": "AVBufferSrcParameters",
    "@_refid": "structAVBufferSrcParameters",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVBufferSrcParameters * av_buffersrc_parameters_alloc",
  "argsstring": "(void)",
  "name": "av_buffersrc_parameters_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVBufferSrcParameters",
     "@_refid": "structAVBufferSrcParameters",
     "@_kindref": "compound"
    },
    "#text": "Allocate a newinstance."
   }
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "av_free()",
     "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
     "@_kindref": "member"
    },
    "#text": "It should be freed by the caller with."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersrc.h",
   "@_line": "129",
   "@_column": "23",
   "@_declfile": "libavfilter/buffersrc.h",
   "@_declline": "129",
   "@_declcolumn": "23"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersrc_1gaedea0ed7a56d424274960bfff78f6477",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a new AVBufferSrcParameters instance. It should be freed by the\n * caller with av_free().\n */"
 },
 "av_buffersrc_parameters_set": {
  "type": "int",
  "definition": "int av_buffersrc_parameters_set",
  "argsstring": "(AVFilterContext *ctx, AVBufferSrcParameters *param)",
  "name": "av_buffersrc_parameters_set",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBufferSrcParameters",
      "@_refid": "structAVBufferSrcParameters",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "param"
   }
  ],
  "briefdescription": {
   "para": "Initialize the buffersrc or abuffersrc filter with the provided parameters."
  },
  "detaileddescription": {
   "para": [
    "This function may be called multiple times, the later calls override the previous ones. Some of the parameters may also be set through AVOptions, then whatever method is used last takes precedence.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ctx"
        },
        "parameterdescription": {
         "para": "an instance of the buffersrc or abuffersrc filter"
        }
       },
       {
        "parameternamelist": {
         "parametername": "param"
        },
        "parameterdescription": {
         "para": "the stream parameters. The frames later passed to this filter must conform to those parameters. All the allocated fields in param remain owned by the caller, libavfilter will make internal copies or references when necessary."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, a negative AVERROR code on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersrc.h",
   "@_line": "144",
   "@_column": "5",
   "@_declfile": "libavfilter/buffersrc.h",
   "@_declline": "144",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersrc_1ga398cd2a84f8b4a588197ab9d90135048",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize the buffersrc or abuffersrc filter with the provided parameters.\n * This function may be called multiple times, the later calls override the\n * previous ones. Some of the parameters may also be set through AVOptions, then\n * whatever method is used last takes precedence.\n *\n * @param ctx an instance of the buffersrc or abuffersrc filter\n * @param param the stream parameters. The frames later passed to this filter\n *              must conform to those parameters. All the allocated fields in\n *              param remain owned by the caller, libavfilter will make internal\n *              copies or references when necessary.\n * @return 0 on success, a negative AVERROR code on failure.\n */"
 },
 "av_buffersrc_write_frame": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int av_buffersrc_write_frame",
  "argsstring": "(AVFilterContext *ctx, const AVFrame *frame)",
  "name": "av_buffersrc_write_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "frame"
   }
  ],
  "briefdescription": {
   "para": "Add a frame to the buffer source."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "an instance of the buffersrc filter"
       }
      },
      {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": "frame to be added. If the frame is reference counted, this function will make a new reference to it. Otherwise the frame data will be copied."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative AVERROR on error",
     "@_kind": "return"
    },
    "ref": {
     "#text": "av_buffersrc_add_frame_flags()",
     "@_refid": "group__lavfi__buffersrc_1ga73ed90c3c3407f36e54d65f91faaaed9",
     "@_kindref": "member"
    },
    "#text": "This function is equivalent towith the AV_BUFFERSRC_FLAG_KEEP_REF flag."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersrc.h",
   "@_line": "160",
   "@_column": "5",
   "@_declfile": "libavfilter/buffersrc.h",
   "@_declline": "160",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersrc_1ga786409c3f3910a0ab5fa6b23b4e7399b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a frame to the buffer source.\n *\n * @param ctx   an instance of the buffersrc filter\n * @param frame frame to be added. If the frame is reference counted, this\n * function will make a new reference to it. Otherwise the frame data will be\n * copied.\n *\n * @return 0 on success, a negative AVERROR on error\n *\n * This function is equivalent to av_buffersrc_add_frame_flags() with the\n * AV_BUFFERSRC_FLAG_KEEP_REF flag.\n */"
 },
 "av_buffersrc_add_frame": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int av_buffersrc_add_frame",
  "argsstring": "(AVFilterContext *ctx, AVFrame *frame)",
  "name": "av_buffersrc_add_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   }
  ],
  "briefdescription": {
   "para": "Add a frame to the buffer source."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "an instance of the buffersrc filter"
       }
      },
      {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": "frame to be added. If the frame is reference counted, this function will take ownership of the reference(s) and reset the frame. Otherwise the frame data will be copied. If this function returns an error, the input frame is not touched."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "0 on success, a negative AVERROR on error.",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": [
        {
         "#text": "av_buffersrc_write_frame()",
         "@_refid": "group__lavfi__buffersrc_1ga786409c3f3910a0ab5fa6b23b4e7399b",
         "@_kindref": "member"
        },
        {
         "#text": "av_buffersrc_write_frame()",
         "@_refid": "group__lavfi__buffersrc_1ga786409c3f3910a0ab5fa6b23b4e7399b",
         "@_kindref": "member"
        }
       ],
       "#text": "the difference between this function andis thatcreates a new reference to the input frame, while this function takes ownership of the reference passed to it."
      },
      "@_kind": "note"
     }
    ],
    "ref": {
     "#text": "av_buffersrc_add_frame_flags()",
     "@_refid": "group__lavfi__buffersrc_1ga73ed90c3c3407f36e54d65f91faaaed9",
     "@_kindref": "member"
    },
    "#text": "This function is equivalent towithout the AV_BUFFERSRC_FLAG_KEEP_REF flag."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersrc.h",
   "@_line": "181",
   "@_column": "5",
   "@_declfile": "libavfilter/buffersrc.h",
   "@_declline": "181",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "filter__audio_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "filter__audio_8c",
   "@_startline": "267",
   "@_endline": "360"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersrc_1ga8fc71cb48c1ad1aa78b48f87daa4cf19",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a frame to the buffer source.\n *\n * @param ctx   an instance of the buffersrc filter\n * @param frame frame to be added. If the frame is reference counted, this\n * function will take ownership of the reference(s) and reset the frame.\n * Otherwise the frame data will be copied. If this function returns an error,\n * the input frame is not touched.\n *\n * @return 0 on success, a negative AVERROR on error.\n *\n * @note the difference between this function and av_buffersrc_write_frame() is\n * that av_buffersrc_write_frame() creates a new reference to the input frame,\n * while this function takes ownership of the reference passed to it.\n *\n * This function is equivalent to av_buffersrc_add_frame_flags() without the\n * AV_BUFFERSRC_FLAG_KEEP_REF flag.\n */"
 },
 "av_buffersrc_add_frame_flags": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int av_buffersrc_add_frame_flags",
  "argsstring": "(AVFilterContext *buffer_src, AVFrame *frame, int flags)",
  "name": "av_buffersrc_add_frame_flags",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "buffer_src"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Add a frame to the buffer source."
  },
  "detaileddescription": {
   "para": [
    "By default, if the frame is reference-counted, this function will take ownership of the reference(s) and reset the frame. This can be controlled using the flags.",
    "If this function returns an error, the input frame is not touched.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "buffer_src"
        },
        "parameterdescription": {
         "para": "pointer to a buffer source context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "frame"
        },
        "parameterdescription": {
         "para": "a frame, or NULL to mark EOF"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "a combination of AV_BUFFERSRC_FLAG_*"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">= 0 in case of success, a negative AVERROR code in case of failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersrc.h",
   "@_line": "199",
   "@_column": "5",
   "@_declfile": "libavfilter/buffersrc.h",
   "@_declline": "199",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "filter_encode_write_frame",
    "@_refid": "transcode_8c_1a255192428438daf73b9f8060c0815712",
    "@_compoundref": "transcode_8c",
    "@_startline": "473",
    "@_endline": "511"
   },
   {
    "#text": "main",
    "@_refid": "decode__filter__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "217",
    "@_endline": "296"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavfi__buffersrc_1ga73ed90c3c3407f36e54d65f91faaaed9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a frame to the buffer source.\n *\n * By default, if the frame is reference-counted, this function will take\n * ownership of the reference(s) and reset the frame. This can be controlled\n * using the flags.\n *\n * If this function returns an error, the input frame is not touched.\n *\n * @param buffer_src  pointer to a buffer source context\n * @param frame       a frame, or NULL to mark EOF\n * @param flags       a combination of AV_BUFFERSRC_FLAG_*\n * @return            >= 0 in case of success, a negative AVERROR code\n *                    in case of failure\n */"
 },
 "av_buffersrc_close": {
  "type": "int",
  "definition": "int av_buffersrc_close",
  "argsstring": "(AVFilterContext *ctx, int64_t pts, unsigned flags)",
  "name": "av_buffersrc_close",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFilterContext",
      "@_refid": "structAVFilterContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": "int64_t",
    "declname": "pts"
   },
   {
    "type": "unsigned",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Close the buffer source after EOF."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "av_buffersrc_add_frame_flags()",
     "@_refid": "group__lavfi__buffersrc_1ga73ed90c3c3407f36e54d65f91faaaed9",
     "@_kindref": "member"
    },
    "#text": "This is similar to passing NULL toexcept it takes the timestamp of the EOF, i.e. the timestamp of the end of the last frame."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/buffersrc.h",
   "@_line": "209",
   "@_column": "5",
   "@_declfile": "libavfilter/buffersrc.h",
   "@_declline": "209",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavfi__buffersrc_1ga828fc86955dc0530ea53c123862e3da6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Close the buffer source after EOF.\n *\n * This is similar to passing NULL to av_buffersrc_add_frame_flags()\n * except it takes the timestamp of the EOF, i.e. the timestamp of the end\n * of the last frame.\n */"
 },
 "av_camellia_size": {
  "type": "const int",
  "definition": "const int av_camellia_size",
  "argsstring": "",
  "name": "av_camellia_size",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/camellia.h",
   "@_line": "36",
   "@_column": "18",
   "@_declfile": "libavutil/camellia.h",
   "@_declline": "36",
   "@_declcolumn": "18"
  },
  "@_kind": "variable",
  "@_id": "group__lavu__camellia_1ga148900bf024608d457ddd7fbb4f7ebc2",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n  * @file\n  * @brief Public header for libavutil CAMELLIA algorithm\n  * @defgroup lavu_camellia CAMELLIA\n  * @ingroup lavu_crypto\n  * @{\n  */"
 },
 "av_camellia_alloc": {
  "type": "struct AVCAMELLIA *",
  "definition": "struct AVCAMELLIA * av_camellia_alloc",
  "argsstring": "(void)",
  "name": "av_camellia_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVCAMELLIA context To free the struct: av_free(ptr)"
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/camellia.h",
   "@_line": "44",
   "@_column": "17",
   "@_declfile": "libavutil/camellia.h",
   "@_declline": "44",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavu__camellia_1ga635ab1e0364e9e605b75dc66956655ac",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n  * Allocate an AVCAMELLIA context\n  * To free the struct: av_free(ptr)\n  */"
 },
 "av_camellia_init": {
  "type": "int",
  "definition": "int av_camellia_init",
  "argsstring": "(struct AVCAMELLIA *ctx, const uint8_t *key, int key_bits)",
  "name": "av_camellia_init",
  "param": [
   {
    "type": "struct AVCAMELLIA *",
    "declname": "ctx"
   },
   {
    "type": "const uint8_t *",
    "declname": "key"
   },
   {
    "type": "int",
    "declname": "key_bits"
   }
  ],
  "briefdescription": {
   "para": "Initialize an AVCAMELLIA context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "an AVCAMELLIA context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "a key of 16, 24, 32 bytes used for encryption/decryption"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key_bits"
       },
       "parameterdescription": {
        "para": "number of keybits: possible are 128, 192, 256"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/camellia.h",
   "@_line": "53",
   "@_column": "5",
   "@_declfile": "libavutil/camellia.h",
   "@_declline": "53",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__camellia_1gaf7f182d8ab55c60e69ac2cf0413a8dbe",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n  * Initialize an AVCAMELLIA context.\n  *\n  * @param ctx an AVCAMELLIA context\n  * @param key a key of 16, 24, 32 bytes used for encryption/decryption\n  * @param key_bits number of keybits: possible are 128, 192, 256\n */"
 },
 "av_camellia_crypt": {
  "type": "void",
  "definition": "void av_camellia_crypt",
  "argsstring": "(struct AVCAMELLIA *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt)",
  "name": "av_camellia_crypt",
  "param": [
   {
    "type": "struct AVCAMELLIA *",
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "uint8_t *",
    "declname": "iv"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypt or decrypt a buffer using a previously initialized context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "an AVCAMELLIA context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of 16 byte blocks"
       }
      },
      {
       "parameternamelist": {
        "parametername": "iv"
       },
       "parameterdescription": {
        "para": "initialization vector for CBC mode, NULL for ECB mode"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/camellia.h",
   "@_line": "65",
   "@_column": "6",
   "@_declfile": "libavutil/camellia.h",
   "@_declline": "65",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__camellia_1ga2928427ed68f873d17ed59e21bb28911",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n  * Encrypt or decrypt a buffer using a previously initialized context\n  *\n  * @param ctx an AVCAMELLIA context\n  * @param dst destination array, can be equal to src\n  * @param src source array, can be equal to dst\n  * @param count number of 16 byte blocks\n  * @param iv initialization vector for CBC mode, NULL for ECB mode\n  * @param decrypt 0 for encryption, 1 for decryption\n */"
 },
 "av_cast5_size": {
  "type": "const int",
  "definition": "const int av_cast5_size",
  "argsstring": "",
  "name": "av_cast5_size",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/cast5.h",
   "@_line": "36",
   "@_column": "18",
   "@_declfile": "libavutil/cast5.h",
   "@_declline": "36",
   "@_declcolumn": "18"
  },
  "@_kind": "variable",
  "@_id": "group__lavu__cast5_1ga00f0cc05aeee06257fb27eb6247d8092",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n  * @file\n  * @brief Public header for libavutil CAST5 algorithm\n  * @defgroup lavu_cast5 CAST5\n  * @ingroup lavu_crypto\n  * @{\n  */"
 },
 "av_cast5_alloc": {
  "type": "struct AVCAST5 *",
  "definition": "struct AVCAST5 * av_cast5_alloc",
  "argsstring": "(void)",
  "name": "av_cast5_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVCAST5 context To free the struct: av_free(ptr)"
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/cast5.h",
   "@_line": "44",
   "@_column": "14",
   "@_declfile": "libavutil/cast5.h",
   "@_declline": "44",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "group__lavu__cast5_1ga6701a501a5ec949150afaa2c7a3c0a06",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n  * Allocate an AVCAST5 context\n  * To free the struct: av_free(ptr)\n  */"
 },
 "av_cast5_init": {
  "type": "int",
  "definition": "int av_cast5_init",
  "argsstring": "(struct AVCAST5 *ctx, const uint8_t *key, int key_bits)",
  "name": "av_cast5_init",
  "param": [
   {
    "type": "struct AVCAST5 *",
    "declname": "ctx"
   },
   {
    "type": "const uint8_t *",
    "declname": "key"
   },
   {
    "type": "int",
    "declname": "key_bits"
   }
  ],
  "briefdescription": {
   "para": "Initialize an AVCAST5 context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "an AVCAST5 context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "a key of 5,6,...16 bytes used for encryption/decryption"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key_bits"
       },
       "parameterdescription": {
        "para": "number of keybits: possible are 40,48,...,128"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, less than 0 on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/cast5.h",
   "@_line": "53",
   "@_column": "5",
   "@_declfile": "libavutil/cast5.h",
   "@_declline": "53",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__cast5_1ga604b7f58779a1c41c9c6c5a1016ecc72",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n  * Initialize an AVCAST5 context.\n  *\n  * @param ctx an AVCAST5 context\n  * @param key a key of 5,6,...16 bytes used for encryption/decryption\n  * @param key_bits number of keybits: possible are 40,48,...,128\n  * @return 0 on success, less than 0 on failure\n */"
 },
 "av_cast5_crypt": {
  "type": "void",
  "definition": "void av_cast5_crypt",
  "argsstring": "(struct AVCAST5 *ctx, uint8_t *dst, const uint8_t *src, int count, int decrypt)",
  "name": "av_cast5_crypt",
  "param": [
   {
    "type": "struct AVCAST5 *",
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypt or decrypt a buffer using a previously initialized context, ECB mode only."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "an AVCAST5 context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of 8 byte blocks"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/cast5.h",
   "@_line": "64",
   "@_column": "6",
   "@_declfile": "libavutil/cast5.h",
   "@_declline": "64",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__cast5_1ga2097b4a332bd12e51674788a3008a53e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n  * Encrypt or decrypt a buffer using a previously initialized context, ECB mode only\n  *\n  * @param ctx an AVCAST5 context\n  * @param dst destination array, can be equal to src\n  * @param src source array, can be equal to dst\n  * @param count number of 8 byte blocks\n  * @param decrypt 0 for encryption, 1 for decryption\n */"
 },
 "av_cast5_crypt2": {
  "type": "void",
  "definition": "void av_cast5_crypt2",
  "argsstring": "(struct AVCAST5 *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt)",
  "name": "av_cast5_crypt2",
  "param": [
   {
    "type": "struct AVCAST5 *",
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "uint8_t *",
    "declname": "iv"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypt or decrypt a buffer using a previously initialized context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "an AVCAST5 context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of 8 byte blocks"
       }
      },
      {
       "parameternamelist": {
        "parametername": "iv"
       },
       "parameterdescription": {
        "para": "initialization vector for CBC mode, NULL for ECB mode"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/cast5.h",
   "@_line": "76",
   "@_column": "6",
   "@_declfile": "libavutil/cast5.h",
   "@_declline": "76",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__cast5_1gad7f20dd3446e711c8fcc8c2e57c2c7d8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n  * Encrypt or decrypt a buffer using a previously initialized context\n  *\n  * @param ctx an AVCAST5 context\n  * @param dst destination array, can be equal to src\n  * @param src source array, can be equal to dst\n  * @param count number of 8 byte blocks\n  * @param iv initialization vector for CBC mode, NULL for ECB mode\n  * @param decrypt 0 for encryption, 1 for decryption\n */"
 },
 "av_channel_name": {
  "type": "int",
  "definition": "int av_channel_name",
  "argsstring": "(char *buf, size_t buf_size, enum AVChannel channel)",
  "name": "av_channel_name",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "size_t",
    "declname": "buf_size"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannel",
      "@_refid": "group__lavu__audio__channels_1gaa4a685b5c38835392552a7f96ee24a3e",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "channel"
   }
  ],
  "briefdescription": {
   "para": "Get a human readable string in an abbreviated form describing a given channel."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_channel_from_string()",
      "@_refid": "group__lavu__audio__channels_1gaf6d58f0ff59e1985f8dd337f7a7736e7",
      "@_kindref": "member"
     },
     "#text": "This is the inverse function of."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "pre-allocated buffer where to put the generated string"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf_size"
        },
        "parameterdescription": {
         "para": "size in bytes of the buffer."
        }
       },
       {
        "parameternamelist": {
         "parametername": "channel"
        },
        "parameterdescription": {
         "para": "the AVChannel whose name to get"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "amount of bytes needed to hold the output string, or a negative AVERROR on failure. If the returned value is bigger than buf_size, then the string was truncated.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "438",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "438",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga681f40bf6e8e1e56189a625fe0a671b5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a human readable string in an abbreviated form describing a given channel.\n * This is the inverse function of @ref av_channel_from_string().\n *\n * @param buf pre-allocated buffer where to put the generated string\n * @param buf_size size in bytes of the buffer.\n * @param channel the AVChannel whose name to get\n * @return amount of bytes needed to hold the output string, or a negative AVERROR\n *         on failure. If the returned value is bigger than buf_size, then the\n *         string was truncated.\n */"
 },
 "av_channel_name_bprint": {
  "type": "void",
  "definition": "void av_channel_name_bprint",
  "argsstring": "(struct AVBPrint *bp, enum AVChannel channel_id)",
  "name": "av_channel_name_bprint",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "bp"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannel",
      "@_refid": "group__lavu__audio__channels_1gaa4a685b5c38835392552a7f96ee24a3e",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "channel_id"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_channel_name()",
     "@_refid": "group__lavu__audio__channels_1ga681f40bf6e8e1e56189a625fe0a671b5",
     "@_kindref": "member"
    },
    "#text": "bprint variant of."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the string will be appended to the bprint buffer.",
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "445",
   "@_column": "6",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "445",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1gac5b1e5d877988c022b6fc82f179d9792",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * bprint variant of av_channel_name().\n *\n * @note the string will be appended to the bprint buffer.\n */"
 },
 "av_channel_description": {
  "type": "int",
  "definition": "int av_channel_description",
  "argsstring": "(char *buf, size_t buf_size, enum AVChannel channel)",
  "name": "av_channel_description",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "size_t",
    "declname": "buf_size"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannel",
      "@_refid": "group__lavu__audio__channels_1gaa4a685b5c38835392552a7f96ee24a3e",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "channel"
   }
  ],
  "briefdescription": {
   "para": "Get a human readable string describing a given channel."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "pre-allocated buffer where to put the generated string"
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf_size"
       },
       "parameterdescription": {
        "para": "size in bytes of the buffer."
       }
      },
      {
       "parameternamelist": {
        "parametername": "channel"
       },
       "parameterdescription": {
        "para": "the AVChannel whose description to get"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "amount of bytes needed to hold the output string, or a negative AVERROR on failure. If the returned value is bigger than buf_size, then the string was truncated.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "457",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "457",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga7234a8b4e45c5d1857a5c5719828a98e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a human readable string describing a given channel.\n *\n * @param buf pre-allocated buffer where to put the generated string\n * @param buf_size size in bytes of the buffer.\n * @param channel the AVChannel whose description to get\n * @return amount of bytes needed to hold the output string, or a negative AVERROR\n *         on failure. If the returned value is bigger than buf_size, then the\n *         string was truncated.\n */"
 },
 "av_channel_description_bprint": {
  "type": "void",
  "definition": "void av_channel_description_bprint",
  "argsstring": "(struct AVBPrint *bp, enum AVChannel channel_id)",
  "name": "av_channel_description_bprint",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "bp"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannel",
      "@_refid": "group__lavu__audio__channels_1gaa4a685b5c38835392552a7f96ee24a3e",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "channel_id"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_channel_description()",
     "@_refid": "group__lavu__audio__channels_1ga7234a8b4e45c5d1857a5c5719828a98e",
     "@_kindref": "member"
    },
    "#text": "bprint variant of."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the string will be appended to the bprint buffer.",
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "464",
   "@_column": "6",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "464",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga4e9e32d714fbab735e73cf0874421692",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * bprint variant of av_channel_description().\n *\n * @note the string will be appended to the bprint buffer.\n */"
 },
 "av_channel_from_string": {
  "type": {
   "ref": {
    "#text": "AVChannel",
    "@_refid": "group__lavu__audio__channels_1gaa4a685b5c38835392552a7f96ee24a3e",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVChannel av_channel_from_string",
  "argsstring": "(const char *name)",
  "name": "av_channel_from_string",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_channel_name()",
     "@_refid": "group__lavu__audio__channels_1ga681f40bf6e8e1e56189a625fe0a671b5",
     "@_kindref": "member"
    },
    "#text": "This is the inverse function of."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the channel with the given name AV_CHAN_NONE when name does not identify a known channel",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "472",
   "@_column": "15",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "472",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1gaf6d58f0ff59e1985f8dd337f7a7736e7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * This is the inverse function of @ref av_channel_name().\n *\n * @return the channel with the given name\n *         AV_CHAN_NONE when name does not identify a known channel\n */"
 },
 "av_channel_layout_custom_init": {
  "type": "int",
  "definition": "int av_channel_layout_custom_init",
  "argsstring": "(AVChannelLayout *channel_layout, int nb_channels)",
  "name": "av_channel_layout_custom_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "channel_layout"
   },
   {
    "type": "int",
    "declname": "nb_channels"
   }
  ],
  "briefdescription": {
   "para": "Initialize a custom channel layout with the specified number of channels."
  },
  "detaileddescription": {
   "para": [
    "The channel map will be allocated and the designation of all channels will be set to AV_CHAN_UNKNOWN.",
    "This is only a convenience helper function, a custom channel layout can also be constructed without using this.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "channel_layout"
        },
        "parameterdescription": {
         "para": "the layout structure to be initialized"
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_channels"
        },
        "parameterdescription": {
         "para": "the number of channels"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "AVERROR(EINVAL)",
         "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
         "@_kindref": "member"
        },
        {
         "#text": "AVERROR(ENOMEM)",
         "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
         "@_kindref": "member"
        }
       ],
       "#text": "0 on successif the number of channels <= 0if the channel map could not be allocated"
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "489",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "489",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga85eb469eb73f5df8317ee713ab460d19",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize a custom channel layout with the specified number of channels.\n * The channel map will be allocated and the designation of all channels will\n * be set to AV_CHAN_UNKNOWN.\n *\n * This is only a convenience helper function, a custom channel layout can also\n * be constructed without using this.\n *\n * @param channel_layout the layout structure to be initialized\n * @param nb_channels the number of channels\n *\n * @return 0 on success\n *         AVERROR(EINVAL) if the number of channels <= 0\n *         AVERROR(ENOMEM) if the channel map could not be allocated\n */"
 },
 "av_channel_layout_from_mask": {
  "type": "int",
  "definition": "int av_channel_layout_from_mask",
  "argsstring": "(AVChannelLayout *channel_layout, uint64_t mask)",
  "name": "av_channel_layout_from_mask",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "channel_layout"
   },
   {
    "type": "uint64_t",
    "declname": "mask"
   }
  ],
  "briefdescription": {
   "para": "Initialize a native channel layout from a bitmask indicating which channels are present."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "channel_layout"
       },
       "parameterdescription": {
        "para": "the layout structure to be initialized"
       }
      },
      {
       "parameternamelist": {
        "parametername": "mask"
       },
       "parameterdescription": {
        "para": "bitmask describing the channel layout"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVERROR(EINVAL)",
       "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
       "@_kindref": "member"
      },
      "#text": "0 on successfor invalid mask values"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "501",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "501",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1gac9cb15062033104227cb64f17196f684",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize a native channel layout from a bitmask indicating which channels\n * are present.\n *\n * @param channel_layout the layout structure to be initialized\n * @param mask bitmask describing the channel layout\n *\n * @return 0 on success\n *         AVERROR(EINVAL) for invalid mask values\n */"
 },
 "av_channel_layout_from_string": {
  "type": "int",
  "definition": "int av_channel_layout_from_string",
  "argsstring": "(AVChannelLayout *channel_layout, const char *str)",
  "name": "av_channel_layout_from_string",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "channel_layout"
   },
   {
    "type": "const char *",
    "declname": "str"
   }
  ],
  "briefdescription": {
   "para": "Initialize a channel layout from a given string description."
  },
  "detaileddescription": {
   "para": [
    {
     "itemizedlist": {
      "listitem": [
       {
        "para": {
         "ref": {
          "#text": "av_channel_layout_describe()",
          "@_refid": "group__lavu__audio__channels_1gacc7d7d1a280248aafb8f9196c9d4e24f",
          "@_kindref": "member"
         },
         "#text": "the formal channel layout name (returned by)"
        }
       },
       {
        "para": {
         "ref": {
          "#text": "av_channel_name()",
          "@_refid": "group__lavu__audio__channels_1ga681f40bf6e8e1e56189a625fe0a671b5",
          "@_kindref": "member"
         },
         "#text": "single or multiple channel names (returned by, eg. \"FL\", or concatenated with \"+\", each optionally containing a custom name after a \"@\", eg. \"FL@Left+FR@Right+LFE\")"
        }
       },
       {
        "para": "a decimal or hexadecimal value of a native channel layout (eg. \"4\" or \"0x4\")"
       },
       {
        "para": "the number of channels with default layout (eg. \"4c\")"
       },
       {
        "para": "the number of unordered channels (eg. \"4C\" or \"4 channels\")"
       },
       {
        "para": "the ambisonic order followed by optional non-diegetic channels (eg. \"ambisonic 2+stereo\") On error, the channel layout will remain uninitialized, but not necessarily untouched."
       }
      ]
     },
     "#text": "The input string can be represented by:"
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "channel_layout"
        },
        "parameterdescription": {
         "para": "uninitialized channel layout for the result"
        }
       },
       {
        "parameternamelist": {
         "parametername": "str"
        },
        "parameterdescription": {
         "para": "string describing the channel layout"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "AVERROR(EINVAL)",
         "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
         "@_kindref": "member"
        },
        {
         "#text": "AVERROR(ENOMEM)",
         "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
         "@_kindref": "member"
        }
       ],
       "#text": "0 on success parsing the channel layoutif an invalid channel layout string was providedif there was not enough memory"
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "524",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "524",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga16a894cd275eba471ccad4fe1c5e5c28",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize a channel layout from a given string description.\n * The input string can be represented by:\n *  - the formal channel layout name (returned by av_channel_layout_describe())\n *  - single or multiple channel names (returned by av_channel_name(), eg. \"FL\",\n *    or concatenated with \"+\", each optionally containing a custom name after\n *    a \"@\", eg. \"FL@Left+FR@Right+LFE\")\n *  - a decimal or hexadecimal value of a native channel layout (eg. \"4\" or \"0x4\")\n *  - the number of channels with default layout (eg. \"4c\")\n *  - the number of unordered channels (eg. \"4C\" or \"4 channels\")\n *  - the ambisonic order followed by optional non-diegetic channels (eg.\n *    \"ambisonic 2+stereo\")\n * On error, the channel layout will remain uninitialized, but not necessarily\n * untouched.\n *\n * @param channel_layout uninitialized channel layout for the result\n * @param str string describing the channel layout\n * @return 0 on success parsing the channel layout\n *         AVERROR(EINVAL) if an invalid channel layout string was provided\n *         AVERROR(ENOMEM) if there was not enough memory\n */"
 },
 "av_channel_layout_default": {
  "type": "void",
  "definition": "void av_channel_layout_default",
  "argsstring": "(AVChannelLayout *ch_layout, int nb_channels)",
  "name": "av_channel_layout_default",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ch_layout"
   },
   {
    "type": "int",
    "declname": "nb_channels"
   }
  ],
  "briefdescription": {
   "para": "Get the default channel layout for a given number of channels."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ch_layout"
       },
       "parameterdescription": {
        "para": "the layout structure to be initialized"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_channels"
       },
       "parameterdescription": {
        "para": "number of channels"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "533",
   "@_column": "6",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "533",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode__aac_8c_1a617f4760254c119fc7caa222f3fcbd21",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "145",
    "@_endline": "246"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga029ec415428807b9c3d433c58985a3da",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the default channel layout for a given number of channels.\n *\n * @param ch_layout the layout structure to be initialized\n * @param nb_channels number of channels\n */"
 },
 "av_channel_layout_standard": {
  "type": {
   "ref": {
    "#text": "AVChannelLayout",
    "@_refid": "structAVChannelLayout",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVChannelLayout * av_channel_layout_standard",
  "argsstring": "(void **opaque)",
  "name": "av_channel_layout_standard",
  "param": {
   "type": "void **",
   "declname": "opaque"
  },
  "briefdescription": {
   "para": "Iterate over all standard channel layouts."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "opaque"
      },
      "parameterdescription": {
       "para": "a pointer where libavutil will store the iteration state. Must point to NULL to start the iteration."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the standard channel layout or NULL when the iteration is finished",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "544",
   "@_column": "23",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "544",
   "@_declcolumn": "23"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1gaeca968d4f1788f6089f2297c267a24ee",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over all standard channel layouts.\n *\n * @param opaque a pointer where libavutil will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the standard channel layout or NULL when the iteration is\n *         finished\n */"
 },
 "av_channel_layout_uninit": {
  "type": "void",
  "definition": "void av_channel_layout_uninit",
  "argsstring": "(AVChannelLayout *channel_layout)",
  "name": "av_channel_layout_uninit",
  "param": {
   "type": {
    "ref": {
     "#text": "AVChannelLayout",
     "@_refid": "structAVChannelLayout",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "channel_layout"
  },
  "briefdescription": {
   "para": "Free any allocated data in the channel layout and reset the channel count to 0."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "channel_layout"
      },
      "parameterdescription": {
       "para": "the layout structure to be uninitialized"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "552",
   "@_column": "6",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "552",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga95f7befa6afcea5958c095da37c4ea04",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free any allocated data in the channel layout and reset the channel\n * count to 0.\n *\n * @param channel_layout the layout structure to be uninitialized\n */"
 },
 "av_channel_layout_copy": {
  "type": "int",
  "definition": "int av_channel_layout_copy",
  "argsstring": "(AVChannelLayout *dst, const AVChannelLayout *src)",
  "name": "av_channel_layout_copy",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Make a copy of a channel layout."
  },
  "detaileddescription": {
   "para": [
    "This differs from just assigning src to dst in that it allocates and copies the map for AV_CHANNEL_ORDER_CUSTOM.",
    {
     "simplesect": [
      {
       "para": "the destination channel_layout will be always uninitialized before copy.",
       "@_kind": "note"
      },
      {
       "para": "0 on success, a negative AVERROR on error.",
       "@_kind": "return"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "destination channel layout"
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "source channel layout"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "564",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "564",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "add_stream",
    "@_refid": "mux_8c_1a22968a15b922fd8c0c37b49beec06dbe",
    "@_compoundref": "mux_8c",
    "@_startline": "125",
    "@_endline": "211"
   },
   {
    "#text": "alloc_audio_frame",
    "@_refid": "mux_8c_1ad09eda99489f30c7d2d9adda00fd4444",
    "@_compoundref": "mux_8c",
    "@_startline": "216",
    "@_endline": "239"
   },
   {
    "#text": "get_input",
    "@_refid": "filter__audio_8c_1a4209191767f4a5779718e9f691a6de53",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "239",
    "@_endline": "265"
   },
   {
    "#text": "init_output_frame",
    "@_refid": "transcode__aac_8c_1a72741423006b4ab38bf924fa567e7081",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "608",
    "@_endline": "640"
   },
   {
    "#text": "main",
    "@_refid": "encode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "encode__audio_8c",
    "@_startline": "122",
    "@_endline": "240"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   },
   {
    "#text": "select_channel_layout",
    "@_refid": "encode__audio_8c_1a175a0fbc2b352f9c1102cf823f0fca0c",
    "@_compoundref": "encode__audio_8c",
    "@_startline": "73",
    "@_endline": "92"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1gad36be43b2a1b14b66492b8025b82f886",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Make a copy of a channel layout. This differs from just assigning src to dst\n * in that it allocates and copies the map for AV_CHANNEL_ORDER_CUSTOM.\n *\n * @note the destination channel_layout will be always uninitialized before copy.\n *\n * @param dst destination channel layout\n * @param src source channel layout\n * @return 0 on success, a negative AVERROR on error.\n */"
 },
 "av_channel_layout_describe": {
  "type": "int",
  "definition": "int av_channel_layout_describe",
  "argsstring": "(const AVChannelLayout *channel_layout, char *buf, size_t buf_size)",
  "name": "av_channel_layout_describe",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "channel_layout"
   },
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "size_t",
    "declname": "buf_size"
   }
  ],
  "briefdescription": {
   "para": "Get a human-readable string describing the channel layout properties."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_channel_layout_from_string()",
      "@_refid": "group__lavu__audio__channels_1ga16a894cd275eba471ccad4fe1c5e5c28",
      "@_kindref": "member"
     },
     "#text": "The string will be in the same format that is accepted by, allowing to rebuild the same channel layout, except for opaque pointers."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "channel_layout"
        },
        "parameterdescription": {
         "para": "channel layout to be described"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "pre-allocated buffer where to put the generated string"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf_size"
        },
        "parameterdescription": {
         "para": "size in bytes of the buffer."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "amount of bytes needed to hold the output string, or a negative AVERROR on failure. If the returned value is bigger than buf_size, then the string was truncated.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "579",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "579",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filter_graph",
    "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "60",
    "@_endline": "208"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   },
   {
    "#text": "main",
    "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "resample__audio_8c",
    "@_startline": "85",
    "@_endline": "220"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1gacc7d7d1a280248aafb8f9196c9d4e24f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a human-readable string describing the channel layout properties.\n * The string will be in the same format that is accepted by\n * @ref av_channel_layout_from_string(), allowing to rebuild the same\n * channel layout, except for opaque pointers.\n *\n * @param channel_layout channel layout to be described\n * @param buf pre-allocated buffer where to put the generated string\n * @param buf_size size in bytes of the buffer.\n * @return amount of bytes needed to hold the output string, or a negative AVERROR\n *         on failure. If the returned value is bigger than buf_size, then the\n *         string was truncated.\n */"
 },
 "av_channel_layout_describe_bprint": {
  "type": "int",
  "definition": "int av_channel_layout_describe_bprint",
  "argsstring": "(const AVChannelLayout *channel_layout, struct AVBPrint *bp)",
  "name": "av_channel_layout_describe_bprint",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "channel_layout"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBPrint",
      "@_refid": "structAVBPrint",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "bp"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_channel_layout_describe()",
     "@_refid": "group__lavu__audio__channels_1gacc7d7d1a280248aafb8f9196c9d4e24f",
     "@_kindref": "member"
    },
    "#text": "bprint variant of."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": "the string will be appended to the bprint buffer.",
      "@_kind": "note"
     },
     {
      "para": "0 on success, or a negative AVERROR value on failure.",
      "@_kind": "return"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "588",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "588",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga33ebd5cd9707073a5868f221808aac48",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * bprint variant of av_channel_layout_describe().\n *\n * @note the string will be appended to the bprint buffer.\n * @return 0 on success, or a negative AVERROR value on failure.\n */"
 },
 "av_channel_layout_channel_from_index": {
  "type": {
   "ref": {
    "#text": "AVChannel",
    "@_refid": "group__lavu__audio__channels_1gaa4a685b5c38835392552a7f96ee24a3e",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVChannel av_channel_layout_channel_from_index",
  "argsstring": "(const AVChannelLayout *channel_layout, unsigned int idx)",
  "name": "av_channel_layout_channel_from_index",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "channel_layout"
   },
   {
    "type": "unsigned int",
    "declname": "idx"
   }
  ],
  "briefdescription": {
   "para": "Get the channel with the given index in a channel layout."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "channel_layout"
       },
       "parameterdescription": {
        "para": "input channel layout"
       }
      },
      {
       "parameternamelist": {
        "parametername": "idx"
       },
       "parameterdescription": {
        "para": "index of the channel"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "channel with the index idx in channel_layout on success or AV_CHAN_NONE on failure (if idx is not valid or the channel order is unspecified)",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "601",
   "@_column": "1",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "601",
   "@_declcolumn": "1"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga88fce9f08c646dabe598123f00425039",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the channel with the given index in a channel layout.\n *\n * @param channel_layout input channel layout\n * @param idx index of the channel\n * @return channel with the index idx in channel_layout on success or\n *         AV_CHAN_NONE on failure (if idx is not valid or the channel order is\n *         unspecified)\n */"
 },
 "av_channel_layout_index_from_channel": {
  "type": "int",
  "definition": "int av_channel_layout_index_from_channel",
  "argsstring": "(const AVChannelLayout *channel_layout, enum AVChannel channel)",
  "name": "av_channel_layout_index_from_channel",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "channel_layout"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannel",
      "@_refid": "group__lavu__audio__channels_1gaa4a685b5c38835392552a7f96ee24a3e",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "channel"
   }
  ],
  "briefdescription": {
   "para": "Get the index of a given channel in a channel layout."
  },
  "detaileddescription": {
   "para": [
    "In case multiple channels are found, only the first match will be returned.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "channel_layout"
        },
        "parameterdescription": {
         "para": "input channel layout"
        }
       },
       {
        "parameternamelist": {
         "parametername": "channel"
        },
        "parameterdescription": {
         "para": "the channel whose index to obtain"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "index of channel in channel_layout on success or a negative number if channel is not present in channel_layout.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "612",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "612",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga195fe07f50c7e4f47303891073fa3867",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the index of a given channel in a channel layout. In case multiple\n * channels are found, only the first match will be returned.\n *\n * @param channel_layout input channel layout\n * @param channel the channel whose index to obtain\n * @return index of channel in channel_layout on success or a negative number if\n *         channel is not present in channel_layout.\n */"
 },
 "av_channel_layout_index_from_string": {
  "type": "int",
  "definition": "int av_channel_layout_index_from_string",
  "argsstring": "(const AVChannelLayout *channel_layout, const char *name)",
  "name": "av_channel_layout_index_from_string",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "channel_layout"
   },
   {
    "type": "const char *",
    "declname": "name"
   }
  ],
  "briefdescription": {
   "para": "Get the index in a channel layout of a channel described by the given string."
  },
  "detaileddescription": {
   "para": [
    "In case multiple channels are found, only the first match will be returned.",
    {
     "ref": {
      "#text": "av_channel_from_string()",
      "@_refid": "group__lavu__audio__channels_1gaf6d58f0ff59e1985f8dd337f7a7736e7",
      "@_kindref": "member"
     },
     "#text": "This function accepts channel names in the same format as."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "channel_layout"
        },
        "parameterdescription": {
         "para": "input channel layout"
        }
       },
       {
        "parameternamelist": {
         "parametername": "name"
        },
        "parameterdescription": {
         "para": "string describing the channel whose index to obtain"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "a channel index described by the given string, or a negative AVERROR value.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "627",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "627",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga2916f559c224d79ca2c0b68882418534",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the index in a channel layout of a channel described by the given string.\n * In case multiple channels are found, only the first match will be returned.\n *\n * This function accepts channel names in the same format as\n * @ref av_channel_from_string().\n *\n * @param channel_layout input channel layout\n * @param name string describing the channel whose index to obtain\n * @return a channel index described by the given string, or a negative AVERROR\n *         value.\n */"
 },
 "av_channel_layout_channel_from_string": {
  "type": {
   "ref": {
    "#text": "AVChannel",
    "@_refid": "group__lavu__audio__channels_1gaa4a685b5c38835392552a7f96ee24a3e",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVChannel av_channel_layout_channel_from_string",
  "argsstring": "(const AVChannelLayout *channel_layout, const char *name)",
  "name": "av_channel_layout_channel_from_string",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "channel_layout"
   },
   {
    "type": "const char *",
    "declname": "name"
   }
  ],
  "briefdescription": {
   "para": "Get a channel described by the given string."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_channel_from_string()",
      "@_refid": "group__lavu__audio__channels_1gaf6d58f0ff59e1985f8dd337f7a7736e7",
      "@_kindref": "member"
     },
     "#text": "This function accepts channel names in the same format as."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "channel_layout"
        },
        "parameterdescription": {
         "para": "input channel layout"
        }
       },
       {
        "parameternamelist": {
         "parametername": "name"
        },
        "parameterdescription": {
         "para": "string describing the channel to obtain"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "a channel described by the given string in channel_layout on success or AV_CHAN_NONE on failure (if the string is not valid or the channel order is unspecified)",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "643",
   "@_column": "1",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "643",
   "@_declcolumn": "1"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga05df26d449e215083fc63cfbc640844c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a channel described by the given string.\n *\n * This function accepts channel names in the same format as\n * @ref av_channel_from_string().\n *\n * @param channel_layout input channel layout\n * @param name string describing the channel to obtain\n * @return a channel described by the given string in channel_layout on success\n *         or AV_CHAN_NONE on failure (if the string is not valid or the channel\n *         order is unspecified)\n */"
 },
 "av_channel_layout_subset": {
  "type": "uint64_t",
  "definition": "uint64_t av_channel_layout_subset",
  "argsstring": "(const AVChannelLayout *channel_layout, uint64_t mask)",
  "name": "av_channel_layout_subset",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "channel_layout"
   },
   {
    "type": "uint64_t",
    "declname": "mask"
   }
  ],
  "briefdescription": {
   "para": "Find out what channels from a given set are present in a channel layout, without regard for their positions."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "channel_layout"
       },
       "parameterdescription": {
        "para": "input channel layout"
       }
      },
      {
       "parameternamelist": {
        "parametername": "mask"
       },
       "parameterdescription": {
        "para": "a combination of AV_CH_* representing a set of channels"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "a bitfield representing all the channels from mask that are present in channel_layout",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "655",
   "@_column": "10",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "655",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1gae597e6f9ab3b7fbcdb74e486feee4f04",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find out what channels from a given set are present in a channel layout,\n * without regard for their positions.\n *\n * @param channel_layout input channel layout\n * @param mask a combination of AV_CH_* representing a set of channels\n * @return a bitfield representing all the channels from mask that are present\n *         in channel_layout\n */"
 },
 "av_channel_layout_check": {
  "type": "int",
  "definition": "int av_channel_layout_check",
  "argsstring": "(const AVChannelLayout *channel_layout)",
  "name": "av_channel_layout_check",
  "param": {
   "type": {
    "ref": {
     "#text": "AVChannelLayout",
     "@_refid": "structAVChannelLayout",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "channel_layout"
  },
  "briefdescription": {
   "para": "Check whether a channel layout is valid, i.e."
  },
  "detaileddescription": {
   "para": [
    "can possibly describe audio data.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "channel_layout"
       },
       "parameterdescription": {
        "para": "input channel layout"
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": "1 if channel_layout is valid, 0 otherwise.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "665",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "665",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1gad15a6bf80ee8551ee4a4789d970ccbea",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check whether a channel layout is valid, i.e. can possibly describe audio\n * data.\n *\n * @param channel_layout input channel layout\n * @return 1 if channel_layout is valid, 0 otherwise.\n */"
 },
 "av_channel_layout_compare": {
  "type": "int",
  "definition": "int av_channel_layout_compare",
  "argsstring": "(const AVChannelLayout *chl, const AVChannelLayout *chl1)",
  "name": "av_channel_layout_compare",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "chl"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "chl1"
   }
  ],
  "briefdescription": {
   "para": "Check whether two channel layouts are semantically the same, i.e."
  },
  "detaileddescription": {
   "para": [
    "the same channels are present on the same positions in both.",
    "If one of the channel layouts is AV_CHANNEL_ORDER_UNSPEC, while the other is not, they are considered to be unequal. If both are AV_CHANNEL_ORDER_UNSPEC, they are considered equal iff the channel counts are the same in both.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "chl"
        },
        "parameterdescription": {
         "para": "input channel layout"
        }
       },
       {
        "parameternamelist": {
         "parametername": "chl1"
        },
        "parameterdescription": {
         "para": "input channel layout"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 if chl and chl1 are equal, 1 if they are not equal. A negative AVERROR code if one or both are invalid.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "680",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "680",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga5da99475fc07b778522974a2e0a1f58c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check whether two channel layouts are semantically the same, i.e. the same\n * channels are present on the same positions in both.\n *\n * If one of the channel layouts is AV_CHANNEL_ORDER_UNSPEC, while the other is\n * not, they are considered to be unequal. If both are AV_CHANNEL_ORDER_UNSPEC,\n * they are considered equal iff the channel counts are the same in both.\n *\n * @param chl input channel layout\n * @param chl1 input channel layout\n * @return 0 if chl and chl1 are equal, 1 if they are not equal. A negative\n *         AVERROR code if one or both are invalid.\n */"
 },
 "av_channel_layout_retype": {
  "type": "int",
  "definition": "int av_channel_layout_retype",
  "argsstring": "(AVChannelLayout *channel_layout, enum AVChannelOrder order, int flags)",
  "name": "av_channel_layout_retype",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "channel_layout"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannelOrder",
      "@_refid": "group__lavu__audio__channels_1ga252e1528ae55fbf873266ca4c7e3b69c",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "order"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Change the AVChannelOrder of a channel layout."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AVERROR(ENOSYS)",
      "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
      "@_kindref": "member"
     },
     "#text": "Change of AVChannelOrder can be either lossless or lossy. In case of a lossless conversion all the channel designations and the associated channel names (if any) are kept. On a lossy conversion the channel names and channel designations might be lost depending on the capabilities of the desired AVChannelOrder. Note that some conversions are simply not possible in which case this function returns."
    },
    "The following conversions are supported:",
    "Any -> Custom : Always possible, always lossless. Any -> Unspecified: Always possible, lossless if channel designations are all unknown and channel names are not used, lossy otherwise. Custom -> Ambisonic : Possible if it contains ambisonic channels with optional non-diegetic channels in the end. Lossy if the channels have custom names, lossless otherwise. Custom -> Native : Possible if it contains native channels in native order. Lossy if the channels have custom names, lossless otherwise.",
    "On error this function keeps the original channel layout untouched.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "channel_layout"
        },
        "parameterdescription": {
         "para": "channel layout which will be changed"
        }
       },
       {
        "parameternamelist": {
         "parametername": "order"
        },
        "parameterdescription": {
         "para": "the desired channel layout order"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "a combination of AV_CHANNEL_LAYOUT_RETYPE_FLAG_* constants"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "AVERROR(ENOSYS)",
         "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
         "@_kindref": "member"
        },
        {
         "#text": "AVERROR(EINVAL)",
         "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
         "@_kindref": "member"
        },
        {
         "#text": "AVERROR(ENOMEM)",
         "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
         "@_kindref": "member"
        }
       ],
       "#text": "0 if the conversion was successful and lossless or if the channel layout was already in the desired order >0 if the conversion was successful but lossyif the conversion was not possible (or would be lossy and AV_CHANNEL_LAYOUT_RETYPE_FLAG_LOSSLESS was specified),on error"
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/channel_layout.h",
   "@_line": "727",
   "@_column": "5",
   "@_declfile": "libavutil/channel_layout.h",
   "@_declline": "727",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__audio__channels_1ga3315a86196d47fcfa78aa866a6c61001",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Change the AVChannelOrder of a channel layout.\n *\n * Change of AVChannelOrder can be either lossless or lossy. In case of a\n * lossless conversion all the channel designations and the associated channel\n * names (if any) are kept. On a lossy conversion the channel names and channel\n * designations might be lost depending on the capabilities of the desired\n * AVChannelOrder. Note that some conversions are simply not possible in which\n * case this function returns AVERROR(ENOSYS).\n *\n * The following conversions are supported:\n *\n * Any       -> Custom     : Always possible, always lossless.\n * Any       -> Unspecified: Always possible, lossless if channel designations\n *   are all unknown and channel names are not used, lossy otherwise.\n * Custom    -> Ambisonic  : Possible if it contains ambisonic channels with\n *   optional non-diegetic channels in the end. Lossy if the channels have\n *   custom names, lossless otherwise.\n * Custom    -> Native     : Possible if it contains native channels in native\n *     order. Lossy if the channels have custom names, lossless otherwise.\n *\n * On error this function keeps the original channel layout untouched.\n *\n * @param channel_layout channel layout which will be changed\n * @param order the desired channel layout order\n * @param flags a combination of AV_CHANNEL_LAYOUT_RETYPE_FLAG_* constants\n * @return 0 if the conversion was successful and lossless or if the channel\n *           layout was already in the desired order\n *         >0 if the conversion was successful but lossy\n *         AVERROR(ENOSYS) if the conversion was not possible (or would be\n *           lossy and AV_CHANNEL_LAYOUT_RETYPE_FLAG_LOSSLESS was specified)\n *         AVERROR(EINVAL), AVERROR(ENOMEM) on error\n */"
 },
 "av_codec_iterate": {
  "type": {
   "ref": {
    "#text": "AVCodec",
    "@_refid": "structAVCodec",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVCodec * av_codec_iterate",
  "argsstring": "(void **opaque)",
  "name": "av_codec_iterate",
  "param": {
   "type": "void **",
   "declname": "opaque"
  },
  "briefdescription": {
   "para": "Iterate over all registered codecs."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "opaque"
      },
      "parameterdescription": {
       "para": "a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the next registered codec or NULL when the iteration is finished",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec.h",
   "@_line": "242",
   "@_column": "15",
   "@_declfile": "libavcodec/codec.h",
   "@_declline": "242",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gaecde133103295e7d5418234089aa2d7f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over all registered codecs.\n *\n * @param opaque a pointer where libavcodec will store the iteration state. Must\n *               point to NULL to start the iteration.\n *\n * @return the next registered codec or NULL when the iteration is\n *         finished\n */"
 },
 "avcodec_find_decoder": {
  "type": {
   "ref": {
    "#text": "AVCodec",
    "@_refid": "structAVCodec",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVCodec * avcodec_find_decoder",
  "argsstring": "(enum AVCodecID id)",
  "name": "avcodec_find_decoder",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecID",
     "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "id"
  },
  "briefdescription": {
   "para": "Find a registered decoder with a matching codec ID."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "id"
      },
      "parameterdescription": {
       "para": "AVCodecID of the requested decoder"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "A decoder if one was found, NULL otherwise.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec.h",
   "@_line": "250",
   "@_column": "15",
   "@_declfile": "libavcodec/codec.h",
   "@_declline": "250",
   "@_declcolumn": "15"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "106",
    "@_endline": "237"
   },
   {
    "#text": "open_codec_context",
    "@_refid": "demux__decode_8c_1ab36dcc13a13c2ae1c1fff2ea5db97616",
    "@_compoundref": "demux__decode_8c",
    "@_startline": "146",
    "@_endline": "195"
   },
   {
    "#text": "open_input_file",
    "@_refid": "transcode_8c_1abd04bf1a933d4d2698482f4949c61fed",
    "@_compoundref": "transcode_8c",
    "@_startline": "61",
    "@_endline": "126"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga89204045c00a7c3216481431e0160753",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find a registered decoder with a matching codec ID.\n *\n * @param id AVCodecID of the requested decoder\n * @return A decoder if one was found, NULL otherwise.\n */"
 },
 "avcodec_find_decoder_by_name": {
  "type": {
   "ref": {
    "#text": "AVCodec",
    "@_refid": "structAVCodec",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVCodec * avcodec_find_decoder_by_name",
  "argsstring": "(const char *name)",
  "name": "avcodec_find_decoder_by_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": {
   "para": "Find a registered decoder with the specified name."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "name"
      },
      "parameterdescription": {
       "para": "name of the requested decoder"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "A decoder if one was found, NULL otherwise.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec.h",
   "@_line": "258",
   "@_column": "15",
   "@_declfile": "libavcodec/codec.h",
   "@_declline": "258",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga8e72f32e219e560db6be06045e2ec32c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find a registered decoder with the specified name.\n *\n * @param name name of the requested decoder\n * @return A decoder if one was found, NULL otherwise.\n */"
 },
 "avcodec_find_encoder": {
  "type": {
   "ref": {
    "#text": "AVCodec",
    "@_refid": "structAVCodec",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVCodec * avcodec_find_encoder",
  "argsstring": "(enum AVCodecID id)",
  "name": "avcodec_find_encoder",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecID",
     "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "id"
  },
  "briefdescription": {
   "para": "Find a registered encoder with a matching codec ID."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "id"
      },
      "parameterdescription": {
       "para": "AVCodecID of the requested encoder"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "An encoder if one was found, NULL otherwise.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec.h",
   "@_line": "266",
   "@_column": "15",
   "@_declfile": "libavcodec/codec.h",
   "@_declline": "266",
   "@_declcolumn": "15"
  },
  "referencedby": [
   {
    "#text": "add_stream",
    "@_refid": "mux_8c_1a22968a15b922fd8c0c37b49beec06dbe",
    "@_compoundref": "mux_8c",
    "@_startline": "125",
    "@_endline": "211"
   },
   {
    "#text": "main",
    "@_refid": "encode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "encode__audio_8c",
    "@_startline": "122",
    "@_endline": "240"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga9e7a88299f4c869b03c5393aee6ebbba",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find a registered encoder with a matching codec ID.\n *\n * @param id AVCodecID of the requested encoder\n * @return An encoder if one was found, NULL otherwise.\n */"
 },
 "avcodec_find_encoder_by_name": {
  "type": {
   "ref": {
    "#text": "AVCodec",
    "@_refid": "structAVCodec",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVCodec * avcodec_find_encoder_by_name",
  "argsstring": "(const char *name)",
  "name": "avcodec_find_encoder_by_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": {
   "para": "Find a registered encoder with the specified name."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "name"
      },
      "parameterdescription": {
       "para": "name of the requested encoder"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "An encoder if one was found, NULL otherwise.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec.h",
   "@_line": "274",
   "@_column": "15",
   "@_declfile": "libavcodec/codec.h",
   "@_declline": "274",
   "@_declcolumn": "15"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "encode__video_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "encode__video_8c",
   "@_startline": "69",
   "@_endline": "216"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gacde808c8f768d6ea0cceb9c6913202d0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find a registered encoder with the specified name.\n *\n * @param name name of the requested encoder\n * @return An encoder if one was found, NULL otherwise.\n */"
 },
 "av_codec_is_encoder": {
  "type": "int",
  "definition": "int av_codec_is_encoder",
  "argsstring": "(const AVCodec *codec)",
  "name": "av_codec_is_encoder",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodec",
     "@_refid": "structAVCodec",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "codec"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "a non-zero number if codec is an encoder, zero otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec.h",
   "@_line": "278",
   "@_column": "5",
   "@_declfile": "libavcodec/codec.h",
   "@_declline": "278",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga2b665824e4d9144f8d4f6c01e3e85aa3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return a non-zero number if codec is an encoder, zero otherwise\n */"
 },
 "av_codec_is_decoder": {
  "type": "int",
  "definition": "int av_codec_is_decoder",
  "argsstring": "(const AVCodec *codec)",
  "name": "av_codec_is_decoder",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodec",
     "@_refid": "structAVCodec",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "codec"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "a non-zero number if codec is a decoder, zero otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec.h",
   "@_line": "283",
   "@_column": "5",
   "@_declfile": "libavcodec/codec.h",
   "@_declline": "283",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga6dc18eef1afca3610644a52565cf8a31",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return a non-zero number if codec is a decoder, zero otherwise\n */"
 },
 "av_get_profile_name": {
  "type": "const char *",
  "definition": "const char * av_get_profile_name",
  "argsstring": "(const AVCodec *codec, int profile)",
  "name": "av_get_profile_name",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodec",
      "@_refid": "structAVCodec",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "codec"
   },
   {
    "type": "int",
    "declname": "profile"
   }
  ],
  "briefdescription": {
   "para": "Return a name for the specified profile, if available."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "codec"
       },
       "parameterdescription": {
        "para": "the codec that is searched for the given profile"
       }
      },
      {
       "parameternamelist": {
        "parametername": "profile"
       },
       "parameterdescription": {
        "para": "the profile value for which a name is requested"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "A name for the profile if found, NULL otherwise.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec.h",
   "@_line": "292",
   "@_column": "12",
   "@_declfile": "libavcodec/codec.h",
   "@_declline": "292",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gaf94924e4132bfde3ec08f94ef8671503",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return a name for the specified profile, if available.\n *\n * @param codec the codec that is searched for the given profile\n * @param profile the profile value for which a name is requested\n * @return A name for the profile if found, NULL otherwise.\n */"
 },
 "avcodec_get_hw_config": {
  "type": {
   "ref": {
    "#text": "AVCodecHWConfig",
    "@_refid": "structAVCodecHWConfig",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVCodecHWConfig * avcodec_get_hw_config",
  "argsstring": "(const AVCodec *codec, int index)",
  "name": "avcodec_get_hw_config",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodec",
      "@_refid": "structAVCodec",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "codec"
   },
   {
    "type": "int",
    "declname": "index"
   }
  ],
  "briefdescription": {
   "para": "Retrieve supported hardware configurations for a codec."
  },
  "detaileddescription": {
   "para": "Values of index from zero to some maximum return the indexed configuration descriptor; all other values return NULL. If the codec does not support any hardware configurations then it will always return NULL."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec.h",
   "@_line": "365",
   "@_column": "23",
   "@_declfile": "libavcodec/codec.h",
   "@_declline": "365",
   "@_declcolumn": "23"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "hw__decode_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "hw__decode_8c",
   "@_startline": "148",
   "@_endline": "255"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gaba0ae8dd2a26f7733becf1b4367ae6f5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Retrieve supported hardware configurations for a codec.\n *\n * Values of index from zero to some maximum return the indexed configuration\n * descriptor; all other values return NULL.  If the codec does not support\n * any hardware configurations then it will always return NULL.\n */"
 },
 "avcodec_descriptor_get": {
  "type": {
   "ref": {
    "#text": "AVCodecDescriptor",
    "@_refid": "structAVCodecDescriptor",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVCodecDescriptor * avcodec_descriptor_get",
  "argsstring": "(enum AVCodecID id)",
  "name": "avcodec_descriptor_get",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecID",
     "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "id"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "descriptor for given codec ID or NULL if no descriptor exists.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_desc.h",
   "@_line": "113",
   "@_column": "25",
   "@_declfile": "libavcodec/codec_desc.h",
   "@_declline": "113",
   "@_declcolumn": "25"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga0e70e7293af4d5ee5a1ed08946ab0ec3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return descriptor for given codec ID or NULL if no descriptor exists.\n */"
 },
 "avcodec_descriptor_next": {
  "type": {
   "ref": {
    "#text": "AVCodecDescriptor",
    "@_refid": "structAVCodecDescriptor",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVCodecDescriptor * avcodec_descriptor_next",
  "argsstring": "(const AVCodecDescriptor *prev)",
  "name": "avcodec_descriptor_next",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecDescriptor",
     "@_refid": "structAVCodecDescriptor",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "prev"
  },
  "briefdescription": {
   "para": "Iterate over all codec descriptors known to libavcodec."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "prev"
      },
      "parameterdescription": {
       "para": "previous descriptor. NULL to get the first descriptor."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "next descriptor or NULL after the last descriptor",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_desc.h",
   "@_line": "122",
   "@_column": "25",
   "@_declfile": "libavcodec/codec_desc.h",
   "@_declline": "122",
   "@_declcolumn": "25"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gacee7f57301eb1767c46b85be2b75a109",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over all codec descriptors known to libavcodec.\n *\n * @param prev previous descriptor. NULL to get the first descriptor.\n *\n * @return next descriptor or NULL after the last descriptor\n */"
 },
 "avcodec_descriptor_get_by_name": {
  "type": {
   "ref": {
    "#text": "AVCodecDescriptor",
    "@_refid": "structAVCodecDescriptor",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVCodecDescriptor * avcodec_descriptor_get_by_name",
  "argsstring": "(const char *name)",
  "name": "avcodec_descriptor_get_by_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "codec descriptor with the given name or NULL if no such descriptor exists.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_desc.h",
   "@_line": "128",
   "@_column": "25",
   "@_declfile": "libavcodec/codec_desc.h",
   "@_declline": "128",
   "@_declcolumn": "25"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gad4d678c24626ec1680e351091136641b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return codec descriptor with the given name or NULL if no such descriptor\n *         exists.\n */"
 },
 "avcodec_get_type": {
  "type": {
   "ref": {
    "#text": "AVMediaType",
    "@_refid": "group__lavu__misc_1ga9a84bba4713dfced21a1a56163be1f48",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVMediaType avcodec_get_type",
  "argsstring": "(enum AVCodecID codec_id)",
  "name": "avcodec_get_type",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecID",
     "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "codec_id"
  },
  "briefdescription": {
   "para": "Get the type of the given codec."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_id.h",
   "@_line": "616",
   "@_column": "17",
   "@_declfile": "libavcodec/codec_id.h",
   "@_declline": "616",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga9680ab906f1206deafc521ed54927375",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the type of the given codec.\n */"
 },
 "avcodec_get_name": {
  "type": "const char *",
  "definition": "const char * avcodec_get_name",
  "argsstring": "(enum AVCodecID id)",
  "name": "avcodec_get_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecID",
     "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "id"
  },
  "briefdescription": {
   "para": "Get the name of a codec."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "a static string identifying the codec; never NULL",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_id.h",
   "@_line": "622",
   "@_column": "12",
   "@_declfile": "libavcodec/codec_id.h",
   "@_declline": "622",
   "@_declcolumn": "12"
  },
  "referencedby": {
   "#text": "add_stream",
   "@_refid": "mux_8c_1a22968a15b922fd8c0c37b49beec06dbe",
   "@_compoundref": "mux_8c",
   "@_startline": "125",
   "@_endline": "211"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gaaba3382a5a2735e81d3e30e948e806f0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the name of a codec.\n * @return  a static string identifying the codec; never NULL\n */"
 },
 "av_get_bits_per_sample": {
  "type": "int",
  "definition": "int av_get_bits_per_sample",
  "argsstring": "(enum AVCodecID codec_id)",
  "name": "av_get_bits_per_sample",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecID",
     "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "codec_id"
  },
  "briefdescription": {
   "para": "Return codec bits per sample."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": {
        "#text": "codec_id",
        "@_direction": "in"
       }
      },
      "parameterdescription": {
       "para": "the codec"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "Number of bits per sample or zero if unknown for the given codec.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_id.h",
   "@_line": "630",
   "@_column": "5",
   "@_declfile": "libavcodec/codec_id.h",
   "@_declline": "630",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga0717e7440fdb123f708082f66cd9b41d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return codec bits per sample.\n *\n * @param[in] codec_id the codec\n * @return Number of bits per sample or zero if unknown for the given codec.\n */"
 },
 "av_get_exact_bits_per_sample": {
  "type": "int",
  "definition": "int av_get_exact_bits_per_sample",
  "argsstring": "(enum AVCodecID codec_id)",
  "name": "av_get_exact_bits_per_sample",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecID",
     "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "codec_id"
  },
  "briefdescription": {
   "para": "Return codec bits per sample."
  },
  "detaileddescription": {
   "para": [
    "Only return non-zero if the bits per sample is exactly correct, not an approximation.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": {
         "#text": "codec_id",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "the codec"
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": "Number of bits per sample or zero if unknown for the given codec.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_id.h",
   "@_line": "640",
   "@_column": "5",
   "@_declfile": "libavcodec/codec_id.h",
   "@_declline": "640",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gadddbcd146ffaf53016bac730c631f7b3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return codec bits per sample.\n * Only return non-zero if the bits per sample is exactly correct, not an\n * approximation.\n *\n * @param[in] codec_id the codec\n * @return Number of bits per sample or zero if unknown for the given codec.\n */"
 },
 "avcodec_profile_name": {
  "type": "const char *",
  "definition": "const char * avcodec_profile_name",
  "argsstring": "(enum AVCodecID codec_id, int profile)",
  "name": "avcodec_profile_name",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecID",
      "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "codec_id"
   },
   {
    "type": "int",
    "declname": "profile"
   }
  ],
  "briefdescription": {
   "para": "Return a name for the specified profile, if available."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "codec_id"
       },
       "parameterdescription": {
        "para": "the ID of the codec to which the requested profile belongs"
       }
      },
      {
       "parameternamelist": {
        "parametername": "profile"
       },
       "parameterdescription": {
        "para": "the profile value for which a name is requested"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "A name for the profile if found, NULL otherwise.",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": [
        {
         "#text": "av_get_profile_name()",
         "@_refid": "group__lavc__core_1gaf94924e4132bfde3ec08f94ef8671503",
         "@_kindref": "member"
        },
        {
         "#text": "AVCodecDescriptor",
         "@_refid": "structAVCodecDescriptor",
         "@_kindref": "compound"
        }
       ],
       "#text": "unlike, which searches a list of profiles supported by a specific decoder or encoder implementation, this function searches the list of profiles from the"
      },
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_id.h",
   "@_line": "653",
   "@_column": "12",
   "@_declfile": "libavcodec/codec_id.h",
   "@_declline": "653",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga56c9160585074829625a88069747dea2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return a name for the specified profile, if available.\n *\n * @param codec_id the ID of the codec to which the requested profile belongs\n * @param profile the profile value for which a name is requested\n * @return A name for the profile if found, NULL otherwise.\n *\n * @note unlike av_get_profile_name(), which searches a list of profiles\n *       supported by a specific decoder or encoder implementation, this\n *       function searches the list of profiles from the AVCodecDescriptor\n */"
 },
 "av_get_pcm_codec": {
  "type": {
   "ref": {
    "#text": "AVCodecID",
    "@_refid": "group__lavc__core_1gaadca229ad2c20e060a14fec08a5cc7ce",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVCodecID av_get_pcm_codec",
  "argsstring": "(enum AVSampleFormat fmt, int be)",
  "name": "av_get_pcm_codec",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "fmt"
   },
   {
    "type": "int",
    "declname": "be"
   }
  ],
  "briefdescription": {
   "para": "Return the PCM codec associated with a sample format."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "be"
      },
      "parameterdescription": {
       "para": "endianness, 0 for little, 1 for big, -1 (or anything else) for native"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_id.h",
   "@_line": "661",
   "@_column": "15",
   "@_declfile": "libavcodec/codec_id.h",
   "@_declline": "661",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1gafa5775a0bd6a6ab58011e8492156eb6e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the PCM codec associated with a sample format.\n * @param be  endianness, 0 for little, 1 for big,\n *            -1 (or anything else) for native\n * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE\n */"
 },
 "avcodec_parameters_alloc": {
  "type": {
   "ref": {
    "#text": "AVCodecParameters",
    "@_refid": "structAVCodecParameters",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVCodecParameters * avcodec_parameters_alloc",
  "argsstring": "(void)",
  "name": "avcodec_parameters_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVCodecParameters",
     "@_refid": "structAVCodecParameters",
     "@_kindref": "compound"
    },
    "#text": "Allocate a newand set its fields to default values (unknown/invalid/0)."
   }
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "avcodec_parameters_free()",
     "@_refid": "group__lavc__core_1ga950c8da55b8112077e640b6a0cb8cf36",
     "@_kindref": "member"
    },
    "#text": "The returned struct must be freed with."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_par.h",
   "@_line": "222",
   "@_column": "19",
   "@_declfile": "libavcodec/codec_par.h",
   "@_declline": "222",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga5dada97c23a87ba510c9f5f5d41ed642",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a new AVCodecParameters and set its fields to default values\n * (unknown/invalid/0). The returned struct must be freed with\n * avcodec_parameters_free().\n */"
 },
 "avcodec_parameters_free": {
  "type": "void",
  "definition": "void avcodec_parameters_free",
  "argsstring": "(AVCodecParameters **par)",
  "name": "avcodec_parameters_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecParameters",
     "@_refid": "structAVCodecParameters",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "par"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVCodecParameters",
     "@_refid": "structAVCodecParameters",
     "@_kindref": "compound"
    },
    "#text": "Free aninstance and everything associated with it and write NULL to the supplied pointer."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_par.h",
   "@_line": "228",
   "@_column": "6",
   "@_declfile": "libavcodec/codec_par.h",
   "@_declline": "228",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga950c8da55b8112077e640b6a0cb8cf36",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free an AVCodecParameters instance and everything associated with it and\n * write NULL to the supplied pointer.\n */"
 },
 "avcodec_parameters_copy": {
  "type": "int",
  "definition": "int avcodec_parameters_copy",
  "argsstring": "(AVCodecParameters *dst, const AVCodecParameters *src)",
  "name": "avcodec_parameters_copy",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecParameters",
      "@_refid": "structAVCodecParameters",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVCodecParameters",
      "@_refid": "structAVCodecParameters",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Copy the contents of src to dst."
  },
  "detaileddescription": {
   "para": [
    "Any allocated fields in dst are freed and replaced with newly allocated duplicates of the corresponding fields in src.",
    {
     "simplesect": {
      "para": ">= 0 on success, a negative AVERROR code on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_par.h",
   "@_line": "236",
   "@_column": "5",
   "@_declfile": "libavcodec/codec_par.h",
   "@_declline": "236",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "remux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "remux_8c",
    "@_startline": "46",
    "@_endline": "198"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga6d02e640ccc12c783841ce51d09b9fa7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy the contents of src to dst. Any allocated fields in dst are freed and\n * replaced with newly allocated duplicates of the corresponding fields in src.\n *\n * @return >= 0 on success, a negative AVERROR code on failure.\n */"
 },
 "av_get_audio_frame_duration2": {
  "type": "int",
  "definition": "int av_get_audio_frame_duration2",
  "argsstring": "(AVCodecParameters *par, int frame_bytes)",
  "name": "av_get_audio_frame_duration2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecParameters",
      "@_refid": "structAVCodecParameters",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "par"
   },
   {
    "type": "int",
    "declname": "frame_bytes"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "av_get_audio_frame_duration()",
      "@_refid": "group__lavc__misc_1ga3266a8c3df0790c62259f91afcde45a9",
      "@_kindref": "member"
     },
     {
      "#text": "AVCodecParameters",
      "@_refid": "structAVCodecParameters",
      "@_kindref": "compound"
     },
     {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     }
    ],
    "#text": "This function is the same as, except it works withinstead of an."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/codec_par.h",
   "@_line": "242",
   "@_column": "5",
   "@_declfile": "libavcodec/codec_par.h",
   "@_declline": "242",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__core_1ga1f4495d5092c1f58283ff9a16352b4e1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * This function is the same as av_get_audio_frame_duration(), except it works\n * with AVCodecParameters instead of an AVCodecContext.\n */"
 },
 "av_log2": {
  "type": {
   "ref": {
    "#text": "av_const",
    "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_const int av_log2",
  "argsstring": "(unsigned v)",
  "name": "av_log2",
  "param": {
   "type": "unsigned",
   "declname": "v"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "162",
   "@_column": "14",
   "@_declfile": "libavutil/common.h",
   "@_declline": "162",
   "@_declcolumn": "14"
  },
  "referencedby": {
   "#text": "av_ceil_log2_c",
   "@_refid": "common_8h_1ad94b463be296690fc9c096d55203b42b",
   "@_compoundref": "common_8h",
   "@_startline": "420",
   "@_endline": "423"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a10e72d08c6a66c91cf7218532631684e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/* misc math functions */"
 },
 "av_log2_16bit": {
  "type": {
   "ref": {
    "#text": "av_const",
    "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_const int av_log2_16bit",
  "argsstring": "(unsigned v)",
  "name": "av_log2_16bit",
  "param": {
   "type": "unsigned",
   "declname": "v"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "166",
   "@_column": "14",
   "@_declfile": "libavutil/common.h",
   "@_declline": "166",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a8a1d3f387b1eab65327453f6a8e7e9ae",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/* misc math functions */"
 },
 "av_clip_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "int"
  },
  "definition": "static av_always_inline av_const int av_clip_c",
  "argsstring": "(int a, int amin, int amax)",
  "name": "av_clip_c",
  "param": [
   {
    "type": "int",
    "declname": "a"
   },
   {
    "type": "int",
    "declname": "amin"
   },
   {
    "type": "int",
    "declname": "amax"
   }
  ],
  "briefdescription": {
   "para": "Clip a signed integer value into the amin-amax range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "value to clip"
       }
      },
      {
       "parameternamelist": {
        "parametername": "amin"
       },
       "parameterdescription": {
        "para": "minimum value of the clip range"
       }
      },
      {
       "parameternamelist": {
        "parametername": "amax"
       },
       "parameterdescription": {
        "para": "maximum value of the clip range"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "176",
   "@_column": "38",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "176",
   "@_bodyend": "184"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a465f39d69c5a5fe0e070b6ec4d0fed29",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clip a signed integer value into the amin-amax range.\n * @param a value to clip\n * @param amin minimum value of the clip range\n * @param amax maximum value of the clip range\n * @return clipped value\n */"
 },
 "av_clip64_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "int64_t"
  },
  "definition": "static av_always_inline av_const int64_t av_clip64_c",
  "argsstring": "(int64_t a, int64_t amin, int64_t amax)",
  "name": "av_clip64_c",
  "param": [
   {
    "type": "int64_t",
    "declname": "a"
   },
   {
    "type": "int64_t",
    "declname": "amin"
   },
   {
    "type": "int64_t",
    "declname": "amax"
   }
  ],
  "briefdescription": {
   "para": "Clip a signed 64bit integer value into the amin-amax range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "value to clip"
       }
      },
      {
       "parameternamelist": {
        "parametername": "amin"
       },
       "parameterdescription": {
        "para": "minimum value of the clip range"
       }
      },
      {
       "parameternamelist": {
        "parametername": "amax"
       },
       "parameterdescription": {
        "para": "maximum value of the clip range"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "193",
   "@_column": "42",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "193",
   "@_bodyend": "201"
  },
  "@_kind": "function",
  "@_id": "common_8h_1aa4ed7e144d5b8397cff8656e9c786cb2",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clip a signed 64bit integer value into the amin-amax range.\n * @param a value to clip\n * @param amin minimum value of the clip range\n * @param amax maximum value of the clip range\n * @return clipped value\n */"
 },
 "av_clip_uint8_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "uint8_t"
  },
  "definition": "static av_always_inline av_const uint8_t av_clip_uint8_c",
  "argsstring": "(int a)",
  "name": "av_clip_uint8_c",
  "param": {
   "type": "int",
   "declname": "a"
  },
  "briefdescription": {
   "para": "Clip a signed integer value into the 0-255 range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "a"
      },
      "parameterdescription": {
       "para": "value to clip"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "208",
   "@_column": "42",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "208",
   "@_bodyend": "212"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a8deed4a1ec39d0b1ab82d1f0e590a6f5",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clip a signed integer value into the 0-255 range.\n * @param a value to clip\n * @return clipped value\n */"
 },
 "av_clip_int8_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "int8_t"
  },
  "definition": "static av_always_inline av_const int8_t av_clip_int8_c",
  "argsstring": "(int a)",
  "name": "av_clip_int8_c",
  "param": {
   "type": "int",
   "declname": "a"
  },
  "briefdescription": {
   "para": "Clip a signed integer value into the -128,127 range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "a"
      },
      "parameterdescription": {
       "para": "value to clip"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "219",
   "@_column": "41",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "219",
   "@_bodyend": "223"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a3091e5b3f2a340c3ddb29f6733fb2a4c",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clip a signed integer value into the -128,127 range.\n * @param a value to clip\n * @return clipped value\n */"
 },
 "av_clip_uint16_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "uint16_t"
  },
  "definition": "static av_always_inline av_const uint16_t av_clip_uint16_c",
  "argsstring": "(int a)",
  "name": "av_clip_uint16_c",
  "param": {
   "type": "int",
   "declname": "a"
  },
  "briefdescription": {
   "para": "Clip a signed integer value into the 0-65535 range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "a"
      },
      "parameterdescription": {
       "para": "value to clip"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "230",
   "@_column": "43",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "230",
   "@_bodyend": "234"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a70a9a6b77373c47c48ef93511edaf9ce",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clip a signed integer value into the 0-65535 range.\n * @param a value to clip\n * @return clipped value\n */"
 },
 "av_clip_int16_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "int16_t"
  },
  "definition": "static av_always_inline av_const int16_t av_clip_int16_c",
  "argsstring": "(int a)",
  "name": "av_clip_int16_c",
  "param": {
   "type": "int",
   "declname": "a"
  },
  "briefdescription": {
   "para": "Clip a signed integer value into the -32768,32767 range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "a"
      },
      "parameterdescription": {
       "para": "value to clip"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "241",
   "@_column": "42",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "241",
   "@_bodyend": "245"
  },
  "@_kind": "function",
  "@_id": "common_8h_1aae95fa7073f1caa097951161985240f7",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clip a signed integer value into the -32768,32767 range.\n * @param a value to clip\n * @return clipped value\n */"
 },
 "av_clipl_int32_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "int32_t"
  },
  "definition": "static av_always_inline av_const int32_t av_clipl_int32_c",
  "argsstring": "(int64_t a)",
  "name": "av_clipl_int32_c",
  "param": {
   "type": "int64_t",
   "declname": "a"
  },
  "briefdescription": {
   "para": "Clip a signed 64-bit integer value into the -2147483648,2147483647 range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "a"
      },
      "parameterdescription": {
       "para": "value to clip"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "252",
   "@_column": "42",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "252",
   "@_bodyend": "256"
  },
  "@_kind": "function",
  "@_id": "common_8h_1ae245fb123a6e2a664c4806c034421e1e",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clip a signed 64-bit integer value into the -2147483648,2147483647 range.\n * @param a value to clip\n * @return clipped value\n */"
 },
 "av_clip_intp2_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "int"
  },
  "definition": "static av_always_inline av_const int av_clip_intp2_c",
  "argsstring": "(int a, int p)",
  "name": "av_clip_intp2_c",
  "param": [
   {
    "type": "int",
    "declname": "a"
   },
   {
    "type": "int",
    "declname": "p"
   }
  ],
  "briefdescription": {
   "para": "Clip a signed integer into the -(2^p),(2^p-1) range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "value to clip"
       }
      },
      {
       "parameternamelist": {
        "parametername": "p"
       },
       "parameterdescription": {
        "para": "bit position to clip at"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "264",
   "@_column": "38",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "264",
   "@_bodyend": "270"
  },
  "@_kind": "function",
  "@_id": "common_8h_1ad24148f23ca385e16b14885f52360abe",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clip a signed integer into the -(2^p),(2^p-1) range.\n * @param  a value to clip\n * @param  p bit position to clip at\n * @return clipped value\n */"
 },
 "av_clip_uintp2_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "unsigned"
  },
  "definition": "static av_always_inline av_const unsigned av_clip_uintp2_c",
  "argsstring": "(int a, int p)",
  "name": "av_clip_uintp2_c",
  "param": [
   {
    "type": "int",
    "declname": "a"
   },
   {
    "type": "int",
    "declname": "p"
   }
  ],
  "briefdescription": {
   "para": "Clip a signed integer to an unsigned power of two range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "value to clip"
       }
      },
      {
       "parameternamelist": {
        "parametername": "p"
       },
       "parameterdescription": {
        "para": "bit position to clip at"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "278",
   "@_column": "43",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "278",
   "@_bodyend": "282"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a867dba37c785d27d42b272aa968efda8",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clip a signed integer to an unsigned power of two range.\n * @param  a value to clip\n * @param  p bit position to clip at\n * @return clipped value\n */"
 },
 "av_mod_uintp2_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "unsigned"
  },
  "definition": "static av_always_inline av_const unsigned av_mod_uintp2_c",
  "argsstring": "(unsigned a, unsigned p)",
  "name": "av_mod_uintp2_c",
  "param": [
   {
    "type": "unsigned",
    "declname": "a"
   },
   {
    "type": "unsigned",
    "declname": "p"
   }
  ],
  "briefdescription": {
   "para": "Clear high bits from an unsigned integer starting with specific bit position."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "value to clip"
       }
      },
      {
       "parameternamelist": {
        "parametername": "p"
       },
       "parameterdescription": {
        "para": "bit position to clip at"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "290",
   "@_column": "43",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "290",
   "@_bodyend": "293"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a3cb38786757c8f2a468560d9d7a6c59c",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clear high bits from an unsigned integer starting with specific bit position\n * @param  a value to clip\n * @param  p bit position to clip at\n * @return clipped value\n */"
 },
 "av_sat_add32_c": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "static av_always_inline int av_sat_add32_c",
  "argsstring": "(int a, int b)",
  "name": "av_sat_add32_c",
  "param": [
   {
    "type": "int",
    "declname": "a"
   },
   {
    "type": "int",
    "declname": "b"
   }
  ],
  "briefdescription": {
   "para": "Add two signed 32-bit values with saturation."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "one value"
       }
      },
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "another value"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "sum with signed saturation",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "302",
   "@_column": "29",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "302",
   "@_bodyend": "305"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a2ff75b1bf7fd1a261dd2f2919e8d23e1",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add two signed 32-bit values with saturation.\n *\n * @param  a one value\n * @param  b another value\n * @return sum with signed saturation\n */"
 },
 "av_sat_dadd32_c": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "static av_always_inline int av_sat_dadd32_c",
  "argsstring": "(int a, int b)",
  "name": "av_sat_dadd32_c",
  "param": [
   {
    "type": "int",
    "declname": "a"
   },
   {
    "type": "int",
    "declname": "b"
   }
  ],
  "briefdescription": {
   "para": "Add a doubled value to another value with saturation at both stages."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "first value"
       }
      },
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "value doubled and added to a"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "sum sat(a + sat(2*b)) with signed saturation",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "314",
   "@_column": "29",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "314",
   "@_bodyend": "317"
  },
  "@_kind": "function",
  "@_id": "common_8h_1af235b48678850832493ac21160ff8458",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a doubled value to another value with saturation at both stages.\n *\n * @param  a first value\n * @param  b value doubled and added to a\n * @return sum sat(a + sat(2*b)) with signed saturation\n */"
 },
 "av_sat_sub32_c": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "static av_always_inline int av_sat_sub32_c",
  "argsstring": "(int a, int b)",
  "name": "av_sat_sub32_c",
  "param": [
   {
    "type": "int",
    "declname": "a"
   },
   {
    "type": "int",
    "declname": "b"
   }
  ],
  "briefdescription": {
   "para": "Subtract two signed 32-bit values with saturation."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "one value"
       }
      },
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "another value"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "difference with signed saturation",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "326",
   "@_column": "29",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "326",
   "@_bodyend": "329"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a7b11597cb0ad86f94f6f442f242cdfe1",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Subtract two signed 32-bit values with saturation.\n *\n * @param  a one value\n * @param  b another value\n * @return difference with signed saturation\n */"
 },
 "av_sat_dsub32_c": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "static av_always_inline int av_sat_dsub32_c",
  "argsstring": "(int a, int b)",
  "name": "av_sat_dsub32_c",
  "param": [
   {
    "type": "int",
    "declname": "a"
   },
   {
    "type": "int",
    "declname": "b"
   }
  ],
  "briefdescription": {
   "para": "Subtract a doubled value from another value with saturation at both stages."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "first value"
       }
      },
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "value doubled and subtracted from a"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "difference sat(a - sat(2*b)) with signed saturation",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "338",
   "@_column": "29",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "338",
   "@_bodyend": "341"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a587c5fbf7350330807f887ca3b4b97e0",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Subtract a doubled value from another value with saturation at both stages.\n *\n * @param  a first value\n * @param  b value doubled and subtracted from a\n * @return difference sat(a - sat(2*b)) with signed saturation\n */"
 },
 "av_sat_add64_c": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "int64_t"
  },
  "definition": "static av_always_inline int64_t av_sat_add64_c",
  "argsstring": "(int64_t a, int64_t b)",
  "name": "av_sat_add64_c",
  "param": [
   {
    "type": "int64_t",
    "declname": "a"
   },
   {
    "type": "int64_t",
    "declname": "b"
   }
  ],
  "briefdescription": {
   "para": "Add two signed 64-bit values with saturation."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "one value"
       }
      },
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "another value"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "sum with signed saturation",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "350",
   "@_column": "33",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "350",
   "@_bodyend": "360"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a7dc055df9c43596b9c59aff5f4abd6d2",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add two signed 64-bit values with saturation.\n *\n * @param  a one value\n * @param  b another value\n * @return sum with signed saturation\n */"
 },
 "av_sat_sub64_c": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "int64_t"
  },
  "definition": "static av_always_inline int64_t av_sat_sub64_c",
  "argsstring": "(int64_t a, int64_t b)",
  "name": "av_sat_sub64_c",
  "param": [
   {
    "type": "int64_t",
    "declname": "a"
   },
   {
    "type": "int64_t",
    "declname": "b"
   }
  ],
  "briefdescription": {
   "para": "Subtract two signed 64-bit values with saturation."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "one value"
       }
      },
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "another value"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "difference with signed saturation",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "369",
   "@_column": "33",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "369",
   "@_bodyend": "380"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a0a617a173ac5dcf764f5f0872c3258c8",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Subtract two signed 64-bit values with saturation.\n *\n * @param  a one value\n * @param  b another value\n * @return difference with signed saturation\n */"
 },
 "av_clipf_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "float"
  },
  "definition": "static av_always_inline av_const float av_clipf_c",
  "argsstring": "(float a, float amin, float amax)",
  "name": "av_clipf_c",
  "param": [
   {
    "type": "float",
    "declname": "a"
   },
   {
    "type": "float",
    "declname": "amin"
   },
   {
    "type": "float",
    "declname": "amax"
   }
  ],
  "briefdescription": {
   "para": "Clip a float value into the amin-amax range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "value to clip"
       }
      },
      {
       "parameternamelist": {
        "parametername": "amin"
       },
       "parameterdescription": {
        "para": "minimum value of the clip range"
       }
      },
      {
       "parameternamelist": {
        "parametername": "amax"
       },
       "parameterdescription": {
        "para": "maximum value of the clip range"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    },
    "#text": "If a is nan or -inf amin will be returned. If a is +inf amax will be returned."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "391",
   "@_column": "40",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "391",
   "@_bodyend": "397"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a7d5a6331d8708d4516aeab2413f86392",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clip a float value into the amin-amax range.\n * If a is nan or -inf amin will be returned.\n * If a is +inf amax will be returned.\n * @param a value to clip\n * @param amin minimum value of the clip range\n * @param amax maximum value of the clip range\n * @return clipped value\n */"
 },
 "av_clipd_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "double"
  },
  "definition": "static av_always_inline av_const double av_clipd_c",
  "argsstring": "(double a, double amin, double amax)",
  "name": "av_clipd_c",
  "param": [
   {
    "type": "double",
    "declname": "a"
   },
   {
    "type": "double",
    "declname": "amin"
   },
   {
    "type": "double",
    "declname": "amax"
   }
  ],
  "briefdescription": {
   "para": "Clip a double value into the amin-amax range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "value to clip"
       }
      },
      {
       "parameternamelist": {
        "parametername": "amin"
       },
       "parameterdescription": {
        "para": "minimum value of the clip range"
       }
      },
      {
       "parameternamelist": {
        "parametername": "amax"
       },
       "parameterdescription": {
        "para": "maximum value of the clip range"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "clipped value",
     "@_kind": "return"
    },
    "#text": "If a is nan or -inf amin will be returned. If a is +inf amax will be returned."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "408",
   "@_column": "41",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "408",
   "@_bodyend": "414"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a9a257b0d07c767325ee48b5e16e0b97f",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Clip a double value into the amin-amax range.\n * If a is nan or -inf amin will be returned.\n * If a is +inf amax will be returned.\n * @param a value to clip\n * @param amin minimum value of the clip range\n * @param amax maximum value of the clip range\n * @return clipped value\n */"
 },
 "av_ceil_log2_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "int"
  },
  "definition": "static av_always_inline av_const int av_ceil_log2_c",
  "argsstring": "(int x)",
  "name": "av_ceil_log2_c",
  "param": {
   "type": "int",
   "declname": "x"
  },
  "briefdescription": {
   "para": "Compute ceil(log2(x))."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "x"
      },
      "parameterdescription": {
       "para": "value used to compute ceil(log2(x))"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "computed ceiling of log2(x)",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "420",
   "@_column": "38",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "420",
   "@_bodyend": "423"
  },
  "@_kind": "function",
  "@_id": "common_8h_1ad94b463be296690fc9c096d55203b42b",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/** Compute ceil(log2(x)).\n * @param x value used to compute ceil(log2(x))\n * @return computed ceiling of log2(x)\n */"
 },
 "av_popcount_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "int"
  },
  "definition": "static av_always_inline av_const int av_popcount_c",
  "argsstring": "(uint32_t x)",
  "name": "av_popcount_c",
  "param": {
   "type": "uint32_t",
   "declname": "x"
  },
  "briefdescription": {
   "para": "Count number of bits set to one in x."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "x"
      },
      "parameterdescription": {
       "para": "value to count bits of"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the number of bits set to one in x",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "430",
   "@_column": "38",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "430",
   "@_bodyend": "437"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a73ced2c040c8e53f58a6073c3f3927b5",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Count number of bits set to one in x\n * @param x value to count bits of\n * @return the number of bits set to one in x\n */"
 },
 "av_popcount64_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "int"
  },
  "definition": "static av_always_inline av_const int av_popcount64_c",
  "argsstring": "(uint64_t x)",
  "name": "av_popcount64_c",
  "param": {
   "type": "uint64_t",
   "declname": "x"
  },
  "briefdescription": {
   "para": "Count number of bits set to one in x."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "x"
      },
      "parameterdescription": {
       "para": "value to count bits of"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the number of bits set to one in x",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "444",
   "@_column": "38",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "444",
   "@_bodyend": "447"
  },
  "@_kind": "function",
  "@_id": "common_8h_1a1016d46d60ca2d27d8ab2af5f0f7c57a",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Count number of bits set to one in x\n * @param x value to count bits of\n * @return the number of bits set to one in x\n */"
 },
 "av_parity_c": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "av_const",
     "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
     "@_kindref": "member"
    }
   ],
   "#text": "int"
  },
  "definition": "static av_always_inline av_const int av_parity_c",
  "argsstring": "(uint32_t v)",
  "name": "av_parity_c",
  "param": {
   "type": "uint32_t",
   "declname": "v"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/common.h",
   "@_line": "449",
   "@_column": "38",
   "@_bodyfile": "libavutil/common.h",
   "@_bodystart": "449",
   "@_bodyend": "452"
  },
  "@_kind": "function",
  "@_id": "common_8h_1aed51dfa317ec3988d6bb7734f19d5cba",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Count number of bits set to one in x\n * @param x value to count bits of\n * @return the number of bits set to one in x\n */"
 },
 "av_get_cpu_flags": {
  "type": "int",
  "definition": "int av_get_cpu_flags",
  "argsstring": "(void)",
  "name": "av_get_cpu_flags",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the flags which specify extensions supported by the CPU."
  },
  "detaileddescription": {
   "para": {
    "ref": [
     {
      "#text": "av_force_cpu_flags()",
      "@_refid": "cpu_8h_1a07015a8f8d5e73558e5deb683ad55823",
      "@_kindref": "member"
     },
     {
      "#text": "av_get_cpu_flags()",
      "@_refid": "cpu_8h_1af731555385cb4808386a716504d5fcc1",
      "@_kindref": "member"
     }
    ],
    "#text": "The returned value is affected byif that was used before. Socan easily be used in an application to detect the enabled cpu flags."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/cpu.h",
   "@_line": "100",
   "@_column": "5",
   "@_declfile": "libavutil/cpu.h",
   "@_declline": "100",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "cpu_8h_1af731555385cb4808386a716504d5fcc1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the flags which specify extensions supported by the CPU.\n * The returned value is affected by av_force_cpu_flags() if that was used\n * before. So av_get_cpu_flags() can easily be used in an application to\n * detect the enabled cpu flags.\n */"
 },
 "av_force_cpu_flags": {
  "type": "void",
  "definition": "void av_force_cpu_flags",
  "argsstring": "(int flags)",
  "name": "av_force_cpu_flags",
  "param": {
   "type": "int",
   "declname": "flags"
  },
  "briefdescription": {
   "para": "Disables cpu detection and forces the specified flags."
  },
  "detaileddescription": {
   "para": "-1 is a special case that disables forcing of specific flags."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/cpu.h",
   "@_line": "106",
   "@_column": "6",
   "@_declfile": "libavutil/cpu.h",
   "@_declline": "106",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "cpu_8h_1a07015a8f8d5e73558e5deb683ad55823",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Disables cpu detection and forces the specified flags.\n * -1 is a special case that disables forcing of specific flags.\n */"
 },
 "av_parse_cpu_caps": {
  "type": "int",
  "definition": "int av_parse_cpu_caps",
  "argsstring": "(unsigned *flags, const char *s)",
  "name": "av_parse_cpu_caps",
  "param": [
   {
    "type": "unsigned *",
    "declname": "flags"
   },
   {
    "type": "const char *",
    "declname": "s"
   }
  ],
  "briefdescription": {
   "para": "Parse CPU caps from a string and update the given AV_CPU_* flags based on that."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "negative on error.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/cpu.h",
   "@_line": "113",
   "@_column": "5",
   "@_declfile": "libavutil/cpu.h",
   "@_declline": "113",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "cpu_8h_1a851439bc19de673484e788402734b1a5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse CPU caps from a string and update the given AV_CPU_* flags based on that.\n *\n * @return negative on error.\n */"
 },
 "av_cpu_count": {
  "type": "int",
  "definition": "int av_cpu_count",
  "argsstring": "(void)",
  "name": "av_cpu_count",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the number of logical CPU cores present.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/cpu.h",
   "@_line": "118",
   "@_column": "5",
   "@_declfile": "libavutil/cpu.h",
   "@_declline": "118",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "cpu_8h_1af8bdb502bd3964052fc8595b0fe721a8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the number of logical CPU cores present.\n */"
 },
 "av_cpu_force_count": {
  "type": "void",
  "definition": "void av_cpu_force_count",
  "argsstring": "(int count)",
  "name": "av_cpu_force_count",
  "param": {
   "type": "int",
   "declname": "count"
  },
  "briefdescription": {
   "para": "Overrides cpu count detection and forces the specified count."
  },
  "detaileddescription": {
   "para": "Count < 1 disables forcing of specific count."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/cpu.h",
   "@_line": "124",
   "@_column": "6",
   "@_declfile": "libavutil/cpu.h",
   "@_declline": "124",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "cpu_8h_1a8dd0b023c2cd11ddf533a6f5f1556ce4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Overrides cpu count detection and forces the specified count.\n * Count < 1 disables forcing of specific count.\n */"
 },
 "av_cpu_max_align": {
  "type": "size_t",
  "definition": "size_t av_cpu_max_align",
  "argsstring": "(void)",
  "name": "av_cpu_max_align",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Get the maximum data alignment that may be required by FFmpeg."
  },
  "detaileddescription": {
   "para": {
    "ndash": "",
    "#text": "Note that this is affected by the build configuration and the CPU flags mask, so e.g. if the CPU supports AVX, but libavutil has been built withdisable-avx or the AV_CPU_FLAG_AVX flag has been disabled through av_set_cpu_flags_mask(), then this function will behave as if AVX is not present."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/cpu.h",
   "@_line": "135",
   "@_column": "8",
   "@_declfile": "libavutil/cpu.h",
   "@_declline": "135",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "cpu_8h_1a3734434485a24830c49ffb56b06d30b8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the maximum data alignment that may be required by FFmpeg.\n *\n * Note that this is affected by the build configuration and the CPU flags mask,\n * so e.g. if the CPU supports AVX, but libavutil has been built with\n * --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through\n *  av_set_cpu_flags_mask(), then this function will behave as if AVX is not\n *  present.\n */"
 },
 "AVCRC": {
  "type": "uint32_t",
  "definition": "typedef uint32_t AVCRC",
  "argsstring": "",
  "name": "AVCRC",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/crc.h",
   "@_line": "46",
   "@_column": "18",
   "@_bodyfile": "libavutil/crc.h",
   "@_bodystart": "46",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavu__crc32_1gad7b1134679f68f2d4a52edaf1441e38f",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * @defgroup lavu_crc32 CRC\n * @ingroup lavu_hash\n * CRC (Cyclic Redundancy Check) hash function implementation.\n *\n * This module supports numerous CRC polynomials, in addition to the most\n * widely used CRC-32-IEEE. See @ref AVCRCId for a list of available\n * polynomials.\n *\n * @{\n */"
 },
 "av_crc_init": {
  "type": "int",
  "definition": "int av_crc_init",
  "argsstring": "(AVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size)",
  "name": "av_crc_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCRC",
      "@_refid": "group__lavu__crc32_1gad7b1134679f68f2d4a52edaf1441e38f",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": "int",
    "declname": "le"
   },
   {
    "type": "int",
    "declname": "bits"
   },
   {
    "type": "uint32_t",
    "declname": "poly"
   },
   {
    "type": "int",
    "declname": "ctx_size"
   }
  ],
  "briefdescription": {
   "para": "Initialize a CRC table."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024"
       }
      },
      {
       "parameternamelist": {
        "parametername": "le"
       },
       "parameterdescription": {
        "para": "If 1, the lowest bit represents the coefficient for the highest exponent of the corresponding polynomial (both for poly and actual CRC). If 0, you must swap the CRC parameter and the result of av_crc if you need the standard representation (can be simplified in most cases to e.g. bswap16): av_bswap32(crc << (32-bits))"
       }
      },
      {
       "parameternamelist": {
        "parametername": "bits"
       },
       "parameterdescription": {
        "para": "number of bits for the CRC"
       }
      },
      {
       "parameternamelist": {
        "parametername": "poly"
       },
       "parameterdescription": {
        "para": "generator polynomial without the x**bits coefficient, in the representation as specified by le"
       }
      },
      {
       "parameternamelist": {
        "parametername": "ctx_size"
       },
       "parameterdescription": {
        "para": "size of ctx in bytes"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "<0 on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/crc.h",
   "@_line": "76",
   "@_column": "5",
   "@_declfile": "libavutil/crc.h",
   "@_declline": "76",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__crc32_1ga27f906ac7e618afdac0be18de678ac3d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize a CRC table.\n * @param ctx must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024\n * @param le If 1, the lowest bit represents the coefficient for the highest\n *           exponent of the corresponding polynomial (both for poly and\n *           actual CRC).\n *           If 0, you must swap the CRC parameter and the result of av_crc\n *           if you need the standard representation (can be simplified in\n *           most cases to e.g. bswap16):\n *           av_bswap32(crc << (32-bits))\n * @param bits number of bits for the CRC\n * @param poly generator polynomial without the x**bits coefficient, in the\n *             representation as specified by le\n * @param ctx_size size of ctx in bytes\n * @return <0 on failure\n */"
 },
 "av_crc_get_table": {
  "type": {
   "ref": {
    "#text": "AVCRC",
    "@_refid": "group__lavu__crc32_1gad7b1134679f68f2d4a52edaf1441e38f",
    "@_kindref": "member"
   },
   "#text": "const*"
  },
  "definition": "const AVCRC * av_crc_get_table",
  "argsstring": "(AVCRCId crc_id)",
  "name": "av_crc_get_table",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCRCId",
     "@_refid": "group__lavu__crc32_1gab7717a9f1179a5ac8516982f9f2997d2",
     "@_kindref": "member"
    }
   },
   "declname": "crc_id"
  },
  "briefdescription": {
   "para": "Get an initialized standard CRC table."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "crc_id"
      },
      "parameterdescription": {
       "para": "ID of a standard CRC"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "a pointer to the CRC table or NULL on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/crc.h",
   "@_line": "83",
   "@_column": "13",
   "@_declfile": "libavutil/crc.h",
   "@_declline": "83",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "group__lavu__crc32_1gaa890314027dc4b7425edd45669b68b61",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get an initialized standard CRC table.\n * @param crc_id ID of a standard CRC\n * @return a pointer to the CRC table or NULL on failure\n */"
 },
 "av_crc": {
  "type": "uint32_t",
  "definition": "uint32_t av_crc",
  "argsstring": "(const AVCRC *ctx, uint32_t crc, const uint8_t *buffer, size_t length) av_pure",
  "name": "av_crc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCRC",
      "@_refid": "group__lavu__crc32_1gad7b1134679f68f2d4a52edaf1441e38f",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "ctx"
   },
   {
    "type": "uint32_t",
    "declname": "crc"
   },
   {
    "type": "const uint8_t *",
    "declname": "buffer"
   },
   {
    "type": "size_t",
    "declname": "length"
   }
  ],
  "briefdescription": {
   "para": "Calculate the CRC of a block."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_crc_init()",
          "@_refid": "group__lavu__crc32_1ga27f906ac7e618afdac0be18de678ac3d",
          "@_kindref": "member"
         },
         "#text": "initialized AVCRC array (see)"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "crc"
       },
       "parameterdescription": {
        "para": "CRC of previous blocks if any or initial value for CRC"
       }
      },
      {
       "parameternamelist": {
        "parametername": "buffer"
       },
       "parameterdescription": {
        "para": "buffer whose CRC to calculate"
       }
      },
      {
       "parameternamelist": {
        "parametername": "length"
       },
       "parameterdescription": {
        "para": "length of the buffer"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "CRC updated with the data from the given block",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_crc_init()",
        "@_refid": "group__lavu__crc32_1ga27f906ac7e618afdac0be18de678ac3d",
        "@_kindref": "member"
       },
       "#text": "\"le\" parameter"
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/crc.h",
   "@_line": "95",
   "@_column": "10",
   "@_declfile": "libavutil/crc.h",
   "@_declline": "95",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavu__crc32_1gae0feb73f66306494315f07de7ab57f80",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Calculate the CRC of a block.\n * @param ctx initialized AVCRC array (see av_crc_init())\n * @param crc CRC of previous blocks if any or initial value for CRC\n * @param buffer buffer whose CRC to calculate\n * @param length length of the buffer\n * @return CRC updated with the data from the given block\n *\n * @see av_crc_init() \"le\" parameter\n */"
 },
 "AVWhitepointCoefficients": {
  "type": {
   "ref": {
    "#text": "AVCIExy",
    "@_refid": "structAVCIExy",
    "@_kindref": "compound"
   }
  },
  "definition": "typedef AVCIExy AVWhitepointCoefficients",
  "argsstring": "",
  "name": "AVWhitepointCoefficients",
  "briefdescription": {
   "para": "Struct defining white point location in terms of CIE 1931 chromaticity x and y."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/csp.h",
   "@_line": "72",
   "@_column": "17",
   "@_bodyfile": "libavutil/csp.h",
   "@_bodystart": "72",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavu__math__csp_1ga5a11f2862052a01f3a5777b939237752",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Struct defining white point location in terms of CIE 1931 chromaticity x\n * and y.\n */"
 },
 "av_csp_trc_function": {
  "type": "double(*",
  "definition": "typedef double(* av_csp_trc_function) (double)",
  "argsstring": ")(double)",
  "name": "av_csp_trc_function",
  "briefdescription": {
   "para": "Function pointer representing a double -> double transfer function that performs an EOTF transfer inversion."
  },
  "detaileddescription": {
   "para": "This function outputs linear light."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/csp.h",
   "@_line": "87",
   "@_column": "9",
   "@_bodyfile": "libavutil/csp.h",
   "@_bodystart": "87",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavu__math__csp_1ga0ce8a1b8f342255eca16c7b3e9e103bf",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Function pointer representing a double -> double transfer function that performs\n * an EOTF transfer inversion. This function outputs linear light.\n */"
 },
 "av_csp_luma_coeffs_from_avcsp": {
  "type": {
   "ref": {
    "#text": "AVLumaCoefficients",
    "@_refid": "structAVLumaCoefficients",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVLumaCoefficients * av_csp_luma_coeffs_from_avcsp",
  "argsstring": "(enum AVColorSpace csp)",
  "name": "av_csp_luma_coeffs_from_avcsp",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorSpace",
     "@_refid": "pixfmt_8h_1aff71a069509a1ad3ff54d53a1c894c85",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "csp"
  },
  "briefdescription": {
   "para": "Retrieves the Luma coefficients necessary to construct a conversion matrix from an enum constant describing the colorspace."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "csp"
      },
      "parameterdescription": {
       "para": "An enum constant indicating YUV or similar colorspace."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "The Luma coefficients associated with that colorspace, or NULL if the constant is unknown to libavutil.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/csp.h",
   "@_line": "96",
   "@_column": "26",
   "@_declfile": "libavutil/csp.h",
   "@_declline": "96",
   "@_declcolumn": "26"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__csp_1ga034901e0adcbebacb871f52a855a602a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Retrieves the Luma coefficients necessary to construct a conversion matrix\n * from an enum constant describing the colorspace.\n * @param csp An enum constant indicating YUV or similar colorspace.\n * @return The Luma coefficients associated with that colorspace, or NULL\n *     if the constant is unknown to libavutil.\n */"
 },
 "av_csp_primaries_desc_from_id": {
  "type": {
   "ref": {
    "#text": "AVColorPrimariesDesc",
    "@_refid": "structAVColorPrimariesDesc",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVColorPrimariesDesc * av_csp_primaries_desc_from_id",
  "argsstring": "(enum AVColorPrimaries prm)",
  "name": "av_csp_primaries_desc_from_id",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorPrimaries",
     "@_refid": "pixfmt_8h_1ad384ee5a840bafd73daef08e6d9cafe7",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "prm"
  },
  "briefdescription": {
   "para": "Retrieves a complete gamut description from an enum constant describing the color primaries."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "prm"
      },
      "parameterdescription": {
       "para": "An enum constant indicating primaries"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "A description of the colorspace gamut associated with that enum constant, or NULL if the constant is unknown to libavutil.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/csp.h",
   "@_line": "105",
   "@_column": "28",
   "@_declfile": "libavutil/csp.h",
   "@_declline": "105",
   "@_declcolumn": "28"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__csp_1ga70f19e851f0f0bfa24c56e62a540e477",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Retrieves a complete gamut description from an enum constant describing the\n * color primaries.\n * @param prm An enum constant indicating primaries\n * @return A description of the colorspace gamut associated with that enum\n *     constant, or NULL if the constant is unknown to libavutil.\n */"
 },
 "av_csp_primaries_id_from_desc": {
  "type": {
   "ref": {
    "#text": "AVColorPrimaries",
    "@_refid": "pixfmt_8h_1ad384ee5a840bafd73daef08e6d9cafe7",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVColorPrimaries av_csp_primaries_id_from_desc",
  "argsstring": "(const AVColorPrimariesDesc *prm)",
  "name": "av_csp_primaries_id_from_desc",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorPrimariesDesc",
     "@_refid": "structAVColorPrimariesDesc",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "prm"
  },
  "briefdescription": {
   "para": "Detects which enum AVColorPrimaries constant corresponds to the given complete gamut description."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "AVColorPrimaries",
        "@_refid": "pixfmt_8h_1ad384ee5a840bafd73daef08e6d9cafe7",
        "@_kindref": "member"
       },
       "#text": "enum"
      },
      "@_kind": "see"
     },
     {
      "para": "The enum constant associated with this gamut, or AVCOL_PRI_UNSPECIFIED if no clear match can be idenitified.",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "prm"
      },
      "parameterdescription": {
       "para": "A description of the colorspace gamut"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/csp.h",
   "@_line": "115",
   "@_column": "22",
   "@_declfile": "libavutil/csp.h",
   "@_declline": "115",
   "@_declcolumn": "22"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__csp_1ga1ad5a7e4fce153b115cbe23e405ea145",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Detects which enum AVColorPrimaries constant corresponds to the given complete\n * gamut description.\n * @see enum AVColorPrimaries\n * @param prm A description of the colorspace gamut\n * @return The enum constant associated with this gamut, or\n *     AVCOL_PRI_UNSPECIFIED if no clear match can be idenitified.\n */"
 },
 "av_csp_approximate_trc_gamma": {
  "type": "double",
  "definition": "double av_csp_approximate_trc_gamma",
  "argsstring": "(enum AVColorTransferCharacteristic trc)",
  "name": "av_csp_approximate_trc_gamma",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorTransferCharacteristic",
     "@_refid": "pixfmt_8h_1ad4791ea14975f098b649db7fcd731ce6",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "trc"
  },
  "briefdescription": {
   "para": "Determine a suitable 'gamma' value to match the supplied AVColorTransferCharacteristic."
  },
  "detaileddescription": {
   "para": [
    {
     "ulink": {
      "#text": "https://developer.apple.com/library/mac/technotes/tn2257/_index.html",
      "@_url": "https://developer.apple.com/library/mac/technotes/tn2257/_index.html"
     },
     "#text": "See Apple Technical Note TN2257 ()"
    },
    "This function returns the gamma exponent for the OETF. For example, sRGB is approximated by gamma 2.2, not by gamma 0.45455.",
    {
     "simplesect": {
      "para": "Will return an approximation to the simple gamma function matching the supplied Transfer Characteristic, Will return 0.0 for any we cannot reasonably match against.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/csp.h",
   "@_line": "130",
   "@_column": "8",
   "@_declfile": "libavutil/csp.h",
   "@_declline": "130",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__csp_1gaee369159d52aec550c6aa2e5d9a0e65f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Determine a suitable 'gamma' value to match the supplied\n * AVColorTransferCharacteristic.\n *\n * See Apple Technical Note TN2257 (https://developer.apple.com/library/mac/technotes/tn2257/_index.html)\n *\n * This function returns the gamma exponent for the OETF. For example, sRGB is approximated\n * by gamma 2.2, not by gamma 0.45455.\n *\n * @return Will return an approximation to the simple gamma function matching\n *         the supplied Transfer Characteristic, Will return 0.0 for any\n *         we cannot reasonably match against.\n */"
 },
 "av_csp_trc_func_from_id": {
  "type": {
   "ref": {
    "#text": "av_csp_trc_function",
    "@_refid": "group__lavu__math__csp_1ga0ce8a1b8f342255eca16c7b3e9e103bf",
    "@_kindref": "member"
   }
  },
  "definition": "av_csp_trc_function av_csp_trc_func_from_id",
  "argsstring": "(enum AVColorTransferCharacteristic trc)",
  "name": "av_csp_trc_func_from_id",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorTransferCharacteristic",
     "@_refid": "pixfmt_8h_1ad4791ea14975f098b649db7fcd731ce6",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "trc"
  },
  "briefdescription": {
   "para": "Determine the function needed to apply the given AVColorTransferCharacteristic to linear input."
  },
  "detaileddescription": {
   "para": [
    "The function returned should expect a nominal domain and range of [0.0-1.0] values outside of this range maybe valid depending on the chosen characteristic function.",
    {
     "simplesect": {
      "para": "Will return pointer to the function matching the supplied Transfer Characteristic. If unspecified will return NULL:",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/csp.h",
   "@_line": "144",
   "@_column": "21",
   "@_declfile": "libavutil/csp.h",
   "@_declline": "144",
   "@_declcolumn": "21"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__csp_1ga55f130f366f96e0e2059811d575c2f03",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Determine the function needed to apply the given\n * AVColorTransferCharacteristic to linear input.\n *\n * The function returned should expect a nominal domain and range of [0.0-1.0]\n * values outside of this range maybe valid depending on the chosen\n * characteristic function.\n *\n * @return Will return pointer to the function matching the\n *         supplied Transfer Characteristic. If unspecified will\n *         return NULL:\n */"
 },
 "av_d3d11va_alloc_context": {
  "type": {
   "ref": {
    "#text": "AVD3D11VAContext",
    "@_refid": "structAVD3D11VAContext",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVD3D11VAContext * av_d3d11va_alloc_context",
  "argsstring": "(void)",
  "name": "av_d3d11va_alloc_context",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVD3D11VAContext",
     "@_refid": "structAVD3D11VAContext",
     "@_kindref": "compound"
    },
    "#text": "Allocate an."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVD3D11VAContext",
       "@_refid": "structAVD3D11VAContext",
       "@_kindref": "compound"
      },
      "#text": "Newly-allocatedor NULL on failure."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/d3d11va.h",
   "@_line": "103",
   "@_column": "18",
   "@_declfile": "libavcodec/d3d11va.h",
   "@_declline": "103",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavc__codec__hwaccel__d3d11va_1ga251823f2f8464b8d524f20b545ba3308",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVD3D11VAContext.\n *\n * @return Newly-allocated AVD3D11VAContext or NULL on failure.\n */"
 },
 "av_cpb_properties_alloc": {
  "type": {
   "ref": {
    "#text": "AVCPBProperties",
    "@_refid": "structAVCPBProperties",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVCPBProperties * av_cpb_properties_alloc",
  "argsstring": "(size_t *size)",
  "name": "av_cpb_properties_alloc",
  "param": {
   "type": "size_t *",
   "declname": "size"
  },
  "briefdescription": {
   "para": "Allocate a CPB properties structure and initialize its fields to default values."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "size"
      },
      "parameterdescription": {
       "para": "if non-NULL, the size of the allocated struct will be written here. This is useful for embedding it in side data."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the newly allocated struct or NULL on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/defs.h",
   "@_line": "311",
   "@_column": "17",
   "@_declfile": "libavcodec/defs.h",
   "@_declline": "311",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "defs_8h_1ab30823cc24dc743ad5cf87e2c90629c2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a CPB properties structure and initialize its fields to default\n * values.\n *\n * @param size if non-NULL, the size of the allocated struct will be written\n *             here. This is useful for embedding it in side data.\n *\n * @return the newly allocated struct or NULL on failure\n */"
 },
 "av_xiphlacing": {
  "type": "unsigned int",
  "definition": "unsigned int av_xiphlacing",
  "argsstring": "(unsigned char *s, unsigned int v)",
  "name": "av_xiphlacing",
  "param": [
   {
    "type": "unsigned char *",
    "declname": "s"
   },
   {
    "type": "unsigned int",
    "declname": "v"
   }
  ],
  "briefdescription": {
   "para": "Encode extradata length to a buffer."
  },
  "detaileddescription": {
   "para": [
    "Used by xiph codecs.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "buffer to write to; must be at least (v/255+1) bytes long"
        }
       },
       {
        "parameternamelist": {
         "parametername": "v"
        },
        "parameterdescription": {
         "para": "size of extradata in bytes"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "number of bytes written to the buffer.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/defs.h",
   "@_line": "333",
   "@_column": "14",
   "@_declfile": "libavcodec/defs.h",
   "@_declline": "333",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "defs_8h_1a144411ccbce77847ee9ce10d7fe5361c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Encode extradata length to a buffer. Used by xiph codecs.\n *\n * @param s buffer to write to; must be at least (v/255+1) bytes long\n * @param v size of extradata in bytes\n * @return number of bytes written to the buffer.\n */"
 },
 "av_des_alloc": {
  "type": {
   "ref": {
    "#text": "AVDES",
    "@_refid": "structAVDES",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDES * av_des_alloc",
  "argsstring": "(void)",
  "name": "av_des_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVDES",
     "@_refid": "structAVDES",
     "@_kindref": "compound"
    },
    "#text": "Allocate ancontext."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/des.h",
   "@_line": "41",
   "@_column": "7",
   "@_declfile": "libavutil/des.h",
   "@_declline": "41",
   "@_declcolumn": "7"
  },
  "@_kind": "function",
  "@_id": "group__lavu__des_1gae2dc433f8f70fce5c740c3384c5a9a9a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVDES context.\n */"
 },
 "av_des_init": {
  "type": "int",
  "definition": "int av_des_init",
  "argsstring": "(struct AVDES *d, const uint8_t *key, int key_bits, int decrypt)",
  "name": "av_des_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDES",
      "@_refid": "structAVDES",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "d"
   },
   {
    "type": "const uint8_t *",
    "declname": "key"
   },
   {
    "type": "int",
    "declname": "key_bits"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVDES",
     "@_refid": "structAVDES",
     "@_kindref": "compound"
    },
    "#text": "Initializes ancontext."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "d"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVDES",
          "@_refid": "structAVDES",
          "@_kindref": "compound"
         },
         "#text": "pointer to astructure to initialize"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "pointer to the key to use"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key_bits"
       },
       "parameterdescription": {
        "para": "must be 64 or 192"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption/CBC-MAC, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "zero on success, negative value otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/des.h",
   "@_line": "52",
   "@_column": "5",
   "@_declfile": "libavutil/des.h",
   "@_declline": "52",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__des_1gae8ebc22ff06f4624f4ff9a60b974eb27",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @brief Initializes an AVDES context.\n *\n * @param d pointer to a AVDES structure to initialize\n * @param key pointer to the key to use\n * @param key_bits must be 64 or 192\n * @param decrypt 0 for encryption/CBC-MAC, 1 for decryption\n * @return zero on success, negative value otherwise\n */"
 },
 "av_des_crypt": {
  "type": "void",
  "definition": "void av_des_crypt",
  "argsstring": "(struct AVDES *d, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt)",
  "name": "av_des_crypt",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDES",
      "@_refid": "structAVDES",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "d"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "uint8_t *",
    "declname": "iv"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypts / decrypts using the DES algorithm."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "d"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVDES",
          "@_refid": "structAVDES",
          "@_kindref": "compound"
         },
         "#text": "pointer to thestructure"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src, must be 8-byte aligned"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst, must be 8-byte aligned, may be NULL"
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of 8 byte blocks"
       }
      },
      {
       "parameternamelist": {
        "parametername": "iv"
       },
       "parameterdescription": {
        "para": "initialization vector for CBC mode, if NULL then ECB will be used, must be 8-byte aligned"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/des.h",
   "@_line": "65",
   "@_column": "6",
   "@_declfile": "libavutil/des.h",
   "@_declline": "65",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__des_1gaf728cddab7963246ec519c8c123b5412",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @brief Encrypts / decrypts using the DES algorithm.\n *\n * @param d pointer to the AVDES structure\n * @param dst destination array, can be equal to src, must be 8-byte aligned\n * @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL\n * @param count number of 8 byte blocks\n * @param iv initialization vector for CBC mode, if NULL then ECB will be used,\n *           must be 8-byte aligned\n * @param decrypt 0 for encryption, 1 for decryption\n */"
 },
 "av_des_mac": {
  "type": "void",
  "definition": "void av_des_mac",
  "argsstring": "(struct AVDES *d, uint8_t *dst, const uint8_t *src, int count)",
  "name": "av_des_mac",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDES",
      "@_refid": "structAVDES",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "d"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   }
  ],
  "briefdescription": {
   "para": "Calculates CBC-MAC using the DES algorithm."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "d"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVDES",
          "@_refid": "structAVDES",
          "@_kindref": "compound"
         },
         "#text": "pointer to thestructure"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src, must be 8-byte aligned"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst, must be 8-byte aligned, may be NULL"
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of 8 byte blocks"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/des.h",
   "@_line": "75",
   "@_column": "6",
   "@_declfile": "libavutil/des.h",
   "@_declline": "75",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__des_1gada639d868e744c18622f4e89b1e5833e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @brief Calculates CBC-MAC using the DES algorithm.\n *\n * @param d pointer to the AVDES structure\n * @param dst destination array, can be equal to src, must be 8-byte aligned\n * @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL\n * @param count number of 8 byte blocks\n */"
 },
 "av_get_detection_bbox": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "AVDetectionBBox",
     "@_refid": "structAVDetectionBBox",
     "@_kindref": "compound"
    }
   ],
   "#text": "*"
  },
  "definition": "static av_always_inline AVDetectionBBox * av_get_detection_bbox",
  "argsstring": "(const AVDetectionBBoxHeader *header, unsigned int idx)",
  "name": "av_get_detection_bbox",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDetectionBBoxHeader",
      "@_refid": "structAVDetectionBBoxHeader",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "header"
   },
   {
    "type": "unsigned int",
    "declname": "idx"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/detection_bbox.h",
   "@_line": "84",
   "@_column": "1",
   "@_bodyfile": "libavutil/detection_bbox.h",
   "@_bodystart": "84",
   "@_bodyend": "89"
  },
  "@_kind": "function",
  "@_id": "detection__bbox_8h_1adffa348f6af7e0148306450fee7449b9",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/*\n * Get the bounding box at the specified {@code idx}. Must be between 0 and nb_bboxes.\n */"
 },
 "av_detection_bbox_alloc": {
  "type": {
   "ref": {
    "#text": "AVDetectionBBoxHeader",
    "@_refid": "structAVDetectionBBoxHeader",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDetectionBBoxHeader * av_detection_bbox_alloc",
  "argsstring": "(uint32_t nb_bboxes, size_t *out_size)",
  "name": "av_detection_bbox_alloc",
  "param": [
   {
    "type": "uint32_t",
    "declname": "nb_bboxes"
   },
   {
    "type": "size_t *",
    "declname": "out_size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVDetectionBBoxHeader",
      "@_refid": "structAVDetectionBBoxHeader",
      "@_kindref": "compound"
     },
     {
      "#text": "AVDetectionBBox",
      "@_refid": "structAVDetectionBBox",
      "@_kindref": "compound"
     }
    ],
    "javadoccode": "nb_bboxes",
    "#text": "Allocates memory for, plus an array of, and initializes the variables."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_free()",
      "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
      "@_kindref": "member"
     },
     "#text": "Can be freed with a normalcall."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "nb_bboxes"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVDetectionBBox",
           "@_refid": "structAVDetectionBBox",
           "@_kindref": "compound"
          },
          "#text": "number ofstructures to allocate"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "out_size"
        },
        "parameterdescription": {
         "para": "if non-NULL, the size in bytes of the resulting data array is written here."
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/detection_bbox.h",
   "@_line": "100",
   "@_column": "23",
   "@_declfile": "libavutil/detection_bbox.h",
   "@_declline": "100",
   "@_declcolumn": "23"
  },
  "@_kind": "function",
  "@_id": "detection__bbox_8h_1a5a52be6c84303dec869a1044ab92f1a8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates memory for AVDetectionBBoxHeader, plus an array of {@code nb_bboxes}\n * AVDetectionBBox, and initializes the variables.\n * Can be freed with a normal av_free() call.\n *\n * @param nb_bboxes number of AVDetectionBBox structures to allocate\n * @param out_size if non-NULL, the size in bytes of the resulting data array is\n * written here.\n */"
 },
 "av_detection_bbox_create_side_data": {
  "type": {
   "ref": {
    "#text": "AVDetectionBBoxHeader",
    "@_refid": "structAVDetectionBBoxHeader",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDetectionBBoxHeader * av_detection_bbox_create_side_data",
  "argsstring": "(AVFrame *frame, uint32_t nb_bboxes)",
  "name": "av_detection_bbox_create_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": "uint32_t",
    "declname": "nb_bboxes"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVDetectionBBoxHeader",
      "@_refid": "structAVDetectionBBoxHeader",
      "@_kindref": "compound"
     },
     {
      "#text": "AVDetectionBBox",
      "@_refid": "structAVDetectionBBox",
      "@_kindref": "compound"
     },
     {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     {
      "#text": "AVFrameSideData",
      "@_refid": "structAVFrameSideData",
      "@_kindref": "compound"
     }
    ],
    "javadoccode": [
     "nb_bboxes",
     "frame"
    ],
    "#text": "Allocates memory for, plus an array of, in the givenasof type AV_FRAME_DATA_DETECTION_BBOXES and initializes the variables."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/detection_bbox.h",
   "@_line": "107",
   "@_column": "23",
   "@_declfile": "libavutil/detection_bbox.h",
   "@_declline": "107",
   "@_declcolumn": "23"
  },
  "@_kind": "function",
  "@_id": "detection__bbox_8h_1abdbb62510f4f20766ee9cb3330db4225",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates memory for AVDetectionBBoxHeader, plus an array of {@code nb_bboxes}\n * AVDetectionBBox, in the given AVFrame {@code frame} as AVFrameSideData of type\n * AV_FRAME_DATA_DETECTION_BBOXES and initializes the variables.\n */"
 },
 "AVDictionary": {
  "type": {
   "ref": {
    "#text": "AVDictionary",
    "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVDictionary AVDictionary",
  "argsstring": "",
  "name": "AVDictionary",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dict.h",
   "@_line": "94",
   "@_column": "27",
   "@_bodyfile": "libavutil/dict.h",
   "@_bodystart": "94",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * @}\n */"
 },
 "av_dict_get": {
  "type": {
   "ref": {
    "#text": "AVDictionaryEntry",
    "@_refid": "structAVDictionaryEntry",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDictionaryEntry * av_dict_get",
  "argsstring": "(const AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags)",
  "name": "av_dict_get",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "m"
   },
   {
    "type": "const char *",
    "declname": "key"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionaryEntry",
      "@_refid": "structAVDictionaryEntry",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "prev"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Get a dictionary entry with matching key."
  },
  "detaileddescription": {
   "para": [
    "The returned entry key or value must not be changed, or it will cause undefined behavior.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "prev"
        },
        "parameterdescription": {
         "para": "Set to the previous matching element to find the next. If set to NULL the first matching element is returned."
        }
       },
       {
        "parameternamelist": {
         "parametername": "key"
        },
        "parameterdescription": {
         "para": "Matching key"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "A collection of AV_DICT_* flags controlling how the entry is retrieved"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "Found entry or NULL in case no matching entry was found in the dictionary",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dict.h",
   "@_line": "110",
   "@_column": "19",
   "@_declfile": "libavutil/dict.h",
   "@_declline": "110",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "group__lavu__dict_1ga246f5c0ff557f9585bbc8c36efb57537",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a dictionary entry with matching key.\n *\n * The returned entry key or value must not be changed, or it will\n * cause undefined behavior.\n *\n * @param prev  Set to the previous matching element to find the next.\n *              If set to NULL the first matching element is returned.\n * @param key   Matching key\n * @param flags A collection of AV_DICT_* flags controlling how the\n *              entry is retrieved\n *\n * @return      Found entry or NULL in case no matching entry was found in the dictionary\n */"
 },
 "av_dict_iterate": {
  "type": {
   "ref": {
    "#text": "AVDictionaryEntry",
    "@_refid": "structAVDictionaryEntry",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVDictionaryEntry * av_dict_iterate",
  "argsstring": "(const AVDictionary *m, const AVDictionaryEntry *prev)",
  "name": "av_dict_iterate",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "m"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionaryEntry",
      "@_refid": "structAVDictionaryEntry",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "prev"
   }
  ],
  "briefdescription": {
   "para": "Iterate over a dictionary."
  },
  "detaileddescription": {
   "para": [
    "Iterates through all entries in the dictionary.",
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "AVDictionaryEntry",
         "@_refid": "structAVDictionaryEntry",
         "@_kindref": "compound"
        },
        "#text": "The returnedkey/value must not be changed."
       },
       "@_kind": "warning"
      },
      {
       "para": {
        "ref": {
         "#text": "av_dict_set()",
         "@_refid": "group__lavu__dict_1ga8d9c2de72b310cef8e6a28c9cd3acbbe",
         "@_kindref": "member"
        },
        "#text": "Asinvalidates all previous entries returned by this function, it must not be called while iterating over the dict."
       },
       "@_kind": "warning"
      }
     ],
     "programlisting": {
      "codeline": [
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          ""
         ],
         "#text": "constAVDictionaryEntry*e=NULL;",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          "",
          ""
         ],
         "#text": "while((e=av_dict_iterate(m,e))){",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          "",
          ""
         ],
         "#text": "//...",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "#text": "}",
         "@_class": "normal"
        }
       }
      ]
     },
     "#text": "Typical usage:"
    },
    {
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "m"
         },
         "parameterdescription": {
          "para": "The dictionary to iterate over"
         }
        },
        {
         "parameternamelist": {
          "parametername": "prev"
         },
         "parameterdescription": {
          "para": {
           "ref": {
            "#text": "AVDictionaryEntry",
            "@_refid": "structAVDictionaryEntry",
            "@_kindref": "compound"
           },
           "#text": "Pointer to the previous, NULL initially"
          }
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "AVDictionaryEntry*"
         },
         "parameterdescription": {
          "para": "The next element in the dictionary"
         }
        },
        {
         "parameternamelist": {
          "parametername": "NULL"
         },
         "parameterdescription": {
          "para": "No more elements in the dictionary"
         }
        }
       ],
       "@_kind": "retval"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dict.h",
   "@_line": "137",
   "@_column": "25",
   "@_declfile": "libavutil/dict.h",
   "@_declline": "137",
   "@_declcolumn": "25"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "show__metadata_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "show__metadata_8c",
   "@_startline": "35",
   "@_endline": "61"
  },
  "@_kind": "function",
  "@_id": "group__lavu__dict_1ga363d73ef1c14dbbad5f40988809ac57a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over a dictionary\n *\n * Iterates through all entries in the dictionary.\n *\n * @warning The returned AVDictionaryEntry key/value must not be changed.\n *\n * @warning As av_dict_set() invalidates all previous entries returned\n * by this function, it must not be called while iterating over the dict.\n *\n * Typical usage:\n * @code\n * const AVDictionaryEntry *e = NULL;\n * while ((e = av_dict_iterate(m, e))) {\n *     // ...\n * }\n * @endcode\n *\n * @param m     The dictionary to iterate over\n * @param prev  Pointer to the previous AVDictionaryEntry, NULL initially\n *\n * @retval AVDictionaryEntry* The next element in the dictionary\n * @retval NULL               No more elements in the dictionary\n */"
 },
 "av_dict_count": {
  "type": "int",
  "definition": "int av_dict_count",
  "argsstring": "(const AVDictionary *m)",
  "name": "av_dict_count",
  "param": {
   "type": {
    "ref": {
     "#text": "AVDictionary",
     "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
     "@_kindref": "member"
    },
    "#text": "const*"
   },
   "declname": "m"
  },
  "briefdescription": {
   "para": "Get number of entries in dictionary."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "m"
      },
      "parameterdescription": {
       "para": "dictionary"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "number of entries in dictionary",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dict.h",
   "@_line": "146",
   "@_column": "5",
   "@_declfile": "libavutil/dict.h",
   "@_declline": "146",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__dict_1gad21456d6601aa096c7c78dce8848d50a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get number of entries in dictionary.\n *\n * @param m dictionary\n * @return  number of entries in dictionary\n */"
 },
 "av_dict_set": {
  "type": "int",
  "definition": "int av_dict_set",
  "argsstring": "(AVDictionary **pm, const char *key, const char *value, int flags)",
  "name": "av_dict_set",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "pm"
   },
   {
    "type": "const char *",
    "declname": "key"
   },
   {
    "type": "const char *",
    "declname": "value"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Set the given entry in *pm, overwriting an existing entry."
  },
  "detaileddescription": {
   "para": [
    "Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set, these arguments will be freed on error.",
    {
     "simplesect": [
      {
       "para": {
        "ref": [
         {
          "#text": "av_dict_get()",
          "@_refid": "group__lavu__dict_1ga246f5c0ff557f9585bbc8c36efb57537",
          "@_kindref": "member"
         },
         {
          "#text": "av_dict_iterate()",
          "@_refid": "group__lavu__dict_1ga363d73ef1c14dbbad5f40988809ac57a",
          "@_kindref": "member"
         }
        ],
        "#text": "Adding a new entry to a dictionary invalidates all existing entries previously returned withor."
       },
       "@_kind": "warning"
      },
      {
       "para": ">= 0 on success otherwise an error code <0",
       "@_kind": "return"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "pm"
        },
        "parameterdescription": {
         "para": "Pointer to a pointer to a dictionary struct. If *pm is NULL a dictionary struct is allocated and put in *pm."
        }
       },
       {
        "parameternamelist": {
         "parametername": "key"
        },
        "parameterdescription": {
         "para": "Entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)"
        }
       },
       {
        "parameternamelist": {
         "parametername": "value"
        },
        "parameterdescription": {
         "para": "Entry value to add to *pm (will be av_strduped or added as a new key depending on flags). Passing a NULL value will cause an existing entry to be deleted."
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dict.h",
   "@_line": "165",
   "@_column": "5",
   "@_declfile": "libavutil/dict.h",
   "@_declline": "165",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "init_filter_graph",
    "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "60",
    "@_endline": "208"
   },
   {
    "#text": "main",
    "@_refid": "mux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "mux_8c",
    "@_startline": "534",
    "@_endline": "643"
   },
   {
    "#text": "open_codec_context",
    "@_refid": "extract__mvs_8c_1a08a44e4ddfb699cb1a263e34948d05c3",
    "@_compoundref": "extract__mvs_8c",
    "@_startline": "86",
    "@_endline": "131"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__dict_1ga8d9c2de72b310cef8e6a28c9cd3acbbe",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set the given entry in *pm, overwriting an existing entry.\n *\n * Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,\n * these arguments will be freed on error.\n *\n * @warning Adding a new entry to a dictionary invalidates all existing entries\n * previously returned with av_dict_get() or av_dict_iterate().\n *\n * @param pm        Pointer to a pointer to a dictionary struct. If *pm is NULL\n *                  a dictionary struct is allocated and put in *pm.\n * @param key       Entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)\n * @param value     Entry value to add to *pm (will be av_strduped or added as a new key depending on flags).\n *                  Passing a NULL value will cause an existing entry to be deleted.\n *\n * @return          >= 0 on success otherwise an error code <0\n */"
 },
 "av_dict_set_int": {
  "type": "int",
  "definition": "int av_dict_set_int",
  "argsstring": "(AVDictionary **pm, const char *key, int64_t value, int flags)",
  "name": "av_dict_set_int",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "pm"
   },
   {
    "type": "const char *",
    "declname": "key"
   },
   {
    "type": "int64_t",
    "declname": "value"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_dict_set()",
     "@_refid": "group__lavu__dict_1ga8d9c2de72b310cef8e6a28c9cd3acbbe",
     "@_kindref": "member"
    },
    "#text": "Convenience wrapper forthat converts the value to a string and stores it."
   }
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "AV_DICT_DONT_STRDUP_KEY",
     "@_refid": "group__lavu__dict_1gacb0ce4f20c15bf174f93590ace0fc8fd",
     "@_kindref": "member"
    },
    "#text": "Note: Ifis set, key will be freed on error."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dict.h",
   "@_line": "173",
   "@_column": "5",
   "@_declfile": "libavutil/dict.h",
   "@_declline": "173",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__dict_1gafd013a88620b2da7d497b083f6ea7d29",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convenience wrapper for av_dict_set() that converts the value to a string\n * and stores it.\n *\n * Note: If ::AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.\n */"
 },
 "av_dict_parse_string": {
  "type": "int",
  "definition": "int av_dict_parse_string",
  "argsstring": "(AVDictionary **pm, const char *str, const char *key_val_sep, const char *pairs_sep, int flags)",
  "name": "av_dict_parse_string",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "pm"
   },
   {
    "type": "const char *",
    "declname": "str"
   },
   {
    "type": "const char *",
    "declname": "key_val_sep"
   },
   {
    "type": "const char *",
    "declname": "pairs_sep"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Parse the key/value pairs list and add the parsed entries to a dictionary."
  },
  "detaileddescription": {
   "para": [
    "In case of failure, all the successfully set entries are stored in *pm. You may need to manually free the created dictionary.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "key_val_sep"
        },
        "parameterdescription": {
         "para": "A 0-terminated list of characters used to separate key from value"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pairs_sep"
        },
        "parameterdescription": {
         "para": "A 0-terminated list of characters used to separate two pairs from each other"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "AV_DICT_DONT_STRDUP_KEY",
            "@_refid": "group__lavu__dict_1gacb0ce4f20c15bf174f93590ace0fc8fd",
            "@_kindref": "member"
           },
           {
            "#text": "AV_DICT_DONT_STRDUP_VAL",
            "@_refid": "group__lavu__dict_1ga7a9a991cb7837b10ffd44725263de425",
            "@_kindref": "member"
           }
          ],
          "#text": "Flags to use when adding to the dictionary.andare ignored since the key/value tokens will always be duplicated."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, negative AVERROR code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dict.h",
   "@_line": "192",
   "@_column": "5",
   "@_declfile": "libavutil/dict.h",
   "@_declline": "192",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__dict_1gaca5ff7c251e60bd13164d13c82f21b79",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse the key/value pairs list and add the parsed entries to a dictionary.\n *\n * In case of failure, all the successfully set entries are stored in\n * *pm. You may need to manually free the created dictionary.\n *\n * @param key_val_sep  A 0-terminated list of characters used to separate\n *                     key from value\n * @param pairs_sep    A 0-terminated list of characters used to separate\n *                     two pairs from each other\n * @param flags        Flags to use when adding to the dictionary.\n *                     ::AV_DICT_DONT_STRDUP_KEY and ::AV_DICT_DONT_STRDUP_VAL\n *                     are ignored since the key/value tokens will always\n *                     be duplicated.\n *\n * @return             0 on success, negative AVERROR code on failure\n */"
 },
 "av_dict_copy": {
  "type": "int",
  "definition": "int av_dict_copy",
  "argsstring": "(AVDictionary **dst, const AVDictionary *src, int flags)",
  "name": "av_dict_copy",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Copy entries from one AVDictionary struct into another."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "AV_DICT_IGNORE_SUFFIX",
        "@_refid": "group__lavu__dict_1ga341bbd1ea599dfb0510f419e5272fecc",
        "@_kindref": "member"
       },
       "#text": "Metadata is read using theflag"
      },
      "@_kind": "note"
     },
     {
      "para": "0 on success, negative AVERROR code on failure. If dst was allocated by this function, callers should free the associated memory.",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "Pointer to a pointer to a AVDictionary struct to copy into. If *dst is NULL, this function will allocate a struct for you and put it in *dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "Pointer to the source AVDictionary struct to copy items from."
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "Flags to use when setting entries in *dst"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dict.h",
   "@_line": "209",
   "@_column": "5",
   "@_declfile": "libavutil/dict.h",
   "@_declline": "209",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "open_audio",
    "@_refid": "mux_8c_1a5de64c6730f86a2a0c7cc3ca2bab3717",
    "@_compoundref": "mux_8c",
    "@_startline": "241",
    "@_endline": "303"
   },
   {
    "#text": "open_video",
    "@_refid": "mux_8c_1a1bc713c33e2d1937f2cbc34d83a3e303",
    "@_compoundref": "mux_8c",
    "@_startline": "404",
    "@_endline": "446"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__dict_1ga59a6372b124b306e3a2233723c5cdc78",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy entries from one AVDictionary struct into another.\n *\n * @note Metadata is read using the ::AV_DICT_IGNORE_SUFFIX flag\n *\n * @param dst   Pointer to a pointer to a AVDictionary struct to copy into. If *dst is NULL,\n *              this function will allocate a struct for you and put it in *dst\n * @param src   Pointer to the source AVDictionary struct to copy items from.\n * @param flags Flags to use when setting entries in *dst\n *\n * @return 0 on success, negative AVERROR code on failure. If dst was allocated\n *           by this function, callers should free the associated memory.\n */"
 },
 "av_dict_free": {
  "type": "void",
  "definition": "void av_dict_free",
  "argsstring": "(AVDictionary **m)",
  "name": "av_dict_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVDictionary",
     "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
     "@_kindref": "member"
    },
    "#text": "**"
   },
   "declname": "m"
  },
  "briefdescription": {
   "para": "Free all the memory allocated for an AVDictionary struct and all keys and values."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dict.h",
   "@_line": "215",
   "@_column": "6",
   "@_declfile": "libavutil/dict.h",
   "@_declline": "215",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "init_filter_graph",
    "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "60",
    "@_endline": "208"
   },
   {
    "#text": "open_audio",
    "@_refid": "mux_8c_1a5de64c6730f86a2a0c7cc3ca2bab3717",
    "@_compoundref": "mux_8c",
    "@_startline": "241",
    "@_endline": "303"
   },
   {
    "#text": "open_codec_context",
    "@_refid": "extract__mvs_8c_1a08a44e4ddfb699cb1a263e34948d05c3",
    "@_compoundref": "extract__mvs_8c",
    "@_startline": "86",
    "@_endline": "131"
   },
   {
    "#text": "open_video",
    "@_refid": "mux_8c_1a1bc713c33e2d1937f2cbc34d83a3e303",
    "@_compoundref": "mux_8c",
    "@_startline": "404",
    "@_endline": "446"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__dict_1ga1bafd682b1fbb90e48a4cc3814b820f7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free all the memory allocated for an AVDictionary struct\n * and all keys and values.\n */"
 },
 "av_dict_get_string": {
  "type": "int",
  "definition": "int av_dict_get_string",
  "argsstring": "(const AVDictionary *m, char **buffer, const char key_val_sep, const char pairs_sep)",
  "name": "av_dict_get_string",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "m"
   },
   {
    "type": "char **",
    "declname": "buffer"
   },
   {
    "type": "const char",
    "declname": "key_val_sep"
   },
   {
    "type": "const char",
    "declname": "pairs_sep"
   }
  ],
  "briefdescription": {
   "para": "Get dictionary entries as a string."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "av_dict_parse_string()",
     "@_refid": "group__lavu__dict_1gaca5ff7c251e60bd13164d13c82f21b79",
     "@_kindref": "member"
    },
    "simplesect": [
     {
      "para": "String is escaped with backslashes ('\\').",
      "@_kind": "note"
     },
     {
      "para": "Separators cannot be neither '\\' nor '\\0'. They also cannot be the same.",
      "@_kind": "warning"
     },
     {
      "para": ">= 0 on success, negative on error",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "m",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "The dictionary"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "buffer",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "Pointer to buffer that will be allocated with string containg entries. Buffer must be freed by the caller when is no longer needed."
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "key_val_sep",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "Character used to separate key from value"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "pairs_sep",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "Character used to separate two pairs from each other"
       }
      }
     ],
     "@_kind": "param"
    },
    "#text": "Create a string containing dictionary's entries. Such string may be passed back to."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dict.h",
   "@_line": "234",
   "@_column": "5",
   "@_declfile": "libavutil/dict.h",
   "@_declline": "234",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__dict_1ga480ab3fb3ac6cae8e60e97f58ec30b66",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get dictionary entries as a string.\n *\n * Create a string containing dictionary's entries.\n * Such string may be passed back to av_dict_parse_string().\n * @note String is escaped with backslashes ('\\').\n *\n * @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same.\n *\n * @param[in]  m             The dictionary\n * @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.\n *                           Buffer must be freed by the caller when is no longer needed.\n * @param[in]  key_val_sep   Character used to separate key from value\n * @param[in]  pairs_sep     Character used to separate two pairs from each other\n *\n * @return                   >= 0 on success, negative on error\n */"
 },
 "av_dirac_parse_sequence_header": {
  "type": "int",
  "definition": "int av_dirac_parse_sequence_header",
  "argsstring": "(AVDiracSeqHeader **dsh, const uint8_t *buf, size_t buf_size, void *log_ctx)",
  "name": "av_dirac_parse_sequence_header",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDiracSeqHeader",
      "@_refid": "structAVDiracSeqHeader",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "dsh"
   },
   {
    "type": "const uint8_t *",
    "declname": "buf"
   },
   {
    "type": "size_t",
    "declname": "buf_size"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Parse a Dirac sequence header."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "dsh"
       },
       "parameterdescription": {
        "para": {
         "ref": [
          {
           "#text": "AVDiracSeqHeader",
           "@_refid": "structAVDiracSeqHeader",
           "@_kindref": "compound"
          },
          {
           "#text": "av_free()",
           "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
           "@_kindref": "member"
          }
         ],
         "#text": "this function will allocate and fill anstruct and write it into this pointer. The caller must free it with."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "the data buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf_size"
       },
       "parameterdescription": {
        "para": "the size of the data buffer in bytes"
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_ctx"
       },
       "parameterdescription": {
        "para": "if non-NULL, this function will log errors here"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative AVERROR code on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/dirac.h",
   "@_line": "131",
   "@_column": "5",
   "@_declfile": "libavcodec/dirac.h",
   "@_declline": "131",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "dirac_8h_1a0939293e7885ab2416545945d2e0afa5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse a Dirac sequence header.\n *\n * @param dsh this function will allocate and fill an AVDiracSeqHeader struct\n *            and write it into this pointer. The caller must free it with\n *            av_free().\n * @param buf the data buffer\n * @param buf_size the size of the data buffer in bytes\n * @param log_ctx if non-NULL, this function will log errors here\n * @return 0 on success, a negative AVERROR code on failure\n */"
 },
 "av_display_rotation_get": {
  "type": "double",
  "definition": "double av_display_rotation_get",
  "argsstring": "(const int32_t matrix[9])",
  "name": "av_display_rotation_get",
  "param": {
   "type": "const int32_t",
   "declname": "matrix",
   "array": "[9]"
  },
  "briefdescription": {
   "para": "Extract the rotation component of the transformation matrix."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "matrix"
      },
      "parameterdescription": {
       "para": "the transformation matrix"
      }
     },
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "the angle (in degrees) by which the transformation rotates the frame counterclockwise. The angle will be in range [-180.0, 180.0], or NaN if the matrix is singular.",
      "@_kind": "return"
     },
     {
      "para": "floating point numbers are inherently inexact, so callers are recommended to round the return value to nearest integer before use.",
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/display.h",
   "@_line": "84",
   "@_column": "8",
   "@_declfile": "libavutil/display.h",
   "@_declline": "84",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__video__display_1gaac2ea94d3f66496c758349450b5b0217",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Extract the rotation component of the transformation matrix.\n *\n * @param matrix the transformation matrix\n * @return the angle (in degrees) by which the transformation rotates the frame\n *         counterclockwise. The angle will be in range [-180.0, 180.0],\n *         or NaN if the matrix is singular.\n *\n * @note floating point numbers are inherently inexact, so callers are\n *       recommended to round the return value to nearest integer before use.\n */"
 },
 "av_display_rotation_set": {
  "type": "void",
  "definition": "void av_display_rotation_set",
  "argsstring": "(int32_t matrix[9], double angle)",
  "name": "av_display_rotation_set",
  "param": [
   {
    "type": "int32_t",
    "declname": "matrix",
    "array": "[9]"
   },
   {
    "type": "double",
    "declname": "angle"
   }
  ],
  "briefdescription": {
   "para": "Initialize a transformation matrix describing a pure clockwise rotation by the specified angle (in degrees)."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "matrix",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "a transformation matrix (will be fully overwritten by this function)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "angle"
       },
       "parameterdescription": {
        "para": "rotation angle in degrees."
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/display.h",
   "@_line": "94",
   "@_column": "6",
   "@_declfile": "libavutil/display.h",
   "@_declline": "94",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__video__display_1ga5964303bfe085ad33683bc2454768d4a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize a transformation matrix describing a pure clockwise\n * rotation by the specified angle (in degrees).\n *\n * @param[out] matrix a transformation matrix (will be fully overwritten\n *                    by this function)\n * @param angle rotation angle in degrees.\n */"
 },
 "av_display_matrix_flip": {
  "type": "void",
  "definition": "void av_display_matrix_flip",
  "argsstring": "(int32_t matrix[9], int hflip, int vflip)",
  "name": "av_display_matrix_flip",
  "param": [
   {
    "type": "int32_t",
    "declname": "matrix",
    "array": "[9]"
   },
   {
    "type": "int",
    "declname": "hflip"
   },
   {
    "type": "int",
    "declname": "vflip"
   }
  ],
  "briefdescription": {
   "para": "Flip the input matrix horizontally and/or vertically."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "matrix",
         "@_direction": "inout"
        }
       },
       "parameterdescription": {
        "para": "a transformation matrix"
       }
      },
      {
       "parameternamelist": {
        "parametername": "hflip"
       },
       "parameterdescription": {
        "para": "whether the matrix should be flipped horizontally"
       }
      },
      {
       "parameternamelist": {
        "parametername": "vflip"
       },
       "parameterdescription": {
        "para": "whether the matrix should be flipped vertically"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/display.h",
   "@_line": "103",
   "@_column": "6",
   "@_declfile": "libavutil/display.h",
   "@_declline": "103",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__video__display_1gadd236b7ced34637aa9f0a9bceaeac5c3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Flip the input matrix horizontally and/or vertically.\n *\n * @param[in,out] matrix a transformation matrix\n * @param hflip whether the matrix should be flipped horizontally\n * @param vflip whether the matrix should be flipped vertically\n */"
 },
 "av_dovi_alloc": {
  "type": {
   "ref": {
    "#text": "AVDOVIDecoderConfigurationRecord",
    "@_refid": "structAVDOVIDecoderConfigurationRecord",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDOVIDecoderConfigurationRecord * av_dovi_alloc",
  "argsstring": "(size_t *size)",
  "name": "av_dovi_alloc",
  "param": {
   "type": "size_t *",
   "declname": "size"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVDOVIDecoderConfigurationRecord",
     "@_refid": "structAVDOVIDecoderConfigurationRecord",
     "@_kindref": "compound"
    },
    "#text": "Allocate astructure and initialize its fields to default values."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the newly allocated struct or NULL on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dovi_meta.h",
   "@_line": "69",
   "@_column": "34",
   "@_declfile": "libavutil/dovi_meta.h",
   "@_declline": "69",
   "@_declcolumn": "34"
  },
  "@_kind": "function",
  "@_id": "dovi__meta_8h_1a2c7f63457d7a3ea79abd608035ac44b3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a AVDOVIDecoderConfigurationRecord structure and initialize its\n * fields to default values.\n *\n * @return the newly allocated struct or NULL on failure\n */"
 },
 "av_dovi_get_header": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "AVDOVIRpuDataHeader",
     "@_refid": "structAVDOVIRpuDataHeader",
     "@_kindref": "compound"
    }
   ],
   "#text": "*"
  },
  "definition": "static av_always_inline AVDOVIRpuDataHeader * av_dovi_get_header",
  "argsstring": "(const AVDOVIMetadata *data)",
  "name": "av_dovi_get_header",
  "param": {
   "type": {
    "ref": {
     "#text": "AVDOVIMetadata",
     "@_refid": "structAVDOVIMetadata",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "data"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dovi_meta.h",
   "@_line": "208",
   "@_column": "1",
   "@_bodyfile": "libavutil/dovi_meta.h",
   "@_bodystart": "208",
   "@_bodyend": "211"
  },
  "@_kind": "function",
  "@_id": "dovi__meta_8h_1a3b1d3962bfa66505dfa9867df064366d",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "    size_t color_offset;    /* AVDOVIColorMetadata */"
 },
 "av_dovi_get_mapping": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "AVDOVIDataMapping",
     "@_refid": "structAVDOVIDataMapping",
     "@_kindref": "compound"
    }
   ],
   "#text": "*"
  },
  "definition": "static av_always_inline AVDOVIDataMapping * av_dovi_get_mapping",
  "argsstring": "(const AVDOVIMetadata *data)",
  "name": "av_dovi_get_mapping",
  "param": {
   "type": {
    "ref": {
     "#text": "AVDOVIMetadata",
     "@_refid": "structAVDOVIMetadata",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "data"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dovi_meta.h",
   "@_line": "214",
   "@_column": "1",
   "@_bodyfile": "libavutil/dovi_meta.h",
   "@_bodystart": "214",
   "@_bodyend": "217"
  },
  "@_kind": "function",
  "@_id": "dovi__meta_8h_1acaf80fa20d1d6bfcedab7d8a4b7ec637",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "    size_t color_offset;    /* AVDOVIColorMetadata */"
 },
 "av_dovi_get_color": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "AVDOVIColorMetadata",
     "@_refid": "structAVDOVIColorMetadata",
     "@_kindref": "compound"
    }
   ],
   "#text": "*"
  },
  "definition": "static av_always_inline AVDOVIColorMetadata * av_dovi_get_color",
  "argsstring": "(const AVDOVIMetadata *data)",
  "name": "av_dovi_get_color",
  "param": {
   "type": {
    "ref": {
     "#text": "AVDOVIMetadata",
     "@_refid": "structAVDOVIMetadata",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "data"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dovi_meta.h",
   "@_line": "220",
   "@_column": "1",
   "@_bodyfile": "libavutil/dovi_meta.h",
   "@_bodystart": "220",
   "@_bodyend": "223"
  },
  "@_kind": "function",
  "@_id": "dovi__meta_8h_1a05f1fe6583270fe394dc9abecddd20e4",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "    size_t color_offset;    /* AVDOVIColorMetadata */"
 },
 "av_dovi_metadata_alloc": {
  "type": {
   "ref": {
    "#text": "AVDOVIMetadata",
    "@_refid": "structAVDOVIMetadata",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDOVIMetadata * av_dovi_metadata_alloc",
  "argsstring": "(size_t *size)",
  "name": "av_dovi_metadata_alloc",
  "param": {
   "type": "size_t *",
   "declname": "size"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVDOVIMetadata",
     "@_refid": "structAVDOVIMetadata",
     "@_kindref": "compound"
    },
    "#text": "Allocate anstructure and initialize its fields to default values."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "size"
      },
      "parameterdescription": {
       "para": "If this parameter is non-NULL, the size in bytes of the allocated struct will be written here on success"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the newly allocated struct or NULL on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/dovi_meta.h",
   "@_line": "234",
   "@_column": "16",
   "@_declfile": "libavutil/dovi_meta.h",
   "@_declline": "234",
   "@_declcolumn": "16"
  },
  "@_kind": "function",
  "@_id": "dovi__meta_8h_1aa43a4759247a0913376d744b0799256b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVDOVIMetadata structure and initialize its\n * fields to default values.\n *\n * @param size If this parameter is non-NULL, the size in bytes of the\n *             allocated struct will be written here on success\n *\n * @return the newly allocated struct or NULL on failure\n */"
 },
 "av_downmix_info_update_side_data": {
  "type": {
   "ref": {
    "#text": "AVDownmixInfo",
    "@_refid": "structAVDownmixInfo",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDownmixInfo * av_downmix_info_update_side_data",
  "argsstring": "(AVFrame *frame)",
  "name": "av_downmix_info_update_side_data",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": "Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing."
  },
  "detaileddescription": {
   "para": [
    "If the side data is absent, it is created and added to the frame.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": "the frame for which the side data is to be obtained or created"
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVDownmixInfo",
        "@_refid": "structAVDownmixInfo",
        "@_kindref": "compound"
       },
       "#text": "thestructure to be edited by the caller, or NULL if the structure cannot be allocated."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/downmix_info.h",
   "@_line": "105",
   "@_column": "15",
   "@_declfile": "libavutil/downmix_info.h",
   "@_declline": "105",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__downmix__info_1gad4864d2789400dfb3e6bdc3c9c2eae4d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing.\n *\n * If the side data is absent, it is created and added to the frame.\n *\n * @param frame the frame for which the side data is to be obtained or created\n *\n * @return the AVDownmixInfo structure to be edited by the caller, or NULL if\n *         the structure cannot be allocated.\n */"
 },
 "av_dv_frame_profile": {
  "type": {
   "ref": {
    "#text": "AVDVProfile",
    "@_refid": "structAVDVProfile",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVDVProfile * av_dv_frame_profile",
  "argsstring": "(const AVDVProfile *sys, const uint8_t *frame, unsigned buf_size)",
  "name": "av_dv_frame_profile",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDVProfile",
      "@_refid": "structAVDVProfile",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "sys"
   },
   {
    "type": "const uint8_t *",
    "declname": "frame"
   },
   {
    "type": "unsigned",
    "declname": "buf_size"
   }
  ],
  "briefdescription": {
   "para": "Get a DV profile for the provided compressed frame."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "sys"
       },
       "parameterdescription": {
        "para": "the profile used for the previous frame, may be NULL"
       }
      },
      {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": "the compressed data buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf_size"
       },
       "parameterdescription": {
        "para": "size of the buffer in bytes"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the DV profile for the supplied data or NULL on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/dv_profile.h",
   "@_line": "68",
   "@_column": "19",
   "@_declfile": "libavcodec/dv_profile.h",
   "@_declline": "68",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "dv__profile_8h_1a61b7fdc545fd6ef8acc9bc352a597f89",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a DV profile for the provided compressed frame.\n *\n * @param sys the profile used for the previous frame, may be NULL\n * @param frame the compressed data buffer\n * @param buf_size size of the buffer in bytes\n * @return the DV profile for the supplied data or NULL on failure\n */"
 },
 "av_dv_codec_profile": {
  "type": {
   "ref": {
    "#text": "AVDVProfile",
    "@_refid": "structAVDVProfile",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVDVProfile * av_dv_codec_profile",
  "argsstring": "(int width, int height, enum AVPixelFormat pix_fmt)",
  "name": "av_dv_codec_profile",
  "param": [
   {
    "type": "int",
    "declname": "width"
   },
   {
    "type": "int",
    "declname": "height"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   }
  ],
  "briefdescription": {
   "para": "Get a DV profile for the provided stream parameters."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/dv_profile.h",
   "@_line": "74",
   "@_column": "19",
   "@_declfile": "libavcodec/dv_profile.h",
   "@_declline": "74",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "dv__profile_8h_1a432e96bbfda4ba9ae79a5df51a244a39",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a DV profile for the provided stream parameters.\n */"
 },
 "av_dv_codec_profile2": {
  "type": {
   "ref": {
    "#text": "AVDVProfile",
    "@_refid": "structAVDVProfile",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVDVProfile * av_dv_codec_profile2",
  "argsstring": "(int width, int height, enum AVPixelFormat pix_fmt, AVRational frame_rate)",
  "name": "av_dv_codec_profile2",
  "param": [
   {
    "type": "int",
    "declname": "width"
   },
   {
    "type": "int",
    "declname": "height"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "frame_rate"
   }
  ],
  "briefdescription": {
   "para": "Get a DV profile for the provided stream parameters."
  },
  "detaileddescription": {
   "para": "The frame rate is used as a best-effort parameter."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/dv_profile.h",
   "@_line": "80",
   "@_column": "19",
   "@_declfile": "libavcodec/dv_profile.h",
   "@_declline": "80",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "dv__profile_8h_1a49c7d514c0b96f6e21b93b8d4a47418c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a DV profile for the provided stream parameters.\n * The frame rate is used as a best-effort parameter.\n */"
 },
 "av_encryption_info_alloc": {
  "type": {
   "ref": {
    "#text": "AVEncryptionInfo",
    "@_refid": "structAVEncryptionInfo",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVEncryptionInfo * av_encryption_info_alloc",
  "argsstring": "(uint32_t subsample_count, uint32_t key_id_size, uint32_t iv_size)",
  "name": "av_encryption_info_alloc",
  "param": [
   {
    "type": "uint32_t",
    "declname": "subsample_count"
   },
   {
    "type": "uint32_t",
    "declname": "key_id_size"
   },
   {
    "type": "uint32_t",
    "declname": "iv_size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVEncryptionInfo",
     "@_refid": "structAVEncryptionInfo",
     "@_kindref": "compound"
    },
    "#text": "Allocates anstructure and sub-pointers to hold the given number of subsamples."
   }
  },
  "detaileddescription": {
   "para": [
    "This will allocate pointers for the key ID, IV, and subsample entries, set the size members, and zero-initialize the rest.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "subsample_count"
        },
        "parameterdescription": {
         "para": "The number of subsamples."
        }
       },
       {
        "parameternamelist": {
         "parametername": "key_id_size"
        },
        "parameterdescription": {
         "para": "The number of bytes in the key ID, should be 16."
        }
       },
       {
        "parameternamelist": {
         "parametername": "iv_size"
        },
        "parameterdescription": {
         "para": "The number of bytes in the IV, should be 16."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVEncryptionInfo",
        "@_refid": "structAVEncryptionInfo",
        "@_kindref": "compound"
       },
       "#text": "The newstructure, or NULL on error."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/encryption_info.h",
   "@_line": "136",
   "@_column": "18",
   "@_declfile": "libavutil/encryption_info.h",
   "@_declline": "136",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "encryption__info_8h_1a29cf4778757e5eb6a3459b09439feffd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates an AVEncryptionInfo structure and sub-pointers to hold the given\n * number of subsamples.  This will allocate pointers for the key ID, IV,\n * and subsample entries, set the size members, and zero-initialize the rest.\n *\n * @param subsample_count The number of subsamples.\n * @param key_id_size The number of bytes in the key ID, should be 16.\n * @param iv_size The number of bytes in the IV, should be 16.\n *\n * @return The new AVEncryptionInfo structure, or NULL on error.\n */"
 },
 "av_encryption_info_clone": {
  "type": {
   "ref": {
    "#text": "AVEncryptionInfo",
    "@_refid": "structAVEncryptionInfo",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVEncryptionInfo * av_encryption_info_clone",
  "argsstring": "(const AVEncryptionInfo *info)",
  "name": "av_encryption_info_clone",
  "param": {
   "type": {
    "ref": {
     "#text": "AVEncryptionInfo",
     "@_refid": "structAVEncryptionInfo",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "info"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVEncryptionInfo",
     "@_refid": "structAVEncryptionInfo",
     "@_kindref": "compound"
    },
    "#text": "Allocates anstructure with a copy of the given data."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVEncryptionInfo",
       "@_refid": "structAVEncryptionInfo",
       "@_kindref": "compound"
      },
      "#text": "The newstructure, or NULL on error."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/encryption_info.h",
   "@_line": "142",
   "@_column": "18",
   "@_declfile": "libavutil/encryption_info.h",
   "@_declline": "142",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "encryption__info_8h_1a46ddaa50e0a86abc63fe379b28842fb1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates an AVEncryptionInfo structure with a copy of the given data.\n * @return The new AVEncryptionInfo structure, or NULL on error.\n */"
 },
 "av_encryption_info_free": {
  "type": "void",
  "definition": "void av_encryption_info_free",
  "argsstring": "(AVEncryptionInfo *info)",
  "name": "av_encryption_info_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVEncryptionInfo",
     "@_refid": "structAVEncryptionInfo",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "info"
  },
  "briefdescription": {
   "para": "Frees the given encryption info object."
  },
  "detaileddescription": {
   "para": "This MUST NOT be used to free the side-data data pointer, that should use normal side-data methods."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/encryption_info.h",
   "@_line": "148",
   "@_column": "6",
   "@_declfile": "libavutil/encryption_info.h",
   "@_declline": "148",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "encryption__info_8h_1ae49dc2ef6b84e80914f401bba34d4410",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Frees the given encryption info object.  This MUST NOT be used to free the\n * side-data data pointer, that should use normal side-data methods.\n */"
 },
 "av_encryption_info_get_side_data": {
  "type": {
   "ref": {
    "#text": "AVEncryptionInfo",
    "@_refid": "structAVEncryptionInfo",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVEncryptionInfo * av_encryption_info_get_side_data",
  "argsstring": "(const uint8_t *side_data, size_t side_data_size)",
  "name": "av_encryption_info_get_side_data",
  "param": [
   {
    "type": "const uint8_t *",
    "declname": "side_data"
   },
   {
    "type": "size_t",
    "declname": "side_data_size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVEncryptionInfo",
     "@_refid": "structAVEncryptionInfo",
     "@_kindref": "compound"
    },
    "#text": "Creates a copy of thethat is contained in the given side data."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_encryption_info_free()",
      "@_refid": "encryption__info_8h_1ae49dc2ef6b84e80914f401bba34d4410",
      "@_kindref": "member"
     },
     "#text": "The resulting object should be passed towhen done."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVEncryptionInfo",
        "@_refid": "structAVEncryptionInfo",
        "@_kindref": "compound"
       },
       "#text": "The newstructure, or NULL on error."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/encryption_info.h",
   "@_line": "157",
   "@_column": "18",
   "@_declfile": "libavutil/encryption_info.h",
   "@_declline": "157",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "encryption__info_8h_1ae36d9a50634fd52765c7d6eda7ab7d8c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Creates a copy of the AVEncryptionInfo that is contained in the given side\n * data.  The resulting object should be passed to av_encryption_info_free()\n * when done.\n *\n * @return The new AVEncryptionInfo structure, or NULL on error.\n */"
 },
 "av_encryption_info_add_side_data": {
  "type": "uint8_t *",
  "definition": "uint8_t * av_encryption_info_add_side_data",
  "argsstring": "(const AVEncryptionInfo *info, size_t *side_data_size)",
  "name": "av_encryption_info_add_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVEncryptionInfo",
      "@_refid": "structAVEncryptionInfo",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "info"
   },
   {
    "type": "size_t *",
    "declname": "side_data_size"
   }
  ],
  "briefdescription": {
   "para": "Allocates and initializes side data that holds a copy of the given encryption info."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_packet_add_side_data()",
      "@_refid": "group__lavc__packet_1ga8ac567e12e7637fa5cba87c1b9841f49",
      "@_kindref": "member"
     },
     "#text": "The resulting pointer should be either freed using av_free or given to."
    },
    {
     "simplesect": {
      "para": "The new side-data pointer, or NULL.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/encryption_info.h",
   "@_line": "166",
   "@_column": "9",
   "@_declfile": "libavutil/encryption_info.h",
   "@_declline": "166",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "encryption__info_8h_1aa46723fc8518521d9ad1d4d2242b6008",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates and initializes side data that holds a copy of the given encryption\n * info.  The resulting pointer should be either freed using av_free or given\n * to av_packet_add_side_data().\n *\n * @return The new side-data pointer, or NULL.\n */"
 },
 "av_encryption_init_info_alloc": {
  "type": {
   "ref": {
    "#text": "AVEncryptionInitInfo",
    "@_refid": "structAVEncryptionInitInfo",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVEncryptionInitInfo * av_encryption_init_info_alloc",
  "argsstring": "(uint32_t system_id_size, uint32_t num_key_ids, uint32_t key_id_size, uint32_t data_size)",
  "name": "av_encryption_init_info_alloc",
  "param": [
   {
    "type": "uint32_t",
    "declname": "system_id_size"
   },
   {
    "type": "uint32_t",
    "declname": "num_key_ids"
   },
   {
    "type": "uint32_t",
    "declname": "key_id_size"
   },
   {
    "type": "uint32_t",
    "declname": "data_size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVEncryptionInitInfo",
     "@_refid": "structAVEncryptionInitInfo",
     "@_kindref": "compound"
    },
    "#text": "Allocates anstructure and sub-pointers to hold the given sizes."
   }
  },
  "detaileddescription": {
   "para": [
    "This will allocate pointers and set all the fields.",
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVEncryptionInitInfo",
        "@_refid": "structAVEncryptionInitInfo",
        "@_kindref": "compound"
       },
       "#text": "The newstructure, or NULL on error."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/encryption_info.h",
   "@_line": "176",
   "@_column": "22",
   "@_declfile": "libavutil/encryption_info.h",
   "@_declline": "176",
   "@_declcolumn": "22"
  },
  "@_kind": "function",
  "@_id": "encryption__info_8h_1ac460920c1e7c16c32f5007d917245dce",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates an AVEncryptionInitInfo structure and sub-pointers to hold the\n * given sizes.  This will allocate pointers and set all the fields.\n *\n * @return The new AVEncryptionInitInfo structure, or NULL on error.\n */"
 },
 "av_encryption_init_info_free": {
  "type": "void",
  "definition": "void av_encryption_init_info_free",
  "argsstring": "(AVEncryptionInitInfo *info)",
  "name": "av_encryption_init_info_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVEncryptionInitInfo",
     "@_refid": "structAVEncryptionInitInfo",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "info"
  },
  "briefdescription": {
   "para": "Frees the given encryption init info object."
  },
  "detaileddescription": {
   "para": "This MUST NOT be used to free the side-data data pointer, that should use normal side-data methods."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/encryption_info.h",
   "@_line": "183",
   "@_column": "6",
   "@_declfile": "libavutil/encryption_info.h",
   "@_declline": "183",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "encryption__info_8h_1ad5b99e780657d38504da850e7d621921",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Frees the given encryption init info object.  This MUST NOT be used to free\n * the side-data data pointer, that should use normal side-data methods.\n */"
 },
 "av_encryption_init_info_get_side_data": {
  "type": {
   "ref": {
    "#text": "AVEncryptionInitInfo",
    "@_refid": "structAVEncryptionInitInfo",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVEncryptionInitInfo * av_encryption_init_info_get_side_data",
  "argsstring": "(const uint8_t *side_data, size_t side_data_size)",
  "name": "av_encryption_init_info_get_side_data",
  "param": [
   {
    "type": "const uint8_t *",
    "declname": "side_data"
   },
   {
    "type": "size_t",
    "declname": "side_data_size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVEncryptionInitInfo",
     "@_refid": "structAVEncryptionInitInfo",
     "@_kindref": "compound"
    },
    "#text": "Creates a copy of thethat is contained in the given side data."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_encryption_init_info_free()",
      "@_refid": "encryption__info_8h_1ad5b99e780657d38504da850e7d621921",
      "@_kindref": "member"
     },
     "#text": "The resulting object should be passed towhen done."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVEncryptionInitInfo",
        "@_refid": "structAVEncryptionInitInfo",
        "@_kindref": "compound"
       },
       "#text": "The newstructure, or NULL on error."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/encryption_info.h",
   "@_line": "192",
   "@_column": "22",
   "@_declfile": "libavutil/encryption_info.h",
   "@_declline": "192",
   "@_declcolumn": "22"
  },
  "@_kind": "function",
  "@_id": "encryption__info_8h_1a47e86dc29b7c62ef3b8657475915d80a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Creates a copy of the AVEncryptionInitInfo that is contained in the given\n * side data.  The resulting object should be passed to\n * av_encryption_init_info_free() when done.\n *\n * @return The new AVEncryptionInitInfo structure, or NULL on error.\n */"
 },
 "av_encryption_init_info_add_side_data": {
  "type": "uint8_t *",
  "definition": "uint8_t * av_encryption_init_info_add_side_data",
  "argsstring": "(const AVEncryptionInitInfo *info, size_t *side_data_size)",
  "name": "av_encryption_init_info_add_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVEncryptionInitInfo",
      "@_refid": "structAVEncryptionInitInfo",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "info"
   },
   {
    "type": "size_t *",
    "declname": "side_data_size"
   }
  ],
  "briefdescription": {
   "para": "Allocates and initializes side data that holds a copy of the given encryption init info."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_packet_add_side_data()",
      "@_refid": "group__lavc__packet_1ga8ac567e12e7637fa5cba87c1b9841f49",
      "@_kindref": "member"
     },
     "#text": "The resulting pointer should be either freed using av_free or given to."
    },
    {
     "simplesect": {
      "para": "The new side-data pointer, or NULL.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/encryption_info.h",
   "@_line": "202",
   "@_column": "9",
   "@_declfile": "libavutil/encryption_info.h",
   "@_declline": "202",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "encryption__info_8h_1a8aa1474343c7a631e5ce5c36a8ee6f90",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates and initializes side data that holds a copy of the given encryption\n * init info.  The resulting pointer should be either freed using av_free or\n * given to av_packet_add_side_data().\n *\n * @return The new side-data pointer, or NULL.\n */"
 },
 "av_strerror": {
  "type": "int",
  "definition": "int av_strerror",
  "argsstring": "(int errnum, char *errbuf, size_t errbuf_size)",
  "name": "av_strerror",
  "param": [
   {
    "type": "int",
    "declname": "errnum"
   },
   {
    "type": "char *",
    "declname": "errbuf"
   },
   {
    "type": "size_t",
    "declname": "errbuf_size"
   }
  ],
  "briefdescription": {
   "para": "Put a description of the AVERROR code errnum in errbuf."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_strerror()",
      "@_refid": "group__lavu__error_1ga5792b4a2d18d7d9cb0efbcfc335dce24",
      "@_kindref": "member"
     },
     "#text": "In case of failure the global variable errno is set to indicate the error. Even in case of failurewill print a generic error message indicating the errnum provided to errbuf."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "errnum"
        },
        "parameterdescription": {
         "para": "error code to describe"
        }
       },
       {
        "parameternamelist": {
         "parametername": "errbuf"
        },
        "parameterdescription": {
         "para": "buffer to which description is written"
        }
       },
       {
        "parameternamelist": {
         "parametername": "errbuf_size"
        },
        "parameterdescription": {
         "para": "the size in bytes of errbuf"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, a negative value if a description for errnum cannot be found",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/error.h",
   "@_line": "99",
   "@_column": "5",
   "@_declfile": "libavutil/error.h",
   "@_declline": "99",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "av_make_error_string",
    "@_refid": "group__lavu__error_1ga2173054c6376a4577c6883e31dc38ac4",
    "@_compoundref": "error_8h",
    "@_startline": "111",
    "@_endline": "115"
   },
   {
    "#text": "main",
    "@_refid": "filter__audio_8c_1a0ddf1224851353fc92bfbff6f499fa97",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "267",
    "@_endline": "360"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__error_1ga5792b4a2d18d7d9cb0efbcfc335dce24",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Put a description of the AVERROR code errnum in errbuf.\n * In case of failure the global variable errno is set to indicate the\n * error. Even in case of failure av_strerror() will print a generic\n * error message indicating the errnum provided to errbuf.\n *\n * @param errnum      error code to describe\n * @param errbuf      buffer to which description is written\n * @param errbuf_size the size in bytes of errbuf\n * @return 0 on success, a negative value if a description for errnum\n * cannot be found\n */"
 },
 "av_make_error_string": {
  "type": "char *",
  "definition": "static char * av_make_error_string",
  "argsstring": "(char *errbuf, size_t errbuf_size, int errnum)",
  "name": "av_make_error_string",
  "param": [
   {
    "type": "char *",
    "declname": "errbuf"
   },
   {
    "type": "size_t",
    "declname": "errbuf_size"
   },
   {
    "type": "int",
    "declname": "errnum"
   }
  ],
  "briefdescription": {
   "para": "Fill the provided buffer with a string containing an error string corresponding to the AVERROR code errnum."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "errbuf"
       },
       "parameterdescription": {
        "para": "a buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "errbuf_size"
       },
       "parameterdescription": {
        "para": "size in bytes of errbuf"
       }
      },
      {
       "parameternamelist": {
        "parametername": "errnum"
       },
       "parameterdescription": {
        "para": "error code to describe"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "the buffer in input, filled with the error description",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_strerror()",
        "@_refid": "group__lavu__error_1ga5792b4a2d18d7d9cb0efbcfc335dce24",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/error.h",
   "@_line": "111",
   "@_column": "20",
   "@_bodyfile": "libavutil/error.h",
   "@_bodystart": "111",
   "@_bodyend": "115"
  },
  "@_kind": "function",
  "@_id": "group__lavu__error_1ga2173054c6376a4577c6883e31dc38ac4",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill the provided buffer with a string containing an error string\n * corresponding to the AVERROR code errnum.\n *\n * @param errbuf         a buffer\n * @param errbuf_size    size in bytes of errbuf\n * @param errnum         error code to describe\n * @return the buffer in input, filled with the error description\n * @see av_strerror()\n */"
 },
 "AVExpr": {
  "type": {
   "ref": {
    "#text": "AVExpr",
    "@_refid": "eval_8h_1ac09a495d176de152a38347ca8ba069a8",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVExpr AVExpr",
  "argsstring": "",
  "name": "AVExpr",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/eval.h",
   "@_line": "29",
   "@_column": "21",
   "@_bodyfile": "libavutil/eval.h",
   "@_bodystart": "29",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "eval_8h_1ac09a495d176de152a38347ca8ba069a8",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * @file\n * simple arithmetic expression evaluator\n */"
 },
 "av_expr_parse_and_eval": {
  "type": "int",
  "definition": "int av_expr_parse_and_eval",
  "argsstring": "(double *res, const char *s, const char *const *const_names, const double *const_values, const char *const *func1_names, double(*const *funcs1)(void *, double), const char *const *func2_names, double(*const *funcs2)(void *, double, double), void *opaque, int log_offset, void *log_ctx)",
  "name": "av_expr_parse_and_eval",
  "param": [
   {
    "type": "double *",
    "declname": "res"
   },
   {
    "type": "const char *",
    "declname": "s"
   },
   {
    "type": "const char *const *",
    "declname": "const_names"
   },
   {
    "type": "const double *",
    "declname": "const_values"
   },
   {
    "type": "const char *const *",
    "declname": "func1_names"
   },
   {
    "type": "double(**)(void *, double)",
    "declname": "funcs1"
   },
   {
    "type": "const char *const *",
    "declname": "func2_names"
   },
   {
    "type": "double(**)(void *, double, double)",
    "declname": "funcs2"
   },
   {
    "type": "void *",
    "declname": "opaque"
   },
   {
    "type": "int",
    "declname": "log_offset"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Parse and evaluate an expression."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_expr_eval()",
      "@_refid": "eval_8h_1a569b6171b99e02f899d9ba8b5545cc27",
      "@_kindref": "member"
     },
     "#text": "Note, this is significantly slower than."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "res"
        },
        "parameterdescription": {
         "para": "a pointer to a double where is put the result value of the expression, or NAN in case of error"
        }
       },
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\""
        }
       },
       {
        "parameternamelist": {
         "parametername": "const_names"
        },
        "parameterdescription": {
         "para": "NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}"
        }
       },
       {
        "parameternamelist": {
         "parametername": "const_values"
        },
        "parameterdescription": {
         "para": "a zero terminated array of values for the identifiers from const_names"
        }
       },
       {
        "parameternamelist": {
         "parametername": "func1_names"
        },
        "parameterdescription": {
         "para": "NULL terminated array of zero terminated strings of funcs1 identifiers"
        }
       },
       {
        "parameternamelist": {
         "parametername": "funcs1"
        },
        "parameterdescription": {
         "para": "NULL terminated array of function pointers for functions which take 1 argument"
        }
       },
       {
        "parameternamelist": {
         "parametername": "func2_names"
        },
        "parameterdescription": {
         "para": "NULL terminated array of zero terminated strings of funcs2 identifiers"
        }
       },
       {
        "parameternamelist": {
         "parametername": "funcs2"
        },
        "parameterdescription": {
         "para": "NULL terminated array of function pointers for functions which take 2 arguments"
        }
       },
       {
        "parameternamelist": {
         "parametername": "opaque"
        },
        "parameterdescription": {
         "para": "a pointer which will be passed to all functions from funcs1 and funcs2"
        }
       },
       {
        "parameternamelist": {
         "parametername": "log_offset"
        },
        "parameterdescription": {
         "para": "log level offset, can be used to silence error messages"
        }
       },
       {
        "parameternamelist": {
         "parametername": "log_ctx"
        },
        "parameterdescription": {
         "para": "parent logging context"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">= 0 in case of success, a negative value corresponding to an AVERROR code otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/eval.h",
   "@_line": "50",
   "@_column": "5",
   "@_declfile": "libavutil/eval.h",
   "@_declline": "50",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "eval_8h_1a2d19271d518d49f3cb2df8c347856b18",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse and evaluate an expression.\n * Note, this is significantly slower than av_expr_eval().\n *\n * @param res a pointer to a double where is put the result value of\n * the expression, or NAN in case of error\n * @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\"\n * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}\n * @param const_values a zero terminated array of values for the identifiers from const_names\n * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers\n * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument\n * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers\n * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments\n * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2\n * @param log_offset log level offset, can be used to silence error messages\n * @param log_ctx parent logging context\n * @return >= 0 in case of success, a negative value corresponding to an\n * AVERROR code otherwise\n */"
 },
 "av_expr_parse": {
  "type": "int",
  "definition": "int av_expr_parse",
  "argsstring": "(AVExpr **expr, const char *s, const char *const *const_names, const char *const *func1_names, double(*const *funcs1)(void *, double), const char *const *func2_names, double(*const *funcs2)(void *, double, double), int log_offset, void *log_ctx)",
  "name": "av_expr_parse",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVExpr",
      "@_refid": "eval_8h_1ac09a495d176de152a38347ca8ba069a8",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "expr"
   },
   {
    "type": "const char *",
    "declname": "s"
   },
   {
    "type": "const char *const *",
    "declname": "const_names"
   },
   {
    "type": "const char *const *",
    "declname": "func1_names"
   },
   {
    "type": "double(**)(void *, double)",
    "declname": "funcs1"
   },
   {
    "type": "const char *const *",
    "declname": "func2_names"
   },
   {
    "type": "double(**)(void *, double, double)",
    "declname": "funcs2"
   },
   {
    "type": "int",
    "declname": "log_offset"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Parse an expression."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "expr"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_expr_free()",
          "@_refid": "eval_8h_1a01c05d7049a9208c2b22147a3f16c58c",
          "@_kindref": "member"
         },
         "#text": "a pointer where is put an AVExpr containing the parsed value in case of successful parsing, or NULL otherwise. The pointed to AVExpr must be freed withby the user when it is not needed anymore."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\""
       }
      },
      {
       "parameternamelist": {
        "parametername": "const_names"
       },
       "parameterdescription": {
        "para": "NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}"
       }
      },
      {
       "parameternamelist": {
        "parametername": "func1_names"
       },
       "parameterdescription": {
        "para": "NULL terminated array of zero terminated strings of funcs1 identifiers"
       }
      },
      {
       "parameternamelist": {
        "parametername": "funcs1"
       },
       "parameterdescription": {
        "para": "NULL terminated array of function pointers for functions which take 1 argument"
       }
      },
      {
       "parameternamelist": {
        "parametername": "func2_names"
       },
       "parameterdescription": {
        "para": "NULL terminated array of zero terminated strings of funcs2 identifiers"
       }
      },
      {
       "parameternamelist": {
        "parametername": "funcs2"
       },
       "parameterdescription": {
        "para": "NULL terminated array of function pointers for functions which take 2 arguments"
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_offset"
       },
       "parameterdescription": {
        "para": "log level offset, can be used to silence error messages"
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_ctx"
       },
       "parameterdescription": {
        "para": "parent logging context"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 in case of success, a negative value corresponding to an AVERROR code otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/eval.h",
   "@_line": "74",
   "@_column": "5",
   "@_declfile": "libavutil/eval.h",
   "@_declline": "74",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "eval_8h_1ad3bf8f3330d1fd139de2ca156c313f34",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse an expression.\n *\n * @param expr a pointer where is put an AVExpr containing the parsed\n * value in case of successful parsing, or NULL otherwise.\n * The pointed to AVExpr must be freed with av_expr_free() by the user\n * when it is not needed anymore.\n * @param s expression as a zero terminated string, for example \"1+2^3+5*5+sin(2/3)\"\n * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {\"PI\", \"E\", 0}\n * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers\n * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument\n * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers\n * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments\n * @param log_offset log level offset, can be used to silence error messages\n * @param log_ctx parent logging context\n * @return >= 0 in case of success, a negative value corresponding to an\n * AVERROR code otherwise\n */"
 },
 "av_expr_eval": {
  "type": "double",
  "definition": "double av_expr_eval",
  "argsstring": "(AVExpr *e, const double *const_values, void *opaque)",
  "name": "av_expr_eval",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVExpr",
      "@_refid": "eval_8h_1ac09a495d176de152a38347ca8ba069a8",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "e"
   },
   {
    "type": "const double *",
    "declname": "const_values"
   },
   {
    "type": "void *",
    "declname": "opaque"
   }
  ],
  "briefdescription": {
   "para": "Evaluate a previously parsed expression."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "e"
       },
       "parameterdescription": {
        "para": "the AVExpr to evaluate"
       }
      },
      {
       "parameternamelist": {
        "parametername": "const_values"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_expr_parse()",
          "@_refid": "eval_8h_1ad3bf8f3330d1fd139de2ca156c313f34",
          "@_kindref": "member"
         },
         "#text": "a zero terminated array of values for the identifiers fromconst_names"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "opaque"
       },
       "parameterdescription": {
        "para": "a pointer which will be passed to all functions from funcs1 and funcs2"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the value of the expression",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/eval.h",
   "@_line": "88",
   "@_column": "8",
   "@_declfile": "libavutil/eval.h",
   "@_declline": "88",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "eval_8h_1a569b6171b99e02f899d9ba8b5545cc27",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Evaluate a previously parsed expression.\n *\n * @param e the AVExpr to evaluate\n * @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names\n * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2\n * @return the value of the expression\n */"
 },
 "av_expr_count_vars": {
  "type": "int",
  "definition": "int av_expr_count_vars",
  "argsstring": "(AVExpr *e, unsigned *counter, int size)",
  "name": "av_expr_count_vars",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVExpr",
      "@_refid": "eval_8h_1ac09a495d176de152a38347ca8ba069a8",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "e"
   },
   {
    "type": "unsigned *",
    "declname": "counter"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Track the presence of variables and their number of occurrences in a parsed expression."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "e"
       },
       "parameterdescription": {
        "para": "the AVExpr to track variables in"
       }
      },
      {
       "parameternamelist": {
        "parametername": "counter"
       },
       "parameterdescription": {
        "para": "a zero-initialized array where the count of each variable will be stored"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "size of array"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative value indicates that no expression or array was passed or size was zero",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/eval.h",
   "@_line": "99",
   "@_column": "5",
   "@_declfile": "libavutil/eval.h",
   "@_declline": "99",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "eval_8h_1a3b78fa7b09ddce03ea821f479c218fa1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Track the presence of variables and their number of occurrences in a parsed expression\n *\n * @param e the AVExpr to track variables in\n * @param counter a zero-initialized array where the count of each variable will be stored\n * @param size size of array\n * @return 0 on success, a negative value indicates that no expression or array was passed\n * or size was zero\n */"
 },
 "av_expr_count_func": {
  "type": "int",
  "definition": "int av_expr_count_func",
  "argsstring": "(AVExpr *e, unsigned *counter, int size, int arg)",
  "name": "av_expr_count_func",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVExpr",
      "@_refid": "eval_8h_1ac09a495d176de152a38347ca8ba069a8",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "e"
   },
   {
    "type": "unsigned *",
    "declname": "counter"
   },
   {
    "type": "int",
    "declname": "size"
   },
   {
    "type": "int",
    "declname": "arg"
   }
  ],
  "briefdescription": {
   "para": "Track the presence of user provided functions and their number of occurrences in a parsed expression."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "e"
       },
       "parameterdescription": {
        "para": "the AVExpr to track user provided functions in"
       }
      },
      {
       "parameternamelist": {
        "parametername": "counter"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_expr_parse()",
          "@_refid": "eval_8h_1ad3bf8f3330d1fd139de2ca156c313f34",
          "@_kindref": "member"
         },
         "#text": "a zero-initialized array where the count of each function will be stored if you passed 5 functions with 2 arguments tothen for arg=2 this will use up to 5 entries."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "size of array"
       }
      },
      {
       "parameternamelist": {
        "parametername": "arg"
       },
       "parameterdescription": {
        "para": "number of arguments the counted functions have"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative value indicates that no expression or array was passed or size was zero",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/eval.h",
   "@_line": "114",
   "@_column": "5",
   "@_declfile": "libavutil/eval.h",
   "@_declline": "114",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "eval_8h_1af6ef984527887871b9a0c38cc8d42dc3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Track the presence of user provided functions and their number of occurrences\n * in a parsed expression.\n *\n * @param e the AVExpr to track user provided functions in\n * @param counter a zero-initialized array where the count of each function will be stored\n *                if you passed 5 functions with 2 arguments to av_expr_parse()\n *                then for arg=2 this will use up to 5 entries.\n * @param size size of array\n * @param arg number of arguments the counted functions have\n * @return 0 on success, a negative value indicates that no expression or array was passed\n * or size was zero\n */"
 },
 "av_expr_free": {
  "type": "void",
  "definition": "void av_expr_free",
  "argsstring": "(AVExpr *e)",
  "name": "av_expr_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVExpr",
     "@_refid": "eval_8h_1ac09a495d176de152a38347ca8ba069a8",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "e"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_expr_parse()",
     "@_refid": "eval_8h_1ad3bf8f3330d1fd139de2ca156c313f34",
     "@_kindref": "member"
    },
    "#text": "Free a parsed expression previously created with."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/eval.h",
   "@_line": "119",
   "@_column": "6",
   "@_declfile": "libavutil/eval.h",
   "@_declline": "119",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "eval_8h_1a01c05d7049a9208c2b22147a3f16c58c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free a parsed expression previously created with av_expr_parse().\n */"
 },
 "av_strtod": {
  "type": "double",
  "definition": "double av_strtod",
  "argsstring": "(const char *numstr, char **tail)",
  "name": "av_strtod",
  "param": [
   {
    "type": "const char *",
    "declname": "numstr"
   },
   {
    "type": "char **",
    "declname": "tail"
   }
  ],
  "briefdescription": {
   "para": "Parse the string in numstr and return its value as a double."
  },
  "detaileddescription": {
   "para": [
    "If the string is empty, contains only whitespaces, or does not contain an initial substring that has the expected syntax for a floating-point number, no conversion is performed. In this case, returns a value of zero and the value returned in tail is the value of numstr.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "numstr"
        },
        "parameterdescription": {
         "para": "a string representing a number, may contain one of the International System number postfixes, for example 'K', 'M', 'G'. If 'i' is appended after the postfix, powers of 2 are used instead of powers of 10. The 'B' postfix multiplies the value by 8, and can be appended after another postfix or used alone. This allows using for example 'KB', 'MiB', 'G' and 'B' as postfix."
        }
       },
       {
        "parameternamelist": {
         "parametername": "tail"
        },
        "parameterdescription": {
         "para": "if non-NULL puts here the pointer to the char next after the last parsed character"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/eval.h",
   "@_line": "138",
   "@_column": "8",
   "@_declfile": "libavutil/eval.h",
   "@_declline": "138",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "eval_8h_1a7d21905c92ee5af0bb529d2daf8cb7c3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse the string in numstr and return its value as a double. If\n * the string is empty, contains only whitespaces, or does not contain\n * an initial substring that has the expected syntax for a\n * floating-point number, no conversion is performed. In this case,\n * returns a value of zero and the value returned in tail is the value\n * of numstr.\n *\n * @param numstr a string representing a number, may contain one of\n * the International System number postfixes, for example 'K', 'M',\n * 'G'. If 'i' is appended after the postfix, powers of 2 are used\n * instead of powers of 10. The 'B' postfix multiplies the value by\n * 8, and can be appended after another postfix or used alone. This\n * allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.\n * @param tail if non-NULL puts here the pointer to the char next\n * after the last parsed character\n */"
 },
 "AVExecutor": {
  "type": {
   "ref": {
    "#text": "AVExecutor",
    "@_refid": "executor_8h_1ac1cecfa93feb47218970a3d9f3c5dc43",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVExecutor AVExecutor",
  "argsstring": "",
  "name": "AVExecutor",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/executor.h",
   "@_line": "24",
   "@_column": "25",
   "@_bodyfile": "libavutil/executor.h",
   "@_bodystart": "24",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "executor_8h_1ac1cecfa93feb47218970a3d9f3c5dc43",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/*\n * Copyright (C) 2023 Nuo Mi\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */"
 },
 "av_executor_alloc": {
  "type": {
   "ref": {
    "#text": "AVExecutor",
    "@_refid": "executor_8h_1ac1cecfa93feb47218970a3d9f3c5dc43",
    "@_kindref": "member"
   },
   "#text": "*"
  },
  "definition": "AVExecutor * av_executor_alloc",
  "argsstring": "(const AVTaskCallbacks *callbacks, int thread_count)",
  "name": "av_executor_alloc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVTaskCallbacks",
      "@_refid": "structAVTaskCallbacks",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "callbacks"
   },
   {
    "type": "int",
    "declname": "thread_count"
   }
  ],
  "briefdescription": {
   "para": "Alloc executor."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "callbacks"
       },
       "parameterdescription": {
        "para": "callback structure for executor"
       }
      },
      {
       "parameternamelist": {
        "parametername": "thread_count"
       },
       "parameterdescription": {
        "para": "worker thread number"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "return the executor",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/executor.h",
   "@_line": "52",
   "@_column": "12",
   "@_declfile": "libavutil/executor.h",
   "@_declline": "52",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "executor_8h_1a9f1adf84d1562afc2fafb10bc1ef7265",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Alloc executor\n * @param callbacks callback structure for executor\n * @param thread_count worker thread number\n * @return return the executor\n */"
 },
 "av_executor_free": {
  "type": "void",
  "definition": "void av_executor_free",
  "argsstring": "(AVExecutor **e)",
  "name": "av_executor_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVExecutor",
     "@_refid": "executor_8h_1ac1cecfa93feb47218970a3d9f3c5dc43",
     "@_kindref": "member"
    },
    "#text": "**"
   },
   "declname": "e"
  },
  "briefdescription": {
   "para": "Free executor."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "e"
      },
      "parameterdescription": {
       "para": "pointer to executor"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/executor.h",
   "@_line": "58",
   "@_column": "6",
   "@_declfile": "libavutil/executor.h",
   "@_declline": "58",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "executor_8h_1a8e88dd5795cd47dfb7b912fe3dadb318",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free executor\n * @param e  pointer to executor\n */"
 },
 "av_executor_execute": {
  "type": "void",
  "definition": "void av_executor_execute",
  "argsstring": "(AVExecutor *e, AVTask *t)",
  "name": "av_executor_execute",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVExecutor",
      "@_refid": "executor_8h_1ac1cecfa93feb47218970a3d9f3c5dc43",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "e"
   },
   {
    "type": {
     "ref": {
      "#text": "AVTask",
      "@_refid": "structAVTask",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "t"
   }
  ],
  "briefdescription": {
   "para": "Add task to executor."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "e"
       },
       "parameterdescription": {
        "para": "pointer to executor"
       }
      },
      {
       "parameternamelist": {
        "parametername": "t"
       },
       "parameterdescription": {
        "para": "pointer to task. If NULL, it will wakeup one work thread"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/executor.h",
   "@_line": "65",
   "@_column": "6",
   "@_declfile": "libavutil/executor.h",
   "@_declline": "65",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "executor_8h_1aedf4b97bc28f7efed558416d69d9e7a3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add task to executor\n * @param e pointer to executor\n * @param t pointer to task. If NULL, it will wakeup one work thread\n */"
 },
 "AVFifo": {
  "type": {
   "ref": {
    "#text": "AVFifo",
    "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVFifo AVFifo",
  "argsstring": "",
  "name": "AVFifo",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "42",
   "@_column": "21",
   "@_bodyfile": "libavutil/fifo.h",
   "@_bodystart": "42",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * @defgroup lavu_fifo AVFifo\n * @ingroup lavu_data\n *\n * @{\n * A generic FIFO API\n */"
 },
 "AVFifoCB": {
  "type": "int",
  "definition": "typedef int AVFifoCB(void *opaque, void *buf, size_t *nb_elems)",
  "argsstring": "(void *opaque, void *buf, size_t *nb_elems)",
  "name": "AVFifoCB",
  "briefdescription": {
   "para": "Callback for writing or reading from a FIFO, passed to (and invoked from) the av_fifo_*_cb() functions."
  },
  "detaileddescription": {
   "para": [
    "It may be invoked multiple times from a single av_fifo_*_cb() call and may process less data than the maximum size indicated by nb_elems.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "opaque"
        },
        "parameterdescription": {
         "para": "the opaque pointer provided to the av_fifo_*_cb() function"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "the buffer for reading or writing the data, depending on which av_fifo_*_cb function is called"
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_elems"
        },
        "parameterdescription": {
         "para": "On entry contains the maximum number of elements that can be read from / written into buf. On success, the callback should update it to contain the number of elements actually written."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, a negative error code on failure (will be returned from the invoking av_fifo_*_cb() function)",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "60",
   "@_column": "13",
   "@_bodyfile": "libavutil/fifo.h",
   "@_bodystart": "60",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavu__fifo_1gac707727e701bbe578dee3b7e5bd94378",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Callback for writing or reading from a FIFO, passed to (and invoked from) the\n * av_fifo_*_cb() functions. It may be invoked multiple times from a single\n * av_fifo_*_cb() call and may process less data than the maximum size indicated\n * by nb_elems.\n *\n * @param opaque the opaque pointer provided to the av_fifo_*_cb() function\n * @param buf the buffer for reading or writing the data, depending on which\n *            av_fifo_*_cb function is called\n * @param nb_elems On entry contains the maximum number of elements that can be\n *                 read from / written into buf. On success, the callback should\n *                 update it to contain the number of elements actually written.\n *\n * @return 0 on success, a negative error code on failure (will be returned from\n *         the invoking av_fifo_*_cb() function)\n */"
 },
 "av_fifo_alloc2": {
  "type": {
   "ref": {
    "#text": "AVFifo",
    "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
    "@_kindref": "member"
   },
   "#text": "*"
  },
  "definition": "AVFifo * av_fifo_alloc2",
  "argsstring": "(size_t elems, size_t elem_size, unsigned int flags)",
  "name": "av_fifo_alloc2",
  "param": [
   {
    "type": "size_t",
    "declname": "elems"
   },
   {
    "type": "size_t",
    "declname": "elem_size"
   },
   {
    "type": "unsigned int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Allocate and initialize an AVFifo with a given element size."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "elems"
       },
       "parameterdescription": {
        "para": "initial number of elements that can be stored in the FIFO"
       }
      },
      {
       "parameternamelist": {
        "parametername": "elem_size"
       },
       "parameterdescription": {
        "para": "Size in bytes of a single element. Further operations on the returned FIFO will implicitly use this element size."
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "a combination of AV_FIFO_FLAG_*"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "newly-allocated AVFifo on success, a negative error code on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "79",
   "@_column": "8",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "79",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1ga1b05c4470d92dd2dd1492e9db227eba2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate and initialize an AVFifo with a given element size.\n *\n * @param elems     initial number of elements that can be stored in the FIFO\n * @param elem_size Size in bytes of a single element. Further operations on\n *                  the returned FIFO will implicitly use this element size.\n * @param flags a combination of AV_FIFO_FLAG_*\n *\n * @return newly-allocated AVFifo on success, a negative error code on failure\n */"
 },
 "av_fifo_elem_size": {
  "type": "size_t",
  "definition": "size_t av_fifo_elem_size",
  "argsstring": "(const AVFifo *f)",
  "name": "av_fifo_elem_size",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFifo",
     "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
     "@_kindref": "member"
    },
    "#text": "const*"
   },
   "declname": "f"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "Element size for FIFO operations. This element size is set at FIFO allocation and remains constant during its lifetime",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "86",
   "@_column": "8",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "86",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1gaa60388ce0e485a9cd831043d2b113c07",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return Element size for FIFO operations. This element size is set at\n *         FIFO allocation and remains constant during its lifetime\n */"
 },
 "av_fifo_auto_grow_limit": {
  "type": "void",
  "definition": "void av_fifo_auto_grow_limit",
  "argsstring": "(AVFifo *f, size_t max_elems)",
  "name": "av_fifo_auto_grow_limit",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFifo",
      "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "f"
   },
   {
    "type": "size_t",
    "declname": "max_elems"
   }
  ],
  "briefdescription": {
   "para": "Set the maximum size (in elements) to which the FIFO can be resized automatically."
  },
  "detaileddescription": {
   "para": "Has no effect unless AV_FIFO_FLAG_AUTO_GROW is used."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "92",
   "@_column": "6",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "92",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1gadfd4012330c600c00a54d68da762e65f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set the maximum size (in elements) to which the FIFO can be resized\n * automatically. Has no effect unless AV_FIFO_FLAG_AUTO_GROW is used.\n */"
 },
 "av_fifo_can_read": {
  "type": "size_t",
  "definition": "size_t av_fifo_can_read",
  "argsstring": "(const AVFifo *f)",
  "name": "av_fifo_can_read",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFifo",
     "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
     "@_kindref": "member"
    },
    "#text": "const*"
   },
   "declname": "f"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "number of elements available for reading from the given FIFO.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "97",
   "@_column": "8",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "97",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1ga67df3d042efad591023b624f4008cae1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return number of elements available for reading from the given FIFO.\n */"
 },
 "av_fifo_can_write": {
  "type": "size_t",
  "definition": "size_t av_fifo_can_write",
  "argsstring": "(const AVFifo *f)",
  "name": "av_fifo_can_write",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFifo",
     "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
     "@_kindref": "member"
    },
    "#text": "const*"
   },
   "declname": "f"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "Number of elements that can be written into the given FIFO without growing it.",
     "@_kind": "return"
    },
    "#text": "In other words, this number of elements or less is guaranteed to fit into the FIFO. More data may be written when the AV_FIFO_FLAG_AUTO_GROW flag was specified at FIFO creation, but this may involve memory allocation, which can fail."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "108",
   "@_column": "8",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "108",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1ga5e9a3a490438b98e1e3949587a7c67a6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return Number of elements that can be written into the given FIFO without\n *         growing it.\n *\n *         In other words, this number of elements or less is guaranteed to fit\n *         into the FIFO. More data may be written when the\n *         AV_FIFO_FLAG_AUTO_GROW flag was specified at FIFO creation, but this\n *         may involve memory allocation, which can fail.\n */"
 },
 "av_fifo_grow2": {
  "type": "int",
  "definition": "int av_fifo_grow2",
  "argsstring": "(AVFifo *f, size_t inc)",
  "name": "av_fifo_grow2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFifo",
      "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "f"
   },
   {
    "type": "size_t",
    "declname": "inc"
   }
  ],
  "briefdescription": {
   "para": "Enlarge an AVFifo."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "av_fifo_can_read()",
       "@_refid": "group__lavu__fifo_1ga67df3d042efad591023b624f4008cae1",
       "@_kindref": "member"
      },
      {
       "#text": "av_fifo_can_write()",
       "@_refid": "group__lavu__fifo_1ga5e9a3a490438b98e1e3949587a7c67a6",
       "@_kindref": "member"
      }
     ],
     "#text": "On success, the FIFO will be large enough to hold exactly inc ++elements. In case of failure, the old FIFO is kept unchanged."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "f"
        },
        "parameterdescription": {
         "para": "AVFifo to resize"
        }
       },
       {
        "parameternamelist": {
         "parametername": "inc"
        },
        "parameterdescription": {
         "para": "number of elements to allocate for, in addition to the current allocated size"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "a non-negative number on success, a negative error code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "122",
   "@_column": "5",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "122",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1gaaf68e2ebea8c138b667013af554d2d5b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Enlarge an AVFifo.\n *\n * On success, the FIFO will be large enough to hold exactly\n * inc + av_fifo_can_read() + av_fifo_can_write()\n * elements. In case of failure, the old FIFO is kept unchanged.\n *\n * @param f AVFifo to resize\n * @param inc number of elements to allocate for, in addition to the current\n *            allocated size\n * @return a non-negative number on success, a negative error code on failure\n */"
 },
 "av_fifo_write": {
  "type": "int",
  "definition": "int av_fifo_write",
  "argsstring": "(AVFifo *f, const void *buf, size_t nb_elems)",
  "name": "av_fifo_write",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFifo",
      "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "f"
   },
   {
    "type": "const void *",
    "declname": "buf"
   },
   {
    "type": "size_t",
    "declname": "nb_elems"
   }
  ],
  "briefdescription": {
   "para": "Write data into a FIFO."
  },
  "detaileddescription": {
   "para": [
    "In case nb_elems > av_fifo_can_write(f) and the AV_FIFO_FLAG_AUTO_GROW flag was not specified at FIFO creation, nothing is written and an error is returned.",
    "Calling function is guaranteed to succeed if nb_elems <= av_fifo_can_write(f).",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "f"
        },
        "parameterdescription": {
         "para": "the FIFO buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "Data to be written. nb_elems * av_fifo_elem_size(f) bytes will be read from buf on success."
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_elems"
        },
        "parameterdescription": {
         "para": "number of elements to write into FIFO"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "a non-negative number on success, a negative error code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "140",
   "@_column": "5",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "140",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1gad35a26cb3d3f9fdbb3748a60831bf710",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write data into a FIFO.\n *\n * In case nb_elems > av_fifo_can_write(f) and the AV_FIFO_FLAG_AUTO_GROW flag\n * was not specified at FIFO creation, nothing is written and an error\n * is returned.\n *\n * Calling function is guaranteed to succeed if nb_elems <= av_fifo_can_write(f).\n *\n * @param f the FIFO buffer\n * @param buf Data to be written. nb_elems * av_fifo_elem_size(f) bytes will be\n *            read from buf on success.\n * @param nb_elems number of elements to write into FIFO\n *\n * @return a non-negative number on success, a negative error code on failure\n */"
 },
 "av_fifo_write_from_cb": {
  "type": "int",
  "definition": "int av_fifo_write_from_cb",
  "argsstring": "(AVFifo *f, AVFifoCB read_cb, void *opaque, size_t *nb_elems)",
  "name": "av_fifo_write_from_cb",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFifo",
      "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "f"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFifoCB",
      "@_refid": "group__lavu__fifo_1gac707727e701bbe578dee3b7e5bd94378",
      "@_kindref": "member"
     }
    },
    "declname": "read_cb"
   },
   {
    "type": "void *",
    "declname": "opaque"
   },
   {
    "type": "size_t *",
    "declname": "nb_elems"
   }
  ],
  "briefdescription": {
   "para": "Write data from a user-provided callback into a FIFO."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "f"
       },
       "parameterdescription": {
        "para": "the FIFO buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "read_cb"
       },
       "parameterdescription": {
        "para": "Callback supplying the data to the FIFO. May be called multiple times."
       }
      },
      {
       "parameternamelist": {
        "parametername": "opaque"
       },
       "parameterdescription": {
        "para": "opaque user data to be provided to read_cb"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_elems"
       },
       "parameterdescription": {
        "para": "Should point to the maximum number of elements that can be written. Will be updated to contain the number of elements actually written."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "non-negative number on success, a negative error code on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "155",
   "@_column": "5",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "155",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1gaa7603ed95b14bdc4651d661a7cfc202e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write data from a user-provided callback into a FIFO.\n *\n * @param f the FIFO buffer\n * @param read_cb Callback supplying the data to the FIFO. May be called\n *                multiple times.\n * @param opaque opaque user data to be provided to read_cb\n * @param nb_elems Should point to the maximum number of elements that can be\n *                 written. Will be updated to contain the number of elements\n *                 actually written.\n *\n * @return non-negative number on success, a negative error code on failure\n */"
 },
 "av_fifo_read": {
  "type": "int",
  "definition": "int av_fifo_read",
  "argsstring": "(AVFifo *f, void *buf, size_t nb_elems)",
  "name": "av_fifo_read",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFifo",
      "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "f"
   },
   {
    "type": "void *",
    "declname": "buf"
   },
   {
    "type": "size_t",
    "declname": "nb_elems"
   }
  ],
  "briefdescription": {
   "para": "Read data from a FIFO."
  },
  "detaileddescription": {
   "para": [
    "In case nb_elems > av_fifo_can_read(f), nothing is read and an error is returned.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "f"
        },
        "parameterdescription": {
         "para": "the FIFO buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes will be written into buf on success."
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_elems"
        },
        "parameterdescription": {
         "para": "number of elements to read from FIFO"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "a non-negative number on success, a negative error code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "171",
   "@_column": "5",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "171",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1gafe3d779829de3fc2d1a3a1a39b69d46d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read data from a FIFO.\n *\n * In case nb_elems > av_fifo_can_read(f), nothing is read and an error\n * is returned.\n *\n * @param f the FIFO buffer\n * @param buf Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes\n *            will be written into buf on success.\n * @param nb_elems number of elements to read from FIFO\n *\n * @return a non-negative number on success, a negative error code on failure\n */"
 },
 "av_fifo_read_to_cb": {
  "type": "int",
  "definition": "int av_fifo_read_to_cb",
  "argsstring": "(AVFifo *f, AVFifoCB write_cb, void *opaque, size_t *nb_elems)",
  "name": "av_fifo_read_to_cb",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFifo",
      "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "f"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFifoCB",
      "@_refid": "group__lavu__fifo_1gac707727e701bbe578dee3b7e5bd94378",
      "@_kindref": "member"
     }
    },
    "declname": "write_cb"
   },
   {
    "type": "void *",
    "declname": "opaque"
   },
   {
    "type": "size_t *",
    "declname": "nb_elems"
   }
  ],
  "briefdescription": {
   "para": "Feed data from a FIFO into a user-provided callback."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "f"
       },
       "parameterdescription": {
        "para": "the FIFO buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "write_cb"
       },
       "parameterdescription": {
        "para": "Callback the data will be supplied to. May be called multiple times."
       }
      },
      {
       "parameternamelist": {
        "parametername": "opaque"
       },
       "parameterdescription": {
        "para": "opaque user data to be provided to write_cb"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_elems"
       },
       "parameterdescription": {
        "para": "Should point to the maximum number of elements that can be read. Will be updated to contain the total number of elements actually sent to the callback."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "non-negative number on success, a negative error code on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "186",
   "@_column": "5",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "186",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1ga947a91f6e6565cc939b11e0e108bf8ad",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Feed data from a FIFO into a user-provided callback.\n *\n * @param f the FIFO buffer\n * @param write_cb Callback the data will be supplied to. May be called\n *                 multiple times.\n * @param opaque opaque user data to be provided to write_cb\n * @param nb_elems Should point to the maximum number of elements that can be\n *                 read. Will be updated to contain the total number of elements\n *                 actually sent to the callback.\n *\n * @return non-negative number on success, a negative error code on failure\n */"
 },
 "av_fifo_peek": {
  "type": "int",
  "definition": "int av_fifo_peek",
  "argsstring": "(const AVFifo *f, void *buf, size_t nb_elems, size_t offset)",
  "name": "av_fifo_peek",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFifo",
      "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "f"
   },
   {
    "type": "void *",
    "declname": "buf"
   },
   {
    "type": "size_t",
    "declname": "nb_elems"
   },
   {
    "type": "size_t",
    "declname": "offset"
   }
  ],
  "briefdescription": {
   "para": "Read data from a FIFO without modifying FIFO state."
  },
  "detaileddescription": {
   "para": [
    "Returns an error if an attempt is made to peek to nonexistent elements (i.e. if offset + nb_elems is larger than av_fifo_can_read(f)).",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "f"
        },
        "parameterdescription": {
         "para": "the FIFO buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes will be written into buf."
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_elems"
        },
        "parameterdescription": {
         "para": "number of elements to read from FIFO"
        }
       },
       {
        "parameternamelist": {
         "parametername": "offset"
        },
        "parameterdescription": {
         "para": "number of initial elements to skip."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "a non-negative number on success, a negative error code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "203",
   "@_column": "5",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "203",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1ga9191ceb1b3c8d293967056a498696741",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read data from a FIFO without modifying FIFO state.\n *\n * Returns an error if an attempt is made to peek to nonexistent elements\n * (i.e. if offset + nb_elems is larger than av_fifo_can_read(f)).\n *\n * @param f the FIFO buffer\n * @param buf Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes\n *            will be written into buf.\n * @param nb_elems number of elements to read from FIFO\n * @param offset number of initial elements to skip.\n *\n * @return a non-negative number on success, a negative error code on failure\n */"
 },
 "av_fifo_peek_to_cb": {
  "type": "int",
  "definition": "int av_fifo_peek_to_cb",
  "argsstring": "(const AVFifo *f, AVFifoCB write_cb, void *opaque, size_t *nb_elems, size_t offset)",
  "name": "av_fifo_peek_to_cb",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFifo",
      "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "f"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFifoCB",
      "@_refid": "group__lavu__fifo_1gac707727e701bbe578dee3b7e5bd94378",
      "@_kindref": "member"
     }
    },
    "declname": "write_cb"
   },
   {
    "type": "void *",
    "declname": "opaque"
   },
   {
    "type": "size_t *",
    "declname": "nb_elems"
   },
   {
    "type": "size_t",
    "declname": "offset"
   }
  ],
  "briefdescription": {
   "para": "Feed data from a FIFO into a user-provided callback."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "f"
       },
       "parameterdescription": {
        "para": "the FIFO buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "write_cb"
       },
       "parameterdescription": {
        "para": "Callback the data will be supplied to. May be called multiple times."
       }
      },
      {
       "parameternamelist": {
        "parametername": "opaque"
       },
       "parameterdescription": {
        "para": "opaque user data to be provided to write_cb"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_elems"
       },
       "parameterdescription": {
        "para": "Should point to the maximum number of elements that can be read. Will be updated to contain the total number of elements actually sent to the callback."
       }
      },
      {
       "parameternamelist": {
        "parametername": "offset"
       },
       "parameterdescription": {
        "para": "number of initial elements to skip; offset + *nb_elems must not be larger than av_fifo_can_read(f)."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "a non-negative number on success, a negative error code on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "220",
   "@_column": "5",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "220",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1gabb8d4c21eea614b707b6534431087b96",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Feed data from a FIFO into a user-provided callback.\n *\n * @param f the FIFO buffer\n * @param write_cb Callback the data will be supplied to. May be called\n *                 multiple times.\n * @param opaque opaque user data to be provided to write_cb\n * @param nb_elems Should point to the maximum number of elements that can be\n *                 read. Will be updated to contain the total number of elements\n *                 actually sent to the callback.\n * @param offset number of initial elements to skip; offset + *nb_elems must not\n *               be larger than av_fifo_can_read(f).\n *\n * @return a non-negative number on success, a negative error code on failure\n */"
 },
 "av_fifo_drain2": {
  "type": "void",
  "definition": "void av_fifo_drain2",
  "argsstring": "(AVFifo *f, size_t size)",
  "name": "av_fifo_drain2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFifo",
      "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "f"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Discard the specified amount of data from an AVFifo."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "size"
      },
      "parameterdescription": {
       "para": "number of elements to discard, MUST NOT be larger than av_fifo_can_read(f)"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "228",
   "@_column": "6",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "228",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1gaedbc9f5747365de9fdd03a410d34b02a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Discard the specified amount of data from an AVFifo.\n * @param size number of elements to discard, MUST NOT be larger than\n *             av_fifo_can_read(f)\n */"
 },
 "av_fifo_reset2": {
  "type": "void",
  "definition": "void av_fifo_reset2",
  "argsstring": "(AVFifo *f)",
  "name": "av_fifo_reset2",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFifo",
     "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "f"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "234",
   "@_column": "6",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "234",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1ga4b6e02477642bdee4f66a8ff5f6bd40e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/*\n * Empty the AVFifo.\n * @param f AVFifo to reset\n */"
 },
 "av_fifo_freep2": {
  "type": "void",
  "definition": "void av_fifo_freep2",
  "argsstring": "(AVFifo **f)",
  "name": "av_fifo_freep2",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFifo",
     "@_refid": "group__lavu__fifo_1gabaa992bdba6ec505da8c23b9e6a603b2",
     "@_kindref": "member"
    },
    "#text": "**"
   },
   "declname": "f"
  },
  "briefdescription": {
   "para": "Free an AVFifo and reset pointer to NULL."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "f"
      },
      "parameterdescription": {
       "para": "Pointer to an AVFifo to free. *f == NULL is allowed."
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/fifo.h",
   "@_line": "240",
   "@_column": "6",
   "@_declfile": "libavutil/fifo.h",
   "@_declline": "240",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__fifo_1ga20ff9b7c1b0d56fa9a57aa547d698c0c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free an AVFifo and reset pointer to NULL.\n * @param f Pointer to an AVFifo to free. *f == NULL is allowed.\n */"
 },
 "av_file_map": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int av_file_map",
  "argsstring": "(const char *filename, uint8_t **bufptr, size_t *size, int log_offset, void *log_ctx)",
  "name": "av_file_map",
  "param": [
   {
    "type": "const char *",
    "declname": "filename"
   },
   {
    "type": "uint8_t **",
    "declname": "bufptr"
   },
   {
    "type": "size_t *",
    "declname": "size"
   },
   {
    "type": "int",
    "declname": "log_offset"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Read the file with name filename, and put its content in a newly allocated buffer or map it with mmap() when available."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_file_unmap()",
      "@_refid": "file_8h_1a12e643af4a329ae6d1d567d8a782af1e",
      "@_kindref": "member"
     },
     "#text": "In case of success set *bufptr to the read or mmapped buffer, and *size to the size in bytes of the buffer in *bufptr. Unlike mmap this function succeeds with zero sized files, in this case *bufptr will be set to NULL and *size will be set to 0. The returned buffer must be released with."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "filename"
        },
        "parameterdescription": {
         "para": "path to the file"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "bufptr",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "pointee is set to the mapped or allocated buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "size",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "pointee is set to the size in bytes of the buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "log_offset"
        },
        "parameterdescription": {
         "para": "loglevel offset used for logging"
        }
       },
       {
        "parameternamelist": {
         "parametername": "log_ctx"
        },
        "parameterdescription": {
         "para": "context used for logging"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "a non negative number in case of success, a negative value corresponding to an AVERROR error code in case of failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/file.h",
   "@_line": "51",
   "@_column": "5",
   "@_declfile": "libavutil/file.h",
   "@_declline": "51",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "avio__read__callback_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "avio__read__callback_8c",
   "@_startline": "58",
   "@_endline": "133"
  },
  "@_kind": "function",
  "@_id": "file_8h_1ade51c2ba717b70fab329362952906cfe",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read the file with name filename, and put its content in a newly\n * allocated buffer or map it with mmap() when available.\n * In case of success set *bufptr to the read or mmapped buffer, and\n * *size to the size in bytes of the buffer in *bufptr.\n * Unlike mmap this function succeeds with zero sized files, in this\n * case *bufptr will be set to NULL and *size will be set to 0.\n * The returned buffer must be released with av_file_unmap().\n *\n * @param filename path to the file\n * @param[out] bufptr pointee is set to the mapped or allocated buffer\n * @param[out] size pointee is set to the size in bytes of the buffer\n * @param log_offset loglevel offset used for logging\n * @param log_ctx context used for logging\n * @return a non negative number in case of success, a negative value\n * corresponding to an AVERROR error code in case of failure\n */"
 },
 "av_file_unmap": {
  "type": "void",
  "definition": "void av_file_unmap",
  "argsstring": "(uint8_t *bufptr, size_t size)",
  "name": "av_file_unmap",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "bufptr"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_file_map()",
     "@_refid": "file_8h_1ade51c2ba717b70fab329362952906cfe",
     "@_kindref": "member"
    },
    "#text": "Unmap or free the buffer bufptr created by."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "bufptr"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_file_map()",
          "@_refid": "file_8h_1ade51c2ba717b70fab329362952906cfe",
          "@_kindref": "member"
         },
         "#text": "the buffer previously created with"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_file_map()",
          "@_refid": "file_8h_1ade51c2ba717b70fab329362952906cfe",
          "@_kindref": "member"
         },
         "#text": "size in bytes of bufptr, must be the same as returned by"
        }
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/file.h",
   "@_line": "61",
   "@_column": "6",
   "@_declfile": "libavutil/file.h",
   "@_declline": "61",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "avio__read__callback_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "avio__read__callback_8c",
   "@_startline": "58",
   "@_endline": "133"
  },
  "@_kind": "function",
  "@_id": "file_8h_1a12e643af4a329ae6d1d567d8a782af1e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Unmap or free the buffer bufptr created by av_file_map().\n *\n * @param bufptr the buffer previously created with av_file_map()\n * @param size size in bytes of bufptr, must be the same as returned\n * by av_file_map()\n */"
 },
 "av_film_grain_params_alloc": {
  "type": {
   "ref": {
    "#text": "AVFilmGrainParams",
    "@_refid": "structAVFilmGrainParams",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFilmGrainParams * av_film_grain_params_alloc",
  "argsstring": "(size_t *size)",
  "name": "av_film_grain_params_alloc",
  "param": {
   "type": "size_t *",
   "declname": "size"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFilmGrainParams",
     "@_refid": "structAVFilmGrainParams",
     "@_kindref": "compound"
    },
    "#text": "Allocate anstructure and set its fields to default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_freep()",
      "@_refid": "group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba",
      "@_kindref": "member"
     },
     "#text": "The resulting struct can be freed using. If size is not NULL it will be set to the number of bytes allocated."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVFilmGrainParams",
        "@_refid": "structAVFilmGrainParams",
        "@_kindref": "compound"
       },
       "#text": "Anfilled with default values or NULL on failure."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/film_grain_params.h",
   "@_line": "300",
   "@_column": "19",
   "@_declfile": "libavutil/film_grain_params.h",
   "@_declline": "300",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "film__grain__params_8h_1aee530d6c32f0f0f0e121eb8ff0dfe55b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVFilmGrainParams structure and set its fields to\n * default values. The resulting struct can be freed using av_freep().\n * If size is not NULL it will be set to the number of bytes allocated.\n *\n * @return An AVFilmGrainParams filled with default values or NULL\n *         on failure.\n */"
 },
 "av_film_grain_params_create_side_data": {
  "type": {
   "ref": {
    "#text": "AVFilmGrainParams",
    "@_refid": "structAVFilmGrainParams",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFilmGrainParams * av_film_grain_params_create_side_data",
  "argsstring": "(AVFrame *frame)",
  "name": "av_film_grain_params_create_side_data",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFilmGrainParams",
     "@_refid": "structAVFilmGrainParams",
     "@_kindref": "compound"
    },
    "#text": "Allocate a completeand add it to the frame."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "frame"
      },
      "parameterdescription": {
       "para": "The frame which side data is added to."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVFilmGrainParams",
       "@_refid": "structAVFilmGrainParams",
       "@_kindref": "compound"
      },
      "#text": "Thestructure to be filled by caller."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/film_grain_params.h",
   "@_line": "309",
   "@_column": "19",
   "@_declfile": "libavutil/film_grain_params.h",
   "@_declline": "309",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "film__grain__params_8h_1aace64a3c0b51ba5091166b784e6ad489",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a complete AVFilmGrainParams and add it to the frame.\n *\n * @param frame The frame which side data is added to.\n *\n * @return The AVFilmGrainParams structure to be filled by caller.\n */"
 },
 "av_film_grain_params_select": {
  "type": {
   "ref": {
    "#text": "AVFilmGrainParams",
    "@_refid": "structAVFilmGrainParams",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVFilmGrainParams * av_film_grain_params_select",
  "argsstring": "(const AVFrame *frame)",
  "name": "av_film_grain_params_select",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": "Select the most appropriate film grain parameters set for the frame, taking into account the frame's format, resolution and video signal characteristics."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": ", for H.274, this may select a film grain parameter set with greater chroma resolution than the frame. Users should take care to correctly adjust the chroma grain frequency to the frame.",
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/film_grain_params.h",
   "@_line": "320",
   "@_column": "25",
   "@_declfile": "libavutil/film_grain_params.h",
   "@_declline": "320",
   "@_declcolumn": "25"
  },
  "@_kind": "function",
  "@_id": "film__grain__params_8h_1ab329124a27522dd54d537e2dc51f7f61",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Select the most appropriate film grain parameters set for the frame,\n * taking into account the frame's format, resolution and video signal\n * characteristics.\n *\n * @note, for H.274, this may select a film grain parameter set with\n * greater chroma resolution than the frame. Users should take care to\n * correctly adjust the chroma grain frequency to the frame.\n */"
 },
 "av_frame_alloc": {
  "type": {
   "ref": {
    "#text": "AVFrame",
    "@_refid": "structAVFrame",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFrame * av_frame_alloc",
  "argsstring": "(void)",
  "name": "av_frame_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "Allocate anand set its fields to default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_frame_free()",
      "@_refid": "group__lavu__frame_1ga979d73f3228814aee56aeca0636e37cc",
      "@_kindref": "member"
     },
     "#text": "The resulting struct must be freed using."
    },
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "AVFrame",
         "@_refid": "structAVFrame",
         "@_kindref": "compound"
        },
        "#text": "Anfilled with default values or NULL on failure."
       },
       "@_kind": "return"
      },
      {
       "para": {
        "ref": [
         {
          "#text": "AVFrame",
          "@_refid": "structAVFrame",
          "@_kindref": "compound"
         },
         {
          "#text": "av_frame_get_buffer()",
          "@_refid": "group__lavu__frame_1ga6b1acbfa82c79bf7fd78d868572f0ceb",
          "@_kindref": "member"
         }
        ],
        "#text": "this only allocates theitself, not the data buffers. Those must be allocated through other means, e.g. withor manually."
       },
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "764",
   "@_column": "9",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "764",
   "@_declcolumn": "9"
  },
  "referencedby": [
   {
    "#text": "alloc_audio_frame",
    "@_refid": "mux_8c_1ad09eda99489f30c7d2d9adda00fd4444",
    "@_compoundref": "mux_8c",
    "@_startline": "216",
    "@_endline": "239"
   },
   {
    "#text": "alloc_frame",
    "@_refid": "mux_8c_1a8436a3ec342b666f3e92660278c51eca",
    "@_compoundref": "mux_8c",
    "@_startline": "381",
    "@_endline": "402"
   },
   {
    "#text": "decode_write",
    "@_refid": "hw__decode_8c_1aa376d8bc0bb004de4856e8920e0f6217",
    "@_compoundref": "hw__decode_8c",
    "@_startline": "76",
    "@_endline": "146"
   },
   {
    "#text": "init_filters",
    "@_refid": "transcode_8c_1a05c93a3c60f2fc12e3fb7884be1128d6",
    "@_compoundref": "transcode_8c",
    "@_startline": "394",
    "@_endline": "430"
   },
   {
    "#text": "init_input_frame",
    "@_refid": "transcode__aac_8c_1a399b9ea45bcc6b114a3e0bef1c743a60",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "267",
    "@_endline": "274"
   },
   {
    "#text": "init_output_frame",
    "@_refid": "transcode__aac_8c_1a72741423006b4ab38bf924fa567e7081",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "608",
    "@_endline": "640"
   },
   {
    "#text": "main",
    "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "106",
    "@_endline": "237"
   },
   {
    "#text": "open_input_file",
    "@_refid": "transcode_8c_1abd04bf1a933d4d2698482f4949c61fed",
    "@_compoundref": "transcode_8c",
    "@_startline": "61",
    "@_endline": "126"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__frame_1gac778d9609ac0c42d0a9445e549de172e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVFrame and set its fields to default values.  The resulting\n * struct must be freed using av_frame_free().\n *\n * @return An AVFrame filled with default values or NULL on failure.\n *\n * @note this only allocates the AVFrame itself, not the data buffers. Those\n * must be allocated through other means, e.g. with av_frame_get_buffer() or\n * manually.\n */"
 },
 "av_frame_free": {
  "type": "void",
  "definition": "void av_frame_free",
  "argsstring": "(AVFrame **frame)",
  "name": "av_frame_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": "Free the frame and any dynamically allocated objects in it, e.g."
  },
  "detaileddescription": {
   "para": [
    "extended_data. If the frame is reference counted, it will be unreferenced first.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": "frame to be freed. The pointer will be set to NULL."
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "773",
   "@_column": "6",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "773",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "close_stream",
    "@_refid": "mux_8c_1a92d8b2751255677797d807161fae9d19",
    "@_compoundref": "mux_8c",
    "@_startline": "521",
    "@_endline": "529"
   },
   {
    "#text": "decode_write",
    "@_refid": "hw__decode_8c_1aa376d8bc0bb004de4856e8920e0f6217",
    "@_compoundref": "hw__decode_8c",
    "@_startline": "76",
    "@_endline": "146"
   },
   {
    "#text": "init_output_frame",
    "@_refid": "transcode__aac_8c_1a72741423006b4ab38bf924fa567e7081",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "608",
    "@_endline": "640"
   },
   {
    "#text": "load_encode_and_write",
    "@_refid": "transcode__aac_8c_1ab4367e0049c0bbd56eec8c525cdbd6e5",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "726",
    "@_endline": "759"
   },
   {
    "#text": "main",
    "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "106",
    "@_endline": "237"
   },
   {
    "#text": "read_decode_convert_and_store",
    "@_refid": "transcode__aac_8c_1a7f6cf47c64ae78cbdad6115e57aa2c2f",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "542",
    "@_endline": "598"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga979d73f3228814aee56aeca0636e37cc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the frame and any dynamically allocated objects in it,\n * e.g. extended_data. If the frame is reference counted, it will be\n * unreferenced first.\n *\n * @param frame frame to be freed. The pointer will be set to NULL.\n */"
 },
 "av_frame_ref": {
  "type": "int",
  "definition": "int av_frame_ref",
  "argsstring": "(AVFrame *dst, const AVFrame *src)",
  "name": "av_frame_ref",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Set up a new reference to the data described by the source frame."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "Copy frame properties from src to dst and create a new reference for eachfrom src."
    },
    "If src is not reference counted, new buffers are allocated and the data is copied.",
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "av_frame_alloc()",
         "@_refid": "group__lavu__frame_1gac778d9609ac0c42d0a9445e549de172e",
         "@_kindref": "member"
        },
        "#text": ": dst MUST have been either unreferenced with av_frame_unref(dst), or newly allocated withbefore calling this function, or undefined behavior will occur."
       },
       "@_kind": "warning"
      },
      {
       "para": "0 on success, a negative AVERROR on error",
       "@_kind": "return"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "790",
   "@_column": "5",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "790",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga88b0ecbc4eb3453eef3fbefa3bddeb7c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set up a new reference to the data described by the source frame.\n *\n * Copy frame properties from src to dst and create a new reference for each\n * AVBufferRef from src.\n *\n * If src is not reference counted, new buffers are allocated and the data is\n * copied.\n *\n * @warning: dst MUST have been either unreferenced with av_frame_unref(dst),\n *           or newly allocated with av_frame_alloc() before calling this\n *           function, or undefined behavior will occur.\n *\n * @return 0 on success, a negative AVERROR on error\n */"
 },
 "av_frame_replace": {
  "type": "int",
  "definition": "int av_frame_replace",
  "argsstring": "(AVFrame *dst, const AVFrame *src)",
  "name": "av_frame_replace",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "Ensure the destination frame refers to the same data described by the source frame, either by creating a new reference for eachfrom src if they differ from those in dst, by allocating new buffers and copying data if src is not reference counted, or by unrefencing it if src is empty."
   }
  },
  "detaileddescription": {
   "para": [
    "Frame properties on dst will be replaced by those from src.",
    {
     "simplesect": {
      "para": "0 on success, a negative AVERROR on error. On error, dst is unreferenced.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "803",
   "@_column": "5",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "803",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga2a85f06e2b9f44a1de63032cad51e922",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Ensure the destination frame refers to the same data described by the source\n * frame, either by creating a new reference for each AVBufferRef from src if\n * they differ from those in dst, by allocating new buffers and copying data if\n * src is not reference counted, or by unrefencing it if src is empty.\n *\n * Frame properties on dst will be replaced by those from src.\n *\n * @return 0 on success, a negative AVERROR on error. On error, dst is\n *         unreferenced.\n */"
 },
 "av_frame_clone": {
  "type": {
   "ref": {
    "#text": "AVFrame",
    "@_refid": "structAVFrame",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFrame * av_frame_clone",
  "argsstring": "(const AVFrame *src)",
  "name": "av_frame_clone",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "src"
  },
  "briefdescription": {
   "para": "Create a new frame that references the same data as src."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "av_frame_alloc()",
       "@_refid": "group__lavu__frame_1gac778d9609ac0c42d0a9445e549de172e",
       "@_kindref": "member"
      },
      {
       "#text": "av_frame_ref()",
       "@_refid": "group__lavu__frame_1ga88b0ecbc4eb3453eef3fbefa3bddeb7c",
       "@_kindref": "member"
      }
     ],
     "#text": "This is a shortcut for+."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVFrame",
        "@_refid": "structAVFrame",
        "@_kindref": "compound"
       },
       "#text": "newly createdon success, NULL on error."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "812",
   "@_column": "9",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "812",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1gadb917e6f2b61717390baf2009fe66c06",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create a new frame that references the same data as src.\n *\n * This is a shortcut for av_frame_alloc()+av_frame_ref().\n *\n * @return newly created AVFrame on success, NULL on error.\n */"
 },
 "av_frame_unref": {
  "type": "void",
  "definition": "void av_frame_unref",
  "argsstring": "(AVFrame *frame)",
  "name": "av_frame_unref",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": "Unreference all the buffers referenced by frame and reset the frame fields."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "817",
   "@_column": "6",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "817",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "decode_packet",
    "@_refid": "demux__decode_8c_1a9e3819273006eb6eb08cfe7a487c222e",
    "@_compoundref": "demux__decode_8c",
    "@_startline": "110",
    "@_endline": "144"
   },
   {
    "#text": "filter_encode_write_frame",
    "@_refid": "transcode_8c_1a255192428438daf73b9f8060c0815712",
    "@_compoundref": "transcode_8c",
    "@_startline": "473",
    "@_endline": "511"
   },
   {
    "#text": "main",
    "@_refid": "decode__filter__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "217",
    "@_endline": "296"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga0a2b687f9c1c5ed0089b01fd61227108",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Unreference all the buffers referenced by frame and reset the frame fields.\n */"
 },
 "av_frame_move_ref": {
  "type": "void",
  "definition": "void av_frame_move_ref",
  "argsstring": "(AVFrame *dst, AVFrame *src)",
  "name": "av_frame_move_ref",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Move everything contained in src to dst and reset src."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": ": dst is not unreferenced, but directly overwritten without reading or deallocating its contents. Call av_frame_unref(dst) manually before calling this function to ensure that no memory is leaked.",
     "@_kind": "warning"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "826",
   "@_column": "6",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "826",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga709e62bc2917ffd84c5c0f4e1dfc48f7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Move everything contained in src to dst and reset src.\n *\n * @warning: dst is not unreferenced, but directly overwritten without reading\n *           or deallocating its contents. Call av_frame_unref(dst) manually\n *           before calling this function to ensure that no memory is leaked.\n */"
 },
 "av_frame_get_buffer": {
  "type": "int",
  "definition": "int av_frame_get_buffer",
  "argsstring": "(AVFrame *frame, int align)",
  "name": "av_frame_get_buffer",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": "int",
    "declname": "align"
   }
  ],
  "briefdescription": {
   "para": "Allocate new buffer(s) for audio or video data."
  },
  "detaileddescription": {
   "para": [
    {
     "itemizedlist": {
      "listitem": [
       {
        "para": "format (pixel format for video, sample format for audio)"
       },
       {
        "para": "width and height for video"
       },
       {
        "para": "nb_samples and ch_layout for audio"
       }
      ]
     },
     "#text": "The following fields must be set on frame before calling this function:"
    },
    {
     "ref": [
      {
       "#text": "AVFrame.data",
       "@_refid": "structAVFrame_1a1d0f65014a8d1bf78cec8cbed2304992",
       "@_kindref": "member"
      },
      {
       "#text": "AVFrame.buf",
       "@_refid": "structAVFrame_1a4a64d05cc676bfa8e18bf22d16c8a51f",
       "@_kindref": "member"
      },
      {
       "#text": "AVFrame.extended_data",
       "@_refid": "structAVFrame_1afca04d808393822625e09b5ba91c6756",
       "@_kindref": "member"
      },
      {
       "#text": "AVFrame.extended_buf",
       "@_refid": "structAVFrame_1a254a144d113ceedc003ec1547cc5bd54",
       "@_kindref": "member"
      }
     ],
     "#text": "This function will fillandarrays and, if necessary, allocate and filland. For planar formats, one buffer will be allocated for each plane."
    },
    {
     "simplesect": [
      {
       "para": ": if frame already has been allocated, calling this function will leak memory. In addition, undefined behavior can occur in certain cases.",
       "@_kind": "warning"
      },
      {
       "para": "0 on success, a negative AVERROR on error.",
       "@_kind": "return"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "frame"
        },
        "parameterdescription": {
         "para": "frame in which to store the new buffers."
        }
       },
       {
        "parameternamelist": {
         "parametername": "align"
        },
        "parameterdescription": {
         "para": "Required buffer size alignment. If equal to 0, alignment will be chosen automatically for the current CPU. It is highly recommended to pass 0 here unless you know what you are doing."
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "851",
   "@_column": "5",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "851",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "alloc_audio_frame",
    "@_refid": "mux_8c_1ad09eda99489f30c7d2d9adda00fd4444",
    "@_compoundref": "mux_8c",
    "@_startline": "216",
    "@_endline": "239"
   },
   {
    "#text": "alloc_frame",
    "@_refid": "mux_8c_1a8436a3ec342b666f3e92660278c51eca",
    "@_compoundref": "mux_8c",
    "@_startline": "381",
    "@_endline": "402"
   },
   {
    "#text": "get_input",
    "@_refid": "filter__audio_8c_1a4209191767f4a5779718e9f691a6de53",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "239",
    "@_endline": "265"
   },
   {
    "#text": "init_output_frame",
    "@_refid": "transcode__aac_8c_1a72741423006b4ab38bf924fa567e7081",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "608",
    "@_endline": "640"
   },
   {
    "#text": "main",
    "@_refid": "encode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "encode__audio_8c",
    "@_startline": "122",
    "@_endline": "240"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga6b1acbfa82c79bf7fd78d868572f0ceb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate new buffer(s) for audio or video data.\n *\n * The following fields must be set on frame before calling this function:\n * - format (pixel format for video, sample format for audio)\n * - width and height for video\n * - nb_samples and ch_layout for audio\n *\n * This function will fill AVFrame.data and AVFrame.buf arrays and, if\n * necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.\n * For planar formats, one buffer will be allocated for each plane.\n *\n * @warning: if frame already has been allocated, calling this function will\n *           leak memory. In addition, undefined behavior can occur in certain\n *           cases.\n *\n * @param frame frame in which to store the new buffers.\n * @param align Required buffer size alignment. If equal to 0, alignment will be\n *              chosen automatically for the current CPU. It is highly\n *              recommended to pass 0 here unless you know what you are doing.\n *\n * @return 0 on success, a negative AVERROR on error.\n */"
 },
 "av_frame_is_writable": {
  "type": "int",
  "definition": "int av_frame_is_writable",
  "argsstring": "(AVFrame *frame)",
  "name": "av_frame_is_writable",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": "Check if the frame data is writable."
  },
  "detaileddescription": {
   "para": [
    {
     "simplesect": {
      "para": "A positive value if the frame data is writable (which is true if and only if each of the underlying buffers has only one reference, namely the one stored in this frame). Return 0 otherwise.",
      "@_kind": "return"
     },
     "ref": [
      {
       "#text": "av_buffer_ref()",
       "@_refid": "group__lavu__buffer_1ga8a684b77a72519dd1e907457898626f1",
       "@_kindref": "member"
      },
      {
       "#text": "av_frame_ref()",
       "@_refid": "group__lavu__frame_1ga88b0ecbc4eb3453eef3fbefa3bddeb7c",
       "@_kindref": "member"
      }
     ],
     "#text": "If 1 is returned the answer is valid untilis called on any of the underlying AVBufferRefs (e.g. throughor directly)."
    },
    {
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "av_frame_make_writable()",
         "@_refid": "group__lavu__frame_1gadd5417c06f5a6b419b0dbd8f0ff363fd",
         "@_kindref": "member"
        },
        {
         "#text": "av_buffer_is_writable()",
         "@_refid": "group__lavu__buffer_1ga060be34ace567ae378fd0a786e847053",
         "@_kindref": "member"
        }
       ],
       "#text": ","
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "865",
   "@_column": "5",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "865",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga3ba755bada5c3c8883361ef43fb5fb7a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if the frame data is writable.\n *\n * @return A positive value if the frame data is writable (which is true if and\n * only if each of the underlying buffers has only one reference, namely the one\n * stored in this frame). Return 0 otherwise.\n *\n * If 1 is returned the answer is valid until av_buffer_ref() is called on any\n * of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).\n *\n * @see av_frame_make_writable(), av_buffer_is_writable()\n */"
 },
 "av_frame_make_writable": {
  "type": "int",
  "definition": "int av_frame_make_writable",
  "argsstring": "(AVFrame *frame)",
  "name": "av_frame_make_writable",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": "Ensure that the frame data is writable, avoiding data copy if possible."
  },
  "detaileddescription": {
   "para": [
    "Do nothing if the frame is writable, allocate new buffers and copy the data if it is not. Non-refcounted frames behave as non-writable, i.e. a copy is always made.",
    {
     "simplesect": [
      {
       "para": "0 on success, a negative AVERROR on error.",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": [
         {
          "#text": "av_frame_is_writable()",
          "@_refid": "group__lavu__frame_1ga3ba755bada5c3c8883361ef43fb5fb7a",
          "@_kindref": "member"
         },
         {
          "#text": "av_buffer_is_writable()",
          "@_refid": "group__lavu__buffer_1ga060be34ace567ae378fd0a786e847053",
          "@_kindref": "member"
         },
         {
          "#text": "av_buffer_make_writable()",
          "@_refid": "group__lavu__buffer_1ga9c2a1be1b7bb80eec8613fdb62a19074",
          "@_kindref": "member"
         }
        ],
        "#text": ",,"
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "879",
   "@_column": "5",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "879",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "get_video_frame",
    "@_refid": "mux_8c_1a21ef8534b79178d738919f5b1b14c37f",
    "@_compoundref": "mux_8c",
    "@_startline": "470",
    "@_endline": "510"
   },
   {
    "#text": "main",
    "@_refid": "encode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "encode__audio_8c",
    "@_startline": "122",
    "@_endline": "240"
   },
   {
    "#text": "write_audio_frame",
    "@_refid": "mux_8c_1a789f35413429ab70610c90c22fc7a4d3",
    "@_compoundref": "mux_8c",
    "@_startline": "336",
    "@_endline": "376"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__frame_1gadd5417c06f5a6b419b0dbd8f0ff363fd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Ensure that the frame data is writable, avoiding data copy if possible.\n *\n * Do nothing if the frame is writable, allocate new buffers and copy the data\n * if it is not. Non-refcounted frames behave as non-writable, i.e. a copy\n * is always made.\n *\n * @return 0 on success, a negative AVERROR on error.\n *\n * @see av_frame_is_writable(), av_buffer_is_writable(),\n * av_buffer_make_writable()\n */"
 },
 "av_frame_copy": {
  "type": "int",
  "definition": "int av_frame_copy",
  "argsstring": "(AVFrame *dst, const AVFrame *src)",
  "name": "av_frame_copy",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Copy the frame data from src to dst."
  },
  "detaileddescription": {
   "para": [
    "This function does not allocate anything, dst must be already initialized and allocated with the same parameters as src.",
    "This function only copies the frame data (i.e. the contents of the data / extended data arrays), not any other properties.",
    {
     "simplesect": {
      "para": ">= 0 on success, a negative AVERROR on error.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "892",
   "@_column": "5",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "892",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1gaec4e92f6e1e75ffaf76e07586fb0c9ed",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy the frame data from src to dst.\n *\n * This function does not allocate anything, dst must be already initialized and\n * allocated with the same parameters as src.\n *\n * This function only copies the frame data (i.e. the contents of the data /\n * extended data arrays), not any other properties.\n *\n * @return >= 0 on success, a negative AVERROR on error.\n */"
 },
 "av_frame_copy_props": {
  "type": "int",
  "definition": "int av_frame_copy_props",
  "argsstring": "(AVFrame *dst, const AVFrame *src)",
  "name": "av_frame_copy_props",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Copy only \"metadata\" fields from src to dst."
  },
  "detaileddescription": {
   "para": "Metadata for the purpose of this function are those fields that do not affect the data layout in the buffers. E.g. pts, sample rate (for audio) or sample aspect ratio (for video), but not width/height or channel layout. Side data is also copied."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "902",
   "@_column": "5",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "902",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1gab9b275b114ace0db95c5796bc71f3012",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy only \"metadata\" fields from src to dst.\n *\n * Metadata for the purpose of this function are those fields that do not affect\n * the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample\n * aspect ratio (for video), but not width/height or channel layout.\n * Side data is also copied.\n */"
 },
 "av_frame_get_plane_buffer": {
  "type": {
   "ref": {
    "#text": "AVBufferRef",
    "@_refid": "structAVBufferRef",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVBufferRef * av_frame_get_plane_buffer",
  "argsstring": "(const AVFrame *frame, int plane)",
  "name": "av_frame_get_plane_buffer",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "frame"
   },
   {
    "type": "int",
    "declname": "plane"
   }
  ],
  "briefdescription": {
   "para": "Get the buffer reference a given data plane is stored in."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": "the frame to get the plane's buffer from"
       }
      },
      {
       "parameternamelist": {
        "parametername": "plane"
       },
       "parameterdescription": {
        "para": "index of the data plane of interest in frame->extended_data."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the buffer reference that contains the plane or NULL if the input frame is not valid.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "913",
   "@_column": "13",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "913",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1gaffbf089810dcaeebc6455144dab84567",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the buffer reference a given data plane is stored in.\n *\n * @param frame the frame to get the plane's buffer from\n * @param plane index of the data plane of interest in frame->extended_data.\n *\n * @return the buffer reference that contains the plane or NULL if the input\n * frame is not valid.\n */"
 },
 "av_frame_new_side_data": {
  "type": {
   "ref": {
    "#text": "AVFrameSideData",
    "@_refid": "structAVFrameSideData",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFrameSideData * av_frame_new_side_data",
  "argsstring": "(AVFrame *frame, enum AVFrameSideDataType type, size_t size)",
  "name": "av_frame_new_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideDataType",
      "@_refid": "group__lavu__frame_1gae01fa7e427274293aacdf2adc17076bc",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Add a new side data to a frame."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": "a frame to which the side data should be added"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "type of the added side data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "size of the side data"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "newly added side data on success, NULL on error",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "924",
   "@_column": "17",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "924",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga9e0cf2909ab6d787845ab6326cd3fb10",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a new side data to a frame.\n *\n * @param frame a frame to which the side data should be added\n * @param type type of the added side data\n * @param size size of the side data\n *\n * @return newly added side data on success, NULL on error\n */"
 },
 "av_frame_new_side_data_from_buf": {
  "type": {
   "ref": {
    "#text": "AVFrameSideData",
    "@_refid": "structAVFrameSideData",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFrameSideData * av_frame_new_side_data_from_buf",
  "argsstring": "(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)",
  "name": "av_frame_new_side_data_from_buf",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideDataType",
      "@_refid": "group__lavu__frame_1gae01fa7e427274293aacdf2adc17076bc",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "buf"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "Add a new side data to a frame from an existing."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": "a frame to which the side data should be added"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "the type of the added side data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVBufferRef",
          "@_refid": "structAVBufferRef",
          "@_kindref": "compound"
         },
         "#text": "anto add as side data. The ownership of the reference is transferred to the frame."
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVBufferRef",
       "@_refid": "structAVBufferRef",
       "@_kindref": "compound"
      },
      "#text": "newly added side data on success, NULL on error. On failure the frame is unchanged and theremains owned by the caller."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "940",
   "@_column": "17",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "940",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1gab2aafcdaafcb1d3e7ce2d0d6f733546a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a new side data to a frame from an existing AVBufferRef\n *\n * @param frame a frame to which the side data should be added\n * @param type  the type of the added side data\n * @param buf   an AVBufferRef to add as side data. The ownership of\n *              the reference is transferred to the frame.\n *\n * @return newly added side data on success, NULL on error. On failure\n *         the frame is unchanged and the AVBufferRef remains owned by\n *         the caller.\n */"
 },
 "av_frame_get_side_data": {
  "type": {
   "ref": {
    "#text": "AVFrameSideData",
    "@_refid": "structAVFrameSideData",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFrameSideData * av_frame_get_side_data",
  "argsstring": "(const AVFrame *frame, enum AVFrameSideDataType type)",
  "name": "av_frame_get_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "frame"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideDataType",
      "@_refid": "group__lavu__frame_1gae01fa7e427274293aacdf2adc17076bc",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   }
  ],
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "a pointer to the side data of a given type on success, NULL if there is no side data with such type in this frame.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "948",
   "@_column": "17",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "948",
   "@_declcolumn": "17"
  },
  "referencedby": {
   "#text": "decode_packet",
   "@_refid": "extract__mvs_8c_1a3740a789b55da53dea5861e772d684a3",
   "@_compoundref": "extract__mvs_8c",
   "@_startline": "45",
   "@_endline": "84"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga0e3085c5a7aa8e8867ec6322983d3bc7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return a pointer to the side data of a given type on success, NULL if there\n * is no side data with such type in this frame.\n */"
 },
 "av_frame_remove_side_data": {
  "type": "void",
  "definition": "void av_frame_remove_side_data",
  "argsstring": "(AVFrame *frame, enum AVFrameSideDataType type)",
  "name": "av_frame_remove_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideDataType",
      "@_refid": "group__lavu__frame_1gae01fa7e427274293aacdf2adc17076bc",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   }
  ],
  "briefdescription": {
   "para": "Remove and free all side data instances of the given type."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "954",
   "@_column": "6",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "954",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga132d6c01d0a21e5b48b96cd7c988de91",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Remove and free all side data instances of the given type.\n */"
 },
 "av_frame_apply_cropping": {
  "type": "int",
  "definition": "int av_frame_apply_cropping",
  "argsstring": "(AVFrame *frame, int flags)",
  "name": "av_frame_apply_cropping",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "Crop the given videoaccording to its crop_left/crop_top/crop_right/ crop_bottom fields."
   }
  },
  "detaileddescription": {
   "para": [
    "If cropping is successful, the function will adjust the data pointers and the width/height fields, and set the crop fields to 0.",
    "In all cases, the cropping boundaries will be rounded to the inherent alignment of the pixel format. In some cases, such as for opaque hwaccel formats, the left/top cropping is ignored. The crop fields are set to 0 even if the cropping was rounded or ignored.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "frame"
        },
        "parameterdescription": {
         "para": "the frame which should be cropped"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "Some combination of AV_FRAME_CROP_* flags, or 0."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVERROR(ERANGE)",
        "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
        "@_kindref": "member"
       },
       "#text": ">= 0 on success, a negative AVERROR on error. If the cropping fields were invalid,is returned, and nothing is changed."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "988",
   "@_column": "5",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "988",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1gaea6d378ff15d984d4eb67b462b7d70b5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Crop the given video AVFrame according to its crop_left/crop_top/crop_right/\n * crop_bottom fields. If cropping is successful, the function will adjust the\n * data pointers and the width/height fields, and set the crop fields to 0.\n *\n * In all cases, the cropping boundaries will be rounded to the inherent\n * alignment of the pixel format. In some cases, such as for opaque hwaccel\n * formats, the left/top cropping is ignored. The crop fields are set to 0 even\n * if the cropping was rounded or ignored.\n *\n * @param frame the frame which should be cropped\n * @param flags Some combination of AV_FRAME_CROP_* flags, or 0.\n *\n * @return >= 0 on success, a negative AVERROR on error. If the cropping fields\n * were invalid, AVERROR(ERANGE) is returned, and nothing is changed.\n */"
 },
 "av_frame_side_data_name": {
  "type": "const char *",
  "definition": "const char * av_frame_side_data_name",
  "argsstring": "(enum AVFrameSideDataType type)",
  "name": "av_frame_side_data_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrameSideDataType",
     "@_refid": "group__lavu__frame_1gae01fa7e427274293aacdf2adc17076bc",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "type"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "a string identifying the side data type",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "993",
   "@_column": "12",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "993",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1gaff674f7f4b25bdacf32fc8f3174138ab",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return a string identifying the side data type\n */"
 },
 "av_frame_side_data_free": {
  "type": "void",
  "definition": "void av_frame_side_data_free",
  "argsstring": "(AVFrameSideData ***sd, int *nb_sd)",
  "name": "av_frame_side_data_free",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideData",
      "@_refid": "structAVFrameSideData",
      "@_kindref": "compound"
     },
     "#text": "***"
    },
    "declname": "sd"
   },
   {
    "type": "int *",
    "declname": "nb_sd"
   }
  ],
  "briefdescription": {
   "para": "Free all side data entries and their contents, then zeroes out the values which the pointers are pointing to."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "sd"
       },
       "parameterdescription": {
        "para": "pointer to array of side data to free. Will be set to NULL upon return."
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_sd"
       },
       "parameterdescription": {
        "para": "pointer to an integer containing the number of entries in the array. Will be set to 0 upon return."
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "1004",
   "@_column": "6",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "1004",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga286128e06e77eb1525859970bccc0bba",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free all side data entries and their contents, then zeroes out the\n * values which the pointers are pointing to.\n *\n * @param sd    pointer to array of side data to free. Will be set to NULL\n *              upon return.\n * @param nb_sd pointer to an integer containing the number of entries in\n *              the array. Will be set to 0 upon return.\n */"
 },
 "av_frame_side_data_new": {
  "type": {
   "ref": {
    "#text": "AVFrameSideData",
    "@_refid": "structAVFrameSideData",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVFrameSideData * av_frame_side_data_new",
  "argsstring": "(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)",
  "name": "av_frame_side_data_new",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideData",
      "@_refid": "structAVFrameSideData",
      "@_kindref": "compound"
     },
     "#text": "***"
    },
    "declname": "sd"
   },
   {
    "type": "int *",
    "declname": "nb_sd"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideDataType",
      "@_refid": "group__lavu__frame_1gae01fa7e427274293aacdf2adc17076bc",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "size_t",
    "declname": "size"
   },
   {
    "type": "unsigned int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Add new side data entry to an array."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "sd"
       },
       "parameterdescription": {
        "para": "pointer to array of side data to which to add another entry, or to NULL in order to start a new array."
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_sd"
       },
       "parameterdescription": {
        "para": "pointer to an integer containing the number of entries in the array."
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "type of the added side data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "size of the side data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "newly added side data on success, NULL on error. In case of AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of matching AVFrameSideDataType will be removed before the addition is attempted.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "1024",
   "@_column": "17",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "1024",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga0b06737fb259ca0ba295c4307c470601",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add new side data entry to an array.\n *\n * @param sd    pointer to array of side data to which to add another entry,\n *              or to NULL in order to start a new array.\n * @param nb_sd pointer to an integer containing the number of entries in\n *              the array.\n * @param type  type of the added side data\n * @param size  size of the side data\n * @param flags Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0.\n *\n * @return newly added side data on success, NULL on error. In case of\n *         AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of matching\n *         AVFrameSideDataType will be removed before the addition is\n *         attempted.\n */"
 },
 "av_frame_side_data_clone": {
  "type": "int",
  "definition": "int av_frame_side_data_clone",
  "argsstring": "(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)",
  "name": "av_frame_side_data_clone",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideData",
      "@_refid": "structAVFrameSideData",
      "@_kindref": "compound"
     },
     "#text": "***"
    },
    "declname": "sd"
   },
   {
    "type": "int *",
    "declname": "nb_sd"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideData",
      "@_refid": "structAVFrameSideData",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   },
   {
    "type": "unsigned int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "Add a new side data entry to an array based on existing side data, taking a reference towards the contained."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "sd"
       },
       "parameterdescription": {
        "para": "pointer to array of side data to which to add another entry, or to NULL in order to start a new array."
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_sd"
       },
       "parameterdescription": {
        "para": "pointer to an integer containing the number of entries in the array."
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "side data to be cloned, with a new reference utilized for the buffer."
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "negative error code on failure, >=0 on success. In case of AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of matching AVFrameSideDataType will be removed before the addition is attempted.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "1045",
   "@_column": "5",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "1045",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1gada6f618b4b43c51d5816dbe0d0acf0df",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a new side data entry to an array based on existing side data, taking\n * a reference towards the contained AVBufferRef.\n *\n * @param sd    pointer to array of side data to which to add another entry,\n *              or to NULL in order to start a new array.\n * @param nb_sd pointer to an integer containing the number of entries in\n *              the array.\n * @param src   side data to be cloned, with a new reference utilized\n *              for the buffer.\n * @param flags Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0.\n *\n * @return negative error code on failure, >=0 on success. In case of\n *         AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of matching\n *         AVFrameSideDataType will be removed before the addition is\n *         attempted.\n */"
 },
 "av_frame_side_data_get_c": {
  "type": {
   "ref": {
    "#text": "AVFrameSideData",
    "@_refid": "structAVFrameSideData",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVFrameSideData * av_frame_side_data_get_c",
  "argsstring": "(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)",
  "name": "av_frame_side_data_get_c",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideData",
      "@_refid": "structAVFrameSideData",
      "@_kindref": "compound"
     },
     "#text": "const*const *"
    },
    "declname": "sd"
   },
   {
    "type": "const int",
    "declname": "nb_sd"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideDataType",
      "@_refid": "group__lavu__frame_1gae01fa7e427274293aacdf2adc17076bc",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   }
  ],
  "briefdescription": {
   "para": "Get a side data entry of a specific type from an array."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "sd"
       },
       "parameterdescription": {
        "para": "array of side data."
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_sd"
       },
       "parameterdescription": {
        "para": "integer containing the number of entries in the array."
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "type of side data to be queried"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "a pointer to the side data of a given type on success, NULL if there is no side data with such type in this set.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "1058",
   "@_column": "23",
   "@_declfile": "libavutil/frame.h",
   "@_declline": "1058",
   "@_declcolumn": "23"
  },
  "referencedby": {
   "#text": "av_frame_side_data_get",
   "@_refid": "group__lavu__frame_1gafca60a503a1c0fa125e0bf6a89230ed0",
   "@_compoundref": "frame_8h",
   "@_startline": "1069",
   "@_endline": "1075"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1ga9eac042c6e899ad7377a2b2ec4ee0624",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a side data entry of a specific type from an array.\n *\n * @param sd    array of side data.\n * @param nb_sd integer containing the number of entries in the array.\n * @param type  type of side data to be queried\n *\n * @return a pointer to the side data of a given type on success, NULL if there\n *         is no side data with such type in this set.\n */"
 },
 "av_frame_side_data_get": {
  "type": {
   "ref": {
    "#text": "AVFrameSideData",
    "@_refid": "structAVFrameSideData",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "static const AVFrameSideData * av_frame_side_data_get",
  "argsstring": "(AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)",
  "name": "av_frame_side_data_get",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideData",
      "@_refid": "structAVFrameSideData",
      "@_kindref": "compound"
     },
     "#text": "*const *"
    },
    "declname": "sd"
   },
   {
    "type": "const int",
    "declname": "nb_sd"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrameSideDataType",
      "@_refid": "group__lavu__frame_1gae01fa7e427274293aacdf2adc17076bc",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_frame_side_data_get_c()",
     "@_refid": "group__lavu__frame_1ga9eac042c6e899ad7377a2b2ec4ee0624",
     "@_kindref": "member"
    },
    "#text": "Wrapper aroundto workaround the limitation that for any type T the conversion from T * const * to const T * const * is not performed automatically in C."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "av_frame_side_data_get_c()",
       "@_refid": "group__lavu__frame_1ga9eac042c6e899ad7377a2b2ec4ee0624",
       "@_kindref": "member"
      }
     },
     "@_kind": "see"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/frame.h",
   "@_line": "1069",
   "@_column": "23",
   "@_bodyfile": "libavutil/frame.h",
   "@_bodystart": "1069",
   "@_bodyend": "1075"
  },
  "@_kind": "function",
  "@_id": "group__lavu__frame_1gafca60a503a1c0fa125e0bf6a89230ed0",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Wrapper around av_frame_side_data_get_c() to workaround the limitation\n * that for any type T the conversion from T * const * to const T * const *\n * is not performed automatically in C.\n * @see av_frame_side_data_get_c()\n */"
 },
 "av_gcd": {
  "type": {
   "ref": {
    "#text": "av_const",
    "@_refid": "attributes_8h_1a9eaead3cde73464fd66bab4cef9307ad",
    "@_kindref": "member"
   },
   "#text": "int64_t"
  },
  "definition": "int64_t av_const av_gcd",
  "argsstring": "(int64_t a, int64_t b)",
  "name": "av_gcd",
  "param": [
   {
    "type": "int64_t",
    "declname": "a"
   },
   {
    "type": "int64_t",
    "declname": "b"
   }
  ],
  "briefdescription": {
   "para": "Compute the greatest common divisor of two integer operands."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "Operand"
       }
      },
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "Operand"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0; if a == 0 and b == 0, returns 0.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mathematics.h",
   "@_line": "170",
   "@_column": "18",
   "@_declfile": "libavutil/mathematics.h",
   "@_declline": "170",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math_1ga952147c7a40c48a05c39e918b153ba99",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Compute the greatest common divisor of two integer operands.\n *\n * @param a Operand\n * @param b Operand\n * @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;\n * if a == 0 and b == 0, returns 0.\n */"
 },
 "av_rescale": {
  "type": "int64_t",
  "definition": "int64_t av_rescale",
  "argsstring": "(int64_t a, int64_t b, int64_t c) av_const",
  "name": "av_rescale",
  "param": [
   {
    "type": "int64_t",
    "declname": "a"
   },
   {
    "type": "int64_t",
    "declname": "b"
   },
   {
    "type": "int64_t",
    "declname": "c"
   }
  ],
  "briefdescription": {
   "para": "Rescale a 64-bit integer with rounding to nearest."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": "a * b / c",
     "#text": "The operation is mathematically equivalent to, but writing that directly can overflow."
    },
    {
     "ref": [
      {
       "#text": "av_rescale_rnd()",
       "@_refid": "group__lavu__math_1ga82d40664213508918093822461cc597e",
       "@_kindref": "member"
      },
      {
       "#text": "AV_ROUND_NEAR_INF",
       "@_refid": "group__lavu__math_1gga921d656eaf2c4d6800a734a13af021d0aea95b00154ff83c740b46376dfa06e11",
       "@_kindref": "member"
      }
     ],
     "#text": "This function is equivalent towith."
    },
    {
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "av_rescale_rnd()",
         "@_refid": "group__lavu__math_1ga82d40664213508918093822461cc597e",
         "@_kindref": "member"
        },
        {
         "#text": "av_rescale_q()",
         "@_refid": "group__lavu__math_1gaf02994a8bbeaa91d4757df179cbe567f",
         "@_kindref": "member"
        },
        {
         "#text": "av_rescale_q_rnd()",
         "@_refid": "group__lavu__math_1gab706bfec9bf56534e02ca9564cb968f6",
         "@_kindref": "member"
        }
       ],
       "#text": ",,"
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mathematics.h",
   "@_line": "182",
   "@_column": "9",
   "@_declfile": "libavutil/mathematics.h",
   "@_declline": "182",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math_1ga3daf97178dd1b08b5e916be381cd33e4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Rescale a 64-bit integer with rounding to nearest.\n *\n * The operation is mathematically equivalent to `a * b / c`, but writing that\n * directly can overflow.\n *\n * This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.\n *\n * @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()\n */"
 },
 "av_rescale_rnd": {
  "type": "int64_t",
  "definition": "int64_t av_rescale_rnd",
  "argsstring": "(int64_t a, int64_t b, int64_t c, enum AVRounding rnd) av_const",
  "name": "av_rescale_rnd",
  "param": [
   {
    "type": "int64_t",
    "declname": "a"
   },
   {
    "type": "int64_t",
    "declname": "b"
   },
   {
    "type": "int64_t",
    "declname": "c"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRounding",
      "@_refid": "group__lavu__math_1ga921d656eaf2c4d6800a734a13af021d0",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "rnd"
   }
  ],
  "briefdescription": {
   "para": "Rescale a 64-bit integer with specified rounding."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": "a * b / c",
     "#text": "The operation is mathematically equivalent to, but writing that directly can overflow, and does not support different rounding methods. If the result is not representable then INT64_MIN is returned."
    },
    {
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "av_rescale()",
         "@_refid": "group__lavu__math_1ga3daf97178dd1b08b5e916be381cd33e4",
         "@_kindref": "member"
        },
        {
         "#text": "av_rescale_q()",
         "@_refid": "group__lavu__math_1gaf02994a8bbeaa91d4757df179cbe567f",
         "@_kindref": "member"
        },
        {
         "#text": "av_rescale_q_rnd()",
         "@_refid": "group__lavu__math_1gab706bfec9bf56534e02ca9564cb968f6",
         "@_kindref": "member"
        }
       ],
       "#text": ",,"
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mathematics.h",
   "@_line": "193",
   "@_column": "9",
   "@_declfile": "libavutil/mathematics.h",
   "@_declline": "193",
   "@_declcolumn": "9"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "resample__audio_8c",
   "@_startline": "85",
   "@_endline": "220"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math_1ga82d40664213508918093822461cc597e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Rescale a 64-bit integer with specified rounding.\n *\n * The operation is mathematically equivalent to `a * b / c`, but writing that\n * directly can overflow, and does not support different rounding methods.\n * If the result is not representable then INT64_MIN is returned.\n *\n * @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()\n */"
 },
 "av_rescale_q": {
  "type": "int64_t",
  "definition": "int64_t av_rescale_q",
  "argsstring": "(int64_t a, AVRational bq, AVRational cq) av_const",
  "name": "av_rescale_q",
  "param": [
   {
    "type": "int64_t",
    "declname": "a"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "bq"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "cq"
   }
  ],
  "briefdescription": {
   "para": "Rescale a 64-bit integer by 2 rational numbers."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": "a * bq / cq",
     "#text": "The operation is mathematically equivalent to."
    },
    {
     "ref": [
      {
       "#text": "av_rescale_q_rnd()",
       "@_refid": "group__lavu__math_1gab706bfec9bf56534e02ca9564cb968f6",
       "@_kindref": "member"
      },
      {
       "#text": "AV_ROUND_NEAR_INF",
       "@_refid": "group__lavu__math_1gga921d656eaf2c4d6800a734a13af021d0aea95b00154ff83c740b46376dfa06e11",
       "@_kindref": "member"
      }
     ],
     "#text": "This function is equivalent towith."
    },
    {
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "av_rescale()",
         "@_refid": "group__lavu__math_1ga3daf97178dd1b08b5e916be381cd33e4",
         "@_kindref": "member"
        },
        {
         "#text": "av_rescale_rnd()",
         "@_refid": "group__lavu__math_1ga82d40664213508918093822461cc597e",
         "@_kindref": "member"
        },
        {
         "#text": "av_rescale_q_rnd()",
         "@_refid": "group__lavu__math_1gab706bfec9bf56534e02ca9564cb968f6",
         "@_kindref": "member"
        }
       ],
       "#text": ",,"
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mathematics.h",
   "@_line": "204",
   "@_column": "9",
   "@_declfile": "libavutil/mathematics.h",
   "@_declline": "204",
   "@_declcolumn": "9"
  },
  "referencedby": [
   {
    "#text": "display_frame",
    "@_refid": "decode__filter__video_8c_1a87e98983e21f6a1e2056fd8ea0407ff4",
    "@_compoundref": "decode__filter__video_8c",
    "@_startline": "179",
    "@_endline": "208"
   },
   {
    "#text": "encode_write_frame",
    "@_refid": "transcode_8c_1a0911d751b11fdf9780825b79badfae91",
    "@_compoundref": "transcode_8c",
    "@_startline": "432",
    "@_endline": "471"
   },
   {
    "#text": "write_audio_frame",
    "@_refid": "mux_8c_1a789f35413429ab70610c90c22fc7a4d3",
    "@_compoundref": "mux_8c",
    "@_startline": "336",
    "@_endline": "376"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__math_1gaf02994a8bbeaa91d4757df179cbe567f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Rescale a 64-bit integer by 2 rational numbers.\n *\n * The operation is mathematically equivalent to `a * bq / cq`.\n *\n * This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.\n *\n * @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()\n */"
 },
 "av_rescale_q_rnd": {
  "type": "int64_t",
  "definition": "int64_t av_rescale_q_rnd",
  "argsstring": "(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd) av_const",
  "name": "av_rescale_q_rnd",
  "param": [
   {
    "type": "int64_t",
    "declname": "a"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "bq"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "cq"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRounding",
      "@_refid": "group__lavu__math_1ga921d656eaf2c4d6800a734a13af021d0",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "rnd"
   }
  ],
  "briefdescription": {
   "para": "Rescale a 64-bit integer by 2 rational numbers with specified rounding."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": "a * bq / cq",
     "#text": "The operation is mathematically equivalent to."
    },
    {
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "av_rescale()",
         "@_refid": "group__lavu__math_1ga3daf97178dd1b08b5e916be381cd33e4",
         "@_kindref": "member"
        },
        {
         "#text": "av_rescale_rnd()",
         "@_refid": "group__lavu__math_1ga82d40664213508918093822461cc597e",
         "@_kindref": "member"
        },
        {
         "#text": "av_rescale_q()",
         "@_refid": "group__lavu__math_1gaf02994a8bbeaa91d4757df179cbe567f",
         "@_kindref": "member"
        }
       ],
       "#text": ",,"
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mathematics.h",
   "@_line": "213",
   "@_column": "9",
   "@_declfile": "libavutil/mathematics.h",
   "@_declline": "213",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math_1gab706bfec9bf56534e02ca9564cb968f6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Rescale a 64-bit integer by 2 rational numbers with specified rounding.\n *\n * The operation is mathematically equivalent to `a * bq / cq`.\n *\n * @see av_rescale(), av_rescale_rnd(), av_rescale_q()\n */"
 },
 "av_compare_ts": {
  "type": "int",
  "definition": "int av_compare_ts",
  "argsstring": "(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)",
  "name": "av_compare_ts",
  "param": [
   {
    "type": "int64_t",
    "declname": "ts_a"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "tb_a"
   },
   {
    "type": "int64_t",
    "declname": "ts_b"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "tb_b"
   }
  ],
  "briefdescription": {
   "para": "Compare two timestamps each in its own time base."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "itemizedlist": {
        "listitem": [
         {
          "para": {
           "computeroutput": [
            "ts_a",
            "ts_b"
           ],
           "#text": "-1 ifis before"
          }
         },
         {
          "para": {
           "computeroutput": [
            "ts_a",
            "ts_b"
           ],
           "#text": "1 ifis after"
          }
         },
         {
          "para": "0 if they represent the same position"
         }
        ]
       },
       "#text": "One of the following values:"
      },
      "@_kind": "return"
     },
     {
      "para": {
       "computeroutput": "int64_t",
       "#text": "The result of the function is undefined if one of the timestamps is outside therange when represented in the other's timebase."
      },
      "@_kind": "warning"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mathematics.h",
   "@_line": "228",
   "@_column": "5",
   "@_declfile": "libavutil/mathematics.h",
   "@_declline": "228",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "get_audio_frame",
    "@_refid": "mux_8c_1ab69ba368d3500fd5e1a5d22c82bd933a",
    "@_compoundref": "mux_8c",
    "@_startline": "307",
    "@_endline": "330"
   },
   {
    "#text": "get_video_frame",
    "@_refid": "mux_8c_1a21ef8534b79178d738919f5b1b14c37f",
    "@_compoundref": "mux_8c",
    "@_startline": "470",
    "@_endline": "510"
   },
   {
    "#text": "main",
    "@_refid": "mux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "mux_8c",
    "@_startline": "534",
    "@_endline": "643"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__math_1ga151744358fff630942b926e67e67c415",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Compare two timestamps each in its own time base.\n *\n * @return One of the following values:\n *         - -1 if `ts_a` is before `ts_b`\n *         - 1 if `ts_a` is after `ts_b`\n *         - 0 if they represent the same position\n *\n * @warning\n * The result of the function is undefined if one of the timestamps is outside\n * the `int64_t` range when represented in the other's timebase.\n */"
 },
 "av_compare_mod": {
  "type": "int64_t",
  "definition": "int64_t av_compare_mod",
  "argsstring": "(uint64_t a, uint64_t b, uint64_t mod)",
  "name": "av_compare_mod",
  "param": [
   {
    "type": "uint64_t",
    "declname": "a"
   },
   {
    "type": "uint64_t",
    "declname": "b"
   },
   {
    "type": "uint64_t",
    "declname": "mod"
   }
  ],
  "briefdescription": {
   "para": "Compare the remainders of two integer operands divided by a common divisor."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": [
      "log2(mod)",
      "a",
      "b"
     ],
     "#text": "In other words, compare the least significantbits of integersand."
    },
    {
     "programlisting": {
      "codeline": [
       {
        "highlight": [
         {
          "ref": {
           "#text": "av_compare_mod",
           "@_refid": "group__lavu__math_1gaf268a1dde957d04da846e026e2ebe6e8",
           "@_kindref": "member"
          },
          "sp": [
           "",
           "",
           "",
           "",
           ""
          ],
          "#text": "(0x11,0x02,0x10)<0",
          "@_class": "normal"
         },
         {
          "sp": [
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           ""
          ],
          "#text": "//since17%16(0x1)<2%16(0x2)",
          "@_class": "comment"
         },
         {
          "@_class": "normal"
         }
        ]
       },
       {
        "highlight": [
         {
          "ref": {
           "#text": "av_compare_mod",
           "@_refid": "group__lavu__math_1gaf268a1dde957d04da846e026e2ebe6e8",
           "@_kindref": "member"
          },
          "sp": [
           "",
           "",
           "",
           "",
           ""
          ],
          "#text": "(0x11,0x02,0x20)>0",
          "@_class": "normal"
         },
         {
          "sp": [
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           ""
          ],
          "#text": "//since17%32(0x11)>2%32(0x02)",
          "@_class": "comment"
         }
        ]
       }
      ],
      "@_filename": ".c"
     }
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "a"
        },
        "parameterdescription": {
         "para": "Operand"
        }
       },
       {
        "parameternamelist": {
         "parametername": "b"
        },
        "parameterdescription": {
         "para": "Operand"
        }
       },
       {
        "parameternamelist": {
         "parametername": "mod"
        },
        "parameterdescription": {
         "para": "Divisor; must be a power of 2"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "itemizedlist": {
        "listitem": [
         {
          "para": {
           "computeroutput": "a % mod < b % mod",
           "#text": "a negative value if"
          }
         },
         {
          "para": {
           "computeroutput": "a % mod > b % mod",
           "#text": "a positive value if"
          }
         },
         {
          "para": {
           "computeroutput": "a % mod == b % mod",
           "#text": "zero if"
          }
         }
        ]
       }
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mathematics.h",
   "@_line": "249",
   "@_column": "9",
   "@_declfile": "libavutil/mathematics.h",
   "@_declline": "249",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math_1gaf268a1dde957d04da846e026e2ebe6e8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Compare the remainders of two integer operands divided by a common divisor.\n *\n * In other words, compare the least significant `log2(mod)` bits of integers\n * `a` and `b`.\n *\n * @code{.c}\n * av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)\n * av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)\n * @endcode\n *\n * @param a Operand\n * @param b Operand\n * @param mod Divisor; must be a power of 2\n * @return\n *         - a negative value if `a % mod < b % mod`\n *         - a positive value if `a % mod > b % mod`\n *         - zero             if `a % mod == b % mod`\n */"
 },
 "av_rescale_delta": {
  "type": "int64_t",
  "definition": "int64_t av_rescale_delta",
  "argsstring": "(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)",
  "name": "av_rescale_delta",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "in_tb"
   },
   {
    "type": "int64_t",
    "declname": "in_ts"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "fs_tb"
   },
   {
    "type": "int",
    "declname": "duration"
   },
   {
    "type": "int64_t *",
    "declname": "last"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "out_tb"
   }
  ],
  "briefdescription": {
   "para": "Rescale a timestamp while preserving known durations."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_rescale_q()",
      "@_refid": "group__lavu__math_1gaf02994a8bbeaa91d4757df179cbe567f",
      "@_kindref": "member"
     },
     "#text": "This function is designed to be called per audio packet to scale the input timestamp to a different time base. Compared to a simplecall, this function is robust against possible inconsistent frame durations."
    },
    {
     "computeroutput": [
      "last",
      "*last"
     ],
     "ref": {
      "#text": "AV_NOPTS_VALUE",
      "@_refid": "group__lavu__time_1ga2eaefe702f95f619ea6f2d08afa01be1",
      "@_kindref": "member"
     },
     "#text": "Theparameter is a state variable that must be preserved for all subsequent calls for the same stream. For the first call,should be initialized to."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "in_tb",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Input time base"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "in_ts",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Input timestamp"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "fs_tb",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": [
           "in_tb",
           "out_tb"
          ],
          "#text": "Duration time base; typically this is finer-grained (greater) thanand"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "duration",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Duration till the next call to this function (i.e. duration of the current packet/frame)"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "last",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "fs_tb",
          "#text": "Pointer to a timestamp expressed in terms of, acting as a state variable"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "out_tb",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Output timebase"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "computeroutput": "out_tb",
        "#text": "Timestamp expressed in terms of"
       },
       "@_kind": "return"
      },
      {
       "para": "In the context of this function, \"duration\" is in term of samples, not seconds.",
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mathematics.h",
   "@_line": "276",
   "@_column": "9",
   "@_declfile": "libavutil/mathematics.h",
   "@_declline": "276",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math_1ga29b7c3d60d68ef678ee1f4adc61a25dc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Rescale a timestamp while preserving known durations.\n *\n * This function is designed to be called per audio packet to scale the input\n * timestamp to a different time base. Compared to a simple av_rescale_q()\n * call, this function is robust against possible inconsistent frame durations.\n *\n * The `last` parameter is a state variable that must be preserved for all\n * subsequent calls for the same stream. For the first call, `*last` should be\n * initialized to #AV_NOPTS_VALUE.\n *\n * @param[in]     in_tb    Input time base\n * @param[in]     in_ts    Input timestamp\n * @param[in]     fs_tb    Duration time base; typically this is finer-grained\n *                         (greater) than `in_tb` and `out_tb`\n * @param[in]     duration Duration till the next call to this function (i.e.\n *                         duration of the current packet/frame)\n * @param[in,out] last     Pointer to a timestamp expressed in terms of\n *                         `fs_tb`, acting as a state variable\n * @param[in]     out_tb   Output timebase\n * @return        Timestamp expressed in terms of `out_tb`\n *\n * @note In the context of this function, \"duration\" is in term of samples, not\n *       seconds.\n */"
 },
 "av_add_stable": {
  "type": "int64_t",
  "definition": "int64_t av_add_stable",
  "argsstring": "(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)",
  "name": "av_add_stable",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "ts_tb"
   },
   {
    "type": "int64_t",
    "declname": "ts"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "inc_tb"
   },
   {
    "type": "int64_t",
    "declname": "inc"
   }
  ],
  "briefdescription": {
   "para": "Add a value to a timestamp."
  },
  "detaileddescription": {
   "para": [
    "This function guarantees that when the same value is repeatly added that no accumulation of rounding errors occurs.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ts",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Input timestamp"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ts_tb",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Input timestamp time base"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "inc",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Value to be added"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "inc_tb",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "inc",
          "#text": "Time base of"
         }
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mathematics.h",
   "@_line": "289",
   "@_column": "9",
   "@_declfile": "libavutil/mathematics.h",
   "@_declline": "289",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math_1ga0c4f9ed3f4102125be7451ad4d848a2f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add a value to a timestamp.\n *\n * This function guarantees that when the same value is repeatly added that\n * no accumulation of rounding errors occurs.\n *\n * @param[in] ts     Input timestamp\n * @param[in] ts_tb  Input timestamp time base\n * @param[in] inc    Value to be added\n * @param[in] inc_tb Time base of `inc`\n */"
 },
 "av_bessel_i0": {
  "type": "double",
  "definition": "double av_bessel_i0",
  "argsstring": "(double x)",
  "name": "av_bessel_i0",
  "param": {
   "type": "double",
   "declname": "x"
  },
  "briefdescription": {
   "para": "0th order modified bessel function of the first kind."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mathematics.h",
   "@_line": "294",
   "@_column": "8",
   "@_declfile": "libavutil/mathematics.h",
   "@_declline": "294",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math_1gac6df8ff9fa00f5daf9f16cc46038f064",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * 0th order modified bessel function of the first kind.\n */"
 },
 "av_twofish_size": {
  "type": "const int",
  "definition": "const int av_twofish_size",
  "argsstring": "",
  "name": "av_twofish_size",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/twofish.h",
   "@_line": "36",
   "@_column": "18",
   "@_declfile": "libavutil/twofish.h",
   "@_declline": "36",
   "@_declcolumn": "18"
  },
  "@_kind": "variable",
  "@_id": "group__lavu__twofish_1gaa3974c485c936db768316fb77e26b7c5",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n  * @file\n  * @brief Public header for libavutil TWOFISH algorithm\n  * @defgroup lavu_twofish TWOFISH\n  * @ingroup lavu_crypto\n  * @{\n  */"
 },
 "av_twofish_alloc": {
  "type": "struct AVTWOFISH *",
  "definition": "struct AVTWOFISH * av_twofish_alloc",
  "argsstring": "(void)",
  "name": "av_twofish_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVTWOFISH context To free the struct: av_free(ptr)"
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/twofish.h",
   "@_line": "44",
   "@_column": "16",
   "@_declfile": "libavutil/twofish.h",
   "@_declline": "44",
   "@_declcolumn": "16"
  },
  "@_kind": "function",
  "@_id": "group__lavu__twofish_1gaed1496e22c8a4a0f78d12c2a28d4d1a2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n  * Allocate an AVTWOFISH context\n  * To free the struct: av_free(ptr)\n  */"
 },
 "av_twofish_init": {
  "type": "int",
  "definition": "int av_twofish_init",
  "argsstring": "(struct AVTWOFISH *ctx, const uint8_t *key, int key_bits)",
  "name": "av_twofish_init",
  "param": [
   {
    "type": "struct AVTWOFISH *",
    "declname": "ctx"
   },
   {
    "type": "const uint8_t *",
    "declname": "key"
   },
   {
    "type": "int",
    "declname": "key_bits"
   }
  ],
  "briefdescription": {
   "para": "Initialize an AVTWOFISH context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "an AVTWOFISH context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "a key of size ranging from 1 to 32 bytes used for encryption/decryption"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key_bits"
       },
       "parameterdescription": {
        "para": "number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key_bits is 128/192/256, -1 if less than 0, 1 otherwise"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/twofish.h",
   "@_line": "53",
   "@_column": "5",
   "@_declfile": "libavutil/twofish.h",
   "@_declline": "53",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__twofish_1gaef4cdbc95118287ee4f170f7493dc948",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n  * Initialize an AVTWOFISH context.\n  *\n  * @param ctx an AVTWOFISH context\n  * @param key a key of size ranging from 1 to 32 bytes used for encryption/decryption\n  * @param key_bits number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key_bits is 128/192/256, -1 if less than 0, 1 otherwise\n */"
 },
 "av_twofish_crypt": {
  "type": "void",
  "definition": "void av_twofish_crypt",
  "argsstring": "(struct AVTWOFISH *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt)",
  "name": "av_twofish_crypt",
  "param": [
   {
    "type": "struct AVTWOFISH *",
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "uint8_t *",
    "declname": "iv"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypt or decrypt a buffer using a previously initialized context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "an AVTWOFISH context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of 16 byte blocks"
       }
      },
      {
       "parameternamelist": {
        "parametername": "iv"
       },
       "parameterdescription": {
        "para": "initialization vector for CBC mode, NULL for ECB mode"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/twofish.h",
   "@_line": "65",
   "@_column": "6",
   "@_declfile": "libavutil/twofish.h",
   "@_declline": "65",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__twofish_1ga2a9bae3c6491601acc809dc939691c38",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n  * Encrypt or decrypt a buffer using a previously initialized context\n  *\n  * @param ctx an AVTWOFISH context\n  * @param dst destination array, can be equal to src\n  * @param src source array, can be equal to dst\n  * @param count number of 16 byte blocks\n  * @param iv initialization vector for CBC mode, NULL for ECB mode\n  * @param decrypt 0 for encryption, 1 for decryption\n */"
 },
 "av_hash_alloc": {
  "type": "int",
  "definition": "int av_hash_alloc",
  "argsstring": "(struct AVHashContext **ctx, const char *name)",
  "name": "av_hash_alloc",
  "param": [
   {
    "type": "struct AVHashContext **",
    "declname": "ctx"
   },
   {
    "type": "const char *",
    "declname": "name"
   }
  ],
  "briefdescription": {
   "para": "Allocate a hash context for the algorithm specified by name."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": ">= 0 for success, a negative error code for failure",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_hash_init()",
        "@_refid": "group__lavu__hash__generic_1ga84ef872a731eb5c2637ddcd0f0976bca",
        "@_kindref": "member"
       },
       "#text": "The context is not initialized after a call to this function; you must callto do so."
      },
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hash.h",
   "@_line": "125",
   "@_column": "5",
   "@_declfile": "libavutil/hash.h",
   "@_declline": "125",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hash__generic_1gad1e018687f3a0e9baf3fb6d3af0dd10b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a hash context for the algorithm specified by name.\n *\n * @return  >= 0 for success, a negative error code for failure\n *\n * @note The context is not initialized after a call to this function; you must\n * call av_hash_init() to do so.\n */"
 },
 "av_hash_names": {
  "type": "const char *",
  "definition": "const char * av_hash_names",
  "argsstring": "(int i)",
  "name": "av_hash_names",
  "param": {
   "type": "int",
   "declname": "i"
  },
  "briefdescription": {
   "para": "Get the names of available hash algorithms."
  },
  "detaileddescription": {
   "para": [
    "This function can be used to enumerate the algorithms.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": {
         "#text": "i",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "Index of the hash algorithm, starting from 0"
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "computeroutput": [
        "NULL",
        "i"
       ],
       "#text": "Pointer to a static string orifis out of range"
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hash.h",
   "@_line": "135",
   "@_column": "12",
   "@_declfile": "libavutil/hash.h",
   "@_declline": "135",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hash__generic_1gadd204c00234c1f0ed710376a448bc77d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the names of available hash algorithms.\n *\n * This function can be used to enumerate the algorithms.\n *\n * @param[in] i  Index of the hash algorithm, starting from 0\n * @return       Pointer to a static string or `NULL` if `i` is out of range\n */"
 },
 "av_hash_get_name": {
  "type": "const char *",
  "definition": "const char * av_hash_get_name",
  "argsstring": "(const struct AVHashContext *ctx)",
  "name": "av_hash_get_name",
  "param": {
   "type": "const struct AVHashContext *",
   "declname": "ctx"
  },
  "briefdescription": {
   "para": "Get the name of the algorithm corresponding to the given hash context."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hash.h",
   "@_line": "140",
   "@_column": "12",
   "@_declfile": "libavutil/hash.h",
   "@_declline": "140",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hash__generic_1ga5e12e548f508b11d02ec29abbabe8cb5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the name of the algorithm corresponding to the given hash context.\n */"
 },
 "av_hash_get_size": {
  "type": "int",
  "definition": "int av_hash_get_size",
  "argsstring": "(const struct AVHashContext *ctx)",
  "name": "av_hash_get_size",
  "param": {
   "type": "const struct AVHashContext *",
   "declname": "ctx"
  },
  "briefdescription": {
   "para": "Get the size of the resulting hash value in bytes."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AV_HASH_MAX_SIZE",
      "@_refid": "group__lavu__hash__generic_1gaff5173f8837eb3afbd20b52528833d72",
      "@_kindref": "member"
     },
     "#text": "The maximum value this function will currently return is available as macro."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": {
         "#text": "ctx",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "Hash context"
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": "Size of the hash value in bytes",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hash.h",
   "@_line": "167",
   "@_column": "5",
   "@_declfile": "libavutil/hash.h",
   "@_declline": "167",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hash__generic_1ga8bf8f94e3ebf73f838d017f83352d880",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the size of the resulting hash value in bytes.\n *\n * The maximum value this function will currently return is available as macro\n * #AV_HASH_MAX_SIZE.\n *\n * @param[in]     ctx Hash context\n * @return            Size of the hash value in bytes\n */"
 },
 "av_hash_init": {
  "type": "void",
  "definition": "void av_hash_init",
  "argsstring": "(struct AVHashContext *ctx)",
  "name": "av_hash_init",
  "param": {
   "type": "struct AVHashContext *",
   "declname": "ctx"
  },
  "briefdescription": {
   "para": "Initialize or reset a hash context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": {
        "#text": "ctx",
        "@_direction": "inout"
       }
      },
      "parameterdescription": {
       "para": "Hash context"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hash.h",
   "@_line": "174",
   "@_column": "6",
   "@_declfile": "libavutil/hash.h",
   "@_declline": "174",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hash__generic_1ga84ef872a731eb5c2637ddcd0f0976bca",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize or reset a hash context.\n *\n * @param[in,out] ctx Hash context\n */"
 },
 "av_hash_update": {
  "type": "void",
  "definition": "void av_hash_update",
  "argsstring": "(struct AVHashContext *ctx, const uint8_t *src, size_t len)",
  "name": "av_hash_update",
  "param": [
   {
    "type": "struct AVHashContext *",
    "declname": "ctx"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "size_t",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Update a hash context with additional data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "ctx",
         "@_direction": "inout"
        }
       },
       "parameterdescription": {
        "para": "Hash context"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "src",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "Data to be added to the hash context"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "len",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "Size of the additional data"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hash.h",
   "@_line": "183",
   "@_column": "6",
   "@_declfile": "libavutil/hash.h",
   "@_declline": "183",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hash__generic_1gaa94897ebd6e994788dbc1bf98fb935f3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Update a hash context with additional data.\n *\n * @param[in,out] ctx Hash context\n * @param[in]     src Data to be added to the hash context\n * @param[in]     len Size of the additional data\n */"
 },
 "av_hash_final": {
  "type": "void",
  "definition": "void av_hash_final",
  "argsstring": "(struct AVHashContext *ctx, uint8_t *dst)",
  "name": "av_hash_final",
  "param": [
   {
    "type": "struct AVHashContext *",
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   }
  ],
  "briefdescription": {
   "para": "Finalize a hash context and compute the actual hash value."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": "dst",
     "ref": [
      {
       "#text": "av_hash_get_size()",
       "@_refid": "group__lavu__hash__generic_1ga8bf8f94e3ebf73f838d017f83352d880",
       "@_kindref": "member"
      },
      {
       "#text": "AV_HASH_MAX_SIZE",
       "@_refid": "group__lavu__hash__generic_1gaff5173f8837eb3afbd20b52528833d72",
       "@_kindref": "member"
      }
     ],
     "#text": "The minimum size ofbuffer is given byor. The use of the latter macro is discouraged."
    },
    "It is not safe to update or finalize a hash context again, if it has already been finalized.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ctx",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": "Hash context"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "dst",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "Where the final hash value will be stored"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_hash_final_bin()",
        "@_refid": "group__lavu__hash__generic_1ga65e1a59bf9c2076eda5884e89249af12",
        "@_kindref": "member"
       },
       "#text": "provides an alternative API"
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hash.h",
   "@_line": "199",
   "@_column": "6",
   "@_declfile": "libavutil/hash.h",
   "@_declline": "199",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hash__generic_1gaeff9a69f576f8f94e33a0b43a08baa70",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finalize a hash context and compute the actual hash value.\n *\n * The minimum size of `dst` buffer is given by av_hash_get_size() or\n * #AV_HASH_MAX_SIZE. The use of the latter macro is discouraged.\n *\n * It is not safe to update or finalize a hash context again, if it has already\n * been finalized.\n *\n * @param[in,out] ctx Hash context\n * @param[out]    dst Where the final hash value will be stored\n *\n * @see av_hash_final_bin() provides an alternative API\n */"
 },
 "av_hash_final_bin": {
  "type": "void",
  "definition": "void av_hash_final_bin",
  "argsstring": "(struct AVHashContext *ctx, uint8_t *dst, int size)",
  "name": "av_hash_final_bin",
  "param": [
   {
    "type": "struct AVHashContext *",
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Finalize a hash context and store the actual hash value in a buffer."
  },
  "detaileddescription": {
   "para": [
    "It is not safe to update or finalize a hash context again, if it has already been finalized.",
    {
     "computeroutput": "size",
     "ref": {
      "#text": "av_hash_get_size()",
      "@_refid": "group__lavu__hash__generic_1ga8bf8f94e3ebf73f838d017f83352d880",
      "@_kindref": "member"
     },
     "#text": "Ifis smaller than the hash size (given by), the hash is truncated; if size is larger, the buffer is padded with 0."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ctx",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": "Hash context"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "dst",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "Where the final hash value will be stored"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "size",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "dst",
          "#text": "Number of bytes to write to"
         }
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hash.h",
   "@_line": "214",
   "@_column": "6",
   "@_declfile": "libavutil/hash.h",
   "@_declline": "214",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hash__generic_1ga65e1a59bf9c2076eda5884e89249af12",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finalize a hash context and store the actual hash value in a buffer.\n *\n * It is not safe to update or finalize a hash context again, if it has already\n * been finalized.\n *\n * If `size` is smaller than the hash size (given by av_hash_get_size()), the\n * hash is truncated; if size is larger, the buffer is padded with 0.\n *\n * @param[in,out] ctx  Hash context\n * @param[out]    dst  Where the final hash value will be stored\n * @param[in]     size Number of bytes to write to `dst`\n */"
 },
 "av_hash_final_hex": {
  "type": "void",
  "definition": "void av_hash_final_hex",
  "argsstring": "(struct AVHashContext *ctx, uint8_t *dst, int size)",
  "name": "av_hash_final_hex",
  "param": [
   {
    "type": "struct AVHashContext *",
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Finalize a hash context and store the hexadecimal representation of the actual hash value as a string."
  },
  "detaileddescription": {
   "para": [
    "It is not safe to update or finalize a hash context again, if it has already been finalized.",
    "The string is always 0-terminated.",
    {
     "computeroutput": [
      "size",
      "2 * hash_size + 1",
      "hash_size"
     ],
     "ref": {
      "#text": "av_hash_get_size()",
      "@_refid": "group__lavu__hash__generic_1ga8bf8f94e3ebf73f838d017f83352d880",
      "@_kindref": "member"
     },
     "#text": "Ifis smaller than, whereis the value returned by, the string will be truncated."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ctx",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": "Hash context"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "dst",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "Where the string will be stored"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "size",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "dst",
          "#text": "Maximum number of bytes to write to"
         }
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hash.h",
   "@_line": "232",
   "@_column": "6",
   "@_declfile": "libavutil/hash.h",
   "@_declline": "232",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hash__generic_1ga8316ebcbe11caebc88b4c4afc0eef16c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finalize a hash context and store the hexadecimal representation of the\n * actual hash value as a string.\n *\n * It is not safe to update or finalize a hash context again, if it has already\n * been finalized.\n *\n * The string is always 0-terminated.\n *\n * If `size` is smaller than `2 * hash_size + 1`, where `hash_size` is the\n * value returned by av_hash_get_size(), the string will be truncated.\n *\n * @param[in,out] ctx  Hash context\n * @param[out]    dst  Where the string will be stored\n * @param[in]     size Maximum number of bytes to write to `dst`\n */"
 },
 "av_hash_final_b64": {
  "type": "void",
  "definition": "void av_hash_final_b64",
  "argsstring": "(struct AVHashContext *ctx, uint8_t *dst, int size)",
  "name": "av_hash_final_b64",
  "param": [
   {
    "type": "struct AVHashContext *",
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Finalize a hash context and store the Base64 representation of the actual hash value as a string."
  },
  "detaileddescription": {
   "para": [
    "It is not safe to update or finalize a hash context again, if it has already been finalized.",
    "The string is always 0-terminated.",
    {
     "computeroutput": [
      "size",
      "hash_size"
     ],
     "ref": [
      {
       "#text": "AV_BASE64_SIZE(hash_size)",
       "@_refid": "group__lavu__base64_1gaa79f39ca3f737b662ae6711d2cbecd20",
       "@_kindref": "member"
      },
      {
       "#text": "av_hash_get_size()",
       "@_refid": "group__lavu__hash__generic_1ga8bf8f94e3ebf73f838d017f83352d880",
       "@_kindref": "member"
      }
     ],
     "#text": "Ifis smaller than, whereis the value returned by, the string will be truncated."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ctx",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": "Hash context"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "dst",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "Where the final hash value will be stored"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "size",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "dst",
          "#text": "Maximum number of bytes to write to"
         }
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hash.h",
   "@_line": "250",
   "@_column": "6",
   "@_declfile": "libavutil/hash.h",
   "@_declline": "250",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hash__generic_1ga2300a29e15fd439bcac2f9bc35b730ca",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finalize a hash context and store the Base64 representation of the\n * actual hash value as a string.\n *\n * It is not safe to update or finalize a hash context again, if it has already\n * been finalized.\n *\n * The string is always 0-terminated.\n *\n * If `size` is smaller than AV_BASE64_SIZE(hash_size), where `hash_size` is\n * the value returned by av_hash_get_size(), the string will be truncated.\n *\n * @param[in,out] ctx  Hash context\n * @param[out]    dst  Where the final hash value will be stored\n * @param[in]     size Maximum number of bytes to write to `dst`\n */"
 },
 "av_hash_freep": {
  "type": "void",
  "definition": "void av_hash_freep",
  "argsstring": "(struct AVHashContext **ctx)",
  "name": "av_hash_freep",
  "param": {
   "type": "struct AVHashContext **",
   "declname": "ctx"
  },
  "briefdescription": {
   "para": {
    "computeroutput": "NULL",
    "#text": "Free hash context and set hash context pointer to."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": {
        "#text": "ctx",
        "@_direction": "inout"
       }
      },
      "parameterdescription": {
       "para": "Pointer to hash context"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hash.h",
   "@_line": "257",
   "@_column": "6",
   "@_declfile": "libavutil/hash.h",
   "@_declline": "257",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hash__generic_1ga1e8bac529966e9af25f3608d3a1515ab",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free hash context and set hash context pointer to `NULL`.\n *\n * @param[in,out] ctx  Pointer to hash context\n */"
 },
 "av_dynamic_hdr_plus_alloc": {
  "type": {
   "ref": {
    "#text": "AVDynamicHDRPlus",
    "@_refid": "structAVDynamicHDRPlus",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDynamicHDRPlus * av_dynamic_hdr_plus_alloc",
  "argsstring": "(size_t *size)",
  "name": "av_dynamic_hdr_plus_alloc",
  "param": {
   "type": "size_t *",
   "declname": "size"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVDynamicHDRPlus",
     "@_refid": "structAVDynamicHDRPlus",
     "@_kindref": "compound"
    },
    "#text": "Allocate anstructure and set its fields to default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_freep()",
      "@_refid": "group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba",
      "@_kindref": "member"
     },
     "#text": "The resulting struct can be freed using."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVDynamicHDRPlus",
        "@_refid": "structAVDynamicHDRPlus",
        "@_kindref": "compound"
       },
       "#text": "Anfilled with default values or NULL on failure."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hdr_dynamic_metadata.h",
   "@_line": "332",
   "@_column": "18",
   "@_declfile": "libavutil/hdr_dynamic_metadata.h",
   "@_declline": "332",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "hdr__dynamic__metadata_8h_1a00dbc5d7b33205c2d366d4f5da8032cf",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVDynamicHDRPlus structure and set its fields to\n * default values. The resulting struct can be freed using av_freep().\n *\n * @return An AVDynamicHDRPlus filled with default values or NULL\n *         on failure.\n */"
 },
 "av_dynamic_hdr_plus_create_side_data": {
  "type": {
   "ref": {
    "#text": "AVDynamicHDRPlus",
    "@_refid": "structAVDynamicHDRPlus",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDynamicHDRPlus * av_dynamic_hdr_plus_create_side_data",
  "argsstring": "(AVFrame *frame)",
  "name": "av_dynamic_hdr_plus_create_side_data",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVDynamicHDRPlus",
     "@_refid": "structAVDynamicHDRPlus",
     "@_kindref": "compound"
    },
    "#text": "Allocate a completeand add it to the frame."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "frame"
      },
      "parameterdescription": {
       "para": "The frame which side data is added to."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVDynamicHDRPlus",
       "@_refid": "structAVDynamicHDRPlus",
       "@_kindref": "compound"
      },
      "#text": "Thestructure to be filled by caller or NULL on failure."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hdr_dynamic_metadata.h",
   "@_line": "341",
   "@_column": "18",
   "@_declfile": "libavutil/hdr_dynamic_metadata.h",
   "@_declline": "341",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "hdr__dynamic__metadata_8h_1a21a09b79ddde6970c464af8d3b92072d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a complete AVDynamicHDRPlus and add it to the frame.\n * @param frame The frame which side data is added to.\n *\n * @return The AVDynamicHDRPlus structure to be filled by caller or NULL\n *         on failure.\n */"
 },
 "av_dynamic_hdr_plus_from_t35": {
  "type": "int",
  "definition": "int av_dynamic_hdr_plus_from_t35",
  "argsstring": "(AVDynamicHDRPlus *s, const uint8_t *data, size_t size)",
  "name": "av_dynamic_hdr_plus_from_t35",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDynamicHDRPlus",
      "@_refid": "structAVDynamicHDRPlus",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "const uint8_t *",
    "declname": "data"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVDynamicHDRPlus",
     "@_refid": "structAVDynamicHDRPlus",
     "@_kindref": "compound"
    },
    "#text": "Parse the user data registered ITU-T T.35 to AVbuffer ()."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVDynamicHDRPlus",
          "@_refid": "structAVDynamicHDRPlus",
          "@_kindref": "compound"
         },
         "#text": "A pointer containing the decodedstructure."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "The byte array containing the raw ITU-T T.35 data."
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "Size of the data array in bytes."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 on success. Otherwise, returns the appropriate AVERROR.",
     "@_kind": "return"
    },
    "#text": "The T.35 buffer must begin with the application mode, skipping the country code, terminal provider codes, and application identifier."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hdr_dynamic_metadata.h",
   "@_line": "353",
   "@_column": "5",
   "@_declfile": "libavutil/hdr_dynamic_metadata.h",
   "@_declline": "353",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "hdr__dynamic__metadata_8h_1a95000e56bdcc89943a58c0d2a2b6cd38",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse the user data registered ITU-T T.35 to AVbuffer (AVDynamicHDRPlus).\n * The T.35 buffer must begin with the application mode, skipping the\n * country code, terminal provider codes, and application identifier.\n * @param s A pointer containing the decoded AVDynamicHDRPlus structure.\n * @param data The byte array containing the raw ITU-T T.35 data.\n * @param size Size of the data array in bytes.\n *\n * @return >= 0 on success. Otherwise, returns the appropriate AVERROR.\n */"
 },
 "av_dynamic_hdr_plus_to_t35": {
  "type": "int",
  "definition": "int av_dynamic_hdr_plus_to_t35",
  "argsstring": "(const AVDynamicHDRPlus *s, uint8_t **data, size_t *size)",
  "name": "av_dynamic_hdr_plus_to_t35",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDynamicHDRPlus",
      "@_refid": "structAVDynamicHDRPlus",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "s"
   },
   {
    "type": "uint8_t **",
    "declname": "data"
   },
   {
    "type": "size_t *",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Serialize dynamic HDR10+ metadata to a user data registered ITU-T T.35 buffer, excluding the first 48 bytes of the header, and beginning with the application mode."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVDynamicHDRPlus",
          "@_refid": "structAVDynamicHDRPlus",
          "@_kindref": "compound"
         },
         "#text": "A pointer containing the decodedstructure."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "data",
         "@_direction": "inout"
        }
       },
       "parameterdescription": {
        "para": "A pointer to pointer to a byte buffer to be filled with the serialized metadata. If *data is NULL, a buffer be will be allocated and a pointer to it stored in its place. The caller assumes ownership of the buffer. May be NULL, in which case the function will only store the required buffer size in *size."
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "size",
         "@_direction": "inout"
        }
       },
       "parameterdescription": {
        "para": "A pointer to a size to be set to the returned buffer's size. If *data is not NULL, *size must contain the size of the input buffer. May be NULL only if *data is NULL."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 on success. Otherwise, returns the appropriate AVERROR.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hdr_dynamic_metadata.h",
   "@_line": "374",
   "@_column": "5",
   "@_declfile": "libavutil/hdr_dynamic_metadata.h",
   "@_declline": "374",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "hdr__dynamic__metadata_8h_1acf53c2f22f88722a2853c9c8bdd52560",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Serialize dynamic HDR10+ metadata to a user data registered ITU-T T.35 buffer,\n * excluding the first 48 bytes of the header, and beginning with the application mode.\n * @param s A pointer containing the decoded AVDynamicHDRPlus structure.\n * @param[in,out] data A pointer to pointer to a byte buffer to be filled with the\n *                     serialized metadata.\n *                     If *data is NULL, a buffer be will be allocated and a pointer to\n *                     it stored in its place. The caller assumes ownership of the buffer.\n *                     May be NULL, in which case the function will only store the\n *                     required buffer size in *size.\n * @param[in,out] size A pointer to a size to be set to the returned buffer's size.\n *                     If *data is not NULL, *size must contain the size of the input\n *                     buffer. May be NULL only if *data is NULL.\n *\n * @return >= 0 on success. Otherwise, returns the appropriate AVERROR.\n */"
 },
 "av_dynamic_hdr_vivid_alloc": {
  "type": {
   "ref": {
    "#text": "AVDynamicHDRVivid",
    "@_refid": "structAVDynamicHDRVivid",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDynamicHDRVivid * av_dynamic_hdr_vivid_alloc",
  "argsstring": "(size_t *size)",
  "name": "av_dynamic_hdr_vivid_alloc",
  "param": {
   "type": "size_t *",
   "declname": "size"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVDynamicHDRVivid",
     "@_refid": "structAVDynamicHDRVivid",
     "@_kindref": "compound"
    },
    "#text": "Allocate anstructure and set its fields to default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_freep()",
      "@_refid": "group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba",
      "@_kindref": "member"
     },
     "#text": "The resulting struct can be freed using."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVDynamicHDRVivid",
        "@_refid": "structAVDynamicHDRVivid",
        "@_kindref": "compound"
       },
       "#text": "Anfilled with default values or NULL on failure."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hdr_dynamic_vivid_metadata.h",
   "@_line": "335",
   "@_column": "19",
   "@_declfile": "libavutil/hdr_dynamic_vivid_metadata.h",
   "@_declline": "335",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "hdr__dynamic__vivid__metadata_8h_1a773cdc0ec893d9cfdf59cfe470716dac",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVDynamicHDRVivid structure and set its fields to\n * default values. The resulting struct can be freed using av_freep().\n *\n * @return An AVDynamicHDRVivid filled with default values or NULL\n *         on failure.\n */"
 },
 "av_dynamic_hdr_vivid_create_side_data": {
  "type": {
   "ref": {
    "#text": "AVDynamicHDRVivid",
    "@_refid": "structAVDynamicHDRVivid",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVDynamicHDRVivid * av_dynamic_hdr_vivid_create_side_data",
  "argsstring": "(AVFrame *frame)",
  "name": "av_dynamic_hdr_vivid_create_side_data",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVDynamicHDRVivid",
     "@_refid": "structAVDynamicHDRVivid",
     "@_kindref": "compound"
    },
    "#text": "Allocate a completeand add it to the frame."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "frame"
      },
      "parameterdescription": {
       "para": "The frame which side data is added to."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVDynamicHDRVivid",
       "@_refid": "structAVDynamicHDRVivid",
       "@_kindref": "compound"
      },
      "#text": "Thestructure to be filled by caller or NULL on failure."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hdr_dynamic_vivid_metadata.h",
   "@_line": "344",
   "@_column": "19",
   "@_declfile": "libavutil/hdr_dynamic_vivid_metadata.h",
   "@_declline": "344",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "hdr__dynamic__vivid__metadata_8h_1a57591d6704dfcdfd93adf4f2df46fe05",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a complete AVDynamicHDRVivid and add it to the frame.\n * @param frame The frame which side data is added to.\n *\n * @return The AVDynamicHDRVivid structure to be filled by caller or NULL\n *         on failure.\n */"
 },
 "AVHMAC": {
  "type": {
   "ref": {
    "#text": "AVHMAC",
    "@_refid": "group__lavu__hmac_1gad8c944f9437e65d8e8ebc526bdeee676",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVHMAC AVHMAC",
  "argsstring": "",
  "name": "AVHMAC",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hmac.h",
   "@_line": "41",
   "@_column": "21",
   "@_bodyfile": "libavutil/hmac.h",
   "@_bodystart": "41",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavu__hmac_1gad8c944f9437e65d8e8ebc526bdeee676",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * @defgroup lavu_hmac HMAC\n * @ingroup lavu_crypto\n * @{\n */"
 },
 "av_hmac_alloc": {
  "type": {
   "ref": {
    "#text": "AVHMAC",
    "@_refid": "group__lavu__hmac_1gad8c944f9437e65d8e8ebc526bdeee676",
    "@_kindref": "member"
   },
   "#text": "*"
  },
  "definition": "AVHMAC * av_hmac_alloc",
  "argsstring": "(enum AVHMACType type)",
  "name": "av_hmac_alloc",
  "param": {
   "type": {
    "ref": {
     "#text": "AVHMACType",
     "@_refid": "group__lavu__hmac_1gaec34f18155d20236c9f39961bb58f7d4",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "type"
  },
  "briefdescription": {
   "para": "Allocate an AVHMAC context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "type"
      },
      "parameterdescription": {
       "para": "The hash function used for the HMAC."
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hmac.h",
   "@_line": "47",
   "@_column": "8",
   "@_declfile": "libavutil/hmac.h",
   "@_declline": "47",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hmac_1ga46ba93d004bffe84ecac69881c8e515f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVHMAC context.\n * @param type The hash function used for the HMAC.\n */"
 },
 "av_hmac_free": {
  "type": "void",
  "definition": "void av_hmac_free",
  "argsstring": "(AVHMAC *ctx)",
  "name": "av_hmac_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVHMAC",
     "@_refid": "group__lavu__hmac_1gad8c944f9437e65d8e8ebc526bdeee676",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "ctx"
  },
  "briefdescription": {
   "para": "Free an AVHMAC context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "ctx"
      },
      "parameterdescription": {
       "para": "The context to free, may be NULL"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hmac.h",
   "@_line": "53",
   "@_column": "6",
   "@_declfile": "libavutil/hmac.h",
   "@_declline": "53",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hmac_1gaaa2951b832fdc7abed35a9112f7f1a02",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free an AVHMAC context.\n * @param ctx The context to free, may be NULL\n */"
 },
 "av_hmac_init": {
  "type": "void",
  "definition": "void av_hmac_init",
  "argsstring": "(AVHMAC *ctx, const uint8_t *key, unsigned int keylen)",
  "name": "av_hmac_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVHMAC",
      "@_refid": "group__lavu__hmac_1gad8c944f9437e65d8e8ebc526bdeee676",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": "const uint8_t *",
    "declname": "key"
   },
   {
    "type": "unsigned int",
    "declname": "keylen"
   }
  ],
  "briefdescription": {
   "para": "Initialize an AVHMAC context with an authentication key."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "The HMAC context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "The authentication key"
       }
      },
      {
       "parameternamelist": {
        "parametername": "keylen"
       },
       "parameterdescription": {
        "para": "The length of the key, in bytes"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hmac.h",
   "@_line": "61",
   "@_column": "6",
   "@_declfile": "libavutil/hmac.h",
   "@_declline": "61",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hmac_1gae91a0c1f832c269006164b29df7e9aa8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize an AVHMAC context with an authentication key.\n * @param ctx    The HMAC context\n * @param key    The authentication key\n * @param keylen The length of the key, in bytes\n */"
 },
 "av_hmac_update": {
  "type": "void",
  "definition": "void av_hmac_update",
  "argsstring": "(AVHMAC *ctx, const uint8_t *data, unsigned int len)",
  "name": "av_hmac_update",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVHMAC",
      "@_refid": "group__lavu__hmac_1gad8c944f9437e65d8e8ebc526bdeee676",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": "const uint8_t *",
    "declname": "data"
   },
   {
    "type": "unsigned int",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Hash data with the HMAC."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "The HMAC context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "The data to hash"
       }
      },
      {
       "parameternamelist": {
        "parametername": "len"
       },
       "parameterdescription": {
        "para": "The length of the data, in bytes"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hmac.h",
   "@_line": "69",
   "@_column": "6",
   "@_declfile": "libavutil/hmac.h",
   "@_declline": "69",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hmac_1ga4c3307cc9b1f331a15e999f8dacb90de",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Hash data with the HMAC.\n * @param ctx  The HMAC context\n * @param data The data to hash\n * @param len  The length of the data, in bytes\n */"
 },
 "av_hmac_final": {
  "type": "int",
  "definition": "int av_hmac_final",
  "argsstring": "(AVHMAC *ctx, uint8_t *out, unsigned int outlen)",
  "name": "av_hmac_final",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVHMAC",
      "@_refid": "group__lavu__hmac_1gad8c944f9437e65d8e8ebc526bdeee676",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "out"
   },
   {
    "type": "unsigned int",
    "declname": "outlen"
   }
  ],
  "briefdescription": {
   "para": "Finish hashing and output the HMAC digest."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "The HMAC context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "out"
       },
       "parameterdescription": {
        "para": "The output buffer to write the digest into"
       }
      },
      {
       "parameternamelist": {
        "parametername": "outlen"
       },
       "parameterdescription": {
        "para": "The length of the out buffer, in bytes"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "The number of bytes written to out, or a negative error code.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hmac.h",
   "@_line": "78",
   "@_column": "5",
   "@_declfile": "libavutil/hmac.h",
   "@_declline": "78",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hmac_1ga02f0b343d9045500beef1f6b09c650cd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finish hashing and output the HMAC digest.\n * @param ctx    The HMAC context\n * @param out    The output buffer to write the digest into\n * @param outlen The length of the out buffer, in bytes\n * @return       The number of bytes written to out, or a negative error code.\n */"
 },
 "av_hmac_calc": {
  "type": "int",
  "definition": "int av_hmac_calc",
  "argsstring": "(AVHMAC *ctx, const uint8_t *data, unsigned int len, const uint8_t *key, unsigned int keylen, uint8_t *out, unsigned int outlen)",
  "name": "av_hmac_calc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVHMAC",
      "@_refid": "group__lavu__hmac_1gad8c944f9437e65d8e8ebc526bdeee676",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": "const uint8_t *",
    "declname": "data"
   },
   {
    "type": "unsigned int",
    "declname": "len"
   },
   {
    "type": "const uint8_t *",
    "declname": "key"
   },
   {
    "type": "unsigned int",
    "declname": "keylen"
   },
   {
    "type": "uint8_t *",
    "declname": "out"
   },
   {
    "type": "unsigned int",
    "declname": "outlen"
   }
  ],
  "briefdescription": {
   "para": "Hash an array of data with a key."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "The HMAC context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "The data to hash"
       }
      },
      {
       "parameternamelist": {
        "parametername": "len"
       },
       "parameterdescription": {
        "para": "The length of the data, in bytes"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "The authentication key"
       }
      },
      {
       "parameternamelist": {
        "parametername": "keylen"
       },
       "parameterdescription": {
        "para": "The length of the key, in bytes"
       }
      },
      {
       "parameternamelist": {
        "parametername": "out"
       },
       "parameterdescription": {
        "para": "The output buffer to write the digest into"
       }
      },
      {
       "parameternamelist": {
        "parametername": "outlen"
       },
       "parameterdescription": {
        "para": "The length of the out buffer, in bytes"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "The number of bytes written to out, or a negative error code.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hmac.h",
   "@_line": "91",
   "@_column": "5",
   "@_declfile": "libavutil/hmac.h",
   "@_declline": "91",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__hmac_1ga22d17ebca8556c49be5c22e706de1ab3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Hash an array of data with a key.\n * @param ctx    The HMAC context\n * @param data   The data to hash\n * @param len    The length of the data, in bytes\n * @param key    The authentication key\n * @param keylen The length of the key, in bytes\n * @param out    The output buffer to write the digest into\n * @param outlen The length of the out buffer, in bytes\n * @return       The number of bytes written to out, or a negative error code.\n */"
 },
 "av_hwdevice_find_type_by_name": {
  "type": {
   "ref": {
    "#text": "AVHWDeviceType",
    "@_refid": "hwcontext_8h_1acf25724be4b066a51ad86aa9214b0d34",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVHWDeviceType av_hwdevice_find_type_by_name",
  "argsstring": "(const char *name)",
  "name": "av_hwdevice_find_type_by_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": {
   "para": "Look up an AVHWDeviceType by name."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "name"
      },
      "parameterdescription": {
       "para": "String name of the device type (case-insensitive)."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "The type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if not found.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "227",
   "@_column": "20",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "227",
   "@_declcolumn": "20"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "hw__decode_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "hw__decode_8c",
   "@_startline": "148",
   "@_endline": "255"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a541943ddced791765349645a30adfa4d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Look up an AVHWDeviceType by name.\n *\n * @param name String name of the device type (case-insensitive).\n * @return The type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if\n *         not found.\n */"
 },
 "av_hwdevice_get_type_name": {
  "type": "const char *",
  "definition": "const char * av_hwdevice_get_type_name",
  "argsstring": "(enum AVHWDeviceType type)",
  "name": "av_hwdevice_get_type_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVHWDeviceType",
     "@_refid": "hwcontext_8h_1acf25724be4b066a51ad86aa9214b0d34",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "type"
  },
  "briefdescription": {
   "para": "Get the string name of an AVHWDeviceType."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "type"
      },
      "parameterdescription": {
       "para": "Type from enum AVHWDeviceType."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "Pointer to a static string containing the name, or NULL if the type is not valid.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "235",
   "@_column": "12",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "235",
   "@_declcolumn": "12"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "hw__decode_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "hw__decode_8c",
   "@_startline": "148",
   "@_endline": "255"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a2d41a8f6e6a52d2bfb8a43f5341c9aea",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/** Get the string name of an AVHWDeviceType.\n *\n * @param type Type from enum AVHWDeviceType.\n * @return Pointer to a static string containing the name, or NULL if the type\n *         is not valid.\n */"
 },
 "av_hwdevice_iterate_types": {
  "type": {
   "ref": {
    "#text": "AVHWDeviceType",
    "@_refid": "hwcontext_8h_1acf25724be4b066a51ad86aa9214b0d34",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVHWDeviceType av_hwdevice_iterate_types",
  "argsstring": "(enum AVHWDeviceType prev)",
  "name": "av_hwdevice_iterate_types",
  "param": {
   "type": {
    "ref": {
     "#text": "AVHWDeviceType",
     "@_refid": "hwcontext_8h_1acf25724be4b066a51ad86aa9214b0d34",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "prev"
  },
  "briefdescription": {
   "para": "Iterate over supported device types."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "prev"
      },
      "parameterdescription": {
       "para": "AV_HWDEVICE_TYPE_NONE initially, then the previous type returned by this function in subsequent iterations."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "The next usable device type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if there are no more.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "245",
   "@_column": "20",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "245",
   "@_declcolumn": "20"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "hw__decode_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "hw__decode_8c",
   "@_startline": "148",
   "@_endline": "255"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a0fb42d664a6ec87f8802e9132b85cac3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over supported device types.\n *\n * @param prev AV_HWDEVICE_TYPE_NONE initially, then the previous type\n *             returned by this function in subsequent iterations.\n * @return The next usable device type from enum AVHWDeviceType, or\n *         AV_HWDEVICE_TYPE_NONE if there are no more.\n */"
 },
 "av_hwdevice_ctx_alloc": {
  "type": {
   "ref": {
    "#text": "AVBufferRef",
    "@_refid": "structAVBufferRef",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVBufferRef * av_hwdevice_ctx_alloc",
  "argsstring": "(enum AVHWDeviceType type)",
  "name": "av_hwdevice_ctx_alloc",
  "param": {
   "type": {
    "ref": {
     "#text": "AVHWDeviceType",
     "@_refid": "hwcontext_8h_1acf25724be4b066a51ad86aa9214b0d34",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "type"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVHWDeviceContext",
     "@_refid": "structAVHWDeviceContext",
     "@_kindref": "compound"
    },
    "#text": "Allocate anfor a given hardware type."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "type"
      },
      "parameterdescription": {
       "para": "the type of the hardware device to allocate."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVHWDeviceContext",
       "@_refid": "structAVHWDeviceContext",
       "@_kindref": "compound"
      },
      "#text": "a reference to the newly createdon success or NULL on failure."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "254",
   "@_column": "13",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "254",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a5fb89a7a827ae6022fa84c686fdf9906",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVHWDeviceContext for a given hardware type.\n *\n * @param type the type of the hardware device to allocate.\n * @return a reference to the newly created AVHWDeviceContext on success or NULL\n *         on failure.\n */"
 },
 "av_hwdevice_ctx_init": {
  "type": "int",
  "definition": "int av_hwdevice_ctx_init",
  "argsstring": "(AVBufferRef *ref)",
  "name": "av_hwdevice_ctx_init",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "ref"
  },
  "briefdescription": {
   "para": "Finalize the device context before use."
  },
  "detaileddescription": {
   "para": [
    "This function must be called after the context is filled with all the required information and before it is used in any way.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "ref"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVHWDeviceContext",
          "@_refid": "structAVHWDeviceContext",
          "@_kindref": "compound"
         },
         "#text": "a reference to the"
        }
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, a negative AVERROR code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "264",
   "@_column": "5",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "264",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a11d8c9101c95cdcab3dbc5b4c03dfd4d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finalize the device context before use. This function must be called after\n * the context is filled with all the required information and before it is\n * used in any way.\n *\n * @param ref a reference to the AVHWDeviceContext\n * @return 0 on success, a negative AVERROR code on failure\n */"
 },
 "av_hwdevice_ctx_create": {
  "type": "int",
  "definition": "int av_hwdevice_ctx_create",
  "argsstring": "(AVBufferRef **device_ctx, enum AVHWDeviceType type, const char *device, AVDictionary *opts, int flags)",
  "name": "av_hwdevice_ctx_create",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "device_ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVHWDeviceType",
      "@_refid": "hwcontext_8h_1acf25724be4b066a51ad86aa9214b0d34",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "const char *",
    "declname": "device"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "opts"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVHWDeviceContext",
     "@_refid": "structAVHWDeviceContext",
     "@_kindref": "compound"
    },
    "#text": "Open a device of the specified type and create anfor it."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "AVHWDeviceContext",
       "@_refid": "structAVHWDeviceContext",
       "@_kindref": "compound"
      },
      {
       "#text": "av_hwdevice_ctx_alloc()",
       "@_refid": "hwcontext_8h_1a5fb89a7a827ae6022fa84c686fdf9906",
       "@_kindref": "member"
      }
     ],
     "#text": "This is a convenience function intended to cover the simple cases. Callers who need to fine-tune device creation/management should open the device manually and then wrap it in anusing/av_hwdevice_ctx_init()."
    },
    {
     "ref": [
      {
       "#text": "av_hwdevice_ctx_init()",
       "@_refid": "hwcontext_8h_1a11d8c9101c95cdcab3dbc5b4c03dfd4d",
       "@_kindref": "member"
      },
      {
       "#text": "AVHWDeviceContext",
       "@_refid": "structAVHWDeviceContext",
       "@_kindref": "compound"
      }
     ],
     "#text": "The returned context is already initialized and ready for use, the caller should not callon it. The user_opaque/free fields of the createdare set by this function and should not be touched by the caller."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "device_ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "av_buffer_unref()",
           "@_refid": "group__lavu__buffer_1ga135e9e929b5033bb8f68322497b2effc",
           "@_kindref": "member"
          },
          "#text": "On success, a reference to the newly-created device context will be written here. The reference is owned by the caller and must be released withwhen no longer needed. On failure, NULL will be written to this pointer."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "type"
        },
        "parameterdescription": {
         "para": "The type of the device to create."
        }
       },
       {
        "parameternamelist": {
         "parametername": "device"
        },
        "parameterdescription": {
         "para": "A type-specific string identifying the device to open."
        }
       },
       {
        "parameternamelist": {
         "parametername": "opts"
        },
        "parameterdescription": {
         "para": "A dictionary of additional (type-specific) options to use in opening the device. The dictionary remains owned by the caller."
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "currently unused"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, a negative AVERROR code on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "291",
   "@_column": "5",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "291",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "hw_decoder_init",
   "@_refid": "hw__decode_8c_1a028fa118aac024a955e2a56e668624d0",
   "@_compoundref": "hw__decode_8c",
   "@_startline": "48",
   "@_endline": "60"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1ac085a5abc44c5330b64489416a42482d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Open a device of the specified type and create an AVHWDeviceContext for it.\n *\n * This is a convenience function intended to cover the simple cases. Callers\n * who need to fine-tune device creation/management should open the device\n * manually and then wrap it in an AVHWDeviceContext using\n * av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init().\n *\n * The returned context is already initialized and ready for use, the caller\n * should not call av_hwdevice_ctx_init() on it. The user_opaque/free fields of\n * the created AVHWDeviceContext are set by this function and should not be\n * touched by the caller.\n *\n * @param device_ctx On success, a reference to the newly-created device context\n *                   will be written here. The reference is owned by the caller\n *                   and must be released with av_buffer_unref() when no longer\n *                   needed. On failure, NULL will be written to this pointer.\n * @param type The type of the device to create.\n * @param device A type-specific string identifying the device to open.\n * @param opts A dictionary of additional (type-specific) options to use in\n *             opening the device. The dictionary remains owned by the caller.\n * @param flags currently unused\n *\n * @return 0 on success, a negative AVERROR code on failure.\n */"
 },
 "av_hwdevice_ctx_create_derived": {
  "type": "int",
  "definition": "int av_hwdevice_ctx_create_derived",
  "argsstring": "(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, int flags)",
  "name": "av_hwdevice_ctx_create_derived",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "dst_ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVHWDeviceType",
      "@_refid": "hwcontext_8h_1acf25724be4b066a51ad86aa9214b0d34",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "src_ctx"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Create a new device of the specified type from an existing device."
  },
  "detaileddescription": {
   "para": [
    "If the source device is a device of the target type or was originally derived from such a device (possibly through one or more intermediate devices of other types), then this will return a reference to the existing device of the same type as is requested.",
    "Otherwise, it will attempt to derive a new device from the given source device. If direct derivation to the new type is not implemented, it will attempt the same derivation from each ancestor of the source device in turn looking for an implemented derivation method.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst_ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVHWDeviceContext",
           "@_refid": "structAVHWDeviceContext",
           "@_kindref": "compound"
          },
          "#text": "On success, a reference to the newly-created."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "type"
        },
        "parameterdescription": {
         "para": "The type of the new device to create."
        }
       },
       {
        "parameternamelist": {
         "parametername": "src_ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVHWDeviceContext",
           "@_refid": "structAVHWDeviceContext",
           "@_kindref": "compound"
          },
          "#text": "A reference to an existingwhich will be used to create the new device."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "Currently unused; should be set to zero."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "Zero on success, a negative AVERROR code on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "315",
   "@_column": "5",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "315",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a6af4a20a0338e3b74075f606e4b5b369",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create a new device of the specified type from an existing device.\n *\n * If the source device is a device of the target type or was originally\n * derived from such a device (possibly through one or more intermediate\n * devices of other types), then this will return a reference to the\n * existing device of the same type as is requested.\n *\n * Otherwise, it will attempt to derive a new device from the given source\n * device.  If direct derivation to the new type is not implemented, it will\n * attempt the same derivation from each ancestor of the source device in\n * turn looking for an implemented derivation method.\n *\n * @param dst_ctx On success, a reference to the newly-created\n *                AVHWDeviceContext.\n * @param type    The type of the new device to create.\n * @param src_ctx A reference to an existing AVHWDeviceContext which will be\n *                used to create the new device.\n * @param flags   Currently unused; should be set to zero.\n * @return        Zero on success, a negative AVERROR code on failure.\n */"
 },
 "av_hwdevice_ctx_create_derived_opts": {
  "type": "int",
  "definition": "int av_hwdevice_ctx_create_derived_opts",
  "argsstring": "(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, AVDictionary *options, int flags)",
  "name": "av_hwdevice_ctx_create_derived_opts",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "dst_ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVHWDeviceType",
      "@_refid": "hwcontext_8h_1acf25724be4b066a51ad86aa9214b0d34",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "src_ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "options"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Create a new device of the specified type from an existing device."
  },
  "detaileddescription": {
   "para": [
    "This function performs the same action as av_hwdevice_ctx_create_derived, however, it is able to set options for the new device to be derived.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst_ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVHWDeviceContext",
           "@_refid": "structAVHWDeviceContext",
           "@_kindref": "compound"
          },
          "#text": "On success, a reference to the newly-created."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "type"
        },
        "parameterdescription": {
         "para": "The type of the new device to create."
        }
       },
       {
        "parameternamelist": {
         "parametername": "src_ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVHWDeviceContext",
           "@_refid": "structAVHWDeviceContext",
           "@_kindref": "compound"
          },
          "#text": "A reference to an existingwhich will be used to create the new device."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "options"
        },
        "parameterdescription": {
         "para": "Options for the new device to create, same format as in av_hwdevice_ctx_create."
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "Currently unused; should be set to zero."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "Zero on success, a negative AVERROR code on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "335",
   "@_column": "5",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "335",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a64b0f014829a3cc5e8ebcee739453772",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create a new device of the specified type from an existing device.\n *\n * This function performs the same action as av_hwdevice_ctx_create_derived,\n * however, it is able to set options for the new device to be derived.\n *\n * @param dst_ctx On success, a reference to the newly-created\n *                AVHWDeviceContext.\n * @param type    The type of the new device to create.\n * @param src_ctx A reference to an existing AVHWDeviceContext which will be\n *                used to create the new device.\n * @param options Options for the new device to create, same format as in\n *                av_hwdevice_ctx_create.\n * @param flags   Currently unused; should be set to zero.\n * @return        Zero on success, a negative AVERROR code on failure.\n */"
 },
 "av_hwframe_ctx_alloc": {
  "type": {
   "ref": {
    "#text": "AVBufferRef",
    "@_refid": "structAVBufferRef",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVBufferRef * av_hwframe_ctx_alloc",
  "argsstring": "(AVBufferRef *device_ctx)",
  "name": "av_hwframe_ctx_alloc",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "device_ctx"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVHWFramesContext",
     "@_refid": "structAVHWFramesContext",
     "@_kindref": "compound"
    },
    "#text": "Allocate antied to a given device context."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "device_ctx"
      },
      "parameterdescription": {
       "para": {
        "ref": {
         "#text": "AVHWDeviceContext",
         "@_refid": "structAVHWDeviceContext",
         "@_kindref": "compound"
        },
        "#text": "a reference to a. This function will make a new reference for internal use, the one passed to the function remains owned by the caller."
       }
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVHWFramesContext",
       "@_refid": "structAVHWFramesContext",
       "@_kindref": "compound"
      },
      "#text": "a reference to the newly createdon success or NULL on failure."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "349",
   "@_column": "13",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "349",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a4ecba8a4ac10bfb324aa117f36b6be32",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVHWFramesContext tied to a given device context.\n *\n * @param device_ctx a reference to a AVHWDeviceContext. This function will make\n *                   a new reference for internal use, the one passed to the\n *                   function remains owned by the caller.\n * @return a reference to the newly created AVHWFramesContext on success or NULL\n *         on failure.\n */"
 },
 "av_hwframe_ctx_init": {
  "type": "int",
  "definition": "int av_hwframe_ctx_init",
  "argsstring": "(AVBufferRef *ref)",
  "name": "av_hwframe_ctx_init",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "ref"
  },
  "briefdescription": {
   "para": "Finalize the context before use."
  },
  "detaileddescription": {
   "para": [
    "This function must be called after the context is filled with all the required information and before it is attached to any frames.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "ref"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVHWFramesContext",
          "@_refid": "structAVHWFramesContext",
          "@_kindref": "compound"
         },
         "#text": "a reference to the"
        }
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, a negative AVERROR code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "359",
   "@_column": "5",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "359",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a66a7e1ebc7e459ce07d3de6639ac7e38",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finalize the context before use. This function must be called after the\n * context is filled with all the required information and before it is attached\n * to any frames.\n *\n * @param ref a reference to the AVHWFramesContext\n * @return 0 on success, a negative AVERROR code on failure\n */"
 },
 "av_hwframe_get_buffer": {
  "type": "int",
  "definition": "int av_hwframe_get_buffer",
  "argsstring": "(AVBufferRef *hwframe_ctx, AVFrame *frame, int flags)",
  "name": "av_hwframe_get_buffer",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "hwframe_ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVHWFramesContext",
     "@_refid": "structAVHWFramesContext",
     "@_kindref": "compound"
    },
    "#text": "Allocate a new frame attached to the given."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "hwframe_ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVHWFramesContext",
          "@_refid": "structAVHWFramesContext",
          "@_kindref": "compound"
         },
         "#text": "a reference to an"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "frame"
       },
       "parameterdescription": {
        "para": "an empty (freshly allocated or unreffed) frame to be filled with newly allocated buffers."
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "currently unused, should be set to zero"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative AVERROR code on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "370",
   "@_column": "5",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "370",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a03e7cf122b61f6472d0a4d37f52d4965",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a new frame attached to the given AVHWFramesContext.\n *\n * @param hwframe_ctx a reference to an AVHWFramesContext\n * @param frame an empty (freshly allocated or unreffed) frame to be filled with\n *              newly allocated buffers.\n * @param flags currently unused, should be set to zero\n * @return 0 on success, a negative AVERROR code on failure\n */"
 },
 "av_hwframe_transfer_data": {
  "type": "int",
  "definition": "int av_hwframe_transfer_data",
  "argsstring": "(AVFrame *dst, const AVFrame *src, int flags)",
  "name": "av_hwframe_transfer_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Copy data to or from a hw surface."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AVHWFramesContext",
      "@_refid": "structAVHWFramesContext",
      "@_kindref": "compound"
     },
     "#text": "At least one of dst/src must have anattached."
    },
    {
     "ref": [
      {
       "#text": "AVHWFramesContext",
       "@_refid": "structAVHWFramesContext",
       "@_kindref": "compound"
      },
      {
       "#text": "AVHWFramesContext",
       "@_refid": "structAVHWFramesContext",
       "@_kindref": "compound"
      }
     ],
     "#text": "If src has anattached, then the format of dst (if set) must use one of the formats returned by av_hwframe_transfer_get_formats(src,\nAV_HWFRAME_TRANSFER_DIRECTION_FROM). If dst has anattached, then the format of src must use one of the formats returned by av_hwframe_transfer_get_formats(dst,\nAV_HWFRAME_TRANSFER_DIRECTION_TO)"
    },
    {
     "ref": {
      "#text": "av_frame_get_buffer()",
      "@_refid": "group__lavu__frame_1ga6b1acbfa82c79bf7fd78d868572f0ceb",
      "@_kindref": "member"
     },
     "#text": "dst may be \"clean\" (i.e. with data/buf pointers unset), in which case the data buffers will be allocated by this function using. If dst->format is set, then this format will be used, otherwise (when dst->format is AV_PIX_FMT_NONE) the first acceptable format will be chosen."
    },
    {
     "ref": [
      {
       "#text": "AVHWFramesContext.width",
       "@_refid": "structAVHWFramesContext_1a9e6f29d0f744930cdd0e8bdff8771520",
       "@_kindref": "member"
      },
      {
       "#text": "AVFrame.width",
       "@_refid": "structAVFrame_1a1e71ce60cedd5f3b6811714a9f7f9e0a",
       "@_kindref": "member"
      }
     ],
     "#text": "The two frames must have matching allocated dimensions (i.e. equal to/height), since not all device types support transferring a sub-rectangle of the whole surface. The display dimensions (i.e./height) may be smaller than the allocated dimensions, but also have to be equal for both frames. When the display dimensions are smaller than the allocated dimensions, the content of the padding in the destination frame is unspecified."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "the destination frame. dst is not touched on failure."
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "the source frame."
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "currently unused, should be set to zero"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, a negative AVERROR error code on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "401",
   "@_column": "5",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "401",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "decode_write",
   "@_refid": "hw__decode_8c_1aa376d8bc0bb004de4856e8920e0f6217",
   "@_compoundref": "hw__decode_8c",
   "@_startline": "76",
   "@_endline": "146"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1abf1b1664b8239d953ae2cac8b643815a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy data to or from a hw surface. At least one of dst/src must have an\n * AVHWFramesContext attached.\n *\n * If src has an AVHWFramesContext attached, then the format of dst (if set)\n * must use one of the formats returned by av_hwframe_transfer_get_formats(src,\n * AV_HWFRAME_TRANSFER_DIRECTION_FROM).\n * If dst has an AVHWFramesContext attached, then the format of src must use one\n * of the formats returned by av_hwframe_transfer_get_formats(dst,\n * AV_HWFRAME_TRANSFER_DIRECTION_TO)\n *\n * dst may be \"clean\" (i.e. with data/buf pointers unset), in which case the\n * data buffers will be allocated by this function using av_frame_get_buffer().\n * If dst->format is set, then this format will be used, otherwise (when\n * dst->format is AV_PIX_FMT_NONE) the first acceptable format will be chosen.\n *\n * The two frames must have matching allocated dimensions (i.e. equal to\n * AVHWFramesContext.width/height), since not all device types support\n * transferring a sub-rectangle of the whole surface. The display dimensions\n * (i.e. AVFrame.width/height) may be smaller than the allocated dimensions, but\n * also have to be equal for both frames. When the display dimensions are\n * smaller than the allocated dimensions, the content of the padding in the\n * destination frame is unspecified.\n *\n * @param dst the destination frame. dst is not touched on failure.\n * @param src the source frame.\n * @param flags currently unused, should be set to zero\n * @return 0 on success, a negative AVERROR error code on failure.\n */"
 },
 "av_hwframe_transfer_get_formats": {
  "type": "int",
  "definition": "int av_hwframe_transfer_get_formats",
  "argsstring": "(AVBufferRef *hwframe_ctx, enum AVHWFrameTransferDirection dir, enum AVPixelFormat **formats, int flags)",
  "name": "av_hwframe_transfer_get_formats",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "hwframe_ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVHWFrameTransferDirection",
      "@_refid": "hwcontext_8h_1aba8d70ed754b2536ca497d7d50ec7b1e",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "dir"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum**"
    },
    "declname": "formats"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_hwframe_transfer_data()",
     "@_refid": "hwcontext_8h_1abf1b1664b8239d953ae2cac8b643815a",
     "@_kindref": "member"
    },
    "#text": "Get a list of possible source or target formats usable in."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "hwframe_ctx"
       },
       "parameterdescription": {
        "para": "the frame context to obtain the information for"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dir"
       },
       "parameterdescription": {
        "para": "the direction of the transfer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "formats"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_free()",
          "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
          "@_kindref": "member"
         },
         "#text": "the pointer to the output format list will be written here. The list is terminated with AV_PIX_FMT_NONE and must be freed by the caller when no longer needed using. If this function returns successfully, the format list will have at least one item (not counting the terminator). On failure, the contents of this pointer are unspecified."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "currently unused, should be set to zero"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative AVERROR code on failure.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "430",
   "@_column": "5",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "430",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1ae758c36d3b0c446af7f9eb1f57110a49",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a list of possible source or target formats usable in\n * av_hwframe_transfer_data().\n *\n * @param hwframe_ctx the frame context to obtain the information for\n * @param dir the direction of the transfer\n * @param formats the pointer to the output format list will be written here.\n *                The list is terminated with AV_PIX_FMT_NONE and must be freed\n *                by the caller when no longer needed using av_free().\n *                If this function returns successfully, the format list will\n *                have at least one item (not counting the terminator).\n *                On failure, the contents of this pointer are unspecified.\n * @param flags currently unused, should be set to zero\n * @return 0 on success, a negative AVERROR code on failure.\n */"
 },
 "av_hwdevice_hwconfig_alloc": {
  "type": "void *",
  "definition": "void * av_hwdevice_hwconfig_alloc",
  "argsstring": "(AVBufferRef *device_ctx)",
  "name": "av_hwdevice_hwconfig_alloc",
  "param": {
   "type": {
    "ref": {
     "#text": "AVBufferRef",
     "@_refid": "structAVBufferRef",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "device_ctx"
  },
  "briefdescription": {
   "para": "Allocate a HW-specific configuration structure for a given HW device."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_free()",
      "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
      "@_kindref": "member"
     },
     "#text": "After use, the user must free all members as required by the specific hardware structure being used, then free the structure itself with."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "device_ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVHWDeviceContext",
          "@_refid": "structAVHWDeviceContext",
          "@_kindref": "compound"
         },
         "#text": "a reference to the associated."
        }
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": "The newly created HW-specific configuration structure on success or NULL on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "480",
   "@_column": "6",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "480",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1addc19f567b2fa6f5ad4c50df4eada401",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a HW-specific configuration structure for a given HW device.\n * After use, the user must free all members as required by the specific\n * hardware structure being used, then free the structure itself with\n * av_free().\n *\n * @param device_ctx a reference to the associated AVHWDeviceContext.\n * @return The newly created HW-specific configuration structure on\n *         success or NULL on failure.\n */"
 },
 "av_hwdevice_get_hwframe_constraints": {
  "type": {
   "ref": {
    "#text": "AVHWFramesConstraints",
    "@_refid": "structAVHWFramesConstraints",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVHWFramesConstraints * av_hwdevice_get_hwframe_constraints",
  "argsstring": "(AVBufferRef *ref, const void *hwconfig)",
  "name": "av_hwdevice_get_hwframe_constraints",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ref"
   },
   {
    "type": "const void *",
    "declname": "hwconfig"
   }
  ],
  "briefdescription": {
   "para": "Get the constraints on HW frames given a device and the HW-specific configuration to be used with that device."
  },
  "detaileddescription": {
   "para": [
    "If no HW-specific configuration is provided, returns the maximum possible capabilities of the device.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ref"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVHWDeviceContext",
           "@_refid": "structAVHWDeviceContext",
           "@_kindref": "compound"
          },
          "#text": "a reference to the associated."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "hwconfig"
        },
        "parameterdescription": {
         "para": "a filled HW-specific configuration structure, or NULL to return the maximum possible capabilities of the device."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVHWFramesConstraints",
        "@_refid": "structAVHWFramesConstraints",
        "@_kindref": "compound"
       },
       "#text": "structure describing the constraints on the device, or NULL if not available."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "494",
   "@_column": "23",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "494",
   "@_declcolumn": "23"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1ad2f0fb54c481ce522095e4f27809054f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the constraints on HW frames given a device and the HW-specific\n * configuration to be used with that device.  If no HW-specific\n * configuration is provided, returns the maximum possible capabilities\n * of the device.\n *\n * @param ref a reference to the associated AVHWDeviceContext.\n * @param hwconfig a filled HW-specific configuration structure, or NULL\n *        to return the maximum possible capabilities of the device.\n * @return AVHWFramesConstraints structure describing the constraints\n *         on the device, or NULL if not available.\n */"
 },
 "av_hwframe_constraints_free": {
  "type": "void",
  "definition": "void av_hwframe_constraints_free",
  "argsstring": "(AVHWFramesConstraints **constraints)",
  "name": "av_hwframe_constraints_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVHWFramesConstraints",
     "@_refid": "structAVHWFramesConstraints",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "constraints"
  },
  "briefdescription": {
   "para": "Free an AVHWFrameConstraints structure."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "constraints"
      },
      "parameterdescription": {
       "para": "The (filled or unfilled) AVHWFrameConstraints structure."
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "502",
   "@_column": "6",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "502",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a29da7fa7ffa73266d1cbfccb116ed634",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free an AVHWFrameConstraints structure.\n *\n * @param constraints The (filled or unfilled) AVHWFrameConstraints structure.\n */"
 },
 "av_hwframe_map": {
  "type": "int",
  "definition": "int av_hwframe_map",
  "argsstring": "(AVFrame *dst, const AVFrame *src, int flags)",
  "name": "av_hwframe_map",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Map a hardware frame."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_frame_alloc()",
      "@_refid": "group__lavu__frame_1gac778d9609ac0c42d0a9445e549de172e",
      "@_kindref": "member"
     },
     "#text": "This has a number of different possible effects, depending on the format and origin of the src and dst frames. On input, src should be a usable frame with valid buffers and dst should be blank (typically as just created by). src should have an associated hwframe context, and dst may optionally have a format and associated hwframe context."
    },
    "If src was created by mapping a frame from the hwframe context of dst, then this function undoes the mapping - dst is replaced by a reference to the frame that src was originally mapped from.",
    {
     "ref": {
      "#text": "av_hwframe_ctx_create_derived()",
      "@_refid": "hwcontext_8h_1a5228c42445cffd10087f0590614edb13",
      "@_kindref": "member"
     },
     "#text": "If both src and dst have an associated hwframe context, then this function attempts to map the src frame from its hardware context to that of dst and then fill dst with appropriate data to be usable there. This will only be possible if the hwframe contexts and associated devices are compatible - given compatible devices,can be used to create a hwframe context for dst in which mapping should be possible."
    },
    "If src has a hwframe context but dst does not, then the src frame is mapped to normal memory and should thereafter be usable as a normal frame. If the format is set on dst, then the mapping will attempt to create dst with that format and fail if it is not possible. If format is unset (is AV_PIX_FMT_NONE) then dst will be mapped with whatever the most appropriate format to use is (probably the sw_format of the src hwframe context).",
    {
     "ref": {
      "#text": "AVERROR(ENOSYS)",
      "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
      "@_kindref": "member"
     },
     "#text": "A return value ofindicates that the mapping is not possible with the given arguments and hwframe setup, while other return values indicate that it failed somehow."
    },
    "On failure, the destination frame will be left blank, except for the hw_frames_ctx/format fields thay may have been set by the caller - those will be preserved as they were.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "Destination frame, to contain the mapping."
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "Source frame, to be mapped."
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "Some combination of AV_HWFRAME_MAP_* flags."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "Zero on success, negative AVERROR code on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "571",
   "@_column": "5",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "571",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a99e028453fba7e66483c2189439219d2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Map a hardware frame.\n *\n * This has a number of different possible effects, depending on the format\n * and origin of the src and dst frames.  On input, src should be a usable\n * frame with valid buffers and dst should be blank (typically as just created\n * by av_frame_alloc()).  src should have an associated hwframe context, and\n * dst may optionally have a format and associated hwframe context.\n *\n * If src was created by mapping a frame from the hwframe context of dst,\n * then this function undoes the mapping - dst is replaced by a reference to\n * the frame that src was originally mapped from.\n *\n * If both src and dst have an associated hwframe context, then this function\n * attempts to map the src frame from its hardware context to that of dst and\n * then fill dst with appropriate data to be usable there.  This will only be\n * possible if the hwframe contexts and associated devices are compatible -\n * given compatible devices, av_hwframe_ctx_create_derived() can be used to\n * create a hwframe context for dst in which mapping should be possible.\n *\n * If src has a hwframe context but dst does not, then the src frame is\n * mapped to normal memory and should thereafter be usable as a normal frame.\n * If the format is set on dst, then the mapping will attempt to create dst\n * with that format and fail if it is not possible.  If format is unset (is\n * AV_PIX_FMT_NONE) then dst will be mapped with whatever the most appropriate\n * format to use is (probably the sw_format of the src hwframe context).\n *\n * A return value of AVERROR(ENOSYS) indicates that the mapping is not\n * possible with the given arguments and hwframe setup, while other return\n * values indicate that it failed somehow.\n *\n * On failure, the destination frame will be left blank, except for the\n * hw_frames_ctx/format fields thay may have been set by the caller - those will\n * be preserved as they were.\n *\n * @param dst Destination frame, to contain the mapping.\n * @param src Source frame, to be mapped.\n * @param flags Some combination of AV_HWFRAME_MAP_* flags.\n * @return Zero on success, negative AVERROR code on failure.\n */"
 },
 "av_hwframe_ctx_create_derived": {
  "type": "int",
  "definition": "int av_hwframe_ctx_create_derived",
  "argsstring": "(AVBufferRef **derived_frame_ctx, enum AVPixelFormat format, AVBufferRef *derived_device_ctx, AVBufferRef *source_frame_ctx, int flags)",
  "name": "av_hwframe_ctx_create_derived",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "derived_frame_ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "format"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "derived_device_ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVBufferRef",
      "@_refid": "structAVBufferRef",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "source_frame_ctx"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVHWFramesContext",
      "@_refid": "structAVHWFramesContext",
      "@_kindref": "compound"
     },
     {
      "#text": "AVHWFramesContext",
      "@_refid": "structAVHWFramesContext",
      "@_kindref": "compound"
     }
    ],
    "#text": "Create and initialise anas a mapping of another existingon a different device."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_hwframe_ctx_init()",
      "@_refid": "hwcontext_8h_1a66a7e1ebc7e459ce07d3de6639ac7e38",
      "@_kindref": "member"
     },
     "#text": "should not be called after this."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "derived_frame_ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVHWFramesContext",
           "@_refid": "structAVHWFramesContext",
           "@_kindref": "compound"
          },
          "#text": "On success, a reference to the newly created."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "format"
        },
        "parameterdescription": {
         "para": "The AVPixelFormat for the derived context."
        }
       },
       {
        "parameternamelist": {
         "parametername": "derived_device_ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVHWFramesContext",
           "@_refid": "structAVHWFramesContext",
           "@_kindref": "compound"
          },
          "#text": "A reference to the device to create the newon."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "source_frame_ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVHWFramesContext",
           "@_refid": "structAVHWFramesContext",
           "@_kindref": "compound"
          },
          "#text": "A reference to an existingwhich will be mapped to the derived context."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "Some combination of AV_HWFRAME_MAP_* flags, defining the mapping parameters to apply to frames which are allocated in the derived device."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "Zero on success, negative AVERROR code on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext.h",
   "@_line": "592",
   "@_column": "5",
   "@_declfile": "libavutil/hwcontext.h",
   "@_declline": "592",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "hwcontext_8h_1a5228c42445cffd10087f0590614edb13",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create and initialise an AVHWFramesContext as a mapping of another existing\n * AVHWFramesContext on a different device.\n *\n * av_hwframe_ctx_init() should not be called after this.\n *\n * @param derived_frame_ctx  On success, a reference to the newly created\n *                           AVHWFramesContext.\n * @param format             The AVPixelFormat for the derived context.\n * @param derived_device_ctx A reference to the device to create the new\n *                           AVHWFramesContext on.\n * @param source_frame_ctx   A reference to an existing AVHWFramesContext\n *                           which will be mapped to the derived context.\n * @param flags  Some combination of AV_HWFRAME_MAP_* flags, defining the\n *               mapping parameters to apply to frames which are allocated\n *               in the derived device.\n * @return       Zero on success, negative AVERROR code on failure.\n */"
 },
 "AVCUDADeviceContextInternal": {
  "type": {
   "ref": {
    "#text": "AVCUDADeviceContextInternal",
    "@_refid": "hwcontext__cuda_8h_1ae8dacd2d18e00e926b500868fefff292",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVCUDADeviceContextInternal AVCUDADeviceContextInternal",
  "argsstring": "",
  "name": "AVCUDADeviceContextInternal",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext_cuda.h",
   "@_line": "37",
   "@_column": "42",
   "@_bodyfile": "libavutil/hwcontext_cuda.h",
   "@_bodystart": "37",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "hwcontext__cuda_8h_1ae8dacd2d18e00e926b500868fefff292",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * @file\n * An API-specific header for AV_HWDEVICE_TYPE_CUDA.\n *\n * This API supports dynamic frame pools. AVHWFramesContext.pool must return\n * AVBufferRefs whose data pointer is a CUdeviceptr.\n */"
 },
 "av_map_videotoolbox_format_to_pixfmt": {
  "type": {
   "ref": {
    "#text": "AVPixelFormat",
    "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVPixelFormat av_map_videotoolbox_format_to_pixfmt",
  "argsstring": "(uint32_t cv_fmt)",
  "name": "av_map_videotoolbox_format_to_pixfmt",
  "param": {
   "type": "uint32_t",
   "declname": "cv_fmt"
  },
  "briefdescription": {
   "para": "Convert a VideoToolbox (actually CoreVideo) format to AVPixelFormat."
  },
  "detaileddescription": {
   "para": "Returns AV_PIX_FMT_NONE if no known equivalent was found."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext_videotoolbox.h",
   "@_line": "53",
   "@_column": "19",
   "@_declfile": "libavutil/hwcontext_videotoolbox.h",
   "@_declline": "53",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "hwcontext__videotoolbox_8h_1a593e5c78abd1680dbfdc831a740f6bdc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert a VideoToolbox (actually CoreVideo) format to AVPixelFormat.\n * Returns AV_PIX_FMT_NONE if no known equivalent was found.\n */"
 },
 "av_map_videotoolbox_format_from_pixfmt": {
  "type": "uint32_t",
  "definition": "uint32_t av_map_videotoolbox_format_from_pixfmt",
  "argsstring": "(enum AVPixelFormat pix_fmt)",
  "name": "av_map_videotoolbox_format_from_pixfmt",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixelFormat",
     "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "pix_fmt"
  },
  "briefdescription": {
   "para": "Convert an AVPixelFormat to a VideoToolbox (actually CoreVideo) format."
  },
  "detaileddescription": {
   "para": "Returns 0 if no known equivalent was found."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext_videotoolbox.h",
   "@_line": "59",
   "@_column": "10",
   "@_declfile": "libavutil/hwcontext_videotoolbox.h",
   "@_declline": "59",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "hwcontext__videotoolbox_8h_1a9444c8247413737b12487dd17e1833f2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert an AVPixelFormat to a VideoToolbox (actually CoreVideo) format.\n * Returns 0 if no known equivalent was found.\n */"
 },
 "av_map_videotoolbox_format_from_pixfmt2": {
  "type": "uint32_t",
  "definition": "uint32_t av_map_videotoolbox_format_from_pixfmt2",
  "argsstring": "(enum AVPixelFormat pix_fmt, bool full_range)",
  "name": "av_map_videotoolbox_format_from_pixfmt2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "bool",
    "declname": "full_range"
   }
  ],
  "briefdescription": {
   "para": "Same as av_map_videotoolbox_format_from_pixfmt function, but can map and return full range pixel formats via a flag."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext_videotoolbox.h",
   "@_line": "65",
   "@_column": "10",
   "@_declfile": "libavutil/hwcontext_videotoolbox.h",
   "@_declline": "65",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "hwcontext__videotoolbox_8h_1ae3d27d783a51e4b5ac69f00ca20d41cc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Same as av_map_videotoolbox_format_from_pixfmt function, but can map and\n * return full range pixel formats via a flag.\n */"
 },
 "av_map_videotoolbox_chroma_loc_from_av": {
  "type": "CFStringRef",
  "definition": "CFStringRef av_map_videotoolbox_chroma_loc_from_av",
  "argsstring": "(enum AVChromaLocation loc)",
  "name": "av_map_videotoolbox_chroma_loc_from_av",
  "param": {
   "type": {
    "ref": {
     "#text": "AVChromaLocation",
     "@_refid": "pixfmt_8h_1a1f86ed1b6a420faccacf77c98db6c1ff",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "loc"
  },
  "briefdescription": {
   "para": "Convert an AVChromaLocation to a VideoToolbox/CoreVideo chroma location string."
  },
  "detaileddescription": {
   "para": "Returns 0 if no known equivalent was found."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext_videotoolbox.h",
   "@_line": "71",
   "@_column": "13",
   "@_declfile": "libavutil/hwcontext_videotoolbox.h",
   "@_declline": "71",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "hwcontext__videotoolbox_8h_1a13dcdea3aed0f9afe839426698cad060",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert an AVChromaLocation to a VideoToolbox/CoreVideo chroma location string.\n * Returns 0 if no known equivalent was found.\n */"
 },
 "av_map_videotoolbox_color_matrix_from_av": {
  "type": "CFStringRef",
  "definition": "CFStringRef av_map_videotoolbox_color_matrix_from_av",
  "argsstring": "(enum AVColorSpace space)",
  "name": "av_map_videotoolbox_color_matrix_from_av",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorSpace",
     "@_refid": "pixfmt_8h_1aff71a069509a1ad3ff54d53a1c894c85",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "space"
  },
  "briefdescription": {
   "para": "Convert an AVColorSpace to a VideoToolbox/CoreVideo color matrix string."
  },
  "detaileddescription": {
   "para": "Returns 0 if no known equivalent was found."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext_videotoolbox.h",
   "@_line": "77",
   "@_column": "13",
   "@_declfile": "libavutil/hwcontext_videotoolbox.h",
   "@_declline": "77",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "hwcontext__videotoolbox_8h_1a6fa608cae315eac7128a435106485fda",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert an AVColorSpace to a VideoToolbox/CoreVideo color matrix string.\n * Returns 0 if no known equivalent was found.\n */"
 },
 "av_map_videotoolbox_color_primaries_from_av": {
  "type": "CFStringRef",
  "definition": "CFStringRef av_map_videotoolbox_color_primaries_from_av",
  "argsstring": "(enum AVColorPrimaries pri)",
  "name": "av_map_videotoolbox_color_primaries_from_av",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorPrimaries",
     "@_refid": "pixfmt_8h_1ad384ee5a840bafd73daef08e6d9cafe7",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "pri"
  },
  "briefdescription": {
   "para": "Convert an AVColorPrimaries to a VideoToolbox/CoreVideo color primaries string."
  },
  "detaileddescription": {
   "para": "Returns 0 if no known equivalent was found."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext_videotoolbox.h",
   "@_line": "83",
   "@_column": "13",
   "@_declfile": "libavutil/hwcontext_videotoolbox.h",
   "@_declline": "83",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "hwcontext__videotoolbox_8h_1a9349840db9b6539b0d98de301f9c01d0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert an AVColorPrimaries to a VideoToolbox/CoreVideo color primaries string.\n * Returns 0 if no known equivalent was found.\n */"
 },
 "av_map_videotoolbox_color_trc_from_av": {
  "type": "CFStringRef",
  "definition": "CFStringRef av_map_videotoolbox_color_trc_from_av",
  "argsstring": "(enum AVColorTransferCharacteristic trc)",
  "name": "av_map_videotoolbox_color_trc_from_av",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorTransferCharacteristic",
     "@_refid": "pixfmt_8h_1ad4791ea14975f098b649db7fcd731ce6",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "trc"
  },
  "briefdescription": {
   "para": "Convert an AVColorTransferCharacteristic to a VideoToolbox/CoreVideo color transfer function string."
  },
  "detaileddescription": {
   "para": "Returns 0 if no known equivalent was found."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext_videotoolbox.h",
   "@_line": "90",
   "@_column": "13",
   "@_declfile": "libavutil/hwcontext_videotoolbox.h",
   "@_declline": "90",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "hwcontext__videotoolbox_8h_1af7e9c1a090a5d723b815e8865ba1118f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert an AVColorTransferCharacteristic to a VideoToolbox/CoreVideo color transfer\n * function string.\n * Returns 0 if no known equivalent was found.\n */"
 },
 "av_vt_pixbuf_set_attachments": {
  "type": "int",
  "definition": "int av_vt_pixbuf_set_attachments",
  "argsstring": "(void *log_ctx, CVPixelBufferRef pixbuf, const struct AVFrame *src)",
  "name": "av_vt_pixbuf_set_attachments",
  "param": [
   {
    "type": "void *",
    "declname": "log_ctx"
   },
   {
    "type": "CVPixelBufferRef",
    "declname": "pixbuf"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const struct*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "Update a CVPixelBufferRef's metadata to based on an."
   }
  },
  "detaileddescription": {
   "para": "Returns 0 if no known equivalent was found."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext_videotoolbox.h",
   "@_line": "96",
   "@_column": "5",
   "@_declfile": "libavutil/hwcontext_videotoolbox.h",
   "@_declline": "96",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "hwcontext__videotoolbox_8h_1a4581a6af2c07981a5c64d347eea93e58",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Update a CVPixelBufferRef's metadata to based on an AVFrame.\n * Returns 0 if no known equivalent was found.\n */"
 },
 "av_vk_frame_alloc": {
  "type": {
   "ref": {
    "#text": "AVVkFrame",
    "@_refid": "structAVVkFrame",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVVkFrame * av_vk_frame_alloc",
  "argsstring": "(void)",
  "name": "av_vk_frame_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVVkFrame",
     "@_refid": "structAVVkFrame",
     "@_kindref": "compound"
    },
    "#text": "Allocates a singleand initializes everything as 0."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "av_free()",
       "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
       "@_kindref": "member"
      },
      "#text": "Must be freed via"
     },
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext_vulkan.h",
   "@_line": "336",
   "@_column": "11",
   "@_declfile": "libavutil/hwcontext_vulkan.h",
   "@_declline": "336",
   "@_declcolumn": "11"
  },
  "@_kind": "function",
  "@_id": "hwcontext__vulkan_8h_1a098c8a938a6975e1a6ca6bf8bf913a3a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates a single AVVkFrame and initializes everything as 0.\n * @note Must be freed via av_free()\n */"
 },
 "av_vkfmt_from_pixfmt": {
  "type": "const VkFormat *",
  "definition": "const VkFormat * av_vkfmt_from_pixfmt",
  "argsstring": "(enum AVPixelFormat p)",
  "name": "av_vkfmt_from_pixfmt",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixelFormat",
     "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "p"
  },
  "briefdescription": {
   "para": "Returns the optimal per-plane Vulkan format for a given sw_format, one for each plane."
  },
  "detaileddescription": {
   "para": "Returns NULL on unsupported formats."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/hwcontext_vulkan.h",
   "@_line": "343",
   "@_column": "16",
   "@_declfile": "libavutil/hwcontext_vulkan.h",
   "@_declline": "343",
   "@_declcolumn": "16"
  },
  "@_kind": "function",
  "@_id": "hwcontext__vulkan_8h_1a3a345146457fd549803a2bce48a1a86d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Returns the optimal per-plane Vulkan format for a given sw_format,\n * one for each plane.\n * Returns NULL on unsupported formats.\n */"
 },
 "av_iamf_param_definition_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * av_iamf_param_definition_get_class",
  "argsstring": "(void)",
  "name": "av_iamf_param_definition_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "232",
   "@_column": "15",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "232",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__params_1ga85d639cead782b0394965bbf77812e44",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "    /**\n     * The duration of every subblock in the case where all subblocks, with\n     * the optional exception of the last subblock, have equal durations.\n     *\n     * Must be 0 if subblocks have different durations.\n     */"
 },
 "av_iamf_param_definition_alloc": {
  "type": {
   "ref": {
    "#text": "AVIAMFParamDefinition",
    "@_refid": "structAVIAMFParamDefinition",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVIAMFParamDefinition * av_iamf_param_definition_alloc",
  "argsstring": "(enum AVIAMFParamDefinitionType type, unsigned int nb_subblocks, size_t *size)",
  "name": "av_iamf_param_definition_alloc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIAMFParamDefinitionType",
      "@_refid": "group__lavu__iamf__params_1ga34b3dda699ae68e2aec90c41afdea4cb",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "unsigned int",
    "declname": "nb_subblocks"
   },
   {
    "type": "size_t *",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIAMFParamDefinition",
     "@_refid": "structAVIAMFParamDefinition",
     "@_kindref": "compound"
    },
    "javadoccode": "nb_subblocks",
    "#text": "Allocates memory for, plus an array ofamount of subblocks of the given type and initializes the variables."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_free()",
      "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
      "@_kindref": "member"
     },
     "#text": "Can be freed with a normalcall."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "if non-NULL, the size in bytes of the resulting data array is written here."
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "241",
   "@_column": "23",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "241",
   "@_declcolumn": "23"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__params_1gaaa3bd2f45c4fdb412177c0b09b103d56",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates memory for AVIAMFParamDefinition, plus an array of {@code nb_subblocks}\n * amount of subblocks of the given type and initializes the variables. Can be\n * freed with a normal av_free() call.\n *\n * @param size if non-NULL, the size in bytes of the resulting data array is written here.\n */"
 },
 "av_iamf_param_definition_get_subblock": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "void *"
  },
  "definition": "static av_always_inline void * av_iamf_param_definition_get_subblock",
  "argsstring": "(const AVIAMFParamDefinition *par, unsigned int idx)",
  "name": "av_iamf_param_definition_get_subblock",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVIAMFParamDefinition",
      "@_refid": "structAVIAMFParamDefinition",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "par"
   },
   {
    "type": "unsigned int",
    "declname": "idx"
   }
  ],
  "briefdescription": {
   "para": {
    "javadoccode": "idx",
    "#text": "Get the subblock at the specified."
   }
  },
  "detaileddescription": {
   "para": [
    "Must be between 0 and nb_subblocks - 1.",
    {
     "ref": {
      "#text": "param definition type",
      "@_refid": "structAVIAMFParamDefinition_1ad23396529750bb097ae718f9dc38cff2",
      "@_kindref": "member"
     },
     "#text": "Thedefines the struct type of the returned pointer."
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "251",
   "@_column": "1",
   "@_bodyfile": "libavutil/iamf.h",
   "@_bodystart": "251",
   "@_bodyend": "255"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__params_1ga07d3f4e1f77850dc56d20fa61ef07647",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the subblock at the specified {@code idx}. Must be between 0 and nb_subblocks - 1.\n *\n * The @ref AVIAMFParamDefinition.type \"param definition type\" defines\n * the struct type of the returned pointer.\n */"
 },
 "av_iamf_audio_element_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * av_iamf_audio_element_get_class",
  "argsstring": "(void)",
  "name": "av_iamf_audio_element_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "387",
   "@_column": "15",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "387",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__audio_1ga3b633299b5895f9eb04a1dfe315e6769",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "    /**\n     * Default weight value as defined in section 3.6 of IAMF.\n     */"
 },
 "av_iamf_audio_element_alloc": {
  "type": {
   "ref": {
    "#text": "AVIAMFAudioElement",
    "@_refid": "structAVIAMFAudioElement",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVIAMFAudioElement * av_iamf_audio_element_alloc",
  "argsstring": "(void)",
  "name": "av_iamf_audio_element_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIAMFAudioElement",
     "@_refid": "structAVIAMFAudioElement",
     "@_kindref": "compound"
    },
    "#text": "Allocates a, and initializes its fields with default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_iamf_audio_element_free()",
      "@_refid": "group__lavu__iamf__audio_1ga958ee581fc7fdf2349beccc27ec8299f",
      "@_kindref": "member"
     },
     "#text": "No layers are allocated. Must be freed with."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_iamf_audio_element_add_layer()",
        "@_refid": "group__lavu__iamf__audio_1ga0ca03f0e3c20b24670a88f7cb1ef656d",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "395",
   "@_column": "20",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "395",
   "@_declcolumn": "20"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__audio_1gae7d6f530919a1283c776f420f979b180",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates a AVIAMFAudioElement, and initializes its fields with default values.\n * No layers are allocated. Must be freed with av_iamf_audio_element_free().\n *\n * @see av_iamf_audio_element_add_layer()\n */"
 },
 "av_iamf_audio_element_add_layer": {
  "type": {
   "ref": {
    "#text": "AVIAMFLayer",
    "@_refid": "structAVIAMFLayer",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVIAMFLayer * av_iamf_audio_element_add_layer",
  "argsstring": "(AVIAMFAudioElement *audio_element)",
  "name": "av_iamf_audio_element_add_layer",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIAMFAudioElement",
     "@_refid": "structAVIAMFAudioElement",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "audio_element"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIAMFAudioElement",
     "@_refid": "structAVIAMFAudioElement",
     "@_kindref": "compound"
    },
    "#text": "Allocate a layer and add it to a given."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "av_iamf_audio_element_free()",
       "@_refid": "group__lavu__iamf__audio_1ga958ee581fc7fdf2349beccc27ec8299f",
       "@_kindref": "member"
      },
      {
       "#text": "AVIAMFAudioElement",
       "@_refid": "structAVIAMFAudioElement",
       "@_kindref": "compound"
      }
     ],
     "#text": "It is freed byalongside the rest of the parent."
    },
    {
     "simplesect": {
      "para": "a pointer to the allocated layer.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "404",
   "@_column": "13",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "404",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__audio_1ga0ca03f0e3c20b24670a88f7cb1ef656d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a layer and add it to a given AVIAMFAudioElement.\n * It is freed by av_iamf_audio_element_free() alongside the rest of the parent\n * AVIAMFAudioElement.\n *\n * @return a pointer to the allocated layer.\n */"
 },
 "av_iamf_audio_element_free": {
  "type": "void",
  "definition": "void av_iamf_audio_element_free",
  "argsstring": "(AVIAMFAudioElement **audio_element)",
  "name": "av_iamf_audio_element_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIAMFAudioElement",
     "@_refid": "structAVIAMFAudioElement",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "audio_element"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIAMFAudioElement",
     "@_refid": "structAVIAMFAudioElement",
     "@_kindref": "compound"
    },
    "#text": "Free anand all its contents."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "audio_element"
      },
      "parameterdescription": {
       "para": {
        "ref": {
         "#text": "AVIAMFAudioElement",
         "@_refid": "structAVIAMFAudioElement",
         "@_kindref": "compound"
        },
        "#text": "pointer to pointer to an allocated. upon return, *audio_element will be set to NULL."
       }
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "412",
   "@_column": "6",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "412",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__audio_1ga958ee581fc7fdf2349beccc27ec8299f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free an AVIAMFAudioElement and all its contents.\n *\n * @param audio_element pointer to pointer to an allocated AVIAMFAudioElement.\n *                      upon return, *audio_element will be set to NULL.\n */"
 },
 "av_iamf_mix_presentation_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * av_iamf_mix_presentation_get_class",
  "argsstring": "(void)",
  "name": "av_iamf_mix_presentation_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "631",
   "@_column": "15",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "631",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__mix_1gad93577f77238bd82c2ce8502f3563d92",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "    /**\n     * A dictionary of strings describing the mix in different languages.\n     * Must have the same amount of entries as every\n     * @ref AVIAMFSubmixElement.annotations \"Submix element annotations\",\n     * stored in the same order, and with the same key strings.\n     *\n     * @ref AVDictionaryEntry.key \"key\" is a string conforming to BCP-47\n     * that specifies the language for the string stored in\n     * @ref AVDictionaryEntry.value \"value\".\n     */"
 },
 "av_iamf_mix_presentation_alloc": {
  "type": {
   "ref": {
    "#text": "AVIAMFMixPresentation",
    "@_refid": "structAVIAMFMixPresentation",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVIAMFMixPresentation * av_iamf_mix_presentation_alloc",
  "argsstring": "(void)",
  "name": "av_iamf_mix_presentation_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIAMFMixPresentation",
     "@_refid": "structAVIAMFMixPresentation",
     "@_kindref": "compound"
    },
    "#text": "Allocates a, and initializes its fields with default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_iamf_mix_presentation_free()",
      "@_refid": "group__lavu__iamf__mix_1ga99c34b5d14760eb2b9307253612cce53",
      "@_kindref": "member"
     },
     "#text": "No submixes are allocated. Must be freed with."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_iamf_mix_presentation_add_submix()",
        "@_refid": "group__lavu__iamf__mix_1gaad1a6b8c71eb96f8d19a016ddca37ecf",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "640",
   "@_column": "23",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "640",
   "@_declcolumn": "23"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__mix_1gaa7a7e9ad085d1b1534763492212a4ce6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates a AVIAMFMixPresentation, and initializes its fields with default\n * values. No submixes are allocated.\n * Must be freed with av_iamf_mix_presentation_free().\n *\n * @see av_iamf_mix_presentation_add_submix()\n */"
 },
 "av_iamf_mix_presentation_add_submix": {
  "type": {
   "ref": {
    "#text": "AVIAMFSubmix",
    "@_refid": "structAVIAMFSubmix",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVIAMFSubmix * av_iamf_mix_presentation_add_submix",
  "argsstring": "(AVIAMFMixPresentation *mix_presentation)",
  "name": "av_iamf_mix_presentation_add_submix",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIAMFMixPresentation",
     "@_refid": "structAVIAMFMixPresentation",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "mix_presentation"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIAMFMixPresentation",
     "@_refid": "structAVIAMFMixPresentation",
     "@_kindref": "compound"
    },
    "#text": "Allocate a submix and add it to a given."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "av_iamf_mix_presentation_free()",
       "@_refid": "group__lavu__iamf__mix_1ga99c34b5d14760eb2b9307253612cce53",
       "@_kindref": "member"
      },
      {
       "#text": "AVIAMFMixPresentation",
       "@_refid": "structAVIAMFMixPresentation",
       "@_kindref": "compound"
      }
     ],
     "#text": "It is freed byalongside the rest of the parent."
    },
    {
     "simplesect": {
      "para": "a pointer to the allocated submix.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "649",
   "@_column": "14",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "649",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__mix_1gaad1a6b8c71eb96f8d19a016ddca37ecf",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a submix and add it to a given AVIAMFMixPresentation.\n * It is freed by av_iamf_mix_presentation_free() alongside the rest of the\n * parent AVIAMFMixPresentation.\n *\n * @return a pointer to the allocated submix.\n */"
 },
 "av_iamf_submix_add_element": {
  "type": {
   "ref": {
    "#text": "AVIAMFSubmixElement",
    "@_refid": "structAVIAMFSubmixElement",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVIAMFSubmixElement * av_iamf_submix_add_element",
  "argsstring": "(AVIAMFSubmix *submix)",
  "name": "av_iamf_submix_add_element",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIAMFSubmix",
     "@_refid": "structAVIAMFSubmix",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "submix"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIAMFSubmix",
     "@_refid": "structAVIAMFSubmix",
     "@_kindref": "compound"
    },
    "#text": "Allocate a submix element and add it to a given."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "av_iamf_mix_presentation_free()",
       "@_refid": "group__lavu__iamf__mix_1ga99c34b5d14760eb2b9307253612cce53",
       "@_kindref": "member"
      },
      {
       "#text": "AVIAMFSubmix",
       "@_refid": "structAVIAMFSubmix",
       "@_kindref": "compound"
      }
     ],
     "#text": "It is freed byalongside the rest of the parent."
    },
    {
     "simplesect": {
      "para": "a pointer to the allocated submix.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "658",
   "@_column": "21",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "658",
   "@_declcolumn": "21"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__mix_1gaaf3d8f67a5a8678496494c301c8a8586",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a submix element and add it to a given AVIAMFSubmix.\n * It is freed by av_iamf_mix_presentation_free() alongside the rest of the\n * parent AVIAMFSubmix.\n *\n * @return a pointer to the allocated submix.\n */"
 },
 "av_iamf_submix_add_layout": {
  "type": {
   "ref": {
    "#text": "AVIAMFSubmixLayout",
    "@_refid": "structAVIAMFSubmixLayout",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVIAMFSubmixLayout * av_iamf_submix_add_layout",
  "argsstring": "(AVIAMFSubmix *submix)",
  "name": "av_iamf_submix_add_layout",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIAMFSubmix",
     "@_refid": "structAVIAMFSubmix",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "submix"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIAMFSubmix",
     "@_refid": "structAVIAMFSubmix",
     "@_kindref": "compound"
    },
    "#text": "Allocate a submix layout and add it to a given."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "av_iamf_mix_presentation_free()",
       "@_refid": "group__lavu__iamf__mix_1ga99c34b5d14760eb2b9307253612cce53",
       "@_kindref": "member"
      },
      {
       "#text": "AVIAMFSubmix",
       "@_refid": "structAVIAMFSubmix",
       "@_kindref": "compound"
      }
     ],
     "#text": "It is freed byalongside the rest of the parent."
    },
    {
     "simplesect": {
      "para": "a pointer to the allocated submix.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "667",
   "@_column": "20",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "667",
   "@_declcolumn": "20"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__mix_1ga7ecb693b04ba889da7df6c1cbff6b95e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a submix layout and add it to a given AVIAMFSubmix.\n * It is freed by av_iamf_mix_presentation_free() alongside the rest of the\n * parent AVIAMFSubmix.\n *\n * @return a pointer to the allocated submix.\n */"
 },
 "av_iamf_mix_presentation_free": {
  "type": "void",
  "definition": "void av_iamf_mix_presentation_free",
  "argsstring": "(AVIAMFMixPresentation **mix_presentation)",
  "name": "av_iamf_mix_presentation_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVIAMFMixPresentation",
     "@_refid": "structAVIAMFMixPresentation",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "mix_presentation"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVIAMFMixPresentation",
     "@_refid": "structAVIAMFMixPresentation",
     "@_kindref": "compound"
    },
    "#text": "Free anand all its contents."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "mix_presentation"
      },
      "parameterdescription": {
       "para": {
        "ref": {
         "#text": "AVIAMFMixPresentation",
         "@_refid": "structAVIAMFMixPresentation",
         "@_kindref": "compound"
        },
        "#text": "pointer to pointer to an allocated. upon return, *mix_presentation will be set to NULL."
       }
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/iamf.h",
   "@_line": "675",
   "@_column": "6",
   "@_declfile": "libavutil/iamf.h",
   "@_declline": "675",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__iamf__mix_1ga99c34b5d14760eb2b9307253612cce53",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free an AVIAMFMixPresentation and all its contents.\n *\n * @param mix_presentation pointer to pointer to an allocated AVIAMFMixPresentation.\n *                         upon return, *mix_presentation will be set to NULL.\n */"
 },
 "av_image_fill_max_pixsteps": {
  "type": "void",
  "definition": "void av_image_fill_max_pixsteps",
  "argsstring": "(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)",
  "name": "av_image_fill_max_pixsteps",
  "param": [
   {
    "type": "int",
    "declname": "max_pixsteps",
    "array": "[4]"
   },
   {
    "type": "int",
    "declname": "max_pixstep_comps",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixFmtDescriptor",
      "@_refid": "structAVPixFmtDescriptor",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "pixdesc"
   }
  ],
  "briefdescription": {
   "para": "Compute the max pixel step for each plane of an image with a format described by pixdesc."
  },
  "detaileddescription": {
   "para": [
    "The pixel step is the distance in bytes between the first byte of the group of bytes which describe a pixel component and the first byte of the successive group in the same plane for the same component.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "max_pixsteps"
        },
        "parameterdescription": {
         "para": "an array which is filled with the max pixel step for each plane. Since a plane may contain different pixel components, the computed max_pixsteps[plane] is relative to the component in the plane with the max pixel step."
        }
       },
       {
        "parameternamelist": {
         "parametername": "max_pixstep_comps"
        },
        "parameterdescription": {
         "para": "an array which is filled with the component for each plane which has the max pixel step. May be NULL."
        }
       },
       {
        "parameternamelist": {
         "parametername": "pixdesc"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVPixFmtDescriptor",
           "@_refid": "structAVPixFmtDescriptor",
           "@_kindref": "compound"
          },
          "#text": "thefor the image, describing its format"
         }
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "53",
   "@_column": "6",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "53",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1gad3af84de3a86a9ebb71715e3c0ebf627",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Compute the max pixel step for each plane of an image with a\n * format described by pixdesc.\n *\n * The pixel step is the distance in bytes between the first byte of\n * the group of bytes which describe a pixel component and the first\n * byte of the successive group in the same plane for the same\n * component.\n *\n * @param max_pixsteps an array which is filled with the max pixel step\n * for each plane. Since a plane may contain different pixel\n * components, the computed max_pixsteps[plane] is relative to the\n * component in the plane with the max pixel step.\n * @param max_pixstep_comps an array which is filled with the component\n * for each plane which has the max pixel step. May be NULL.\n * @param pixdesc the AVPixFmtDescriptor for the image, describing its format\n */"
 },
 "av_image_get_linesize": {
  "type": "int",
  "definition": "int av_image_get_linesize",
  "argsstring": "(enum AVPixelFormat pix_fmt, int width, int plane)",
  "name": "av_image_get_linesize",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "width"
   },
   {
    "type": "int",
    "declname": "plane"
   }
  ],
  "briefdescription": {
   "para": "Compute the size of an image line with format pix_fmt and width width for the plane plane."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the computed size in bytes",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "62",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "62",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga8eddd074d5eb6a235591013675ac1055",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Compute the size of an image line with format pix_fmt and width\n * width for the plane plane.\n *\n * @return the computed size in bytes\n */"
 },
 "av_image_fill_linesizes": {
  "type": "int",
  "definition": "int av_image_fill_linesizes",
  "argsstring": "(int linesizes[4], enum AVPixelFormat pix_fmt, int width)",
  "name": "av_image_fill_linesizes",
  "param": [
   {
    "type": "int",
    "declname": "linesizes",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "width"
   }
  ],
  "briefdescription": {
   "para": "Fill plane linesizes for an image with pixel format pix_fmt and width width."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "linesizes"
       },
       "parameterdescription": {
        "para": "array to be filled with the linesize for each plane"
       }
      },
      {
       "parameternamelist": {
        "parametername": "pix_fmt"
       },
       "parameterdescription": {
        "para": "the AVPixelFormat of the image"
       }
      },
      {
       "parameternamelist": {
        "parametername": "width"
       },
       "parameterdescription": {
        "para": "width of the image in pixels"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 in case of success, a negative error code otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "73",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "73",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1gaccd7fda79188060dadb28408223946ef",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill plane linesizes for an image with pixel format pix_fmt and\n * width width.\n *\n * @param linesizes array to be filled with the linesize for each plane\n * @param pix_fmt the AVPixelFormat of the image\n * @param width width of the image in pixels\n * @return >= 0 in case of success, a negative error code otherwise\n */"
 },
 "av_image_fill_plane_sizes": {
  "type": "int",
  "definition": "int av_image_fill_plane_sizes",
  "argsstring": "(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])",
  "name": "av_image_fill_plane_sizes",
  "param": [
   {
    "type": "size_t",
    "declname": "size",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "height"
   },
   {
    "type": "const ptrdiff_t",
    "declname": "linesizes",
    "array": "[4]"
   }
  ],
  "briefdescription": {
   "para": "Fill plane sizes for an image with pixel format pix_fmt and height height."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "the array to be filled with the size of each image plane"
       }
      },
      {
       "parameternamelist": {
        "parametername": "pix_fmt"
       },
       "parameterdescription": {
        "para": "the AVPixelFormat of the image"
       }
      },
      {
       "parameternamelist": {
        "parametername": "height"
       },
       "parameterdescription": {
        "para": "height of the image in pixels"
       }
      },
      {
       "parameternamelist": {
        "parametername": "linesizes"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_image_fill_linesizes()",
          "@_refid": "group__lavu__picture_1gaccd7fda79188060dadb28408223946ef",
          "@_kindref": "member"
         },
         "#text": "the array containing the linesize for each plane, should be filled by"
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": ">= 0 in case of success, a negative error code otherwise",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_image_fill_linesizes()",
        "@_refid": "group__lavu__picture_1gaccd7fda79188060dadb28408223946ef",
        "@_kindref": "member"
       },
       "#text": "The linesize parameters have the type ptrdiff_t here, while they are int for."
      },
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "88",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "88",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga58cffc1b2c32f1f186144e81176128eb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill plane sizes for an image with pixel format pix_fmt and height height.\n *\n * @param size the array to be filled with the size of each image plane\n * @param pix_fmt the AVPixelFormat of the image\n * @param height height of the image in pixels\n * @param linesizes the array containing the linesize for each\n *        plane, should be filled by av_image_fill_linesizes()\n * @return >= 0 in case of success, a negative error code otherwise\n *\n * @note The linesize parameters have the type ptrdiff_t here, while they are\n *       int for av_image_fill_linesizes().\n */"
 },
 "av_image_fill_pointers": {
  "type": "int",
  "definition": "int av_image_fill_pointers",
  "argsstring": "(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])",
  "name": "av_image_fill_pointers",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "data",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "height"
   },
   {
    "type": "uint8_t *",
    "declname": "ptr"
   },
   {
    "type": "const int",
    "declname": "linesizes",
    "array": "[4]"
   }
  ],
  "briefdescription": {
   "para": "Fill plane data pointers for an image with pixel format pix_fmt and height height."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "pointers array to be filled with the pointer for each image plane"
       }
      },
      {
       "parameternamelist": {
        "parametername": "pix_fmt"
       },
       "parameterdescription": {
        "para": "the AVPixelFormat of the image"
       }
      },
      {
       "parameternamelist": {
        "parametername": "height"
       },
       "parameterdescription": {
        "para": "height of the image in pixels"
       }
      },
      {
       "parameternamelist": {
        "parametername": "ptr"
       },
       "parameterdescription": {
        "para": "the pointer to a buffer which will contain the image"
       }
      },
      {
       "parameternamelist": {
        "parametername": "linesizes"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_image_fill_linesizes()",
          "@_refid": "group__lavu__picture_1gaccd7fda79188060dadb28408223946ef",
          "@_kindref": "member"
         },
         "#text": "the array containing the linesize for each plane, should be filled by"
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the size in bytes required for the image buffer, a negative error code in case of failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "104",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "104",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga4513d36f527c1476e89845631d975542",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill plane data pointers for an image with pixel format pix_fmt and\n * height height.\n *\n * @param data pointers array to be filled with the pointer for each image plane\n * @param pix_fmt the AVPixelFormat of the image\n * @param height height of the image in pixels\n * @param ptr the pointer to a buffer which will contain the image\n * @param linesizes the array containing the linesize for each\n * plane, should be filled by av_image_fill_linesizes()\n * @return the size in bytes required for the image buffer, a negative\n * error code in case of failure\n */"
 },
 "av_image_alloc": {
  "type": "int",
  "definition": "int av_image_alloc",
  "argsstring": "(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)",
  "name": "av_image_alloc",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "pointers",
    "array": "[4]"
   },
   {
    "type": "int",
    "declname": "linesizes",
    "array": "[4]"
   },
   {
    "type": "int",
    "declname": "w"
   },
   {
    "type": "int",
    "declname": "h"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "align"
   }
  ],
  "briefdescription": {
   "para": "Allocate an image with size w and h and pixel format pix_fmt, and fill pointers and linesizes accordingly."
  },
  "detaileddescription": {
   "para": [
    "The allocated image buffer has to be freed by using av_freep(&pointers[0]).",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "pointers"
        },
        "parameterdescription": {
         "para": "array to be filled with the pointer for each image plane"
        }
       },
       {
        "parameternamelist": {
         "parametername": "linesizes"
        },
        "parameterdescription": {
         "para": "the array filled with the linesize for each plane"
        }
       },
       {
        "parameternamelist": {
         "parametername": "w"
        },
        "parameterdescription": {
         "para": "width of the image in pixels"
        }
       },
       {
        "parameternamelist": {
         "parametername": "h"
        },
        "parameterdescription": {
         "para": "height of the image in pixels"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pix_fmt"
        },
        "parameterdescription": {
         "para": "the AVPixelFormat of the image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "align"
        },
        "parameterdescription": {
         "para": "the value to use for buffer size alignment"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the size in bytes required for the image buffer, a negative error code in case of failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "122",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "122",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "demux__decode_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "demux__decode_8c",
   "@_startline": "226",
   "@_endline": "380"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga841e0a89a642e24141af1918a2c10448",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an image with size w and h and pixel format pix_fmt, and\n * fill pointers and linesizes accordingly.\n * The allocated image buffer has to be freed by using\n * av_freep(&pointers[0]).\n *\n * @param pointers array to be filled with the pointer for each image plane\n * @param linesizes the array filled with the linesize for each plane\n * @param w width of the image in pixels\n * @param h height of the image in pixels\n * @param pix_fmt the AVPixelFormat of the image\n * @param align the value to use for buffer size alignment\n * @return the size in bytes required for the image buffer, a negative\n * error code in case of failure\n */"
 },
 "av_image_copy_plane": {
  "type": "void",
  "definition": "void av_image_copy_plane",
  "argsstring": "(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)",
  "name": "av_image_copy_plane",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "int",
    "declname": "dst_linesize"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "src_linesize"
   },
   {
    "type": "int",
    "declname": "bytewidth"
   },
   {
    "type": "int",
    "declname": "height"
   }
  ],
  "briefdescription": {
   "para": "Copy image plane from src to dst."
  },
  "detaileddescription": {
   "para": [
    "That is, copy \"height\" number of lines of \"bytewidth\" bytes each. The first byte of each successive line is separated by *_linesize bytes.",
    "bytewidth must be contained by both absolute values of dst_linesize and src_linesize, otherwise the function behavior is undefined.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "destination plane to copy to"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dst_linesize"
        },
        "parameterdescription": {
         "para": "linesize for the image plane in dst"
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "source plane to copy from"
        }
       },
       {
        "parameternamelist": {
         "parametername": "src_linesize"
        },
        "parameterdescription": {
         "para": "linesize for the image plane in src"
        }
       },
       {
        "parameternamelist": {
         "parametername": "height"
        },
        "parameterdescription": {
         "para": "height (number of lines) of the plane"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "140",
   "@_column": "6",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "140",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga735cb949320867e9c2fffcb327d0ece2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy image plane from src to dst.\n * That is, copy \"height\" number of lines of \"bytewidth\" bytes each.\n * The first byte of each successive line is separated by *_linesize\n * bytes.\n *\n * bytewidth must be contained by both absolute values of dst_linesize\n * and src_linesize, otherwise the function behavior is undefined.\n *\n * @param dst          destination plane to copy to\n * @param dst_linesize linesize for the image plane in dst\n * @param src          source plane to copy from\n * @param src_linesize linesize for the image plane in src\n * @param height       height (number of lines) of the plane\n */"
 },
 "av_image_copy_plane_uc_from": {
  "type": "void",
  "definition": "void av_image_copy_plane_uc_from",
  "argsstring": "(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)",
  "name": "av_image_copy_plane_uc_from",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "ptrdiff_t",
    "declname": "dst_linesize"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "ptrdiff_t",
    "declname": "src_linesize"
   },
   {
    "type": "ptrdiff_t",
    "declname": "bytewidth"
   },
   {
    "type": "int",
    "declname": "height"
   }
  ],
  "briefdescription": {
   "para": "Copy image data located in uncacheable (e.g."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_image_copy_plane()",
      "@_refid": "group__lavu__picture_1ga735cb949320867e9c2fffcb327d0ece2",
      "@_kindref": "member"
     },
     "#text": "GPU mapped) memory. Where available, this function will use special functionality for reading from such memory, which may result in greatly improved performance compared to plain."
    },
    "bytewidth must be contained by both absolute values of dst_linesize and src_linesize, otherwise the function behavior is undefined.",
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "av_image_copy_plane()",
         "@_refid": "group__lavu__picture_1ga735cb949320867e9c2fffcb327d0ece2",
         "@_kindref": "member"
        },
        "#text": "The linesize parameters have the type ptrdiff_t here, while they are int for."
       },
       "@_kind": "note"
      },
      {
       "para": "On x86, the linesizes currently need to be aligned to the cacheline size (i.e. 64) to get improved performance.",
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "158",
   "@_column": "6",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "158",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga42cd459c848ba400041f527e50ddd705",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy image data located in uncacheable (e.g. GPU mapped) memory. Where\n * available, this function will use special functionality for reading from such\n * memory, which may result in greatly improved performance compared to plain\n * av_image_copy_plane().\n *\n * bytewidth must be contained by both absolute values of dst_linesize\n * and src_linesize, otherwise the function behavior is undefined.\n *\n * @note The linesize parameters have the type ptrdiff_t here, while they are\n *       int for av_image_copy_plane().\n * @note On x86, the linesizes currently need to be aligned to the cacheline\n *       size (i.e. 64) to get improved performance.\n */"
 },
 "av_image_copy": {
  "type": "void",
  "definition": "void av_image_copy",
  "argsstring": "(uint8_t *const dst_data[4], const int dst_linesizes[4], const uint8_t *const src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)",
  "name": "av_image_copy",
  "param": [
   {
    "type": "uint8_t *const",
    "declname": "dst_data",
    "array": "[4]"
   },
   {
    "type": "const int",
    "declname": "dst_linesizes",
    "array": "[4]"
   },
   {
    "type": "const uint8_t *const",
    "declname": "src_data",
    "array": "[4]"
   },
   {
    "type": "const int",
    "declname": "src_linesizes",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "width"
   },
   {
    "type": "int",
    "declname": "height"
   }
  ],
  "briefdescription": {
   "para": "Copy image in src_data to dst_data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "dst_data"
       },
       "parameterdescription": {
        "para": "destination image data buffer to copy to"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst_linesizes"
       },
       "parameterdescription": {
        "para": "linesizes for the image in dst_data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src_data"
       },
       "parameterdescription": {
        "para": "source image data buffer to copy from"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src_linesizes"
       },
       "parameterdescription": {
        "para": "linesizes for the image in src_data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "pix_fmt"
       },
       "parameterdescription": {
        "para": "the AVPixelFormat of the image"
       }
      },
      {
       "parameternamelist": {
        "parametername": "width"
       },
       "parameterdescription": {
        "para": "width of the image in pixels"
       }
      },
      {
       "parameternamelist": {
        "parametername": "height"
       },
       "parameterdescription": {
        "para": "height of the image in pixels"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "173",
   "@_column": "6",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "173",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "av_image_copy2",
   "@_refid": "group__lavu__picture_1ga911cb7d723163b88bdbbdacbeeaacf2d",
   "@_compoundref": "imgutils_8h",
   "@_startline": "184",
   "@_endline": "191"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga578575e5ab6cfab428a3c19d1a227336",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy image in src_data to dst_data.\n *\n * @param dst_data      destination image data buffer to copy to\n * @param dst_linesizes linesizes for the image in dst_data\n * @param src_data      source image data buffer to copy from\n * @param src_linesizes linesizes for the image in src_data\n * @param pix_fmt       the AVPixelFormat of the image\n * @param width         width of the image in pixels\n * @param height        height of the image in pixels\n */"
 },
 "av_image_copy2": {
  "type": "void",
  "definition": "static void av_image_copy2",
  "argsstring": "(uint8_t *const dst_data[4], const int dst_linesizes[4], uint8_t *const src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)",
  "name": "av_image_copy2",
  "param": [
   {
    "type": "uint8_t *const",
    "declname": "dst_data",
    "array": "[4]"
   },
   {
    "type": "const int",
    "declname": "dst_linesizes",
    "array": "[4]"
   },
   {
    "type": "uint8_t *const",
    "declname": "src_data",
    "array": "[4]"
   },
   {
    "type": "const int",
    "declname": "src_linesizes",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "width"
   },
   {
    "type": "int",
    "declname": "height"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_image_copy()",
     "@_refid": "group__lavu__picture_1ga578575e5ab6cfab428a3c19d1a227336",
     "@_kindref": "member"
    },
    "#text": "Wrapper aroundto workaround the limitation that the conversion from uint8_t * const * to const uint8_t * const * is not performed automatically in C."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "av_image_copy()",
       "@_refid": "group__lavu__picture_1ga578575e5ab6cfab428a3c19d1a227336",
       "@_kindref": "member"
      }
     },
     "@_kind": "see"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "184",
   "@_column": "6",
   "@_bodyfile": "libavutil/imgutils.h",
   "@_bodystart": "184",
   "@_bodyend": "191"
  },
  "referencedby": {
   "#text": "output_video_frame",
   "@_refid": "demux__decode_8c_1a62690f6eca6ce700ad0d17121eb50a57",
   "@_compoundref": "demux__decode_8c",
   "@_startline": "59",
   "@_endline": "88"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga911cb7d723163b88bdbbdacbeeaacf2d",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Wrapper around av_image_copy() to workaround the limitation\n * that the conversion from uint8_t * const * to const uint8_t * const *\n * is not performed automatically in C.\n * @see av_image_copy()\n */"
 },
 "av_image_copy_uc_from": {
  "type": "void",
  "definition": "void av_image_copy_uc_from",
  "argsstring": "(uint8_t *const dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *const src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)",
  "name": "av_image_copy_uc_from",
  "param": [
   {
    "type": "uint8_t *const",
    "declname": "dst_data",
    "array": "[4]"
   },
   {
    "type": "const ptrdiff_t",
    "declname": "dst_linesizes",
    "array": "[4]"
   },
   {
    "type": "const uint8_t *const",
    "declname": "src_data",
    "array": "[4]"
   },
   {
    "type": "const ptrdiff_t",
    "declname": "src_linesizes",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "width"
   },
   {
    "type": "int",
    "declname": "height"
   }
  ],
  "briefdescription": {
   "para": "Copy image data located in uncacheable (e.g."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_image_copy()",
      "@_refid": "group__lavu__picture_1ga578575e5ab6cfab428a3c19d1a227336",
      "@_kindref": "member"
     },
     "#text": "GPU mapped) memory. Where available, this function will use special functionality for reading from such memory, which may result in greatly improved performance compared to plain."
    },
    "The data pointers and the linesizes must be aligned to the maximum required by the CPU architecture.",
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "av_image_copy()",
         "@_refid": "group__lavu__picture_1ga578575e5ab6cfab428a3c19d1a227336",
         "@_kindref": "member"
        },
        "#text": "The linesize parameters have the type ptrdiff_t here, while they are int for."
       },
       "@_kind": "note"
      },
      {
       "para": "On x86, the linesizes currently need to be aligned to the cacheline size (i.e. 64) to get improved performance.",
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "207",
   "@_column": "6",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "207",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga74dbf395c196834f4f43b6c60aa4de44",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy image data located in uncacheable (e.g. GPU mapped) memory. Where\n * available, this function will use special functionality for reading from such\n * memory, which may result in greatly improved performance compared to plain\n * av_image_copy().\n *\n * The data pointers and the linesizes must be aligned to the maximum required\n * by the CPU architecture.\n *\n * @note The linesize parameters have the type ptrdiff_t here, while they are\n *       int for av_image_copy().\n * @note On x86, the linesizes currently need to be aligned to the cacheline\n *       size (i.e. 64) to get improved performance.\n */"
 },
 "av_image_fill_arrays": {
  "type": "int",
  "definition": "int av_image_fill_arrays",
  "argsstring": "(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)",
  "name": "av_image_fill_arrays",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "dst_data",
    "array": "[4]"
   },
   {
    "type": "int",
    "declname": "dst_linesize",
    "array": "[4]"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "width"
   },
   {
    "type": "int",
    "declname": "height"
   },
   {
    "type": "int",
    "declname": "align"
   }
  ],
  "briefdescription": {
   "para": "Setup the data pointers and linesizes based on the specified image parameters and the provided array."
  },
  "detaileddescription": {
   "para": [
    "The fields of the given image are filled in by using the src address which points to the image data buffer. Depending on the specified pixel format, one or multiple image data pointers and line sizes will be set. If a planar format is specified, several pointers will be set pointing to the different picture planes and the line sizes of the different planes will be stored in the lines_sizes array. Call with src == NULL to get the required size for the src buffer.",
    {
     "ref": {
      "#text": "av_image_alloc()",
      "@_refid": "group__lavu__picture_1ga841e0a89a642e24141af1918a2c10448",
      "@_kindref": "member"
     },
     "#text": "To allocate the buffer and fill in the dst_data and dst_linesize in one call, use."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst_data"
        },
        "parameterdescription": {
         "para": "data pointers to be filled in"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dst_linesize"
        },
        "parameterdescription": {
         "para": "linesizes for the image in dst_data to be filled in"
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "buffer which will contain or contains the actual image data, can be NULL"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pix_fmt"
        },
        "parameterdescription": {
         "para": "the pixel format of the image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "width"
        },
        "parameterdescription": {
         "para": "the width of the image in pixels"
        }
       },
       {
        "parameternamelist": {
         "parametername": "height"
        },
        "parameterdescription": {
         "para": "the height of the image in pixels"
        }
       },
       {
        "parameternamelist": {
         "parametername": "align"
        },
        "parameterdescription": {
         "para": "the value used in src for linesize alignment"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the size in bytes required for src, a negative error code in case of failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "237",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "237",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga5b6ead346a70342ae8a303c16d2b3629",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Setup the data pointers and linesizes based on the specified image\n * parameters and the provided array.\n *\n * The fields of the given image are filled in by using the src\n * address which points to the image data buffer. Depending on the\n * specified pixel format, one or multiple image data pointers and\n * line sizes will be set.  If a planar format is specified, several\n * pointers will be set pointing to the different picture planes and\n * the line sizes of the different planes will be stored in the\n * lines_sizes array. Call with src == NULL to get the required\n * size for the src buffer.\n *\n * To allocate the buffer and fill in the dst_data and dst_linesize in\n * one call, use av_image_alloc().\n *\n * @param dst_data      data pointers to be filled in\n * @param dst_linesize  linesizes for the image in dst_data to be filled in\n * @param src           buffer which will contain or contains the actual image data, can be NULL\n * @param pix_fmt       the pixel format of the image\n * @param width         the width of the image in pixels\n * @param height        the height of the image in pixels\n * @param align         the value used in src for linesize alignment\n * @return the size in bytes required for src, a negative error code\n * in case of failure\n */"
 },
 "av_image_get_buffer_size": {
  "type": "int",
  "definition": "int av_image_get_buffer_size",
  "argsstring": "(enum AVPixelFormat pix_fmt, int width, int height, int align)",
  "name": "av_image_get_buffer_size",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "width"
   },
   {
    "type": "int",
    "declname": "height"
   },
   {
    "type": "int",
    "declname": "align"
   }
  ],
  "briefdescription": {
   "para": "Return the size in bytes of the amount of data required to store an image with the given parameters."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pix_fmt"
       },
       "parameterdescription": {
        "para": "the pixel format of the image"
       }
      },
      {
       "parameternamelist": {
        "parametername": "width"
       },
       "parameterdescription": {
        "para": "the width of the image in pixels"
       }
      },
      {
       "parameternamelist": {
        "parametername": "height"
       },
       "parameterdescription": {
        "para": "the height of the image in pixels"
       }
      },
      {
       "parameternamelist": {
        "parametername": "align"
       },
       "parameterdescription": {
        "para": "the assumed linesize alignment"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the buffer size in bytes, a negative error code in case of failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "251",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "251",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "decode_write",
   "@_refid": "hw__decode_8c_1aa376d8bc0bb004de4856e8920e0f6217",
   "@_compoundref": "hw__decode_8c",
   "@_startline": "76",
   "@_endline": "146"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga24a67963c3ae0054a2a4bab35930e694",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the size in bytes of the amount of data required to store an\n * image with the given parameters.\n *\n * @param pix_fmt  the pixel format of the image\n * @param width    the width of the image in pixels\n * @param height   the height of the image in pixels\n * @param align    the assumed linesize alignment\n * @return the buffer size in bytes, a negative error code in case of failure\n */"
 },
 "av_image_copy_to_buffer": {
  "type": "int",
  "definition": "int av_image_copy_to_buffer",
  "argsstring": "(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)",
  "name": "av_image_copy_to_buffer",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "int",
    "declname": "dst_size"
   },
   {
    "type": "const uint8_t *const",
    "declname": "src_data",
    "array": "[4]"
   },
   {
    "type": "const int",
    "declname": "src_linesize",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "width"
   },
   {
    "type": "int",
    "declname": "height"
   },
   {
    "type": "int",
    "declname": "align"
   }
  ],
  "briefdescription": {
   "para": "Copy image data from an image into a buffer."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_image_get_buffer_size()",
      "@_refid": "group__lavu__picture_1ga24a67963c3ae0054a2a4bab35930e694",
      "@_kindref": "member"
     },
     "#text": "can be used to compute the required size for the buffer to fill."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "a buffer into which picture data will be copied"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dst_size"
        },
        "parameterdescription": {
         "para": "the size in bytes of dst"
        }
       },
       {
        "parameternamelist": {
         "parametername": "src_data"
        },
        "parameterdescription": {
         "para": "pointers containing the source image data"
        }
       },
       {
        "parameternamelist": {
         "parametername": "src_linesize"
        },
        "parameterdescription": {
         "para": "linesizes for the image in src_data"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pix_fmt"
        },
        "parameterdescription": {
         "para": "the pixel format of the source image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "width"
        },
        "parameterdescription": {
         "para": "the width of the source image in pixels"
        }
       },
       {
        "parameternamelist": {
         "parametername": "height"
        },
        "parameterdescription": {
         "para": "the height of the source image in pixels"
        }
       },
       {
        "parameternamelist": {
         "parametername": "align"
        },
        "parameterdescription": {
         "para": "the assumed linesize alignment for dst"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the number of bytes written to dst, or a negative value (error code) on error",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "270",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "270",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "decode_write",
   "@_refid": "hw__decode_8c_1aa376d8bc0bb004de4856e8920e0f6217",
   "@_compoundref": "hw__decode_8c",
   "@_startline": "76",
   "@_endline": "146"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga6f8576f1ef0c2d9a9f7c5ac7f9a28c52",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy image data from an image into a buffer.\n *\n * av_image_get_buffer_size() can be used to compute the required size\n * for the buffer to fill.\n *\n * @param dst           a buffer into which picture data will be copied\n * @param dst_size      the size in bytes of dst\n * @param src_data      pointers containing the source image data\n * @param src_linesize  linesizes for the image in src_data\n * @param pix_fmt       the pixel format of the source image\n * @param width         the width of the source image in pixels\n * @param height        the height of the source image in pixels\n * @param align         the assumed linesize alignment for dst\n * @return the number of bytes written to dst, or a negative value\n * (error code) on error\n */"
 },
 "av_image_check_size": {
  "type": "int",
  "definition": "int av_image_check_size",
  "argsstring": "(unsigned int w, unsigned int h, int log_offset, void *log_ctx)",
  "name": "av_image_check_size",
  "param": [
   {
    "type": "unsigned int",
    "declname": "w"
   },
   {
    "type": "unsigned int",
    "declname": "h"
   },
   {
    "type": "int",
    "declname": "log_offset"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Check if the given dimension of an image is valid, meaning that all bytes of the image can be addressed with a signed int."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "w"
       },
       "parameterdescription": {
        "para": "the width of the picture"
       }
      },
      {
       "parameternamelist": {
        "parametername": "h"
       },
       "parameterdescription": {
        "para": "the height of the picture"
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_offset"
       },
       "parameterdescription": {
        "para": "the offset to sum to the log level for logging with log_ctx"
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_ctx"
       },
       "parameterdescription": {
        "para": "the parent logging context, it may be NULL"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 if valid, a negative error code otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "284",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "284",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga3a867b6180ddad1e0c382ef0c5940b8e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if the given dimension of an image is valid, meaning that all\n * bytes of the image can be addressed with a signed int.\n *\n * @param w the width of the picture\n * @param h the height of the picture\n * @param log_offset the offset to sum to the log level for logging with log_ctx\n * @param log_ctx the parent logging context, it may be NULL\n * @return >= 0 if valid, a negative error code otherwise\n */"
 },
 "av_image_check_size2": {
  "type": "int",
  "definition": "int av_image_check_size2",
  "argsstring": "(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)",
  "name": "av_image_check_size2",
  "param": [
   {
    "type": "unsigned int",
    "declname": "w"
   },
   {
    "type": "unsigned int",
    "declname": "h"
   },
   {
    "type": "int64_t",
    "declname": "max_pixels"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int",
    "declname": "log_offset"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Check if the given dimension of an image is valid, meaning that all bytes of a plane of an image with the specified pix_fmt can be addressed with a signed int."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "w"
       },
       "parameterdescription": {
        "para": "the width of the picture"
       }
      },
      {
       "parameternamelist": {
        "parametername": "h"
       },
       "parameterdescription": {
        "para": "the height of the picture"
       }
      },
      {
       "parameternamelist": {
        "parametername": "max_pixels"
       },
       "parameterdescription": {
        "para": "the maximum number of pixels the user wants to accept"
       }
      },
      {
       "parameternamelist": {
        "parametername": "pix_fmt"
       },
       "parameterdescription": {
        "para": "the pixel format, can be AV_PIX_FMT_NONE if unknown."
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_offset"
       },
       "parameterdescription": {
        "para": "the offset to sum to the log level for logging with log_ctx"
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_ctx"
       },
       "parameterdescription": {
        "para": "the parent logging context, it may be NULL"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 if valid, a negative error code otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "299",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "299",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1gac75c3c0dfc82367b2be34e99384927c2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if the given dimension of an image is valid, meaning that all\n * bytes of a plane of an image with the specified pix_fmt can be addressed\n * with a signed int.\n *\n * @param w the width of the picture\n * @param h the height of the picture\n * @param max_pixels the maximum number of pixels the user wants to accept\n * @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown.\n * @param log_offset the offset to sum to the log level for logging with log_ctx\n * @param log_ctx the parent logging context, it may be NULL\n * @return >= 0 if valid, a negative error code otherwise\n */"
 },
 "av_image_check_sar": {
  "type": "int",
  "definition": "int av_image_check_sar",
  "argsstring": "(unsigned int w, unsigned int h, AVRational sar)",
  "name": "av_image_check_sar",
  "param": [
   {
    "type": "unsigned int",
    "declname": "w"
   },
   {
    "type": "unsigned int",
    "declname": "h"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "sar"
   }
  ],
  "briefdescription": {
   "para": "Check if the given sample aspect ratio of an image is valid."
  },
  "detaileddescription": {
   "para": [
    "It is considered invalid if the denominator is 0 or if applying the ratio to the image size would make the smaller dimension less than 1. If the sar numerator is 0, it is considered unknown and will return as valid.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "w"
        },
        "parameterdescription": {
         "para": "width of the image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "h"
        },
        "parameterdescription": {
         "para": "height of the image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "sar"
        },
        "parameterdescription": {
         "para": "sample aspect ratio of the image"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 if valid, a negative AVERROR code otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "313",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "313",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1gada0f86cd0051ff8b9eef214e83e7ad1f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if the given sample aspect ratio of an image is valid.\n *\n * It is considered invalid if the denominator is 0 or if applying the ratio\n * to the image size would make the smaller dimension less than 1. If the\n * sar numerator is 0, it is considered unknown and will return as valid.\n *\n * @param w width of the image\n * @param h height of the image\n * @param sar sample aspect ratio of the image\n * @return 0 if valid, a negative AVERROR code otherwise\n */"
 },
 "av_image_fill_black": {
  "type": "int",
  "definition": "int av_image_fill_black",
  "argsstring": "(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)",
  "name": "av_image_fill_black",
  "param": [
   {
    "type": "uint8_t *const",
    "declname": "dst_data",
    "array": "[4]"
   },
   {
    "type": "const ptrdiff_t",
    "declname": "dst_linesize",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVColorRange",
      "@_refid": "pixfmt_8h_1a3da0bf691418bc22c4bcbe6583ad589a",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "range"
   },
   {
    "type": "int",
    "declname": "width"
   },
   {
    "type": "int",
    "declname": "height"
   }
  ],
  "briefdescription": {
   "para": "Overwrite the image data with black."
  },
  "detaileddescription": {
   "para": [
    "This is suitable for filling a sub-rectangle of an image, meaning the padding between the right most pixel and the left most pixel on the next line will not be overwritten. For some formats, the image size might be rounded up due to inherent alignment.",
    "If the pixel format has alpha, the alpha is cleared to opaque.",
    "This can return an error if the pixel format is not supported. Normally, all non-hwaccel pixel formats should be supported.",
    "Passing NULL for dst_data is allowed. Then the function returns whether the operation would have succeeded. (It can return an error if the pix_fmt is not supported.)",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst_data"
        },
        "parameterdescription": {
         "para": "data pointers to destination image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dst_linesize"
        },
        "parameterdescription": {
         "para": "linesizes for the destination image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pix_fmt"
        },
        "parameterdescription": {
         "para": "the pixel format of the image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "range"
        },
        "parameterdescription": {
         "para": "the color range of the image (important for colorspaces such as YUV)"
        }
       },
       {
        "parameternamelist": {
         "parametername": "width"
        },
        "parameterdescription": {
         "para": "the width of the image in pixels"
        }
       },
       {
        "parameternamelist": {
         "parametername": "height"
        },
        "parameterdescription": {
         "para": "the height of the image in pixels"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 if the image data was cleared, a negative AVERROR code otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "338",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "338",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga3fa8e484cc214e8c7b9026825b5f4078",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Overwrite the image data with black. This is suitable for filling a\n * sub-rectangle of an image, meaning the padding between the right most pixel\n * and the left most pixel on the next line will not be overwritten. For some\n * formats, the image size might be rounded up due to inherent alignment.\n *\n * If the pixel format has alpha, the alpha is cleared to opaque.\n *\n * This can return an error if the pixel format is not supported. Normally, all\n * non-hwaccel pixel formats should be supported.\n *\n * Passing NULL for dst_data is allowed. Then the function returns whether the\n * operation would have succeeded. (It can return an error if the pix_fmt is\n * not supported.)\n *\n * @param dst_data      data pointers to destination image\n * @param dst_linesize  linesizes for the destination image\n * @param pix_fmt       the pixel format of the image\n * @param range         the color range of the image (important for colorspaces such as YUV)\n * @param width         the width of the image in pixels\n * @param height        the height of the image in pixels\n * @return 0 if the image data was cleared, a negative AVERROR code otherwise\n */"
 },
 "av_image_fill_color": {
  "type": "int",
  "definition": "int av_image_fill_color",
  "argsstring": "(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, const uint32_t color[4], int width, int height, int flags)",
  "name": "av_image_fill_color",
  "param": [
   {
    "type": "uint8_t *const",
    "declname": "dst_data",
    "array": "[4]"
   },
   {
    "type": "const ptrdiff_t",
    "declname": "dst_linesize",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "const uint32_t",
    "declname": "color",
    "array": "[4]"
   },
   {
    "type": "int",
    "declname": "width"
   },
   {
    "type": "int",
    "declname": "height"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Overwrite the image data with a color."
  },
  "detaileddescription": {
   "para": [
    "This is suitable for filling a sub-rectangle of an image, meaning the padding between the right most pixel and the left most pixel on the next line will not be overwritten. For some formats, the image size might be rounded up due to inherent alignment.",
    "If the pixel format has alpha, it is also replaced. Color component values are interpreted as native integers (or intfloats) regardless of actual pixel format endianness.",
    "This can return an error if the pixel format is not supported. Normally, all non-hwaccel pixel formats should be supported.",
    "Passing NULL for dst_data is allowed. Then the function returns whether the operation would have succeeded. (It can return an error if the pix_fmt is not supported.)",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst_data"
        },
        "parameterdescription": {
         "para": "data pointers to destination image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dst_linesize"
        },
        "parameterdescription": {
         "para": "linesizes for the destination image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pix_fmt"
        },
        "parameterdescription": {
         "para": "the pixel format of the image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "color"
        },
        "parameterdescription": {
         "para": "the color components to be used for the fill"
        }
       },
       {
        "parameternamelist": {
         "parametername": "width"
        },
        "parameterdescription": {
         "para": "the width of the image in pixels"
        }
       },
       {
        "parameternamelist": {
         "parametername": "height"
        },
        "parameterdescription": {
         "para": "the height of the image in pixels"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "currently unused"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 if the image data was filled, a negative AVERROR code otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/imgutils.h",
   "@_line": "368",
   "@_column": "5",
   "@_declfile": "libavutil/imgutils.h",
   "@_declline": "368",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__picture_1ga58595f4ce6255e7b147b4b48ac9d96a4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Overwrite the image data with a color. This is suitable for filling a\n * sub-rectangle of an image, meaning the padding between the right most pixel\n * and the left most pixel on the next line will not be overwritten. For some\n * formats, the image size might be rounded up due to inherent alignment.\n *\n * If the pixel format has alpha, it is also replaced. Color component values\n * are interpreted as native integers (or intfloats) regardless of actual pixel\n * format endianness.\n *\n * This can return an error if the pixel format is not supported. Normally, all\n * non-hwaccel pixel formats should be supported.\n *\n * Passing NULL for dst_data is allowed. Then the function returns whether the\n * operation would have succeeded. (It can return an error if the pix_fmt is\n * not supported.)\n *\n * @param dst_data      data pointers to destination image\n * @param dst_linesize  linesizes for the destination image\n * @param pix_fmt       the pixel format of the image\n * @param color         the color components to be used for the fill\n * @param width         the width of the image in pixels\n * @param height        the height of the image in pixels\n * @param flags         currently unused\n * @return 0 if the image data was filled, a negative AVERROR code otherwise\n */"
 },
 "av_int2float": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "float"
  },
  "definition": "static av_always_inline float av_int2float",
  "argsstring": "(uint32_t i)",
  "name": "av_int2float",
  "param": {
   "type": "uint32_t",
   "declname": "i"
  },
  "briefdescription": {
   "para": "Reinterpret a 32-bit integer as a float."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/intfloat.h",
   "@_line": "40",
   "@_column": "31",
   "@_bodyfile": "libavutil/intfloat.h",
   "@_bodystart": "40",
   "@_bodyend": "45"
  },
  "@_kind": "function",
  "@_id": "intfloat_8h_1a2dc216ec0441d07d650e42d7bdb94b00",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reinterpret a 32-bit integer as a float.\n */"
 },
 "av_float2int": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "uint32_t"
  },
  "definition": "static av_always_inline uint32_t av_float2int",
  "argsstring": "(float f)",
  "name": "av_float2int",
  "param": {
   "type": "float",
   "declname": "f"
  },
  "briefdescription": {
   "para": "Reinterpret a float as a 32-bit integer."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/intfloat.h",
   "@_line": "50",
   "@_column": "34",
   "@_bodyfile": "libavutil/intfloat.h",
   "@_bodystart": "50",
   "@_bodyend": "55"
  },
  "@_kind": "function",
  "@_id": "intfloat_8h_1a1219ed71d83c37c34558df54778e8b46",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reinterpret a float as a 32-bit integer.\n */"
 },
 "av_int2double": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "double"
  },
  "definition": "static av_always_inline double av_int2double",
  "argsstring": "(uint64_t i)",
  "name": "av_int2double",
  "param": {
   "type": "uint64_t",
   "declname": "i"
  },
  "briefdescription": {
   "para": "Reinterpret a 64-bit integer as a double."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/intfloat.h",
   "@_line": "60",
   "@_column": "32",
   "@_bodyfile": "libavutil/intfloat.h",
   "@_bodystart": "60",
   "@_bodyend": "65"
  },
  "@_kind": "function",
  "@_id": "intfloat_8h_1af4532dd95ee81d7dd271fd1bffade817",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reinterpret a 64-bit integer as a double.\n */"
 },
 "av_double2int": {
  "type": {
   "ref": {
    "#text": "av_always_inline",
    "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
    "@_kindref": "member"
   },
   "#text": "uint64_t"
  },
  "definition": "static av_always_inline uint64_t av_double2int",
  "argsstring": "(double f)",
  "name": "av_double2int",
  "param": {
   "type": "double",
   "declname": "f"
  },
  "briefdescription": {
   "para": "Reinterpret a double as a 64-bit integer."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/intfloat.h",
   "@_line": "70",
   "@_column": "34",
   "@_bodyfile": "libavutil/intfloat.h",
   "@_bodystart": "70",
   "@_bodyend": "75"
  },
  "@_kind": "function",
  "@_id": "intfloat_8h_1ae3b5f3db537273543dfcce45816ba02a",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reinterpret a double as a 64-bit integer.\n */"
 },
 "av_alias": {
  "type": {
   "ref": {
    "#text": "unaligned_64",
    "@_refid": "unionunaligned__64",
    "@_kindref": "compound"
   },
   "#text": "union"
  },
  "definition": "union unaligned_16 av_alias",
  "argsstring": "",
  "name": "av_alias",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/intreadwrite.h",
   "@_line": "218",
   "@_column": "29"
  },
  "@_kind": "variable",
  "@_id": "intreadwrite_8h_1ae7fb094d0e833b9afe387f7283dbbad3",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/*\n * Define AV_[RW]N helper macros to simplify definitions not provided\n * by per-arch headers.\n */"
 },
 "av_jni_set_java_vm": {
  "type": "int",
  "definition": "int av_jni_set_java_vm",
  "argsstring": "(void *vm, void *log_ctx)",
  "name": "av_jni_set_java_vm",
  "param": [
   {
    "type": "void *",
    "declname": "vm"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/jni.h",
   "@_line": "36",
   "@_column": "5",
   "@_declfile": "libavcodec/jni.h",
   "@_declline": "36",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "jni_8h_1a76eef69bbf6f59433855cb42a55fd5bb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/*\n * Manually set a Java virtual machine which will be used to retrieve the JNI\n * environment. Once a Java VM is set it cannot be changed afterwards, meaning\n * you can call multiple times av_jni_set_java_vm with the same Java VM pointer\n * however it will error out if you try to set a different Java VM.\n *\n * @param vm Java virtual machine\n * @param log_ctx context used for logging, can be NULL\n * @return 0 on success, < 0 otherwise\n */"
 },
 "av_jni_get_java_vm": {
  "type": "void *",
  "definition": "void * av_jni_get_java_vm",
  "argsstring": "(void *log_ctx)",
  "name": "av_jni_get_java_vm",
  "param": {
   "type": "void *",
   "declname": "log_ctx"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/jni.h",
   "@_line": "44",
   "@_column": "6",
   "@_declfile": "libavcodec/jni.h",
   "@_declline": "44",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "jni_8h_1ad07c79d829259a1a893aeb859c7ad404",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/*\n * Get the Java virtual machine which has been set with av_jni_set_java_vm.\n *\n * @param vm Java virtual machine\n * @return a pointer to the Java virtual machine\n */"
 },
 "av_jni_set_android_app_ctx": {
  "type": "int",
  "definition": "int av_jni_set_android_app_ctx",
  "argsstring": "(void *app_ctx, void *log_ctx)",
  "name": "av_jni_set_android_app_ctx",
  "param": [
   {
    "type": "void *",
    "declname": "app_ctx"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/jni.h",
   "@_line": "55",
   "@_column": "5",
   "@_declfile": "libavcodec/jni.h",
   "@_declline": "55",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "jni_8h_1a2b95ddfaa5ac3e3d643d0df8fe30bb87",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/*\n * Set the Android application context which will be used to retrieve the Android\n * content resolver to handle content uris.\n *\n * This function is only available on Android.\n *\n * @param app_ctx global JNI reference to the Android application context\n * @return 0 on success, < 0 otherwise\n */"
 },
 "av_jni_get_android_app_ctx": {
  "type": "void *",
  "definition": "void * av_jni_get_android_app_ctx",
  "argsstring": "(void)",
  "name": "av_jni_get_android_app_ctx",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/jni.h",
   "@_line": "65",
   "@_column": "6",
   "@_declfile": "libavcodec/jni.h",
   "@_declline": "65",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "jni_8h_1a53cbe217af7d64ac839da77f60d601e7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/*\n * Get the Android application context that has been set with\n * av_jni_set_android_app_ctx.\n *\n * This function is only available on Android.\n *\n * @return a pointer the the Android application context\n */"
 },
 "av_lfg_init": {
  "type": "void",
  "definition": "void av_lfg_init",
  "argsstring": "(AVLFG *c, unsigned int seed)",
  "name": "av_lfg_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVLFG",
      "@_refid": "structAVLFG",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "c"
   },
   {
    "type": "unsigned int",
    "declname": "seed"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/lfg.h",
   "@_line": "38",
   "@_column": "6",
   "@_declfile": "libavutil/lfg.h",
   "@_declline": "38",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "lfg_8h_1a43003943a9712bf75f2aae140ee01ab3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Context structure for the Lagged Fibonacci PRNG.\n * The exact layout, types and content of this struct may change and should\n * not be accessed directly. Only its `sizeof()` is guaranteed to stay the same\n * to allow easy instanciation.\n */"
 },
 "av_lfg_init_from_data": {
  "type": "int",
  "definition": "int av_lfg_init_from_data",
  "argsstring": "(AVLFG *c, const uint8_t *data, unsigned int length)",
  "name": "av_lfg_init_from_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVLFG",
      "@_refid": "structAVLFG",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "c"
   },
   {
    "type": "const uint8_t *",
    "declname": "data"
   },
   {
    "type": "unsigned int",
    "declname": "length"
   }
  ],
  "briefdescription": {
   "para": "Seed the state of the ALFG using binary data."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "0 on success, negative value (AVERROR) on failure.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/lfg.h",
   "@_line": "45",
   "@_column": "5",
   "@_declfile": "libavutil/lfg.h",
   "@_declline": "45",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "lfg_8h_1ac9dd83b5b0c2559217e3da92cbbfc330",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Seed the state of the ALFG using binary data.\n *\n * @return 0 on success, negative value (AVERROR) on failure.\n */"
 },
 "av_lfg_get": {
  "type": "unsigned int",
  "definition": "static unsigned int av_lfg_get",
  "argsstring": "(AVLFG *c)",
  "name": "av_lfg_get",
  "param": {
   "type": {
    "ref": {
     "#text": "AVLFG",
     "@_refid": "structAVLFG",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "c"
  },
  "briefdescription": {
   "para": "Get the next random unsigned 32-bit number using an ALFG."
  },
  "detaileddescription": {
   "para": "Please also consider a simple LCG like state= state*1664525+1013904223, it may be good enough and faster for your specific use case."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/lfg.h",
   "@_line": "53",
   "@_column": "28",
   "@_bodyfile": "libavutil/lfg.h",
   "@_bodystart": "53",
   "@_bodyend": "57"
  },
  "@_kind": "function",
  "@_id": "lfg_8h_1a58feb242e560adee0b7a16e11cce43e9",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the next random unsigned 32-bit number using an ALFG.\n *\n * Please also consider a simple LCG like state= state*1664525+1013904223,\n * it may be good enough and faster for your specific use case.\n */"
 },
 "av_mlfg_get": {
  "type": "unsigned int",
  "definition": "static unsigned int av_mlfg_get",
  "argsstring": "(AVLFG *c)",
  "name": "av_mlfg_get",
  "param": {
   "type": {
    "ref": {
     "#text": "AVLFG",
     "@_refid": "structAVLFG",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "c"
  },
  "briefdescription": {
   "para": "Get the next random unsigned 32-bit number using a MLFG."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "av_lfg_get()",
     "@_refid": "lfg_8h_1a58feb242e560adee0b7a16e11cce43e9",
     "@_kindref": "member"
    },
    "#text": "Please also considerabove, it is faster."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/lfg.h",
   "@_line": "64",
   "@_column": "28",
   "@_bodyfile": "libavutil/lfg.h",
   "@_bodystart": "64",
   "@_bodyend": "70"
  },
  "@_kind": "function",
  "@_id": "lfg_8h_1a6f7ac2501d6740c557ceedf53588df0d",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the next random unsigned 32-bit number using a MLFG.\n *\n * Please also consider av_lfg_get() above, it is faster.\n */"
 },
 "av_bmg_get": {
  "type": "void",
  "definition": "void av_bmg_get",
  "argsstring": "(AVLFG *lfg, double out[2])",
  "name": "av_bmg_get",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVLFG",
      "@_refid": "structAVLFG",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "lfg"
   },
   {
    "type": "double",
    "declname": "out",
    "array": "[2]"
   }
  ],
  "briefdescription": {
   "para": "Get the next two numbers generated by a Box-Muller Gaussian generator using the random numbers issued by lfg."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "lfg"
       },
       "parameterdescription": {
        "para": "pointer to the contex structure"
       }
      },
      {
       "parameternamelist": {
        "parametername": "out"
       },
       "parameterdescription": {
        "para": "array where the two generated numbers are placed"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/lfg.h",
   "@_line": "79",
   "@_column": "6",
   "@_declfile": "libavutil/lfg.h",
   "@_declline": "79",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "lfg_8h_1a64cbf8ac9c59912b4fddae8286eb8303",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the next two numbers generated by a Box-Muller Gaussian\n * generator using the random numbers issued by lfg.\n *\n * @param lfg pointer to the contex structure\n * @param out array where the two generated numbers are placed\n */"
 },
 "av_log": {
  "type": "void",
  "definition": "void av_log",
  "argsstring": "(void *avcl, int level, const char *fmt,...) av_printf_format(3",
  "name": "av_log",
  "param": [
   {
    "type": "void *",
    "declname": "avcl"
   },
   {
    "type": "int",
    "declname": "level"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "..."
   }
  ],
  "briefdescription": {
   "para": "Send the specified message to the log if the level is less than or equal to the current av_log_level."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "av_log_set_callback",
       "@_refid": "group__lavu__log_1ga14034761faf581a8b9ed6ef19b313708",
       "@_kindref": "member"
      }
     },
     "@_kind": "see"
    },
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "avcl"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "A pointer to an arbitrary struct of which the first field is a pointer to anstruct or NULL if general log."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "level"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "Logging Constant",
          "@_refid": "group__lavu__log__constants",
          "@_kindref": "compound"
         },
         "#text": "The importance level of the message expressed using a."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "fmt"
       },
       "parameterdescription": {
        "para": "The format string (printf-compatible) that specifies how subsequent arguments are converted to output."
       }
      }
     ],
     "@_kind": "param"
    },
    "#text": "By default, all logging messages are sent to stderr. This behavior can be altered by setting a different logging callback function."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "238",
   "@_column": "6"
  },
  "referencedby": [
   {
    "#text": "encode_write_frame",
    "@_refid": "transcode_8c_1a0911d751b11fdf9780825b79badfae91",
    "@_compoundref": "transcode_8c",
    "@_startline": "432",
    "@_endline": "471"
   },
   {
    "#text": "filter_encode_write_frame",
    "@_refid": "transcode_8c_1a255192428438daf73b9f8060c0815712",
    "@_compoundref": "transcode_8c",
    "@_startline": "473",
    "@_endline": "511"
   },
   {
    "#text": "flush_encoder",
    "@_refid": "transcode_8c_1ad55ba3d9c6ebe490eb8766a91b627d3e",
    "@_compoundref": "transcode_8c",
    "@_startline": "513",
    "@_endline": "521"
   },
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filter_graph",
    "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "60",
    "@_endline": "208"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   },
   {
    "#text": "list_op",
    "@_refid": "avio__list__dir_8c_1ad0826d7847655ff15d32ecb58bfc625b",
    "@_compoundref": "avio__list__dir_8c",
    "@_startline": "64",
    "@_endline": "110"
   },
   {
    "#text": "main",
    "@_refid": "decode__filter__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "217",
    "@_endline": "296"
   },
   {
    "#text": "open_input_file",
    "@_refid": "decode__filter__audio_8c_1abd04bf1a933d4d2698482f4949c61fed",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "52",
    "@_endline": "88"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
    "@_compoundref": "transcode_8c",
    "@_startline": "128",
    "@_endline": "242"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__log_1gabd386ffd4b27637cf34e98d5d1a6e8ae",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Send the specified message to the log if the level is less than or equal\n * to the current av_log_level. By default, all logging messages are sent to\n * stderr. This behavior can be altered by setting a different logging callback\n * function.\n * @see av_log_set_callback\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n *        pointer to an AVClass struct or NULL if general log.\n * @param level The importance level of the message expressed using a @ref\n *        lavu_log_constants \"Logging Constant\".\n * @param fmt The format string (printf-compatible) that specifies how\n *        subsequent arguments are converted to output.\n */"
 },
 "av_log_once": {
  "type": "void void",
  "definition": "void void av_log_once",
  "argsstring": "(void *avcl, int initial_level, int subsequent_level, int *state, const char *fmt,...) av_printf_format(5",
  "name": "av_log_once",
  "param": [
   {
    "type": "void *",
    "declname": "avcl"
   },
   {
    "type": "int",
    "declname": "initial_level"
   },
   {
    "type": "int",
    "declname": "subsequent_level"
   },
   {
    "type": "int *",
    "declname": "state"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "..."
   }
  ],
  "briefdescription": {
   "para": "Send the specified message to the log once with the initial_level and then with the subsequent_level."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "av_log",
       "@_refid": "group__lavu__log_1gabd386ffd4b27637cf34e98d5d1a6e8ae",
       "@_kindref": "member"
      }
     },
     "@_kind": "see"
    },
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "avcl"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "A pointer to an arbitrary struct of which the first field is a pointer to anstruct or NULL if general log."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "initial_level"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "Logging Constant",
          "@_refid": "group__lavu__log__constants",
          "@_kindref": "compound"
         },
         "#text": "importance level of the message expressed using afor the first occurance."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "subsequent_level"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "Logging Constant",
          "@_refid": "group__lavu__log__constants",
          "@_kindref": "compound"
         },
         "#text": "importance level of the message expressed using aafter the first occurance."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "fmt"
       },
       "parameterdescription": {
        "para": "The format string (printf-compatible) that specifies how subsequent arguments are converted to output."
       }
      },
      {
       "parameternamelist": {
        "parametername": "state"
       },
       "parameterdescription": {
        "para": "a variable to keep trak of if a message has already been printed this must be initialized to 0 before the first use. The same state must not be accessed by 2 Threads simultaneously."
       }
      }
     ],
     "@_kind": "param"
    },
    "#text": "By default, all logging messages are sent to stderr. This behavior can be altered by setting a different logging callback function."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "259",
   "@_column": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1gaf2d7ec50a1d2ceb6395062b46fd4dac5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Send the specified message to the log once with the initial_level and then with\n * the subsequent_level. By default, all logging messages are sent to\n * stderr. This behavior can be altered by setting a different logging callback\n * function.\n * @see av_log\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n *        pointer to an AVClass struct or NULL if general log.\n * @param initial_level importance level of the message expressed using a @ref\n *        lavu_log_constants \"Logging Constant\" for the first occurance.\n * @param subsequent_level importance level of the message expressed using a @ref\n *        lavu_log_constants \"Logging Constant\" after the first occurance.\n * @param fmt The format string (printf-compatible) that specifies how\n *        subsequent arguments are converted to output.\n * @param state a variable to keep trak of if a message has already been printed\n *        this must be initialized to 0 before the first use. The same state\n *        must not be accessed by 2 Threads simultaneously.\n */"
 },
 "av_vlog": {
  "type": "void void void",
  "definition": "void void void av_vlog",
  "argsstring": "(void *avcl, int level, const char *fmt, va_list vl)",
  "name": "av_vlog",
  "param": [
   {
    "type": "void *",
    "declname": "avcl"
   },
   {
    "type": "int",
    "declname": "level"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "va_list",
    "declname": "vl"
   }
  ],
  "briefdescription": {
   "para": "Send the specified message to the log if the level is less than or equal to the current av_log_level."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "av_log_set_callback",
       "@_refid": "group__lavu__log_1ga14034761faf581a8b9ed6ef19b313708",
       "@_kindref": "member"
      }
     },
     "@_kind": "see"
    },
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "avcl"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "A pointer to an arbitrary struct of which the first field is a pointer to anstruct."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "level"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "Logging Constant",
          "@_refid": "group__lavu__log__constants",
          "@_kindref": "compound"
         },
         "#text": "The importance level of the message expressed using a."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "fmt"
       },
       "parameterdescription": {
        "para": "The format string (printf-compatible) that specifies how subsequent arguments are converted to output."
       }
      },
      {
       "parameternamelist": {
        "parametername": "vl"
       },
       "parameterdescription": {
        "para": "The arguments referenced by the format string."
       }
      }
     ],
     "@_kind": "param"
    },
    "#text": "By default, all logging messages are sent to stderr. This behavior can be altered by setting a different logging callback function."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "277",
   "@_column": "6",
   "@_declfile": "libavutil/log.h",
   "@_declline": "277",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1ga5e764a9f07a7c3267ceeaa2cf7b571a9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Send the specified message to the log if the level is less than or equal\n * to the current av_log_level. By default, all logging messages are sent to\n * stderr. This behavior can be altered by setting a different logging callback\n * function.\n * @see av_log_set_callback\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n *        pointer to an AVClass struct.\n * @param level The importance level of the message expressed using a @ref\n *        lavu_log_constants \"Logging Constant\".\n * @param fmt The format string (printf-compatible) that specifies how\n *        subsequent arguments are converted to output.\n * @param vl The arguments referenced by the format string.\n */"
 },
 "av_log_get_level": {
  "type": "int",
  "definition": "int av_log_get_level",
  "argsstring": "(void)",
  "name": "av_log_get_level",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Get the current log level."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "Logging Constants",
        "@_refid": "group__lavu__log__constants",
        "@_kindref": "compound"
       }
      },
      "@_kind": "see"
     },
     {
      "para": "Current log level",
      "@_kind": "return"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "286",
   "@_column": "5",
   "@_declfile": "libavutil/log.h",
   "@_declline": "286",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1gae8ada5cc5722548d8698650b05207904",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the current log level\n *\n * @see lavu_log_constants\n *\n * @return Current log level\n */"
 },
 "av_log_set_level": {
  "type": "void",
  "definition": "void av_log_set_level",
  "argsstring": "(int level)",
  "name": "av_log_set_level",
  "param": {
   "type": "int",
   "declname": "level"
  },
  "briefdescription": {
   "para": "Set the log level."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "Logging Constants",
       "@_refid": "group__lavu__log__constants",
       "@_kindref": "compound"
      }
     },
     "@_kind": "see"
    },
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "level"
      },
      "parameterdescription": {
       "para": "Logging level"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "295",
   "@_column": "6",
   "@_declfile": "libavutil/log.h",
   "@_declline": "295",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "avio__list__dir_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "avio__list__dir_8c",
   "@_startline": "119",
   "@_endline": "137"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1ga1fd32c74db581e3e2e7f35d277bb1e24",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set the log level\n *\n * @see lavu_log_constants\n *\n * @param level Logging level\n */"
 },
 "av_log_set_callback": {
  "type": "void",
  "definition": "void av_log_set_callback",
  "argsstring": "(void(*callback)(void *, int, const char *, va_list))",
  "name": "av_log_set_callback",
  "param": {
   "type": "void(*)(void *, int, const char *, va_list)",
   "declname": "callback"
  },
  "briefdescription": {
   "para": "Set the logging callback."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": "The callback must be thread safe, even if the application does not use threads itself as some codecs are multithreaded.",
      "@_kind": "note"
     },
     {
      "para": {
       "ref": {
        "#text": "av_log_default_callback",
        "@_refid": "group__lavu__log_1ga5bd132d2e4ac6f9843ef6d8e3c05050a",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    ],
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "callback"
      },
      "parameterdescription": {
       "para": "A logging function with a compatible signature."
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "307",
   "@_column": "6",
   "@_declfile": "libavutil/log.h",
   "@_declline": "307",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1ga14034761faf581a8b9ed6ef19b313708",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set the logging callback\n *\n * @note The callback must be thread safe, even if the application does not use\n *       threads itself as some codecs are multithreaded.\n *\n * @see av_log_default_callback\n *\n * @param callback A logging function with a compatible signature.\n */"
 },
 "av_log_default_callback": {
  "type": "void",
  "definition": "void av_log_default_callback",
  "argsstring": "(void *avcl, int level, const char *fmt, va_list vl)",
  "name": "av_log_default_callback",
  "param": [
   {
    "type": "void *",
    "declname": "avcl"
   },
   {
    "type": "int",
    "declname": "level"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "va_list",
    "declname": "vl"
   }
  ],
  "briefdescription": {
   "para": "Default logging callback."
  },
  "detaileddescription": {
   "para": [
    "It prints the message to stderr, optionally colorizing it.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "avcl"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVClass",
           "@_refid": "structAVClass",
           "@_kindref": "compound"
          },
          "#text": "A pointer to an arbitrary struct of which the first field is a pointer to anstruct."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "level"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "Logging Constant",
           "@_refid": "group__lavu__log__constants",
           "@_kindref": "compound"
          },
          "#text": "The importance level of the message expressed using a."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "fmt"
        },
        "parameterdescription": {
         "para": "The format string (printf-compatible) that specifies how subsequent arguments are converted to output."
        }
       },
       {
        "parameternamelist": {
         "parametername": "vl"
        },
        "parameterdescription": {
         "para": "The arguments referenced by the format string."
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "322",
   "@_column": "6",
   "@_declfile": "libavutil/log.h",
   "@_declline": "322",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1ga5bd132d2e4ac6f9843ef6d8e3c05050a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Default logging callback\n *\n * It prints the message to stderr, optionally colorizing it.\n *\n * @param avcl A pointer to an arbitrary struct of which the first field is a\n *        pointer to an AVClass struct.\n * @param level The importance level of the message expressed using a @ref\n *        lavu_log_constants \"Logging Constant\".\n * @param fmt The format string (printf-compatible) that specifies how\n *        subsequent arguments are converted to output.\n * @param vl The arguments referenced by the format string.\n */"
 },
 "av_default_item_name": {
  "type": "const char *",
  "definition": "const char * av_default_item_name",
  "argsstring": "(void *ctx)",
  "name": "av_default_item_name",
  "param": {
   "type": "void *",
   "declname": "ctx"
  },
  "briefdescription": {
   "para": "Return the context name."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "ctx"
      },
      "parameterdescription": {
       "para": {
        "ref": {
         "#text": "AVClass",
         "@_refid": "structAVClass",
         "@_kindref": "compound"
        },
        "#text": "Thecontext"
       }
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVClass",
       "@_refid": "structAVClass",
       "@_kindref": "compound"
      },
      "#text": "Theclass_name"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "332",
   "@_column": "12",
   "@_declfile": "libavutil/log.h",
   "@_declline": "332",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1ga1e2d13acd5bf1c5790faa60edae84cf0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the context name\n *\n * @param  ctx The AVClass context\n *\n * @return The AVClass class_name\n */"
 },
 "av_default_get_category": {
  "type": {
   "ref": {
    "#text": "AVClassCategory",
    "@_refid": "log_8h_1aeb1c06cc3e47a029ca6afeac782ac8f9",
    "@_kindref": "member"
   }
  },
  "definition": "AVClassCategory av_default_get_category",
  "argsstring": "(void *ptr)",
  "name": "av_default_get_category",
  "param": {
   "type": "void *",
   "declname": "ptr"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "333",
   "@_column": "17",
   "@_declfile": "libavutil/log.h",
   "@_declline": "333",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1ga796896ca6a991fda200e8363777aeea3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the context name\n *\n * @param  ctx The AVClass context\n *\n * @return The AVClass class_name\n */"
 },
 "av_log_format_line": {
  "type": "void",
  "definition": "void av_log_format_line",
  "argsstring": "(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)",
  "name": "av_log_format_line",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "int",
    "declname": "level"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "va_list",
    "declname": "vl"
   },
   {
    "type": "char *",
    "declname": "line"
   },
   {
    "type": "int",
    "declname": "line_size"
   },
   {
    "type": "int *",
    "declname": "print_prefix"
   }
  ],
  "briefdescription": {
   "para": "Format a line of log the same way as the default callback."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "line"
       },
       "parameterdescription": {
        "para": "buffer to receive the formatted line"
       }
      },
      {
       "parameternamelist": {
        "parametername": "line_size"
       },
       "parameterdescription": {
        "para": "size of the buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "print_prefix"
       },
       "parameterdescription": {
        "para": "used to store whether the prefix must be printed; must point to a persistent integer initially set to 1"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "342",
   "@_column": "6",
   "@_declfile": "libavutil/log.h",
   "@_declline": "342",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1gaed9e57ccba2adc41864f54f47dfcccec",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Format a line of log the same way as the default callback.\n * @param line          buffer to receive the formatted line\n * @param line_size     size of the buffer\n * @param print_prefix  used to store whether the prefix must be printed;\n *                      must point to a persistent integer initially set to 1\n */"
 },
 "av_log_format_line2": {
  "type": "int",
  "definition": "int av_log_format_line2",
  "argsstring": "(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)",
  "name": "av_log_format_line2",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "int",
    "declname": "level"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "va_list",
    "declname": "vl"
   },
   {
    "type": "char *",
    "declname": "line"
   },
   {
    "type": "int",
    "declname": "line_size"
   },
   {
    "type": "int *",
    "declname": "print_prefix"
   }
  ],
  "briefdescription": {
   "para": "Format a line of log the same way as the default callback."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "line"
       },
       "parameterdescription": {
        "para": "buffer to receive the formatted line; may be NULL if line_size is 0"
       }
      },
      {
       "parameternamelist": {
        "parametername": "line_size"
       },
       "parameterdescription": {
        "para": "size of the buffer; at most line_size-1 characters will be written to the buffer, plus one null terminator"
       }
      },
      {
       "parameternamelist": {
        "parametername": "print_prefix"
       },
       "parameterdescription": {
        "para": "used to store whether the prefix must be printed; must point to a persistent integer initially set to 1"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "Returns a negative value if an error occurred, otherwise returns the number of characters that would have been written for a sufficiently large buffer, not including the terminating null character. If the return value is not less than line_size, it means that the log message was truncated to fit the buffer.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "359",
   "@_column": "5",
   "@_declfile": "libavutil/log.h",
   "@_declline": "359",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1ga0c595c96d63711069accb9c60549e84f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Format a line of log the same way as the default callback.\n * @param line          buffer to receive the formatted line;\n *                      may be NULL if line_size is 0\n * @param line_size     size of the buffer; at most line_size-1 characters will\n *                      be written to the buffer, plus one null terminator\n * @param print_prefix  used to store whether the prefix must be printed;\n *                      must point to a persistent integer initially set to 1\n * @return Returns a negative value if an error occurred, otherwise returns\n *         the number of characters that would have been written for a\n *         sufficiently large buffer, not including the terminating null\n *         character. If the return value is not less than line_size, it means\n *         that the log message was truncated to fit the buffer.\n */"
 },
 "av_log_set_flags": {
  "type": "void",
  "definition": "void av_log_set_flags",
  "argsstring": "(int arg)",
  "name": "av_log_set_flags",
  "param": {
   "type": "int",
   "declname": "arg"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "380",
   "@_column": "6",
   "@_declfile": "libavutil/log.h",
   "@_declline": "380",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1gaf8143cc9a7cd364af1ff525c6181c0ce",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Include the log severity in messages originating from codecs.\n *\n * Results in messages such as:\n * [rawvideo @ 0xDEADBEEF] [error] encode did not produce valid pts\n */"
 },
 "av_log_get_flags": {
  "type": "int",
  "definition": "int av_log_get_flags",
  "argsstring": "(void)",
  "name": "av_log_get_flags",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/log.h",
   "@_line": "381",
   "@_column": "5",
   "@_declfile": "libavutil/log.h",
   "@_declline": "381",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__log_1ga86a29f38fba2fdb9579d5fa3bbf6f8bf",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Include the log severity in messages originating from codecs.\n *\n * Results in messages such as:\n * [rawvideo @ 0xDEADBEEF] [error] encode did not produce valid pts\n */"
 },
 "av_lzo1x_decode": {
  "type": "int",
  "definition": "int av_lzo1x_decode",
  "argsstring": "(void *out, int *outlen, const void *in, int *inlen)",
  "name": "av_lzo1x_decode",
  "param": [
   {
    "type": "void *",
    "declname": "out"
   },
   {
    "type": "int *",
    "declname": "outlen"
   },
   {
    "type": "const void *",
    "declname": "in"
   },
   {
    "type": "int *",
    "declname": "inlen"
   }
  ],
  "briefdescription": {
   "para": "Decodes LZO 1x compressed data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "out"
       },
       "parameterdescription": {
        "para": "output buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "outlen"
       },
       "parameterdescription": {
        "para": "size of output buffer, number of bytes left are returned here"
       }
      },
      {
       "parameternamelist": {
        "parametername": "in"
       },
       "parameterdescription": {
        "para": "input buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "inlen"
       },
       "parameterdescription": {
        "para": "size of input buffer, number of bytes left are returned here"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, otherwise a combination of the error flags above",
     "@_kind": "return"
    },
    "#text": "Make sure all buffers are appropriately padded, in must provide AV_LZO_INPUT_PADDING, out must provide AV_LZO_OUTPUT_PADDING additional bytes."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/lzo.h",
   "@_line": "60",
   "@_column": "5",
   "@_declfile": "libavutil/lzo.h",
   "@_declline": "60",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__lzo_1gaafb2f88aa03d1fe059f3c2e174df6142",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @brief Decodes LZO 1x compressed data.\n * @param out output buffer\n * @param outlen size of output buffer, number of bytes left are returned here\n * @param in input buffer\n * @param inlen size of input buffer, number of bytes left are returned here\n * @return 0 on success, otherwise a combination of the error flags above\n *\n * Make sure all buffers are appropriately padded, in must provide\n * AV_LZO_INPUT_PADDING, out must provide AV_LZO_OUTPUT_PADDING additional bytes.\n */"
 },
 "av_mastering_display_metadata_alloc": {
  "type": {
   "ref": {
    "#text": "AVMasteringDisplayMetadata",
    "@_refid": "structAVMasteringDisplayMetadata",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVMasteringDisplayMetadata * av_mastering_display_metadata_alloc",
  "argsstring": "(void)",
  "name": "av_mastering_display_metadata_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVMasteringDisplayMetadata",
     "@_refid": "structAVMasteringDisplayMetadata",
     "@_kindref": "compound"
    },
    "#text": "Allocate anstructure and set its fields to default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_freep()",
      "@_refid": "group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba",
      "@_kindref": "member"
     },
     "#text": "The resulting struct can be freed using."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVMasteringDisplayMetadata",
        "@_refid": "structAVMasteringDisplayMetadata",
        "@_kindref": "compound"
       },
       "#text": "Anfilled with default values or NULL on failure."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mastering_display_metadata.h",
   "@_line": "78",
   "@_column": "28",
   "@_declfile": "libavutil/mastering_display_metadata.h",
   "@_declline": "78",
   "@_declcolumn": "28"
  },
  "@_kind": "function",
  "@_id": "mastering__display__metadata_8h_1a3212f64c936fa1442103d571d405c160",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVMasteringDisplayMetadata structure and set its fields to\n * default values. The resulting struct can be freed using av_freep().\n *\n * @return An AVMasteringDisplayMetadata filled with default values or NULL\n *         on failure.\n */"
 },
 "av_mastering_display_metadata_create_side_data": {
  "type": {
   "ref": {
    "#text": "AVMasteringDisplayMetadata",
    "@_refid": "structAVMasteringDisplayMetadata",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVMasteringDisplayMetadata * av_mastering_display_metadata_create_side_data",
  "argsstring": "(AVFrame *frame)",
  "name": "av_mastering_display_metadata_create_side_data",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVMasteringDisplayMetadata",
     "@_refid": "structAVMasteringDisplayMetadata",
     "@_kindref": "compound"
    },
    "#text": "Allocate a completeand add it to the frame."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "frame"
      },
      "parameterdescription": {
       "para": "The frame which side data is added to."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVMasteringDisplayMetadata",
       "@_refid": "structAVMasteringDisplayMetadata",
       "@_kindref": "compound"
      },
      "#text": "Thestructure to be filled by caller."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mastering_display_metadata.h",
   "@_line": "87",
   "@_column": "28",
   "@_declfile": "libavutil/mastering_display_metadata.h",
   "@_declline": "87",
   "@_declcolumn": "28"
  },
  "@_kind": "function",
  "@_id": "mastering__display__metadata_8h_1acb784f11b2b44500b594ed7d311f9876",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a complete AVMasteringDisplayMetadata and add it to the frame.\n *\n * @param frame The frame which side data is added to.\n *\n * @return The AVMasteringDisplayMetadata structure to be filled by caller.\n */"
 },
 "av_content_light_metadata_alloc": {
  "type": {
   "ref": {
    "#text": "AVContentLightMetadata",
    "@_refid": "structAVContentLightMetadata",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVContentLightMetadata * av_content_light_metadata_alloc",
  "argsstring": "(size_t *size)",
  "name": "av_content_light_metadata_alloc",
  "param": {
   "type": "size_t *",
   "declname": "size"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVContentLightMetadata",
     "@_refid": "structAVContentLightMetadata",
     "@_kindref": "compound"
    },
    "#text": "Allocate anstructure and set its fields to default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_freep()",
      "@_refid": "group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba",
      "@_kindref": "member"
     },
     "#text": "The resulting struct can be freed using."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVContentLightMetadata",
        "@_refid": "structAVContentLightMetadata",
        "@_kindref": "compound"
       },
       "#text": "Anfilled with default values or NULL on failure."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mastering_display_metadata.h",
   "@_line": "117",
   "@_column": "24",
   "@_declfile": "libavutil/mastering_display_metadata.h",
   "@_declline": "117",
   "@_declcolumn": "24"
  },
  "@_kind": "function",
  "@_id": "mastering__display__metadata_8h_1a686b55b7e63bc8ec4df356645f12ee9d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVContentLightMetadata structure and set its fields to\n * default values. The resulting struct can be freed using av_freep().\n *\n * @return An AVContentLightMetadata filled with default values or NULL\n *         on failure.\n */"
 },
 "av_content_light_metadata_create_side_data": {
  "type": {
   "ref": {
    "#text": "AVContentLightMetadata",
    "@_refid": "structAVContentLightMetadata",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVContentLightMetadata * av_content_light_metadata_create_side_data",
  "argsstring": "(AVFrame *frame)",
  "name": "av_content_light_metadata_create_side_data",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVContentLightMetadata",
     "@_refid": "structAVContentLightMetadata",
     "@_kindref": "compound"
    },
    "#text": "Allocate a completeand add it to the frame."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "frame"
      },
      "parameterdescription": {
       "para": "The frame which side data is added to."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVContentLightMetadata",
       "@_refid": "structAVContentLightMetadata",
       "@_kindref": "compound"
      },
      "#text": "Thestructure to be filled by caller."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mastering_display_metadata.h",
   "@_line": "126",
   "@_column": "24",
   "@_declfile": "libavutil/mastering_display_metadata.h",
   "@_declline": "126",
   "@_declcolumn": "24"
  },
  "@_kind": "function",
  "@_id": "mastering__display__metadata_8h_1a6f05d210285c3b4ad60e73b0b8ceafa9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a complete AVContentLightMetadata and add it to the frame.\n *\n * @param frame The frame which side data is added to.\n *\n * @return The AVContentLightMetadata structure to be filled by caller.\n */"
 },
 "av_md5_size": {
  "type": "const int",
  "definition": "const int av_md5_size",
  "argsstring": "",
  "name": "av_md5_size",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/md5.h",
   "@_line": "43",
   "@_column": "18",
   "@_declfile": "libavutil/md5.h",
   "@_declline": "43",
   "@_declcolumn": "18"
  },
  "@_kind": "variable",
  "@_id": "group__lavu__md5_1ga758362caf2146c2ef1e433415893d536",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * @defgroup lavu_md5 MD5\n * @ingroup lavu_hash\n * MD5 hash function implementation.\n *\n * @{\n */"
 },
 "av_md5_alloc": {
  "type": "struct AVMD5 *",
  "definition": "struct AVMD5 * av_md5_alloc",
  "argsstring": "(void)",
  "name": "av_md5_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVMD5 context."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/md5.h",
   "@_line": "50",
   "@_column": "12",
   "@_declfile": "libavutil/md5.h",
   "@_declline": "50",
   "@_declcolumn": "12"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "filter__audio_8c_1a0ddf1224851353fc92bfbff6f499fa97",
   "@_compoundref": "filter__audio_8c",
   "@_startline": "267",
   "@_endline": "360"
  },
  "@_kind": "function",
  "@_id": "group__lavu__md5_1ga98ba7bd1346a6f4c186086da17a43e68",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVMD5 context.\n */"
 },
 "av_md5_init": {
  "type": "void",
  "definition": "void av_md5_init",
  "argsstring": "(struct AVMD5 *ctx)",
  "name": "av_md5_init",
  "param": {
   "type": "struct AVMD5 *",
   "declname": "ctx"
  },
  "briefdescription": {
   "para": "Initialize MD5 hashing."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "ctx"
      },
      "parameterdescription": {
       "para": "pointer to the function context (of size av_md5_size)"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/md5.h",
   "@_line": "57",
   "@_column": "6",
   "@_declfile": "libavutil/md5.h",
   "@_declline": "57",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "process_output",
   "@_refid": "filter__audio_8c_1a6a52930eb2ed533366ebb43a038baa36",
   "@_compoundref": "filter__audio_8c",
   "@_startline": "212",
   "@_endline": "235"
  },
  "@_kind": "function",
  "@_id": "group__lavu__md5_1ga31b412926441fa8f496a6033c6e918d0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize MD5 hashing.\n *\n * @param ctx pointer to the function context (of size av_md5_size)\n */"
 },
 "av_md5_update": {
  "type": "void",
  "definition": "void av_md5_update",
  "argsstring": "(struct AVMD5 *ctx, const uint8_t *src, size_t len)",
  "name": "av_md5_update",
  "param": [
   {
    "type": "struct AVMD5 *",
    "declname": "ctx"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "size_t",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Update hash value."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "hash function context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "input data to update hash with"
       }
      },
      {
       "parameternamelist": {
        "parametername": "len"
       },
       "parameterdescription": {
        "para": "input data length"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/md5.h",
   "@_line": "66",
   "@_column": "6",
   "@_declfile": "libavutil/md5.h",
   "@_declline": "66",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__md5_1gaf572f08fc8d9fa06c015bbba332b97af",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Update hash value.\n *\n * @param ctx hash function context\n * @param src input data to update hash with\n * @param len input data length\n */"
 },
 "av_md5_final": {
  "type": "void",
  "definition": "void av_md5_final",
  "argsstring": "(struct AVMD5 *ctx, uint8_t *dst)",
  "name": "av_md5_final",
  "param": [
   {
    "type": "struct AVMD5 *",
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   }
  ],
  "briefdescription": {
   "para": "Finish hashing and output digest value."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "hash function context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "buffer where output digest value is stored"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/md5.h",
   "@_line": "74",
   "@_column": "6",
   "@_declfile": "libavutil/md5.h",
   "@_declline": "74",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__md5_1ga855dfc4c59bc1da98635390f8294237c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finish hashing and output digest value.\n *\n * @param ctx hash function context\n * @param dst buffer where output digest value is stored\n */"
 },
 "av_md5_sum": {
  "type": "void",
  "definition": "void av_md5_sum",
  "argsstring": "(uint8_t *dst, const uint8_t *src, size_t len)",
  "name": "av_md5_sum",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "size_t",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Hash an array of data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "The output buffer to write the digest into"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "The data to hash"
       }
      },
      {
       "parameternamelist": {
        "parametername": "len"
       },
       "parameterdescription": {
        "para": "The length of the data, in bytes"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/md5.h",
   "@_line": "83",
   "@_column": "6",
   "@_declfile": "libavutil/md5.h",
   "@_declline": "83",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "process_output",
   "@_refid": "filter__audio_8c_1a6a52930eb2ed533366ebb43a038baa36",
   "@_compoundref": "filter__audio_8c",
   "@_startline": "212",
   "@_endline": "235"
  },
  "@_kind": "function",
  "@_id": "group__lavu__md5_1ga4ca11c72ce6e6f9e9cf9e54a5500b363",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Hash an array of data.\n *\n * @param dst The output buffer to write the digest into\n * @param src The data to hash\n * @param len The length of the data, in bytes\n */"
 },
 "AVMediaCodecBuffer": {
  "type": "struct MediaCodecBuffer",
  "definition": "typedef struct MediaCodecBuffer AVMediaCodecBuffer",
  "argsstring": "",
  "name": "AVMediaCodecBuffer",
  "briefdescription": {
   "para": "Opaque structure representing a MediaCodec buffer to render."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/mediacodec.h",
   "@_line": "73",
   "@_column": "31",
   "@_bodyfile": "libavcodec/mediacodec.h",
   "@_bodystart": "73",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "mediacodec_8h_1ac5e9b9aba9045bc7c09f4309cecd7212",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Opaque structure representing a MediaCodec buffer to render.\n */"
 },
 "av_mediacodec_alloc_context": {
  "type": {
   "ref": {
    "#text": "AVMediaCodecContext",
    "@_refid": "structAVMediaCodecContext",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVMediaCodecContext * av_mediacodec_alloc_context",
  "argsstring": "(void)",
  "name": "av_mediacodec_alloc_context",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate and initialize a MediaCodec context."
  },
  "detaileddescription": {
   "para": [
    "When decoding with MediaCodec is finished, the caller must free the MediaCodec context with av_mediacodec_default_free.",
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVMediaCodecContext",
        "@_refid": "structAVMediaCodecContext",
        "@_kindref": "compound"
       },
       "#text": "a pointer to a newly allocatedon success, NULL otherwise"
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/mediacodec.h",
   "@_line": "50",
   "@_column": "21",
   "@_declfile": "libavcodec/mediacodec.h",
   "@_declline": "50",
   "@_declcolumn": "21"
  },
  "@_kind": "function",
  "@_id": "mediacodec_8h_1a8664930ba947910156be5e9978e03b45",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate and initialize a MediaCodec context.\n *\n * When decoding with MediaCodec is finished, the caller must free the\n * MediaCodec context with av_mediacodec_default_free.\n *\n * @return a pointer to a newly allocated AVMediaCodecContext on success, NULL otherwise\n */"
 },
 "av_mediacodec_default_init": {
  "type": "int",
  "definition": "int av_mediacodec_default_init",
  "argsstring": "(AVCodecContext *avctx, AVMediaCodecContext *ctx, void *surface)",
  "name": "av_mediacodec_default_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVMediaCodecContext",
      "@_refid": "structAVMediaCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "ctx"
   },
   {
    "type": "void *",
    "declname": "surface"
   }
  ],
  "briefdescription": {
   "para": "Convenience function that sets up the MediaCodec context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "avctx"
       },
       "parameterdescription": {
        "para": "codec context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "MediaCodec context to initialize"
       }
      },
      {
       "parameternamelist": {
        "parametername": "surface"
       },
       "parameterdescription": {
        "para": "reference to an android/view/Surface"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, < 0 otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/mediacodec.h",
   "@_line": "60",
   "@_column": "5",
   "@_declfile": "libavcodec/mediacodec.h",
   "@_declline": "60",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "mediacodec_8h_1a11017813a418700a6a80a915c8a393aa",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convenience function that sets up the MediaCodec context.\n *\n * @param avctx codec context\n * @param ctx MediaCodec context to initialize\n * @param surface reference to an android/view/Surface\n * @return 0 on success, < 0 otherwise\n */"
 },
 "av_mediacodec_default_free": {
  "type": "void",
  "definition": "void av_mediacodec_default_free",
  "argsstring": "(AVCodecContext *avctx)",
  "name": "av_mediacodec_default_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVCodecContext",
     "@_refid": "structAVCodecContext",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "avctx"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_mediacodec_default_init()",
     "@_refid": "mediacodec_8h_1a11017813a418700a6a80a915c8a393aa",
     "@_kindref": "member"
    },
    "#text": "This function must be called to free the MediaCodec context initialized with."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "avctx"
      },
      "parameterdescription": {
       "para": "codec context"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/mediacodec.h",
   "@_line": "68",
   "@_column": "6",
   "@_declfile": "libavcodec/mediacodec.h",
   "@_declline": "68",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "mediacodec_8h_1af4195e0ef95ed3b12cb440c9ce9565b5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * This function must be called to free the MediaCodec context initialized with\n * av_mediacodec_default_init().\n *\n * @param avctx codec context\n */"
 },
 "av_mediacodec_release_buffer": {
  "type": "int",
  "definition": "int av_mediacodec_release_buffer",
  "argsstring": "(AVMediaCodecBuffer *buffer, int render)",
  "name": "av_mediacodec_release_buffer",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVMediaCodecBuffer",
      "@_refid": "mediacodec_8h_1ac5e9b9aba9045bc7c09f4309cecd7212",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "buffer"
   },
   {
    "type": "int",
    "declname": "render"
   }
  ],
  "briefdescription": {
   "para": "Release a MediaCodec buffer and render it to the surface that is associated with the decoder."
  },
  "detaileddescription": {
   "para": [
    "This function should only be called once on a given buffer, once released the underlying buffer returns to the codec, thus subsequent calls to this function will have no effect.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "buffer"
        },
        "parameterdescription": {
         "para": "the buffer to render"
        }
       },
       {
        "parameternamelist": {
         "parametername": "render"
        },
        "parameterdescription": {
         "para": "1 to release and render the buffer to the surface or 0 to discard the buffer"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, < 0 otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/mediacodec.h",
   "@_line": "86",
   "@_column": "5",
   "@_declfile": "libavcodec/mediacodec.h",
   "@_declline": "86",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "mediacodec_8h_1a36761de99f3b4c76f29cf4039a1f3eb2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Release a MediaCodec buffer and render it to the surface that is associated\n * with the decoder. This function should only be called once on a given\n * buffer, once released the underlying buffer returns to the codec, thus\n * subsequent calls to this function will have no effect.\n *\n * @param buffer the buffer to render\n * @param render 1 to release and render the buffer to the surface or 0 to\n * discard the buffer\n * @return 0 on success, < 0 otherwise\n */"
 },
 "av_mediacodec_render_buffer_at_time": {
  "type": "int",
  "definition": "int av_mediacodec_render_buffer_at_time",
  "argsstring": "(AVMediaCodecBuffer *buffer, int64_t time)",
  "name": "av_mediacodec_render_buffer_at_time",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVMediaCodecBuffer",
      "@_refid": "mediacodec_8h_1ac5e9b9aba9045bc7c09f4309cecd7212",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "buffer"
   },
   {
    "type": "int64_t",
    "declname": "time"
   }
  ],
  "briefdescription": {
   "para": "Release a MediaCodec buffer and render it at the given time to the surface that is associated with the decoder."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": [
      "java/lang/System#nanoTime()",
      "CLOCK_MONOTONIC"
     ],
     "ulink": {
      "computeroutput": "android/media/MediaCodec#releaseOutputBuffer(int,long)",
      "@_url": "https://developer.android.com/reference/android/media/MediaCodec#releaseOutputBuffer(int,%20long)"
     },
     "#text": "The timestamp must be within one second of the current(which is implemented usingon Android). See the Android MediaCodec documentation offor more details."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "buffer"
        },
        "parameterdescription": {
         "para": "the buffer to render"
        }
       },
       {
        "parameternamelist": {
         "parametername": "time"
        },
        "parameterdescription": {
         "para": "timestamp in nanoseconds of when to render the buffer"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, < 0 otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/mediacodec.h",
   "@_line": "101",
   "@_column": "5",
   "@_declfile": "libavcodec/mediacodec.h",
   "@_declline": "101",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "mediacodec_8h_1a3b14761c6a139598e9f28353c19ac899",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Release a MediaCodec buffer and render it at the given time to the surface\n * that is associated with the decoder. The timestamp must be within one second\n * of the current `java/lang/System#nanoTime()` (which is implemented using\n * `CLOCK_MONOTONIC` on Android). See the Android MediaCodec documentation\n * of [`android/media/MediaCodec#releaseOutputBuffer(int,long)`][0] for more details.\n *\n * @param buffer the buffer to render\n * @param time timestamp in nanoseconds of when to render the buffer\n * @return 0 on success, < 0 otherwise\n *\n * [0]: https://developer.android.com/reference/android/media/MediaCodec#releaseOutputBuffer(int,%20long)\n */"
 },
 "av_malloc": {
  "type": "void *",
  "definition": "void * av_malloc",
  "argsstring": "(size_t size) av_malloc_attrib",
  "name": "av_malloc",
  "param": {
   "type": "size_t",
   "declname": "size"
  },
  "briefdescription": {
   "para": "Allocate a memory block with alignment suitable for all memory accesses (including vectors if available on the CPU)."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "size"
      },
      "parameterdescription": {
       "para": "Size in bytes for the memory block to be allocated"
      }
     },
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": {
       "computeroutput": "NULL",
       "#text": "Pointer to the allocated block, orif the block cannot be allocated"
      },
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_mallocz()",
        "@_refid": "group__lavu__mem__funcs_1ga40a68c9615da8e3217dcb317961bd57b",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "119",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "119",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "decode_write",
    "@_refid": "hw__decode_8c_1aa376d8bc0bb004de4856e8920e0f6217",
    "@_compoundref": "hw__decode_8c",
    "@_startline": "76",
    "@_endline": "146"
   },
   {
    "#text": "main",
    "@_refid": "avio__read__callback_8c_1a0ddf1224851353fc92bfbff6f499fa97",
    "@_compoundref": "avio__read__callback_8c",
    "@_startline": "58",
    "@_endline": "133"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a memory block with alignment suitable for all memory accesses\n * (including vectors if available on the CPU).\n *\n * @param size Size in bytes for the memory block to be allocated\n * @return Pointer to the allocated block, or `NULL` if the block cannot\n *         be allocated\n * @see av_mallocz()\n */"
 },
 "av_mallocz": {
  "type": "void *",
  "definition": "void * av_mallocz",
  "argsstring": "(size_t size) av_malloc_attrib",
  "name": "av_mallocz",
  "param": {
   "type": "size_t",
   "declname": "size"
  },
  "briefdescription": {
   "para": "Allocate a memory block with alignment suitable for all memory accesses (including vectors if available on the CPU) and zero all the bytes of the block."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "size"
      },
      "parameterdescription": {
       "para": "Size in bytes for the memory block to be allocated"
      }
     },
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": {
       "computeroutput": "NULL",
       "#text": "Pointer to the allocated block, orif it cannot be allocated"
      },
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_malloc()",
        "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "130",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "130",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga40a68c9615da8e3217dcb317961bd57b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a memory block with alignment suitable for all memory accesses\n * (including vectors if available on the CPU) and zero all the bytes of the\n * block.\n *\n * @param size Size in bytes for the memory block to be allocated\n * @return Pointer to the allocated block, or `NULL` if it cannot be allocated\n * @see av_malloc()\n */"
 },
 "av_malloc_array": {
  "type": "void *",
  "definition": "void * av_malloc_array",
  "argsstring": "(size_t nmemb, size_t size)",
  "name": "av_malloc_array",
  "param": [
   {
    "type": "size_t",
    "declname": "nmemb"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_malloc()",
     "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
     "@_kindref": "member"
    },
    "#text": "Allocate a memory block for an array with."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": "size * nmemb",
     "#text": "The allocated memory will have sizebytes."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "nmemb"
        },
        "parameterdescription": {
         "para": "Number of element"
        }
       },
       {
        "parameternamelist": {
         "parametername": "size"
        },
        "parameterdescription": {
         "para": "Size of a single element"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "computeroutput": "NULL",
        "#text": "Pointer to the allocated block, orif the block cannot be allocated"
       },
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_malloc()",
         "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "143",
   "@_column": "7",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "143",
   "@_declcolumn": "7"
  },
  "referencedby": {
   "#text": "init_filters",
   "@_refid": "transcode_8c_1a05c93a3c60f2fc12e3fb7884be1128d6",
   "@_compoundref": "transcode_8c",
   "@_startline": "394",
   "@_endline": "430"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1gaf67bb927d82719854d46eb3330f27f46",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a memory block for an array with av_malloc().\n *\n * The allocated memory will have size `size * nmemb` bytes.\n *\n * @param nmemb Number of element\n * @param size  Size of a single element\n * @return Pointer to the allocated block, or `NULL` if the block cannot\n *         be allocated\n * @see av_malloc()\n */"
 },
 "av_calloc": {
  "type": "void *",
  "definition": "void * av_calloc",
  "argsstring": "(size_t nmemb, size_t size) av_malloc_attrib",
  "name": "av_calloc",
  "param": [
   {
    "type": "size_t",
    "declname": "nmemb"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_mallocz()",
     "@_refid": "group__lavu__mem__funcs_1ga40a68c9615da8e3217dcb317961bd57b",
     "@_kindref": "member"
    },
    "#text": "Allocate a memory block for an array with."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": "size * nmemb",
     "#text": "The allocated memory will have sizebytes."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "nmemb"
        },
        "parameterdescription": {
         "para": "Number of elements"
        }
       },
       {
        "parameternamelist": {
         "parametername": "size"
        },
        "parameterdescription": {
         "para": "Size of the single element"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "computeroutput": "NULL",
        "#text": "Pointer to the allocated block, orif the block cannot be allocated"
       },
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_mallocz()",
         "@_refid": "group__lavu__mem__funcs_1ga40a68c9615da8e3217dcb317961bd57b",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      },
      {
       "para": {
        "ref": {
         "#text": "av_malloc_array()",
         "@_refid": "group__lavu__mem__funcs_1gaf67bb927d82719854d46eb3330f27f46",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "158",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "158",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "remux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "remux_8c",
    "@_startline": "46",
    "@_endline": "198"
   },
   {
    "#text": "open_input_file",
    "@_refid": "transcode_8c_1abd04bf1a933d4d2698482f4949c61fed",
    "@_compoundref": "transcode_8c",
    "@_startline": "61",
    "@_endline": "126"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1gaf324b11824b95e09d83c7e9f5511e815",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a memory block for an array with av_mallocz().\n *\n * The allocated memory will have size `size * nmemb` bytes.\n *\n * @param nmemb Number of elements\n * @param size  Size of the single element\n * @return Pointer to the allocated block, or `NULL` if the block cannot\n *         be allocated\n *\n * @see av_mallocz()\n * @see av_malloc_array()\n */"
 },
 "av_realloc": {
  "type": "void *",
  "definition": "void * av_realloc",
  "argsstring": "(void *ptr, size_t size)",
  "name": "av_realloc",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Allocate, reallocate, or free a block of memory."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": [
      "ptr",
      "NULL",
      "size",
      "size"
     ],
     "#text": "Ifisand> 0, allocate a new block. Otherwise, expand or shrink that block of memory according to."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ptr"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "av_realloc()",
           "@_refid": "group__lavu__mem__funcs_1ga45fc6fd08120d07ddf4ed39f597f31b4",
           "@_kindref": "member"
          },
          "computeroutput": "NULL",
          "#text": "Pointer to a memory block already allocated withor"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "size"
        },
        "parameterdescription": {
         "para": "Size in bytes of the memory block to be allocated or reallocated"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "computeroutput": "NULL",
        "#text": "Pointer to a newly-reallocated block orif the block cannot be reallocated"
       },
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_malloc()",
         "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
         "@_kindref": "member"
        },
        "#text": "Unlike, the returned pointer is not guaranteed to be correctly aligned. The returned pointer must be freed after even if size is zero."
       },
       "@_kind": "warning"
      },
      {
       "para": {
        "ref": {
         "#text": "av_fast_realloc()",
         "@_refid": "group__lavu__mem__funcs_1ga0e8e75b89c5fa2966b8fbffbdb6ec774",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      },
      {
       "para": {
        "ref": {
         "#text": "av_reallocp()",
         "@_refid": "group__lavu__mem__funcs_1ga9665abf3720f9f460790c2c3b224c052",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "180",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "180",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga45fc6fd08120d07ddf4ed39f597f31b4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate, reallocate, or free a block of memory.\n *\n * If `ptr` is `NULL` and `size` > 0, allocate a new block. Otherwise, expand or\n * shrink that block of memory according to `size`.\n *\n * @param ptr  Pointer to a memory block already allocated with\n *             av_realloc() or `NULL`\n * @param size Size in bytes of the memory block to be allocated or\n *             reallocated\n *\n * @return Pointer to a newly-reallocated block or `NULL` if the block\n *         cannot be reallocated\n *\n * @warning Unlike av_malloc(), the returned pointer is not guaranteed to be\n *          correctly aligned. The returned pointer must be freed after even\n *          if size is zero.\n * @see av_fast_realloc()\n * @see av_reallocp()\n */"
 },
 "av_reallocp": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int av_reallocp",
  "argsstring": "(void *ptr, size_t size)",
  "name": "av_reallocp",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Allocate, reallocate, or free a block of memory through a pointer to a pointer."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": [
      "*ptr",
      "NULL",
      "size",
      "size",
      "*ptr",
      "size"
     ],
     "#text": "Ifisand> 0, allocate a new block. Ifis zero, free the memory block pointed to by. Otherwise, expand or shrink that block of memory according to."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ptr",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "av_realloc()",
           "@_refid": "group__lavu__mem__funcs_1ga45fc6fd08120d07ddf4ed39f597f31b4",
           "@_kindref": "member"
          },
          "computeroutput": "NULL",
          "#text": "Pointer to a pointer to a memory block already allocated with, or a pointer to. The pointer is updated on success, or freed on failure."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "size",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Size in bytes for the memory block to be allocated or reallocated"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "Zero on success, an AVERROR error code on failure",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_malloc()",
         "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
         "@_kindref": "member"
        },
        "#text": "Unlike, the allocated memory is not guaranteed to be correctly aligned."
       },
       "@_kind": "warning"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "202",
   "@_column": "5",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "202",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga9665abf3720f9f460790c2c3b224c052",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate, reallocate, or free a block of memory through a pointer to a\n * pointer.\n *\n * If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is\n * zero, free the memory block pointed to by `*ptr`. Otherwise, expand or\n * shrink that block of memory according to `size`.\n *\n * @param[in,out] ptr  Pointer to a pointer to a memory block already allocated\n *                     with av_realloc(), or a pointer to `NULL`. The pointer\n *                     is updated on success, or freed on failure.\n * @param[in]     size Size in bytes for the memory block to be allocated or\n *                     reallocated\n *\n * @return Zero on success, an AVERROR error code on failure\n *\n * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n *          correctly aligned.\n */"
 },
 "av_realloc_f": {
  "type": "void *",
  "definition": "void * av_realloc_f",
  "argsstring": "(void *ptr, size_t nelem, size_t elsize)",
  "name": "av_realloc_f",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "size_t",
    "declname": "nelem"
   },
   {
    "type": "size_t",
    "declname": "elsize"
   }
  ],
  "briefdescription": {
   "para": "Allocate, reallocate, or free a block of memory."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "av_realloc()",
     "@_refid": "group__lavu__mem__funcs_1ga45fc6fd08120d07ddf4ed39f597f31b4",
     "@_kindref": "member"
    },
    "itemizedlist": {
     "listitem": [
      {
       "para": {
        "computeroutput": "nelem * elsize",
        "#text": "It takes two size arguments and allocatesbytes, after checking the result of the multiplication for integer overflow."
       }
      },
      {
       "para": {
        "programlisting": {
         "codeline": [
          {
           "highlight": {
            "sp": [
             "",
             ""
            ],
            "#text": "buf=realloc(buf);",
            "@_class": "normal"
           }
          },
          {
           "highlight": [
            {
             "@_class": "normal"
            },
            {
             "#text": "if",
             "@_class": "keywordflow"
            },
            {
             "sp": "",
             "#text": "(!buf)",
             "@_class": "normal"
            }
           ]
          },
          {
           "highlight": [
            {
             "sp": [
              "",
              "",
              "",
              ""
             ],
             "@_class": "normal"
            },
            {
             "#text": "return",
             "@_class": "keywordflow"
            },
            {
             "sp": "",
             "#text": "-1;",
             "@_class": "normal"
            }
           ]
          }
         ],
         "@_filename": ".c"
        },
        "#text": "It frees the input block in case of failure, thus avoiding the memory leak with the classicpattern."
       }
      }
     ]
    },
    "#text": "This function does the same thing as, except:"
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "219",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "219",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga5af878050b68d10ad3c1ef2050eae000",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate, reallocate, or free a block of memory.\n *\n * This function does the same thing as av_realloc(), except:\n * - It takes two size arguments and allocates `nelem * elsize` bytes,\n *   after checking the result of the multiplication for integer overflow.\n * - It frees the input block in case of failure, thus avoiding the memory\n *   leak with the classic\n *   @code{.c}\n *   buf = realloc(buf);\n *   if (!buf)\n *       return -1;\n *   @endcode\n *   pattern.\n */"
 },
 "av_realloc_array": {
  "type": "void *",
  "definition": "void * av_realloc_array",
  "argsstring": "(void *ptr, size_t nmemb, size_t size)",
  "name": "av_realloc_array",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "size_t",
    "declname": "nmemb"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Allocate, reallocate, or free an array."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": [
      "ptr",
      "NULL",
      "nmemb"
     ],
     "#text": "Ifisand> 0, allocate a new block."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ptr"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "av_realloc()",
           "@_refid": "group__lavu__mem__funcs_1ga45fc6fd08120d07ddf4ed39f597f31b4",
           "@_kindref": "member"
          },
          "computeroutput": "NULL",
          "#text": "Pointer to a memory block already allocated withor"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "nmemb"
        },
        "parameterdescription": {
         "para": "Number of elements in the array"
        }
       },
       {
        "parameternamelist": {
         "parametername": "size"
        },
        "parameterdescription": {
         "para": "Size of the single element of the array"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "Pointer to a newly-reallocated block or NULL if the block cannot be reallocated",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_malloc()",
         "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
         "@_kindref": "member"
        },
        "#text": "Unlike, the allocated memory is not guaranteed to be correctly aligned. The returned pointer must be freed after even if nmemb is zero."
       },
       "@_kind": "warning"
      },
      {
       "para": {
        "ref": {
         "#text": "av_reallocp_array()",
         "@_refid": "group__lavu__mem__funcs_1gad8fde0c159ac905909339e082a049cde",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "239",
   "@_column": "7",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "239",
   "@_declcolumn": "7"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga39346b39fc189a4a7d5bcdc9e34d9006",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate, reallocate, or free an array.\n *\n * If `ptr` is `NULL` and `nmemb` > 0, allocate a new block.\n *\n * @param ptr   Pointer to a memory block already allocated with\n *              av_realloc() or `NULL`\n * @param nmemb Number of elements in the array\n * @param size  Size of the single element of the array\n *\n * @return Pointer to a newly-reallocated block or NULL if the block\n *         cannot be reallocated\n *\n * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n *          correctly aligned. The returned pointer must be freed after even if\n *          nmemb is zero.\n * @see av_reallocp_array()\n */"
 },
 "av_reallocp_array": {
  "type": "int",
  "definition": "int av_reallocp_array",
  "argsstring": "(void *ptr, size_t nmemb, size_t size)",
  "name": "av_reallocp_array",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "size_t",
    "declname": "nmemb"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Allocate, reallocate an array through a pointer to a pointer."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": [
      "*ptr",
      "NULL",
      "nmemb"
     ],
     "#text": "Ifisand> 0, allocate a new block."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ptr",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "av_realloc()",
           "@_refid": "group__lavu__mem__funcs_1ga45fc6fd08120d07ddf4ed39f597f31b4",
           "@_kindref": "member"
          },
          "computeroutput": "NULL",
          "#text": "Pointer to a pointer to a memory block already allocated with, or a pointer to. The pointer is updated on success, or freed on failure."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "nmemb",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Number of elements"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "size",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Size of the single element"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "Zero on success, an AVERROR error code on failure",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_malloc()",
         "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
         "@_kindref": "member"
        },
        "#text": "Unlike, the allocated memory is not guaranteed to be correctly aligned. *ptr must be freed after even if nmemb is zero."
       },
       "@_kind": "warning"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "257",
   "@_column": "5",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "257",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1gad8fde0c159ac905909339e082a049cde",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate, reallocate an array through a pointer to a pointer.\n *\n * If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block.\n *\n * @param[in,out] ptr   Pointer to a pointer to a memory block already\n *                      allocated with av_realloc(), or a pointer to `NULL`.\n *                      The pointer is updated on success, or freed on failure.\n * @param[in]     nmemb Number of elements\n * @param[in]     size  Size of the single element\n *\n * @return Zero on success, an AVERROR error code on failure\n *\n * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be\n *          correctly aligned. *ptr must be freed after even if nmemb is zero.\n */"
 },
 "av_fast_realloc": {
  "type": "void *",
  "definition": "void * av_fast_realloc",
  "argsstring": "(void *ptr, unsigned int *size, size_t min_size)",
  "name": "av_fast_realloc",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "unsigned int *",
    "declname": "size"
   },
   {
    "type": "size_t",
    "declname": "min_size"
   }
  ],
  "briefdescription": {
   "para": "Reallocate the given buffer if it is not large enough, otherwise do nothing."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": "NULL",
     "#text": "If the given buffer is, then a new uninitialized buffer is allocated."
    },
    {
     "computeroutput": [
      "NULL",
      "*size"
     ],
     "#text": "If the given buffer is not large enough, and reallocation fails,is returned andis set to 0, but the original buffer is not changed or freed."
    },
    "A typical use pattern follows:",
    {
     "programlisting": {
      "codeline": [
       {
        "highlight": {
         "sp": [
          "",
          "",
          ""
         ],
         "#text": "uint8_t*buf=...;",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          "",
          ""
         ],
         "ref": {
          "#text": "av_fast_realloc",
          "@_refid": "group__lavu__mem__funcs_1ga0e8e75b89c5fa2966b8fbffbdb6ec774",
          "@_kindref": "member"
         },
         "#text": "uint8_t*new_buf=(buf,&current_size,size_needed);",
         "@_class": "normal"
        }
       },
       {
        "highlight": [
         {
          "@_class": "normal"
         },
         {
          "#text": "if",
          "@_class": "keywordflow"
         },
         {
          "sp": [
           "",
           ""
          ],
          "#text": "(!new_buf){",
          "@_class": "normal"
         }
        ]
       },
       {
        "highlight": [
         {
          "sp": [
           "",
           "",
           "",
           ""
          ],
          "@_class": "normal"
         },
         {
          "sp": [
           "",
           "",
           "",
           "",
           "",
           ""
          ],
          "#text": "//Allocationfailed;cleanuporiginalbuffer",
          "@_class": "comment"
         },
         {
          "@_class": "normal"
         }
        ]
       },
       {
        "highlight": {
         "sp": [
          "",
          "",
          "",
          ""
         ],
         "ref": {
          "#text": "av_freep",
          "@_refid": "group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba",
          "@_kindref": "member"
         },
         "#text": "(&buf);",
         "@_class": "normal"
        }
       },
       {
        "highlight": [
         {
          "sp": [
           "",
           "",
           "",
           ""
          ],
          "@_class": "normal"
         },
         {
          "#text": "return",
          "@_class": "keywordflow"
         },
         {
          "sp": "",
          "ref": {
           "#text": "AVERROR",
           "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
           "@_kindref": "member"
          },
          "#text": "(ENOMEM);",
          "@_class": "normal"
         }
        ]
       },
       {
        "highlight": {
         "#text": "}",
         "@_class": "normal"
        }
       }
      ],
      "@_filename": ".c"
     }
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ptr",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "NULL",
          "#text": "Already allocated buffer, or"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "size",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": [
           "ptr",
           "*size"
          ],
          "#text": "Pointer to the size of buffer.is updated to the new allocated size, in particular 0 in case of failure."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "min_size",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "ptr",
          "#text": "Desired minimal size of buffer"
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "computeroutput": [
         "ptr",
         "NULL"
        ],
        "#text": "if the buffer is large enough, a pointer to newly reallocated buffer if the buffer was not large enough, orin case of error"
       },
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_realloc()",
         "@_refid": "group__lavu__mem__funcs_1ga45fc6fd08120d07ddf4ed39f597f31b4",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      },
      {
       "para": {
        "ref": {
         "#text": "av_fast_malloc()",
         "@_refid": "group__lavu__mem__funcs_1ga29d0252b981f157e713a68ffca52f003",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "291",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "291",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga0e8e75b89c5fa2966b8fbffbdb6ec774",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reallocate the given buffer if it is not large enough, otherwise do nothing.\n *\n * If the given buffer is `NULL`, then a new uninitialized buffer is allocated.\n *\n * If the given buffer is not large enough, and reallocation fails, `NULL` is\n * returned and `*size` is set to 0, but the original buffer is not changed or\n * freed.\n *\n * A typical use pattern follows:\n *\n * @code{.c}\n * uint8_t *buf = ...;\n * uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);\n * if (!new_buf) {\n *     // Allocation failed; clean up original buffer\n *     av_freep(&buf);\n *     return AVERROR(ENOMEM);\n * }\n * @endcode\n *\n * @param[in,out] ptr      Already allocated buffer, or `NULL`\n * @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is\n *                         updated to the new allocated size, in particular 0\n *                         in case of failure.\n * @param[in]     min_size Desired minimal size of buffer `ptr`\n * @return `ptr` if the buffer is large enough, a pointer to newly reallocated\n *         buffer if the buffer was not large enough, or `NULL` in case of\n *         error\n * @see av_realloc()\n * @see av_fast_malloc()\n */"
 },
 "av_fast_malloc": {
  "type": "void",
  "definition": "void av_fast_malloc",
  "argsstring": "(void *ptr, unsigned int *size, size_t min_size)",
  "name": "av_fast_malloc",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "unsigned int *",
    "declname": "size"
   },
   {
    "type": "size_t",
    "declname": "min_size"
   }
  ],
  "briefdescription": {
   "para": "Allocate a buffer, reusing the given one if large enough."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_fast_realloc()",
      "@_refid": "group__lavu__mem__funcs_1ga0e8e75b89c5fa2966b8fbffbdb6ec774",
      "@_kindref": "member"
     },
     "#text": "Contrary to, the current buffer contents might not be preserved and on error the old buffer is freed, thus no special handling to avoid memleaks is necessary."
    },
    {
     "computeroutput": [
      "*ptr",
      "NULL",
      "size_needed"
     ],
     "#text": "is allowed to be, in which case allocation always happens ifis greater than 0."
    },
    {
     "programlisting": {
      "codeline": [
       {
        "highlight": {
         "sp": [
          "",
          "",
          ""
         ],
         "#text": "uint8_t*buf=...;",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "ref": {
          "#text": "av_fast_malloc",
          "@_refid": "group__lavu__mem__funcs_1ga29d0252b981f157e713a68ffca52f003",
          "@_kindref": "member"
         },
         "sp": [
          "",
          ""
         ],
         "#text": "(&buf,&current_size,size_needed);",
         "@_class": "normal"
        }
       },
       {
        "highlight": [
         {
          "@_class": "normal"
         },
         {
          "#text": "if",
          "@_class": "keywordflow"
         },
         {
          "sp": [
           "",
           ""
          ],
          "#text": "(!buf){",
          "@_class": "normal"
         }
        ]
       },
       {
        "highlight": [
         {
          "sp": [
           "",
           "",
           "",
           ""
          ],
          "@_class": "normal"
         },
         {
          "sp": [
           "",
           "",
           "",
           "",
           ""
          ],
          "#text": "//Allocationfailed;bufalreadyfreed",
          "@_class": "comment"
         },
         {
          "@_class": "normal"
         }
        ]
       },
       {
        "highlight": [
         {
          "sp": [
           "",
           "",
           "",
           ""
          ],
          "@_class": "normal"
         },
         {
          "#text": "return",
          "@_class": "keywordflow"
         },
         {
          "sp": "",
          "ref": {
           "#text": "AVERROR",
           "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
           "@_kindref": "member"
          },
          "#text": "(ENOMEM);",
          "@_class": "normal"
         }
        ]
       },
       {
        "highlight": {
         "#text": "}",
         "@_class": "normal"
        }
       }
      ],
      "@_filename": ".c"
     }
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ptr",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": [
           "*ptr",
           "NULL"
          ],
          "#text": "Pointer to pointer to an already allocated buffer.will be overwritten with pointer to new buffer on success oron failure"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "size",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": [
           "*ptr",
           "*size"
          ],
          "#text": "Pointer to the size of buffer.is updated to the new allocated size, in particular 0 in case of failure."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "min_size",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "*ptr",
          "#text": "Desired minimal size of buffer"
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "av_realloc()",
         "@_refid": "group__lavu__mem__funcs_1ga45fc6fd08120d07ddf4ed39f597f31b4",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      },
      {
       "para": {
        "ref": {
         "#text": "av_fast_mallocz()",
         "@_refid": "group__lavu__mem__funcs_1ga0bfda4adf7f9e943f9eb1a08eeda3791",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "322",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "322",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga29d0252b981f157e713a68ffca52f003",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a buffer, reusing the given one if large enough.\n *\n * Contrary to av_fast_realloc(), the current buffer contents might not be\n * preserved and on error the old buffer is freed, thus no special handling to\n * avoid memleaks is necessary.\n *\n * `*ptr` is allowed to be `NULL`, in which case allocation always happens if\n * `size_needed` is greater than 0.\n *\n * @code{.c}\n * uint8_t *buf = ...;\n * av_fast_malloc(&buf, &current_size, size_needed);\n * if (!buf) {\n *     // Allocation failed; buf already freed\n *     return AVERROR(ENOMEM);\n * }\n * @endcode\n *\n * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.\n *                         `*ptr` will be overwritten with pointer to new\n *                         buffer on success or `NULL` on failure\n * @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is\n *                         updated to the new allocated size, in particular 0\n *                         in case of failure.\n * @param[in]     min_size Desired minimal size of buffer `*ptr`\n * @see av_realloc()\n * @see av_fast_mallocz()\n */"
 },
 "av_fast_mallocz": {
  "type": "void",
  "definition": "void av_fast_mallocz",
  "argsstring": "(void *ptr, unsigned int *size, size_t min_size)",
  "name": "av_fast_mallocz",
  "param": [
   {
    "type": "void *",
    "declname": "ptr"
   },
   {
    "type": "unsigned int *",
    "declname": "size"
   },
   {
    "type": "size_t",
    "declname": "min_size"
   }
  ],
  "briefdescription": {
   "para": "Allocate and clear a buffer, reusing the given one if large enough."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_fast_malloc()",
      "@_refid": "group__lavu__mem__funcs_1ga29d0252b981f157e713a68ffca52f003",
      "@_kindref": "member"
     },
     "#text": "Like, but all newly allocated space is initially cleared. Reused buffer is not cleared."
    },
    {
     "computeroutput": [
      "*ptr",
      "NULL",
      "size_needed"
     ],
     "#text": "is allowed to be, in which case allocation always happens ifis greater than 0."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "ptr",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": [
           "*ptr",
           "NULL"
          ],
          "#text": "Pointer to pointer to an already allocated buffer.will be overwritten with pointer to new buffer on success oron failure"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "size",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": [
           "*ptr",
           "*size"
          ],
          "#text": "Pointer to the size of buffer.is updated to the new allocated size, in particular 0 in case of failure."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "min_size",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "*ptr",
          "#text": "Desired minimal size of buffer"
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_fast_malloc()",
        "@_refid": "group__lavu__mem__funcs_1ga29d0252b981f157e713a68ffca52f003",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "342",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "342",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga0bfda4adf7f9e943f9eb1a08eeda3791",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate and clear a buffer, reusing the given one if large enough.\n *\n * Like av_fast_malloc(), but all newly allocated space is initially cleared.\n * Reused buffer is not cleared.\n *\n * `*ptr` is allowed to be `NULL`, in which case allocation always happens if\n * `size_needed` is greater than 0.\n *\n * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.\n *                         `*ptr` will be overwritten with pointer to new\n *                         buffer on success or `NULL` on failure\n * @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is\n *                         updated to the new allocated size, in particular 0\n *                         in case of failure.\n * @param[in]     min_size Desired minimal size of buffer `*ptr`\n * @see av_fast_malloc()\n */"
 },
 "av_free": {
  "type": "void",
  "definition": "void av_free",
  "argsstring": "(void *ptr)",
  "name": "av_free",
  "param": {
   "type": "void *",
   "declname": "ptr"
  },
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "av_malloc()",
      "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
      "@_kindref": "member"
     },
     {
      "#text": "av_realloc()",
      "@_refid": "group__lavu__mem__funcs_1ga45fc6fd08120d07ddf4ed39f597f31b4",
      "@_kindref": "member"
     }
    ],
    "#text": "Free a memory block which has been allocated with a function oforfamily."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "ptr"
      },
      "parameterdescription": {
       "para": "Pointer to the memory block which should be freed."
      }
     },
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": {
       "computeroutput": "ptr = NULL",
       "#text": "is explicitly allowed."
      },
      "@_kind": "note"
     },
     {
      "para": {
       "ref": {
        "#text": "av_freep()",
        "@_refid": "group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba",
        "@_kindref": "member"
       },
       "#text": "It is recommended that you useinstead, to prevent leaving behind dangling pointers."
      },
      "@_kind": "note"
     },
     {
      "para": {
       "ref": {
        "#text": "av_freep()",
        "@_refid": "group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "355",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "355",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "decode__audio_8c",
   "@_startline": "106",
   "@_endline": "237"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free a memory block which has been allocated with a function of av_malloc()\n * or av_realloc() family.\n *\n * @param ptr Pointer to the memory block which should be freed.\n *\n * @note `ptr = NULL` is explicitly allowed.\n * @note It is recommended that you use av_freep() instead, to prevent leaving\n *       behind dangling pointers.\n * @see av_freep()\n */"
 },
 "av_freep": {
  "type": "void",
  "definition": "void av_freep",
  "argsstring": "(void *ptr)",
  "name": "av_freep",
  "param": {
   "type": "void *",
   "declname": "ptr"
  },
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "av_malloc()",
      "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
      "@_kindref": "member"
     },
     {
      "#text": "av_realloc()",
      "@_refid": "group__lavu__mem__funcs_1ga45fc6fd08120d07ddf4ed39f597f31b4",
      "@_kindref": "member"
     }
    ],
    "computeroutput": "NULL",
    "#text": "Free a memory block which has been allocated with a function oforfamily, and set the pointer pointing to it to."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "programlisting": {
      "codeline": [
       {
        "highlight": {
         "sp": [
          "",
          "",
          ""
         ],
         "ref": {
          "#text": "av_malloc",
          "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
          "@_kindref": "member"
         },
         "#text": "uint8_t*buf=(16);",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "ref": {
          "#text": "av_free",
          "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
          "@_kindref": "member"
         },
         "#text": "(buf);",
         "@_class": "normal"
        }
       },
       {
        "highlight": [
         {
          "@_class": "normal"
         },
         {
          "sp": [
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           ""
          ],
          "#text": "//bufnowcontainsadanglingpointertofreedmemory,andaccidental",
          "@_class": "comment"
         },
         {
          "@_class": "normal"
         }
        ]
       },
       {
        "highlight": [
         {
          "@_class": "normal"
         },
         {
          "sp": [
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           ""
          ],
          "#text": "//dereferenceofbufwillresultinause-after-free,whichmaybea",
          "@_class": "comment"
         },
         {
          "@_class": "normal"
         }
        ]
       },
       {
        "highlight": [
         {
          "@_class": "normal"
         },
         {
          "sp": [
           "",
           ""
          ],
          "#text": "//securityrisk.",
          "@_class": "comment"
         },
         {
          "@_class": "normal"
         }
        ]
       },
       {
        "highlight": {
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "sp": [
          "",
          "",
          ""
         ],
         "ref": {
          "#text": "av_malloc",
          "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
          "@_kindref": "member"
         },
         "#text": "uint8_t*buf=(16);",
         "@_class": "normal"
        }
       },
       {
        "highlight": {
         "ref": {
          "#text": "av_freep",
          "@_refid": "group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba",
          "@_kindref": "member"
         },
         "#text": "(&buf);",
         "@_class": "normal"
        }
       },
       {
        "highlight": [
         {
          "@_class": "normal"
         },
         {
          "sp": [
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           "",
           ""
          ],
          "#text": "//bufisnowNULL,andaccidentaldereferencewillonlyresultina",
          "@_class": "comment"
         },
         {
          "@_class": "normal"
         }
        ]
       },
       {
        "highlight": [
         {
          "@_class": "normal"
         },
         {
          "sp": [
           "",
           ""
          ],
          "#text": "//NULL-pointerdereference.",
          "@_class": "comment"
         }
        ]
       }
      ],
      "@_filename": ".c"
     }
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "ptr"
       },
       "parameterdescription": {
        "para": "Pointer to the pointer to the memory block which should be freed"
       }
      },
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "computeroutput": "*ptr = NULL",
        "#text": "is safe and leads to no action."
       },
       "@_kind": "note"
      },
      {
       "para": {
        "ref": {
         "#text": "av_free()",
         "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "378",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "378",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "decode_write",
    "@_refid": "hw__decode_8c_1aa376d8bc0bb004de4856e8920e0f6217",
    "@_compoundref": "hw__decode_8c",
    "@_startline": "76",
    "@_endline": "146"
   },
   {
    "#text": "main",
    "@_refid": "avio__read__callback_8c_1a0ddf1224851353fc92bfbff6f499fa97",
    "@_compoundref": "avio__read__callback_8c",
    "@_startline": "58",
    "@_endline": "133"
   },
   {
    "#text": "read_decode_convert_and_store",
    "@_refid": "transcode__aac_8c_1a7f6cf47c64ae78cbdad6115e57aa2c2f",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "542",
    "@_endline": "598"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free a memory block which has been allocated with a function of av_malloc()\n * or av_realloc() family, and set the pointer pointing to it to `NULL`.\n *\n * @code{.c}\n * uint8_t *buf = av_malloc(16);\n * av_free(buf);\n * // buf now contains a dangling pointer to freed memory, and accidental\n * // dereference of buf will result in a use-after-free, which may be a\n * // security risk.\n *\n * uint8_t *buf = av_malloc(16);\n * av_freep(&buf);\n * // buf is now NULL, and accidental dereference will only result in a\n * // NULL-pointer dereference.\n * @endcode\n *\n * @param ptr Pointer to the pointer to the memory block which should be freed\n * @note `*ptr = NULL` is safe and leads to no action.\n * @see av_free()\n */"
 },
 "av_strdup": {
  "type": "char *",
  "definition": "char * av_strdup",
  "argsstring": "(const char *s) av_malloc_attrib",
  "name": "av_strdup",
  "param": {
   "type": "const char *",
   "declname": "s"
  },
  "briefdescription": {
   "para": "Duplicate a string."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "s"
      },
      "parameterdescription": {
       "para": "String to be duplicated"
      }
     },
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": {
       "computeroutput": [
        "s",
        "NULL"
       ],
       "#text": "Pointer to a newly-allocated string containing a copy oforif the string cannot be allocated"
      },
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_strndup()",
        "@_refid": "group__lavu__mem__funcs_1ga218fb02c84a1a72e6a81d63c56785a4d",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "388",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "388",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   },
   {
    "#text": "open_output_file",
    "@_refid": "transcode__aac_8c_1a617f4760254c119fc7caa222f3fcbd21",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "145",
    "@_endline": "246"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga669091e689cc330998001d79edca9b3e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Duplicate a string.\n *\n * @param s String to be duplicated\n * @return Pointer to a newly-allocated string containing a\n *         copy of `s` or `NULL` if the string cannot be allocated\n * @see av_strndup()\n */"
 },
 "av_strndup": {
  "type": "char *",
  "definition": "char * av_strndup",
  "argsstring": "(const char *s, size_t len) av_malloc_attrib",
  "name": "av_strndup",
  "param": [
   {
    "type": "const char *",
    "declname": "s"
   },
   {
    "type": "size_t",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Duplicate a substring of a string."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "String to be duplicated"
       }
      },
      {
       "parameternamelist": {
        "parametername": "len"
       },
       "parameterdescription": {
        "para": "Maximum length of the resulting string (not counting the terminating byte)"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "computeroutput": [
       "s",
       "NULL"
      ],
      "#text": "Pointer to a newly-allocated string containing a substring oforif the string cannot be allocated"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "399",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "399",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga218fb02c84a1a72e6a81d63c56785a4d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Duplicate a substring of a string.\n *\n * @param s   String to be duplicated\n * @param len Maximum length of the resulting string (not counting the\n *            terminating byte)\n * @return Pointer to a newly-allocated string containing a\n *         substring of `s` or `NULL` if the string cannot be allocated\n */"
 },
 "av_memdup": {
  "type": "void *",
  "definition": "void * av_memdup",
  "argsstring": "(const void *p, size_t size)",
  "name": "av_memdup",
  "param": [
   {
    "type": "const void *",
    "declname": "p"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_malloc()",
     "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
     "@_kindref": "member"
    },
    "#text": "Duplicate a buffer with."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "p"
       },
       "parameterdescription": {
        "para": "Buffer to be duplicated"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "Size in bytes of the buffer copied"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "computeroutput": [
       "p",
       "NULL"
      ],
      "#text": "Pointer to a newly allocated buffer containing a copy oforif the buffer cannot be allocated"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "409",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "409",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1gaa3c6ad87f3cf7f98404653809fb00c63",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Duplicate a buffer with av_malloc().\n *\n * @param p    Buffer to be duplicated\n * @param size Size in bytes of the buffer copied\n * @return Pointer to a newly allocated buffer containing a\n *         copy of `p` or `NULL` if the buffer cannot be allocated\n */"
 },
 "av_memcpy_backptr": {
  "type": "void",
  "definition": "void av_memcpy_backptr",
  "argsstring": "(uint8_t *dst, int back, int cnt)",
  "name": "av_memcpy_backptr",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "int",
    "declname": "back"
   },
   {
    "type": "int",
    "declname": "cnt"
   }
  ],
  "briefdescription": {
   "para": "Overlapping memcpy() implementation."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "Destination buffer"
       }
      },
      {
       "parameternamelist": {
        "parametername": "back"
       },
       "parameterdescription": {
        "para": "Number of bytes back to start copying (i.e. the initial size of the overlapping window); must be > 0"
       }
      },
      {
       "parameternamelist": {
        "parametername": "cnt"
       },
       "parameterdescription": {
        "para": "Number of bytes to copy; must be >= 0"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "computeroutput": [
       "cnt > back",
       "back"
      ],
      "#text": "is valid, this will copy the bytes we just copied, thus creating a repeating pattern with a period length of."
     },
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "422",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "422",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__funcs_1ga3ea4736dcceab4ba033b8abd2c2a180e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Overlapping memcpy() implementation.\n *\n * @param dst  Destination buffer\n * @param back Number of bytes back to start copying (i.e. the initial size of\n *             the overlapping window); must be > 0\n * @param cnt  Number of bytes to copy; must be >= 0\n *\n * @note `cnt > back` is valid, this will copy the bytes we just copied,\n *       thus creating a repeating pattern with a period length of `back`.\n */"
 },
 "av_dynarray_add": {
  "type": "void",
  "definition": "void av_dynarray_add",
  "argsstring": "(void *tab_ptr, int *nb_ptr, void *elem)",
  "name": "av_dynarray_add",
  "param": [
   {
    "type": "void *",
    "declname": "tab_ptr"
   },
   {
    "type": "int *",
    "declname": "nb_ptr"
   },
   {
    "type": "void *",
    "declname": "elem"
   }
  ],
  "briefdescription": {
   "para": "Add the pointer to an element to a dynamic array."
  },
  "detaileddescription": {
   "para": [
    "The array to grow is supposed to be an array of pointers to structures, and the element to add must be a pointer to an already allocated structure.",
    "The array is reallocated when its size reaches powers of 2. Therefore, the amortized cost of adding an element is constant.",
    {
     "computeroutput": [
      "nb_ptr",
      "*tab_ptr",
      "NULL",
      "*nb_ptr"
     ],
     "#text": "In case of success, the pointer to the array is updated in order to point to the new grown array, and the number pointed to byis incremented. In case of failure, the array is freed,is set toandis set to 0."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "tab_ptr",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": "Pointer to the array to grow"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "nb_ptr",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": "Pointer to the number of elements in the array"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "elem",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Element to add"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "av_dynarray_add_nofree()",
         "@_refid": "group__lavu__mem__dynarray_1ga5e3735b4568e78fffd7c4ea2f793996e",
         "@_kindref": "member"
        },
        {
         "#text": "av_dynarray2_add()",
         "@_refid": "group__lavu__mem__dynarray_1ga3065fcfabfeff13806c455b7e56300b0",
         "@_kindref": "member"
        }
       ],
       "#text": ","
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "524",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "524",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__dynarray_1ga385b582522cedf5a88ce2cf158c396c9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add the pointer to an element to a dynamic array.\n *\n * The array to grow is supposed to be an array of pointers to\n * structures, and the element to add must be a pointer to an already\n * allocated structure.\n *\n * The array is reallocated when its size reaches powers of 2.\n * Therefore, the amortized cost of adding an element is constant.\n *\n * In case of success, the pointer to the array is updated in order to\n * point to the new grown array, and the number pointed to by `nb_ptr`\n * is incremented.\n * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and\n * `*nb_ptr` is set to 0.\n *\n * @param[in,out] tab_ptr Pointer to the array to grow\n * @param[in,out] nb_ptr  Pointer to the number of elements in the array\n * @param[in]     elem    Element to add\n * @see av_dynarray_add_nofree(), av_dynarray2_add()\n */"
 },
 "av_dynarray_add_nofree": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int av_dynarray_add_nofree",
  "argsstring": "(void *tab_ptr, int *nb_ptr, void *elem)",
  "name": "av_dynarray_add_nofree",
  "param": [
   {
    "type": "void *",
    "declname": "tab_ptr"
   },
   {
    "type": "int *",
    "declname": "nb_ptr"
   },
   {
    "type": "void *",
    "declname": "elem"
   }
  ],
  "briefdescription": {
   "para": "Add an element to a dynamic array."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_dynarray_add()",
      "@_refid": "group__lavu__mem__dynarray_1ga385b582522cedf5a88ce2cf158c396c9",
      "@_kindref": "member"
     },
     "#text": "Function has the same functionality as, but it doesn't free memory on fails. It returns error code instead and leave current buffer untouched."
    },
    {
     "simplesect": [
      {
       "para": ">=0 on success, negative otherwise",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": [
         {
          "#text": "av_dynarray_add()",
          "@_refid": "group__lavu__mem__dynarray_1ga385b582522cedf5a88ce2cf158c396c9",
          "@_kindref": "member"
         },
         {
          "#text": "av_dynarray2_add()",
          "@_refid": "group__lavu__mem__dynarray_1ga3065fcfabfeff13806c455b7e56300b0",
          "@_kindref": "member"
         }
        ],
        "#text": ","
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "537",
   "@_column": "5",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "537",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__dynarray_1ga5e3735b4568e78fffd7c4ea2f793996e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add an element to a dynamic array.\n *\n * Function has the same functionality as av_dynarray_add(),\n * but it doesn't free memory on fails. It returns error code\n * instead and leave current buffer untouched.\n *\n * @return >=0 on success, negative otherwise\n * @see av_dynarray_add(), av_dynarray2_add()\n */"
 },
 "av_dynarray2_add": {
  "type": "void *",
  "definition": "void * av_dynarray2_add",
  "argsstring": "(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)",
  "name": "av_dynarray2_add",
  "param": [
   {
    "type": "void **",
    "declname": "tab_ptr"
   },
   {
    "type": "int *",
    "declname": "nb_ptr"
   },
   {
    "type": "size_t",
    "declname": "elem_size"
   },
   {
    "type": "const uint8_t *",
    "declname": "elem_data"
   }
  ],
  "briefdescription": {
   "para": {
    "computeroutput": "elem_size",
    "#text": "Add an element of sizeto a dynamic array."
   }
  },
  "detaileddescription": {
   "para": [
    "The array is reallocated when its number of elements reaches powers of 2. Therefore, the amortized cost of adding an element is constant.",
    {
     "computeroutput": [
      "nb_ptr",
      "*tab_ptr",
      "NULL",
      "*nb_ptr"
     ],
     "#text": "In case of success, the pointer to the array is updated in order to point to the new grown array, and the number pointed to byis incremented. In case of failure, the array is freed,is set toandis set to 0."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "tab_ptr",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": "Pointer to the array to grow"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "nb_ptr",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": "Pointer to the number of elements in the array"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "elem_size",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Size in bytes of an element in the array"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "elem_data",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "NULL",
          "#text": "Pointer to the data of the element to add. If, the space of the newly added element is allocated but left uninitialized."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "Pointer to the data of the element to copy in the newly allocated space",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": [
         {
          "#text": "av_dynarray_add()",
          "@_refid": "group__lavu__mem__dynarray_1ga385b582522cedf5a88ce2cf158c396c9",
          "@_kindref": "member"
         },
         {
          "#text": "av_dynarray_add_nofree()",
          "@_refid": "group__lavu__mem__dynarray_1ga5e3735b4568e78fffd7c4ea2f793996e",
          "@_kindref": "member"
         }
        ],
        "#text": ","
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "562",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "562",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__dynarray_1ga3065fcfabfeff13806c455b7e56300b0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add an element of size `elem_size` to a dynamic array.\n *\n * The array is reallocated when its number of elements reaches powers of 2.\n * Therefore, the amortized cost of adding an element is constant.\n *\n * In case of success, the pointer to the array is updated in order to\n * point to the new grown array, and the number pointed to by `nb_ptr`\n * is incremented.\n * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and\n * `*nb_ptr` is set to 0.\n *\n * @param[in,out] tab_ptr   Pointer to the array to grow\n * @param[in,out] nb_ptr    Pointer to the number of elements in the array\n * @param[in]     elem_size Size in bytes of an element in the array\n * @param[in]     elem_data Pointer to the data of the element to add. If\n *                          `NULL`, the space of the newly added element is\n *                          allocated but left uninitialized.\n *\n * @return Pointer to the data of the element to copy in the newly allocated\n *         space\n * @see av_dynarray_add(), av_dynarray_add_nofree()\n */"
 },
 "av_size_mult": {
  "type": "int",
  "definition": "int av_size_mult",
  "argsstring": "(size_t a, size_t b, size_t *r)",
  "name": "av_size_mult",
  "param": [
   {
    "type": "size_t",
    "declname": "a"
   },
   {
    "type": "size_t",
    "declname": "b"
   },
   {
    "type": "size_t *",
    "declname": "r"
   }
  ],
  "briefdescription": {
   "para": {
    "computeroutput": "size_t",
    "#text": "Multiply twovalues checking for overflow."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "a",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "Operand of multiplication"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "b",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "Operand of multiplication"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "r",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "Pointer to the result of the operation"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVERROR(EINVAL)",
       "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
       "@_kindref": "member"
      },
      "#text": "0 on success,on overflow"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "585",
   "@_column": "5",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "585",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__misc_1gad53b48e68dc3cf6d186d2c69450f9fe7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Multiply two `size_t` values checking for overflow.\n *\n * @param[in]  a   Operand of multiplication\n * @param[in]  b   Operand of multiplication\n * @param[out] r   Pointer to the result of the operation\n * @return 0 on success, AVERROR(EINVAL) on overflow\n */"
 },
 "av_max_alloc": {
  "type": "void",
  "definition": "void av_max_alloc",
  "argsstring": "(size_t max)",
  "name": "av_max_alloc",
  "param": {
   "type": "size_t",
   "declname": "max"
  },
  "briefdescription": {
   "para": "Set the maximum size that may be allocated in one block."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "heap management functions.",
      "@_refid": "group__lavu__mem__funcs",
      "@_kindref": "compound"
     },
     "#text": "The value specified with this function is effective for all libavutil's"
    },
    {
     "computeroutput": "INT_MAX",
     "#text": "By default, the max value is defined as."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "max"
       },
       "parameterdescription": {
        "para": "Value to be set as the new maximum size"
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": "Exercise extreme caution when using this function. Don't touch this if you do not understand the full consequence of doing so.",
      "@_kind": "warning"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/mem.h",
   "@_line": "600",
   "@_column": "6",
   "@_declfile": "libavutil/mem.h",
   "@_declline": "600",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__mem__misc_1ga2204fc859b4a3ca2d5bfd1bf4e8c4dfb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set the maximum size that may be allocated in one block.\n *\n * The value specified with this function is effective for all libavutil's @ref\n * lavu_mem_funcs \"heap management functions.\"\n *\n * By default, the max value is defined as `INT_MAX`.\n *\n * @param max Value to be set as the new maximum size\n *\n * @warning Exercise extreme caution when using this function. Don't touch\n *          this if you do not understand the full consequence of doing so.\n */"
 },
 "av_murmur3_alloc": {
  "type": "struct AVMurMur3 *",
  "definition": "struct AVMurMur3 * av_murmur3_alloc",
  "argsstring": "(void)",
  "name": "av_murmur3_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVMurMur3 hash context."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "computeroutput": "NULL",
      "#text": "Uninitialized hash context orin case of error"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/murmur3.h",
   "@_line": "67",
   "@_column": "16",
   "@_declfile": "libavutil/murmur3.h",
   "@_declline": "67",
   "@_declcolumn": "16"
  },
  "@_kind": "function",
  "@_id": "group__lavu__murmur3_1ga136a791b3e1ace3d7dd54d7539af7bab",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVMurMur3 hash context.\n *\n * @return Uninitialized hash context or `NULL` in case of error\n */"
 },
 "av_murmur3_init_seeded": {
  "type": "void",
  "definition": "void av_murmur3_init_seeded",
  "argsstring": "(struct AVMurMur3 *c, uint64_t seed)",
  "name": "av_murmur3_init_seeded",
  "param": [
   {
    "type": "struct AVMurMur3 *",
    "declname": "c"
   },
   {
    "type": "uint64_t",
    "declname": "seed"
   }
  ],
  "briefdescription": {
   "para": "Initialize or reinitialize an AVMurMur3 hash context with a seed."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "c",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "Hash context"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "seed",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "Random seed"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "av_murmur3_init()",
        "@_refid": "group__lavu__murmur3_1ga403fc40619831d043c444bf1df0b893d",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     },
     {
      "para": {
       "ref": {
        "#text": "Detailed description",
        "@_refid": "group__lavu__murmur3_1lavu_murmur3_seedinfo",
        "@_kindref": "member"
       },
       "#text": "on a discussion of seeds for MurmurHash3."
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/murmur3.h",
   "@_line": "79",
   "@_column": "6",
   "@_declfile": "libavutil/murmur3.h",
   "@_declline": "79",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__murmur3_1ga8870f1e1d537790bc224c04e955d357b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize or reinitialize an AVMurMur3 hash context with a seed.\n *\n * @param[out] c    Hash context\n * @param[in]  seed Random seed\n *\n * @see av_murmur3_init()\n * @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of\n * seeds for MurmurHash3.\n */"
 },
 "av_murmur3_init": {
  "type": "void",
  "definition": "void av_murmur3_init",
  "argsstring": "(struct AVMurMur3 *c)",
  "name": "av_murmur3_init",
  "param": {
   "type": "struct AVMurMur3 *",
   "declname": "c"
  },
  "briefdescription": {
   "para": "Initialize or reinitialize an AVMurMur3 hash context."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_murmur3_init_seeded()",
      "@_refid": "group__lavu__murmur3_1ga8870f1e1d537790bc224c04e955d357b",
      "@_kindref": "member"
     },
     "#text": "Equivalent towith a built-in seed."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": {
         "#text": "c",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "Hash context"
       }
      },
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "av_murmur3_init_seeded()",
         "@_refid": "group__lavu__murmur3_1ga8870f1e1d537790bc224c04e955d357b",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      },
      {
       "para": {
        "ref": {
         "#text": "Detailed description",
         "@_refid": "group__lavu__murmur3_1lavu_murmur3_seedinfo",
         "@_kindref": "member"
        },
        "#text": "on a discussion of seeds for MurmurHash3."
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/murmur3.h",
   "@_line": "92",
   "@_column": "6",
   "@_declfile": "libavutil/murmur3.h",
   "@_declline": "92",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__murmur3_1ga403fc40619831d043c444bf1df0b893d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize or reinitialize an AVMurMur3 hash context.\n *\n * Equivalent to av_murmur3_init_seeded() with a built-in seed.\n *\n * @param[out] c    Hash context\n *\n * @see av_murmur3_init_seeded()\n * @see @ref lavu_murmur3_seedinfo \"Detailed description\" on a discussion of\n * seeds for MurmurHash3.\n */"
 },
 "av_murmur3_update": {
  "type": "void",
  "definition": "void av_murmur3_update",
  "argsstring": "(struct AVMurMur3 *c, const uint8_t *src, size_t len)",
  "name": "av_murmur3_update",
  "param": [
   {
    "type": "struct AVMurMur3 *",
    "declname": "c"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "size_t",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Update hash context with new data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "c",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "Hash context"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "src",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "Input data to update hash with"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "len",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": {
         "computeroutput": "src",
         "#text": "Number of bytes to read from"
        }
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/murmur3.h",
   "@_line": "101",
   "@_column": "6",
   "@_declfile": "libavutil/murmur3.h",
   "@_declline": "101",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__murmur3_1ga267125b7374138187085b0e9eb737571",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Update hash context with new data.\n *\n * @param[out] c    Hash context\n * @param[in]  src  Input data to update hash with\n * @param[in]  len  Number of bytes to read from `src`\n */"
 },
 "av_murmur3_final": {
  "type": "void",
  "definition": "void av_murmur3_final",
  "argsstring": "(struct AVMurMur3 *c, uint8_t dst[16])",
  "name": "av_murmur3_final",
  "param": [
   {
    "type": "struct AVMurMur3 *",
    "declname": "c"
   },
   {
    "type": "uint8_t",
    "declname": "dst",
    "array": "[16]"
   }
  ],
  "briefdescription": {
   "para": "Finish hashing and output digest value."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "c",
         "@_direction": "inout"
        }
       },
       "parameterdescription": {
        "para": "Hash context"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "dst",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "Buffer where output digest value is stored"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/murmur3.h",
   "@_line": "109",
   "@_column": "6",
   "@_declfile": "libavutil/murmur3.h",
   "@_declline": "109",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__murmur3_1gaf11c74aa0af4c0d6d422eb627b96a0c6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finish hashing and output digest value.\n *\n * @param[in,out] c    Hash context\n * @param[out]    dst  Buffer where output digest value is stored\n */"
 },
 "av_opt_set_defaults": {
  "type": "void",
  "definition": "void av_opt_set_defaults",
  "argsstring": "(void *s)",
  "name": "av_opt_set_defaults",
  "param": {
   "type": "void *",
   "declname": "s"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVOption",
     "@_refid": "structAVOption",
     "@_kindref": "compound"
    },
    "#text": "Set the values of allfields to their default values."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "s"
      },
      "parameterdescription": {
       "para": {
        "ref": {
         "#text": "AVClass",
         "@_refid": "structAVClass",
         "@_kindref": "compound"
        },
        "#text": "an AVOption-enabled struct (its first member must be a pointer to)"
       }
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "477",
   "@_column": "6",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "477",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__opt__mng_1gad4ca968e9058b39b2da630ad0a091bdb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set the values of all AVOption fields to their default values.\n *\n * @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)\n */"
 },
 "av_opt_set_defaults2": {
  "type": "void",
  "definition": "void av_opt_set_defaults2",
  "argsstring": "(void *s, int mask, int flags)",
  "name": "av_opt_set_defaults2",
  "param": [
   {
    "type": "void *",
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "mask"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVOption",
     "@_refid": "structAVOption",
     "@_kindref": "compound"
    },
    "#text": "Set the values of allfields to their default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AVOption",
      "@_refid": "structAVOption",
      "@_kindref": "compound"
     },
     "#text": "Only thesefields for which (opt->flags & mask) == flags will have their default applied to s."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVClass",
           "@_refid": "structAVClass",
           "@_kindref": "compound"
          },
          "#text": "an AVOption-enabled struct (its first member must be a pointer to)"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "mask"
        },
        "parameterdescription": {
         "para": "combination of AV_OPT_FLAG_*"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "combination of AV_OPT_FLAG_*"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "488",
   "@_column": "6",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "488",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__opt__mng_1gaeef5479b31ac29a6a55eb9d108d6225f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set the values of all AVOption fields to their default values. Only these\n * AVOption fields for which (opt->flags & mask) == flags will have their\n * default applied to s.\n *\n * @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)\n * @param mask combination of AV_OPT_FLAG_*\n * @param flags combination of AV_OPT_FLAG_*\n */"
 },
 "av_opt_free": {
  "type": "void",
  "definition": "void av_opt_free",
  "argsstring": "(void *obj)",
  "name": "av_opt_free",
  "param": {
   "type": "void *",
   "declname": "obj"
  },
  "briefdescription": {
   "para": "Free all allocated objects in obj."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "493",
   "@_column": "6",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "493",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__opt__mng_1gac14db824af52baf8181406e98d116097",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free all allocated objects in obj.\n */"
 },
 "av_opt_next": {
  "type": {
   "ref": {
    "#text": "AVOption",
    "@_refid": "structAVOption",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVOption * av_opt_next",
  "argsstring": "(const void *obj, const AVOption *prev)",
  "name": "av_opt_next",
  "param": [
   {
    "type": "const void *",
    "declname": "obj"
   },
   {
    "type": {
     "ref": {
      "#text": "AVOption",
      "@_refid": "structAVOption",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "prev"
   }
  ],
  "briefdescription": {
   "para": "Iterate over all AVOptions belonging to obj."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "obj"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "an AVOptions-enabled struct or a double pointer to andescribing it."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "prev"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_opt_next()",
          "@_refid": "group__opt__mng_1gafbe418a443aa11838ac10318df5d96f7",
          "@_kindref": "member"
         },
         "#text": "result of the previous call toon this object or NULL"
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVOption",
       "@_refid": "structAVOption",
       "@_kindref": "compound"
      },
      "#text": "nextor NULL"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "504",
   "@_column": "16",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "504",
   "@_declcolumn": "16"
  },
  "@_kind": "function",
  "@_id": "group__opt__mng_1gafbe418a443aa11838ac10318df5d96f7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over all AVOptions belonging to obj.\n *\n * @param obj an AVOptions-enabled struct or a double pointer to an\n *            AVClass describing it.\n * @param prev result of the previous call to av_opt_next() on this object\n *             or NULL\n * @return next AVOption or NULL\n */"
 },
 "av_opt_child_next": {
  "type": "void *",
  "definition": "void * av_opt_child_next",
  "argsstring": "(void *obj, void *prev)",
  "name": "av_opt_child_next",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "void *",
    "declname": "prev"
   }
  ],
  "briefdescription": {
   "para": "Iterate over AVOptions-enabled children of obj."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "prev"
      },
      "parameterdescription": {
       "para": "result of a previous call to this function or NULL"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "next AVOptions-enabled child or NULL",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "512",
   "@_column": "6",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "512",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__opt__mng_1gac93347d7be97385868d17e7284356df4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over AVOptions-enabled children of obj.\n *\n * @param prev result of a previous call to this function or NULL\n * @return next AVOptions-enabled child or NULL\n */"
 },
 "av_opt_child_class_iterate": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * av_opt_child_class_iterate",
  "argsstring": "(const AVClass *parent, void **iter)",
  "name": "av_opt_child_class_iterate",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVClass",
      "@_refid": "structAVClass",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "parent"
   },
   {
    "type": "void **",
    "declname": "iter"
   }
  ],
  "briefdescription": {
   "para": "Iterate over potential AVOptions-enabled children of parent."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "iter"
      },
      "parameterdescription": {
       "para": "a pointer where iteration state is stored."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVClass",
       "@_refid": "structAVClass",
       "@_kindref": "compound"
      },
      "#text": "corresponding to next potential child or NULL"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "520",
   "@_column": "15",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "520",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__opt__mng_1ga0d73b14a043d066d877b173049429d0c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over potential AVOptions-enabled children of parent.\n *\n * @param iter a pointer where iteration state is stored.\n * @return AVClass corresponding to next potential child or NULL\n */"
 },
 "av_opt_find": {
  "type": {
   "ref": {
    "#text": "AVOption",
    "@_refid": "structAVOption",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVOption * av_opt_find",
  "argsstring": "(void *obj, const char *name, const char *unit, int opt_flags, int search_flags)",
  "name": "av_opt_find",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "const char *",
    "declname": "unit"
   },
   {
    "type": "int",
    "declname": "opt_flags"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": {
   "para": "Look for an option in an object."
  },
  "detaileddescription": {
   "para": [
    "Consider only options which have all the specified flags set.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "obj",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "AVClass",
            "@_refid": "structAVClass",
            "@_kindref": "compound"
           },
           {
            "#text": "AVClass",
            "@_refid": "structAVClass",
            "@_kindref": "compound"
           }
          ],
          "#text": "A pointer to a struct whose first element is a pointer to an. Alternatively a double pointer to an, if AV_OPT_SEARCH_FAKE_OBJ search flag is set."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "name",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "The name of the option to look for."
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "unit",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "When searching for named constants, name of the unit it belongs to."
        }
       },
       {
        "parameternamelist": {
         "parametername": "opt_flags"
        },
        "parameterdescription": {
         "para": "Find only options with all the specified flags set (AV_OPT_FLAG)."
        }
       },
       {
        "parameternamelist": {
         "parametername": "search_flags"
        },
        "parameterdescription": {
         "para": "A combination of AV_OPT_SEARCH_*."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "A pointer to the option found, or NULL if no option was found.",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": [
         {
          "#text": "av_opt_set()",
          "@_refid": "group__opt__set__funcs_1ga5fd4b92bdf4f392a2847f711676a7537",
          "@_kindref": "member"
         },
         {
          "#text": "avformat_open_input()",
          "@_refid": "group__lavf__decoding_1gac05d61a2b492ae3985c658f34622c19d",
          "@_kindref": "member"
         }
        ],
        "#text": "Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable directly with. Use special calls which take an options AVDictionary (e.g.) to set options found with this flag."
       },
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "567",
   "@_column": "16",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "567",
   "@_declcolumn": "16"
  },
  "@_kind": "function",
  "@_id": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Look for an option in an object. Consider only options which\n * have all the specified flags set.\n *\n * @param[in] obj A pointer to a struct whose first element is a\n *                pointer to an AVClass.\n *                Alternatively a double pointer to an AVClass, if\n *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.\n * @param[in] name The name of the option to look for.\n * @param[in] unit When searching for named constants, name of the unit\n *                 it belongs to.\n * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).\n * @param search_flags A combination of AV_OPT_SEARCH_*.\n *\n * @return A pointer to the option found, or NULL if no option\n *         was found.\n *\n * @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable\n * directly with av_opt_set(). Use special calls which take an options\n * AVDictionary (e.g. avformat_open_input()) to set options found with this\n * flag.\n */"
 },
 "av_opt_find2": {
  "type": {
   "ref": {
    "#text": "AVOption",
    "@_refid": "structAVOption",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVOption * av_opt_find2",
  "argsstring": "(void *obj, const char *name, const char *unit, int opt_flags, int search_flags, void **target_obj)",
  "name": "av_opt_find2",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "const char *",
    "declname": "unit"
   },
   {
    "type": "int",
    "declname": "opt_flags"
   },
   {
    "type": "int",
    "declname": "search_flags"
   },
   {
    "type": "void **",
    "declname": "target_obj"
   }
  ],
  "briefdescription": {
   "para": "Look for an option in an object."
  },
  "detaileddescription": {
   "para": [
    "Consider only options which have all the specified flags set.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "obj",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "AVClass",
            "@_refid": "structAVClass",
            "@_kindref": "compound"
           },
           {
            "#text": "AVClass",
            "@_refid": "structAVClass",
            "@_kindref": "compound"
           }
          ],
          "#text": "A pointer to a struct whose first element is a pointer to an. Alternatively a double pointer to an, if AV_OPT_SEARCH_FAKE_OBJ search flag is set."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "name",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "The name of the option to look for."
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "unit",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "When searching for named constants, name of the unit it belongs to."
        }
       },
       {
        "parameternamelist": {
         "parametername": "opt_flags"
        },
        "parameterdescription": {
         "para": "Find only options with all the specified flags set (AV_OPT_FLAG)."
        }
       },
       {
        "parameternamelist": {
         "parametername": "search_flags"
        },
        "parameterdescription": {
         "para": "A combination of AV_OPT_SEARCH_*."
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "target_obj",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "if non-NULL, an object to which the option belongs will be written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present in search_flags. This parameter is ignored if search_flags contain AV_OPT_SEARCH_FAKE_OBJ."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "A pointer to the option found, or NULL if no option was found.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "591",
   "@_column": "16",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "591",
   "@_declcolumn": "16"
  },
  "@_kind": "function",
  "@_id": "group__opt__mng_1ga25d2940b96b13eaec40fd2234ca9dca0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Look for an option in an object. Consider only options which\n * have all the specified flags set.\n *\n * @param[in] obj A pointer to a struct whose first element is a\n *                pointer to an AVClass.\n *                Alternatively a double pointer to an AVClass, if\n *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.\n * @param[in] name The name of the option to look for.\n * @param[in] unit When searching for named constants, name of the unit\n *                 it belongs to.\n * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).\n * @param search_flags A combination of AV_OPT_SEARCH_*.\n * @param[out] target_obj if non-NULL, an object to which the option belongs will be\n * written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present\n * in search_flags. This parameter is ignored if search_flags contain\n * AV_OPT_SEARCH_FAKE_OBJ.\n *\n * @return A pointer to the option found, or NULL if no option\n *         was found.\n */"
 },
 "av_opt_show2": {
  "type": "int",
  "definition": "int av_opt_show2",
  "argsstring": "(void *obj, void *av_log_obj, int req_flags, int rej_flags)",
  "name": "av_opt_show2",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "void *",
    "declname": "av_log_obj"
   },
   {
    "type": "int",
    "declname": "req_flags"
   },
   {
    "type": "int",
    "declname": "rej_flags"
   }
  ],
  "briefdescription": {
   "para": "Show the obj options."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "req_flags"
       },
       "parameterdescription": {
        "para": "requested flags for the options to show. Show only the options for which it is opt->flags & req_flags."
       }
      },
      {
       "parameternamelist": {
        "parametername": "rej_flags"
       },
       "parameterdescription": {
        "para": "rejected flags for the options to show. Show only the options for which it is !(opt->flags & req_flags)."
       }
      },
      {
       "parameternamelist": {
        "parametername": "av_log_obj"
       },
       "parameterdescription": {
        "para": "log context to use for showing the options"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "603",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "603",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__mng_1gaf7394e27d34208b24af8bb4b4a11741b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Show the obj options.\n *\n * @param req_flags requested flags for the options to show. Show only the\n * options for which it is opt->flags & req_flags.\n * @param rej_flags rejected flags for the options to show. Show only the\n * options for which it is !(opt->flags & req_flags).\n * @param av_log_obj log context to use for showing the options\n */"
 },
 "av_opt_get_key_value": {
  "type": "int",
  "definition": "int av_opt_get_key_value",
  "argsstring": "(const char **ropts, const char *key_val_sep, const char *pairs_sep, unsigned flags, char **rkey, char **rval)",
  "name": "av_opt_get_key_value",
  "param": [
   {
    "type": "const char **",
    "declname": "ropts"
   },
   {
    "type": "const char *",
    "declname": "key_val_sep"
   },
   {
    "type": "const char *",
    "declname": "pairs_sep"
   },
   {
    "type": "unsigned",
    "declname": "flags"
   },
   {
    "type": "char **",
    "declname": "rkey"
   },
   {
    "type": "char **",
    "declname": "rval"
   }
  ],
  "briefdescription": {
   "para": "Extract a key-value pair from the beginning of a string."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ropts"
       },
       "parameterdescription": {
        "para": "pointer to the options string, will be updated to point to the rest of the string (one of the pairs_sep or the final NUL)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key_val_sep"
       },
       "parameterdescription": {
        "para": "a 0-terminated list of characters used to separate key from value, for example '='"
       }
      },
      {
       "parameternamelist": {
        "parametername": "pairs_sep"
       },
       "parameterdescription": {
        "para": "a 0-terminated list of characters used to separate two pairs from each other, for example ':' or ','"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "flags; see the AV_OPT_FLAG_* values below"
       }
      },
      {
       "parameternamelist": {
        "parametername": "rkey"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_free()",
          "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
          "@_kindref": "member"
         },
         "#text": "parsed key; must be freed using"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "rval"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_free()",
          "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
          "@_kindref": "member"
         },
         "#text": "parsed value; must be freed using"
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVERROR(EINVAL)",
       "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
       "@_kindref": "member"
      },
      "#text": ">=0 for success, or a negative value corresponding to an AVERROR code in case of error; in particular:if no key is present"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "624",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "624",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__mng_1ga1e459af4e23415b8eb9b05aee81c933c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Extract a key-value pair from the beginning of a string.\n *\n * @param ropts        pointer to the options string, will be updated to\n *                     point to the rest of the string (one of the pairs_sep\n *                     or the final NUL)\n * @param key_val_sep  a 0-terminated list of characters used to separate\n *                     key from value, for example '='\n * @param pairs_sep    a 0-terminated list of characters used to separate\n *                     two pairs from each other, for example ':' or ','\n * @param flags        flags; see the AV_OPT_FLAG_* values below\n * @param rkey         parsed key; must be freed using av_free()\n * @param rval         parsed value; must be freed using av_free()\n *\n * @return  >=0 for success, or a negative value corresponding to an\n *          AVERROR code in case of error; in particular:\n *          AVERROR(EINVAL) if no key is present\n *\n */"
 },
 "av_set_options_string": {
  "type": "int",
  "definition": "int av_set_options_string",
  "argsstring": "(void *ctx, const char *opts, const char *key_val_sep, const char *pairs_sep)",
  "name": "av_set_options_string",
  "param": [
   {
    "type": "void *",
    "declname": "ctx"
   },
   {
    "type": "const char *",
    "declname": "opts"
   },
   {
    "type": "const char *",
    "declname": "key_val_sep"
   },
   {
    "type": "const char *",
    "declname": "pairs_sep"
   }
  ],
  "briefdescription": {
   "para": "Parse the key/value pairs list in opts."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AVClass",
      "@_refid": "structAVClass",
      "@_kindref": "compound"
     },
     "#text": "For each key/value pair found, stores the value in the field in ctx that is named like the key. ctx must be ancontext, storing is done using AVOptions."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "opts"
        },
        "parameterdescription": {
         "para": "options string to parse, may be NULL"
        }
       },
       {
        "parameternamelist": {
         "parametername": "key_val_sep"
        },
        "parameterdescription": {
         "para": "a 0-terminated list of characters used to separate key from value"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pairs_sep"
        },
        "parameterdescription": {
         "para": "a 0-terminated list of characters used to separate two pairs from each other"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "AVERROR(EINVAL)",
         "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
         "@_kindref": "member"
        },
        {
         "#text": "av_opt_set()",
         "@_refid": "group__opt__set__funcs_1ga5fd4b92bdf4f392a2847f711676a7537",
         "@_kindref": "member"
        }
       ],
       "#text": "the number of successfully set key/value pairs, or a negative value corresponding to an AVERROR code in case of error:if opts cannot be parsed, the error code issued byif a key/value pair cannot be set"
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "664",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "664",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__write_1gab48669d1326f7d47ef39e5702e34abd2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse the key/value pairs list in opts. For each key/value pair\n * found, stores the value in the field in ctx that is named like the\n * key. ctx must be an AVClass context, storing is done using\n * AVOptions.\n *\n * @param opts options string to parse, may be NULL\n * @param key_val_sep a 0-terminated list of characters used to\n * separate key from value\n * @param pairs_sep a 0-terminated list of characters used to separate\n * two pairs from each other\n * @return the number of successfully set key/value pairs, or a negative\n * value corresponding to an AVERROR code in case of error:\n * AVERROR(EINVAL) if opts cannot be parsed,\n * the error code issued by av_opt_set() if a key/value pair\n * cannot be set\n */"
 },
 "av_opt_set_from_string": {
  "type": "int",
  "definition": "int av_opt_set_from_string",
  "argsstring": "(void *ctx, const char *opts, const char *const *shorthand, const char *key_val_sep, const char *pairs_sep)",
  "name": "av_opt_set_from_string",
  "param": [
   {
    "type": "void *",
    "declname": "ctx"
   },
   {
    "type": "const char *",
    "declname": "opts"
   },
   {
    "type": "const char *const *",
    "declname": "shorthand"
   },
   {
    "type": "const char *",
    "declname": "key_val_sep"
   },
   {
    "type": "const char *",
    "declname": "pairs_sep"
   }
  ],
  "briefdescription": {
   "para": "Parse the key-value pairs list in opts."
  },
  "detaileddescription": {
   "para": [
    "For each key=value pair found, set the value of the corresponding option in ctx.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVClass",
           "@_refid": "structAVClass",
           "@_kindref": "compound"
          },
          "#text": "theobject to set options on"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "opts"
        },
        "parameterdescription": {
         "para": "the options string, key-value pairs separated by a delimiter"
        }
       },
       {
        "parameternamelist": {
         "parametername": "shorthand"
        },
        "parameterdescription": {
         "para": "a NULL-terminated array of options names for shorthand notation: if the first field in opts has no key part, the key is taken from the first element of shorthand; then again for the second, etc., until either opts is finished, shorthand is finished or a named option is found; after that, all options must be named"
        }
       },
       {
        "parameternamelist": {
         "parametername": "key_val_sep"
        },
        "parameterdescription": {
         "para": "a 0-terminated list of characters used to separate key from value, for example '='"
        }
       },
       {
        "parameternamelist": {
         "parametername": "pairs_sep"
        },
        "parameterdescription": {
         "para": "a 0-terminated list of characters used to separate two pairs from each other, for example ':' or ','"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVERROR(EINVAL)",
        "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
        "@_kindref": "member"
       },
       "#text": "the number of successfully set key=value pairs, or a negative value corresponding to an AVERROR code in case of error:if opts cannot be parsed, the error code issued by av_set_string3() if a key/value pair cannot be set"
      },
      "@_kind": "return"
     },
     "#text": "Options names must use only the following characters: a-z A-Z 0-9 - . / _ Separators must use characters distinct from option names and from each other."
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "694",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "694",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__write_1gaa936b1aa7caca67b21cd50819c2b9fb1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse the key-value pairs list in opts. For each key=value pair found,\n * set the value of the corresponding option in ctx.\n *\n * @param ctx          the AVClass object to set options on\n * @param opts         the options string, key-value pairs separated by a\n *                     delimiter\n * @param shorthand    a NULL-terminated array of options names for shorthand\n *                     notation: if the first field in opts has no key part,\n *                     the key is taken from the first element of shorthand;\n *                     then again for the second, etc., until either opts is\n *                     finished, shorthand is finished or a named option is\n *                     found; after that, all options must be named\n * @param key_val_sep  a 0-terminated list of characters used to separate\n *                     key from value, for example '='\n * @param pairs_sep    a 0-terminated list of characters used to separate\n *                     two pairs from each other, for example ':' or ','\n * @return  the number of successfully set key=value pairs, or a negative\n *          value corresponding to an AVERROR code in case of error:\n *          AVERROR(EINVAL) if opts cannot be parsed,\n *          the error code issued by av_set_string3() if a key/value pair\n *          cannot be set\n *\n * Options names must use only the following characters: a-z A-Z 0-9 - . / _\n * Separators must use characters distinct from option names and from each\n * other.\n */"
 },
 "av_opt_set_dict": {
  "type": "int",
  "definition": "int av_opt_set_dict",
  "argsstring": "(void *obj, struct AVDictionary **options)",
  "name": "av_opt_set_dict",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "struct**"
    },
    "declname": "options"
   }
  ],
  "briefdescription": {
   "para": "Set all the options from a given dictionary on an object."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "obj"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "a struct whose first element is a pointer to"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "options"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_dict_free()",
          "@_refid": "group__lavu__dict_1ga1bafd682b1fbb90e48a4cc3814b820f7",
          "@_kindref": "member"
         },
         "#text": "options to process. This dictionary will be freed and replaced by a new one containing all options not found in obj. Of course this new dictionary needs to be freed by caller with."
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "0 on success, a negative AVERROR if some option was found in obj, but could not be set.",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_dict_copy()",
        "@_refid": "group__lavu__dict_1ga59a6372b124b306e3a2233723c5cdc78",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "712",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "712",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__write_1gaf1a88e8f152d7835f111b1ef8813fb2e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set all the options from a given dictionary on an object.\n *\n * @param obj a struct whose first element is a pointer to AVClass\n * @param options options to process. This dictionary will be freed and replaced\n *                by a new one containing all options not found in obj.\n *                Of course this new dictionary needs to be freed by caller\n *                with av_dict_free().\n *\n * @return 0 on success, a negative AVERROR if some option was found in obj,\n *         but could not be set.\n *\n * @see av_dict_copy()\n */"
 },
 "av_opt_set_dict2": {
  "type": "int",
  "definition": "int av_opt_set_dict2",
  "argsstring": "(void *obj, struct AVDictionary **options, int search_flags)",
  "name": "av_opt_set_dict2",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "struct**"
    },
    "declname": "options"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": {
   "para": "Set all the options from a given dictionary on an object."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "obj"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "a struct whose first element is a pointer to"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "options"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_dict_free()",
          "@_refid": "group__lavu__dict_1ga1bafd682b1fbb90e48a4cc3814b820f7",
          "@_kindref": "member"
         },
         "#text": "options to process. This dictionary will be freed and replaced by a new one containing all options not found in obj. Of course this new dictionary needs to be freed by caller with."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "search_flags"
       },
       "parameterdescription": {
        "para": "A combination of AV_OPT_SEARCH_*."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "0 on success, a negative AVERROR if some option was found in obj, but could not be set.",
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_dict_copy()",
        "@_refid": "group__lavu__dict_1ga59a6372b124b306e3a2233723c5cdc78",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "730",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "730",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__write_1ga1824a600b215f1807e77b5f6cfa58586",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set all the options from a given dictionary on an object.\n *\n * @param obj a struct whose first element is a pointer to AVClass\n * @param options options to process. This dictionary will be freed and replaced\n *                by a new one containing all options not found in obj.\n *                Of course this new dictionary needs to be freed by caller\n *                with av_dict_free().\n * @param search_flags A combination of AV_OPT_SEARCH_*.\n *\n * @return 0 on success, a negative AVERROR if some option was found in obj,\n *         but could not be set.\n *\n * @see av_dict_copy()\n */"
 },
 "av_opt_copy": {
  "type": "int",
  "definition": "int av_opt_copy",
  "argsstring": "(void *dest, const void *src)",
  "name": "av_opt_copy",
  "param": [
   {
    "type": "void *",
    "declname": "dest"
   },
   {
    "type": "const void *",
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Copy options from src object into dest object."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AVClass",
      "@_refid": "structAVClass",
      "@_kindref": "compound"
     },
     "#text": "The underlyingof both src and dest must coincide. The guarantee below does not apply if this is not fulfilled."
    },
    "Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object. Original memory allocated for such options is freed unless both src and dest options points to the same memory.",
    {
     "ref": {
      "#text": "av_opt_free()",
      "@_refid": "group__opt__mng_1gac14db824af52baf8181406e98d116097",
      "@_kindref": "member"
     },
     "#text": "Even on error it is guaranteed that allocated options from src and dest no longer alias each other afterwards; in particular callingon both src and dest is safe afterwards if dest has been memdup'ed from src."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dest"
        },
        "parameterdescription": {
         "para": "Object to copy from"
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "Object to copy into"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, negative on error",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "749",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "749",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__write_1ga0bcbbef33c677ddbf37d423dcb9c7833",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy options from src object into dest object.\n *\n * The underlying AVClass of both src and dest must coincide. The guarantee\n * below does not apply if this is not fulfilled.\n *\n * Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.\n * Original memory allocated for such options is freed unless both src and dest options points to the same memory.\n *\n * Even on error it is guaranteed that allocated options from src and dest\n * no longer alias each other afterwards; in particular calling av_opt_free()\n * on both src and dest is safe afterwards if dest has been memdup'ed from src.\n *\n * @param dest Object to copy from\n * @param src  Object to copy into\n * @return 0 on success, negative on error\n */"
 },
 "av_opt_set": {
  "type": "int",
  "definition": "int av_opt_set",
  "argsstring": "(void *obj, const char *name, const char *val, int search_flags)",
  "name": "av_opt_set",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "const char *",
    "declname": "val"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "780",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "780",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filter_graph",
    "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "60",
    "@_endline": "208"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   },
   {
    "#text": "main",
    "@_refid": "encode__video_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "encode__video_8c",
    "@_startline": "69",
    "@_endline": "216"
   }
  ],
  "@_kind": "function",
  "@_id": "group__opt__set__funcs_1ga5fd4b92bdf4f392a2847f711676a7537",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_set_funcs Option setting functions\n * @{\n * Those functions set the field of obj with the given name to value.\n *\n * @param[in] obj A struct whose first element is a pointer to an AVClass.\n * @param[in] name the name of the field to set\n * @param[in] val The value to set. In case of av_opt_set() if the field is not\n * of a string type, then the given string is parsed.\n * SI postfixes and some named scalars are supported.\n * If the field is of a numeric type, it has to be a numeric or named\n * scalar. Behavior with more than one scalar and +- infix operators\n * is undefined.\n * If the field is of a flags type, it has to be a sequence of numeric\n * scalars or named flags separated by '+' or '-'. Prefixing a flag\n * with '+' causes it to be set without affecting the other flags;\n * similarly, '-' unsets a flag.\n * If the field is of a dictionary type, it has to be a ':' separated list of\n * key=value parameters. Values containing ':' special characters must be\n * escaped.\n * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be set on a child of obj.\n *\n * @return 0 if the value has been set, or an AVERROR code in case of\n * error:\n * AVERROR_OPTION_NOT_FOUND if no matching option exists\n * AVERROR(ERANGE) if the value is out of range\n * AVERROR(EINVAL) if the value is not valid\n */"
 },
 "av_opt_set_int": {
  "type": "int",
  "definition": "int av_opt_set_int",
  "argsstring": "(void *obj, const char *name, int64_t val, int search_flags)",
  "name": "av_opt_set_int",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int64_t",
    "declname": "val"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "781",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "781",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "init_filter_graph",
    "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "60",
    "@_endline": "208"
   },
   {
    "#text": "main",
    "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "resample__audio_8c",
    "@_startline": "85",
    "@_endline": "220"
   },
   {
    "#text": "open_audio",
    "@_refid": "mux_8c_1a5de64c6730f86a2a0c7cc3ca2bab3717",
    "@_compoundref": "mux_8c",
    "@_startline": "241",
    "@_endline": "303"
   }
  ],
  "@_kind": "function",
  "@_id": "group__opt__set__funcs_1ga3adf7185c21cc080890a5ec02c2e56b2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_set_funcs Option setting functions\n * @{\n * Those functions set the field of obj with the given name to value.\n *\n * @param[in] obj A struct whose first element is a pointer to an AVClass.\n * @param[in] name the name of the field to set\n * @param[in] val The value to set. In case of av_opt_set() if the field is not\n * of a string type, then the given string is parsed.\n * SI postfixes and some named scalars are supported.\n * If the field is of a numeric type, it has to be a numeric or named\n * scalar. Behavior with more than one scalar and +- infix operators\n * is undefined.\n * If the field is of a flags type, it has to be a sequence of numeric\n * scalars or named flags separated by '+' or '-'. Prefixing a flag\n * with '+' causes it to be set without affecting the other flags;\n * similarly, '-' unsets a flag.\n * If the field is of a dictionary type, it has to be a ':' separated list of\n * key=value parameters. Values containing ':' special characters must be\n * escaped.\n * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be set on a child of obj.\n *\n * @return 0 if the value has been set, or an AVERROR code in case of\n * error:\n * AVERROR_OPTION_NOT_FOUND if no matching option exists\n * AVERROR(ERANGE) if the value is out of range\n * AVERROR(EINVAL) if the value is not valid\n */"
 },
 "av_opt_set_double": {
  "type": "int",
  "definition": "int av_opt_set_double",
  "argsstring": "(void *obj, const char *name, double val, int search_flags)",
  "name": "av_opt_set_double",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "double",
    "declname": "val"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "782",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "782",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__set__funcs_1ga11f22424bb01fd58f6b34f220a0fff6a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_set_funcs Option setting functions\n * @{\n * Those functions set the field of obj with the given name to value.\n *\n * @param[in] obj A struct whose first element is a pointer to an AVClass.\n * @param[in] name the name of the field to set\n * @param[in] val The value to set. In case of av_opt_set() if the field is not\n * of a string type, then the given string is parsed.\n * SI postfixes and some named scalars are supported.\n * If the field is of a numeric type, it has to be a numeric or named\n * scalar. Behavior with more than one scalar and +- infix operators\n * is undefined.\n * If the field is of a flags type, it has to be a sequence of numeric\n * scalars or named flags separated by '+' or '-'. Prefixing a flag\n * with '+' causes it to be set without affecting the other flags;\n * similarly, '-' unsets a flag.\n * If the field is of a dictionary type, it has to be a ':' separated list of\n * key=value parameters. Values containing ':' special characters must be\n * escaped.\n * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be set on a child of obj.\n *\n * @return 0 if the value has been set, or an AVERROR code in case of\n * error:\n * AVERROR_OPTION_NOT_FOUND if no matching option exists\n * AVERROR(ERANGE) if the value is out of range\n * AVERROR(EINVAL) if the value is not valid\n */"
 },
 "av_opt_set_q": {
  "type": "int",
  "definition": "int av_opt_set_q",
  "argsstring": "(void *obj, const char *name, AVRational val, int search_flags)",
  "name": "av_opt_set_q",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "val"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "783",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "783",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "init_filter_graph",
   "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
   "@_compoundref": "filter__audio_8c",
   "@_startline": "60",
   "@_endline": "208"
  },
  "@_kind": "function",
  "@_id": "group__opt__set__funcs_1ga4f4f0b06e931c638ee8b4074e3638cef",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_set_funcs Option setting functions\n * @{\n * Those functions set the field of obj with the given name to value.\n *\n * @param[in] obj A struct whose first element is a pointer to an AVClass.\n * @param[in] name the name of the field to set\n * @param[in] val The value to set. In case of av_opt_set() if the field is not\n * of a string type, then the given string is parsed.\n * SI postfixes and some named scalars are supported.\n * If the field is of a numeric type, it has to be a numeric or named\n * scalar. Behavior with more than one scalar and +- infix operators\n * is undefined.\n * If the field is of a flags type, it has to be a sequence of numeric\n * scalars or named flags separated by '+' or '-'. Prefixing a flag\n * with '+' causes it to be set without affecting the other flags;\n * similarly, '-' unsets a flag.\n * If the field is of a dictionary type, it has to be a ':' separated list of\n * key=value parameters. Values containing ':' special characters must be\n * escaped.\n * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be set on a child of obj.\n *\n * @return 0 if the value has been set, or an AVERROR code in case of\n * error:\n * AVERROR_OPTION_NOT_FOUND if no matching option exists\n * AVERROR(ERANGE) if the value is out of range\n * AVERROR(EINVAL) if the value is not valid\n */"
 },
 "av_opt_set_bin": {
  "type": "int",
  "definition": "int av_opt_set_bin",
  "argsstring": "(void *obj, const char *name, const uint8_t *val, int size, int search_flags)",
  "name": "av_opt_set_bin",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "const uint8_t *",
    "declname": "val"
   },
   {
    "type": "int",
    "declname": "size"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "784",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "784",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "init_filter",
   "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
   "@_compoundref": "transcode_8c",
   "@_startline": "244",
   "@_endline": "392"
  },
  "@_kind": "function",
  "@_id": "group__opt__set__funcs_1ga6c32155fd8a96bed2f8cf5ebc030dadf",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_set_funcs Option setting functions\n * @{\n * Those functions set the field of obj with the given name to value.\n *\n * @param[in] obj A struct whose first element is a pointer to an AVClass.\n * @param[in] name the name of the field to set\n * @param[in] val The value to set. In case of av_opt_set() if the field is not\n * of a string type, then the given string is parsed.\n * SI postfixes and some named scalars are supported.\n * If the field is of a numeric type, it has to be a numeric or named\n * scalar. Behavior with more than one scalar and +- infix operators\n * is undefined.\n * If the field is of a flags type, it has to be a sequence of numeric\n * scalars or named flags separated by '+' or '-'. Prefixing a flag\n * with '+' causes it to be set without affecting the other flags;\n * similarly, '-' unsets a flag.\n * If the field is of a dictionary type, it has to be a ':' separated list of\n * key=value parameters. Values containing ':' special characters must be\n * escaped.\n * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be set on a child of obj.\n *\n * @return 0 if the value has been set, or an AVERROR code in case of\n * error:\n * AVERROR_OPTION_NOT_FOUND if no matching option exists\n * AVERROR(ERANGE) if the value is out of range\n * AVERROR(EINVAL) if the value is not valid\n */"
 },
 "av_opt_set_image_size": {
  "type": "int",
  "definition": "int av_opt_set_image_size",
  "argsstring": "(void *obj, const char *name, int w, int h, int search_flags)",
  "name": "av_opt_set_image_size",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "w"
   },
   {
    "type": "int",
    "declname": "h"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "785",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "785",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__set__funcs_1ga29c5723116dcc9be891ee2ca61f2df5e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_set_funcs Option setting functions\n * @{\n * Those functions set the field of obj with the given name to value.\n *\n * @param[in] obj A struct whose first element is a pointer to an AVClass.\n * @param[in] name the name of the field to set\n * @param[in] val The value to set. In case of av_opt_set() if the field is not\n * of a string type, then the given string is parsed.\n * SI postfixes and some named scalars are supported.\n * If the field is of a numeric type, it has to be a numeric or named\n * scalar. Behavior with more than one scalar and +- infix operators\n * is undefined.\n * If the field is of a flags type, it has to be a sequence of numeric\n * scalars or named flags separated by '+' or '-'. Prefixing a flag\n * with '+' causes it to be set without affecting the other flags;\n * similarly, '-' unsets a flag.\n * If the field is of a dictionary type, it has to be a ':' separated list of\n * key=value parameters. Values containing ':' special characters must be\n * escaped.\n * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be set on a child of obj.\n *\n * @return 0 if the value has been set, or an AVERROR code in case of\n * error:\n * AVERROR_OPTION_NOT_FOUND if no matching option exists\n * AVERROR(ERANGE) if the value is out of range\n * AVERROR(EINVAL) if the value is not valid\n */"
 },
 "av_opt_set_pixel_fmt": {
  "type": "int",
  "definition": "int av_opt_set_pixel_fmt",
  "argsstring": "(void *obj, const char *name, enum AVPixelFormat fmt, int search_flags)",
  "name": "av_opt_set_pixel_fmt",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "fmt"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "786",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "786",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__set__funcs_1gae8992c7875fd69a0c0e8c010098d402d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_set_funcs Option setting functions\n * @{\n * Those functions set the field of obj with the given name to value.\n *\n * @param[in] obj A struct whose first element is a pointer to an AVClass.\n * @param[in] name the name of the field to set\n * @param[in] val The value to set. In case of av_opt_set() if the field is not\n * of a string type, then the given string is parsed.\n * SI postfixes and some named scalars are supported.\n * If the field is of a numeric type, it has to be a numeric or named\n * scalar. Behavior with more than one scalar and +- infix operators\n * is undefined.\n * If the field is of a flags type, it has to be a sequence of numeric\n * scalars or named flags separated by '+' or '-'. Prefixing a flag\n * with '+' causes it to be set without affecting the other flags;\n * similarly, '-' unsets a flag.\n * If the field is of a dictionary type, it has to be a ':' separated list of\n * key=value parameters. Values containing ':' special characters must be\n * escaped.\n * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be set on a child of obj.\n *\n * @return 0 if the value has been set, or an AVERROR code in case of\n * error:\n * AVERROR_OPTION_NOT_FOUND if no matching option exists\n * AVERROR(ERANGE) if the value is out of range\n * AVERROR(EINVAL) if the value is not valid\n */"
 },
 "av_opt_set_sample_fmt": {
  "type": "int",
  "definition": "int av_opt_set_sample_fmt",
  "argsstring": "(void *obj, const char *name, enum AVSampleFormat fmt, int search_flags)",
  "name": "av_opt_set_sample_fmt",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "fmt"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "787",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "787",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "resample__audio_8c",
    "@_startline": "85",
    "@_endline": "220"
   },
   {
    "#text": "open_audio",
    "@_refid": "mux_8c_1a5de64c6730f86a2a0c7cc3ca2bab3717",
    "@_compoundref": "mux_8c",
    "@_startline": "241",
    "@_endline": "303"
   }
  ],
  "@_kind": "function",
  "@_id": "group__opt__set__funcs_1gad446f7a7b92442e464d43e400e661040",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_set_funcs Option setting functions\n * @{\n * Those functions set the field of obj with the given name to value.\n *\n * @param[in] obj A struct whose first element is a pointer to an AVClass.\n * @param[in] name the name of the field to set\n * @param[in] val The value to set. In case of av_opt_set() if the field is not\n * of a string type, then the given string is parsed.\n * SI postfixes and some named scalars are supported.\n * If the field is of a numeric type, it has to be a numeric or named\n * scalar. Behavior with more than one scalar and +- infix operators\n * is undefined.\n * If the field is of a flags type, it has to be a sequence of numeric\n * scalars or named flags separated by '+' or '-'. Prefixing a flag\n * with '+' causes it to be set without affecting the other flags;\n * similarly, '-' unsets a flag.\n * If the field is of a dictionary type, it has to be a ':' separated list of\n * key=value parameters. Values containing ':' special characters must be\n * escaped.\n * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be set on a child of obj.\n *\n * @return 0 if the value has been set, or an AVERROR code in case of\n * error:\n * AVERROR_OPTION_NOT_FOUND if no matching option exists\n * AVERROR(ERANGE) if the value is out of range\n * AVERROR(EINVAL) if the value is not valid\n */"
 },
 "av_opt_set_video_rate": {
  "type": "int",
  "definition": "int av_opt_set_video_rate",
  "argsstring": "(void *obj, const char *name, AVRational val, int search_flags)",
  "name": "av_opt_set_video_rate",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "val"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "788",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "788",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__set__funcs_1gac4a81110dd4f5c717ec6ccf0a9e94b9f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_set_funcs Option setting functions\n * @{\n * Those functions set the field of obj with the given name to value.\n *\n * @param[in] obj A struct whose first element is a pointer to an AVClass.\n * @param[in] name the name of the field to set\n * @param[in] val The value to set. In case of av_opt_set() if the field is not\n * of a string type, then the given string is parsed.\n * SI postfixes and some named scalars are supported.\n * If the field is of a numeric type, it has to be a numeric or named\n * scalar. Behavior with more than one scalar and +- infix operators\n * is undefined.\n * If the field is of a flags type, it has to be a sequence of numeric\n * scalars or named flags separated by '+' or '-'. Prefixing a flag\n * with '+' causes it to be set without affecting the other flags;\n * similarly, '-' unsets a flag.\n * If the field is of a dictionary type, it has to be a ':' separated list of\n * key=value parameters. Values containing ':' special characters must be\n * escaped.\n * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be set on a child of obj.\n *\n * @return 0 if the value has been set, or an AVERROR code in case of\n * error:\n * AVERROR_OPTION_NOT_FOUND if no matching option exists\n * AVERROR(ERANGE) if the value is out of range\n * AVERROR(EINVAL) if the value is not valid\n */"
 },
 "av_opt_set_chlayout": {
  "type": "int",
  "definition": "int av_opt_set_chlayout",
  "argsstring": "(void *obj, const char *name, const AVChannelLayout *layout, int search_flags)",
  "name": "av_opt_set_chlayout",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "layout"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "789",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "789",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "resample__audio_8c",
    "@_startline": "85",
    "@_endline": "220"
   },
   {
    "#text": "open_audio",
    "@_refid": "mux_8c_1a5de64c6730f86a2a0c7cc3ca2bab3717",
    "@_compoundref": "mux_8c",
    "@_startline": "241",
    "@_endline": "303"
   }
  ],
  "@_kind": "function",
  "@_id": "group__opt__set__funcs_1gac111d12d38108a9f19004b16437a9647",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_set_funcs Option setting functions\n * @{\n * Those functions set the field of obj with the given name to value.\n *\n * @param[in] obj A struct whose first element is a pointer to an AVClass.\n * @param[in] name the name of the field to set\n * @param[in] val The value to set. In case of av_opt_set() if the field is not\n * of a string type, then the given string is parsed.\n * SI postfixes and some named scalars are supported.\n * If the field is of a numeric type, it has to be a numeric or named\n * scalar. Behavior with more than one scalar and +- infix operators\n * is undefined.\n * If the field is of a flags type, it has to be a sequence of numeric\n * scalars or named flags separated by '+' or '-'. Prefixing a flag\n * with '+' causes it to be set without affecting the other flags;\n * similarly, '-' unsets a flag.\n * If the field is of a dictionary type, it has to be a ':' separated list of\n * key=value parameters. Values containing ':' special characters must be\n * escaped.\n * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN\n * is passed here, then the option may be set on a child of obj.\n *\n * @return 0 if the value has been set, or an AVERROR code in case of\n * error:\n * AVERROR_OPTION_NOT_FOUND if no matching option exists\n * AVERROR(ERANGE) if the value is out of range\n * AVERROR(EINVAL) if the value is not valid\n */"
 },
 "av_opt_set_dict_val": {
  "type": "int",
  "definition": "int av_opt_set_dict_val",
  "argsstring": "(void *obj, const char *name, const AVDictionary *val, int search_flags)",
  "name": "av_opt_set_dict_val",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "const*"
    },
    "declname": "val"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "Any old dictionary present is discarded and replaced with a copy of the new one. The caller still owns val is and responsible for freeing it.",
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "794",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "794",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__set__funcs_1gad19358af12f0766fedec516e387b8196",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @note Any old dictionary present is discarded and replaced with a copy of the new one. The\n * caller still owns val is and responsible for freeing it.\n */"
 },
 "av_opt_get": {
  "type": "int",
  "definition": "int av_opt_get",
  "argsstring": "(void *obj, const char *name, int search_flags, uint8_t **out_val)",
  "name": "av_opt_get",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "search_flags"
   },
   {
    "type": "uint8_t **",
    "declname": "out_val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": [
        {
         "#text": "av_malloc()",
         "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
         "@_kindref": "member"
        },
        {
         "#text": "av_free()",
         "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
         "@_kindref": "member"
        }
       ],
       "#text": "the returned string will beed and must beed by the caller"
      },
      "@_kind": "note"
     },
     {
      "para": "if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT and is set to NULL, *out_val will be set to NULL instead of an allocated empty string.",
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "842",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "842",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__get__funcs_1gaf31144e60f9ce89dbe8cbea57a0b232c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n *\n * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n * option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n * and is set to NULL, *out_val will be set to NULL instead of an allocated\n * empty string.\n */"
 },
 "av_opt_get_int": {
  "type": "int",
  "definition": "int av_opt_get_int",
  "argsstring": "(void *obj, const char *name, int search_flags, int64_t *out_val)",
  "name": "av_opt_get_int",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "search_flags"
   },
   {
    "type": "int64_t *",
    "declname": "out_val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "843",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "843",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__get__funcs_1gaab5b9c0969efe56420536a5d190e59bd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n *\n * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n * option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n * and is set to NULL, *out_val will be set to NULL instead of an allocated\n * empty string.\n */"
 },
 "av_opt_get_double": {
  "type": "int",
  "definition": "int av_opt_get_double",
  "argsstring": "(void *obj, const char *name, int search_flags, double *out_val)",
  "name": "av_opt_get_double",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "search_flags"
   },
   {
    "type": "double *",
    "declname": "out_val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "844",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "844",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__get__funcs_1ga4ee50245cd18a65ec1cd27bc8e0cab83",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n *\n * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n * option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n * and is set to NULL, *out_val will be set to NULL instead of an allocated\n * empty string.\n */"
 },
 "av_opt_get_q": {
  "type": "int",
  "definition": "int av_opt_get_q",
  "argsstring": "(void *obj, const char *name, int search_flags, AVRational *out_val)",
  "name": "av_opt_get_q",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "search_flags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "out_val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "845",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "845",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__get__funcs_1gabc553a1b95468f935eedfa9db86e2a15",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n *\n * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n * option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n * and is set to NULL, *out_val will be set to NULL instead of an allocated\n * empty string.\n */"
 },
 "av_opt_get_image_size": {
  "type": "int",
  "definition": "int av_opt_get_image_size",
  "argsstring": "(void *obj, const char *name, int search_flags, int *w_out, int *h_out)",
  "name": "av_opt_get_image_size",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "search_flags"
   },
   {
    "type": "int *",
    "declname": "w_out"
   },
   {
    "type": "int *",
    "declname": "h_out"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "846",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "846",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__get__funcs_1ga96d9c726c3feff308e7fe447633c9720",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n *\n * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n * option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n * and is set to NULL, *out_val will be set to NULL instead of an allocated\n * empty string.\n */"
 },
 "av_opt_get_pixel_fmt": {
  "type": "int",
  "definition": "int av_opt_get_pixel_fmt",
  "argsstring": "(void *obj, const char *name, int search_flags, enum AVPixelFormat *out_fmt)",
  "name": "av_opt_get_pixel_fmt",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "search_flags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum*"
    },
    "declname": "out_fmt"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "847",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "847",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__get__funcs_1ga41fdd93f0483e96548168f9cfaf5bf6b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n *\n * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n * option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n * and is set to NULL, *out_val will be set to NULL instead of an allocated\n * empty string.\n */"
 },
 "av_opt_get_sample_fmt": {
  "type": "int",
  "definition": "int av_opt_get_sample_fmt",
  "argsstring": "(void *obj, const char *name, int search_flags, enum AVSampleFormat *out_fmt)",
  "name": "av_opt_get_sample_fmt",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "search_flags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum*"
    },
    "declname": "out_fmt"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "848",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "848",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__get__funcs_1gade39dd8ce34b193f7012022072e36642",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n *\n * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n * option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n * and is set to NULL, *out_val will be set to NULL instead of an allocated\n * empty string.\n */"
 },
 "av_opt_get_video_rate": {
  "type": "int",
  "definition": "int av_opt_get_video_rate",
  "argsstring": "(void *obj, const char *name, int search_flags, AVRational *out_val)",
  "name": "av_opt_get_video_rate",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "search_flags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "out_val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "849",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "849",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__get__funcs_1gaf565dc77c53e8e56d08ee1a3c642f95f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n *\n * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n * option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n * and is set to NULL, *out_val will be set to NULL instead of an allocated\n * empty string.\n */"
 },
 "av_opt_get_chlayout": {
  "type": "int",
  "definition": "int av_opt_get_chlayout",
  "argsstring": "(void *obj, const char *name, int search_flags, AVChannelLayout *layout)",
  "name": "av_opt_get_chlayout",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "search_flags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "layout"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "850",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "850",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__get__funcs_1ga4f83e9c58c2c2b444655ccee034e69cd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller\n *\n * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the\n * option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT\n * and is set to NULL, *out_val will be set to NULL instead of an allocated\n * empty string.\n */"
 },
 "av_opt_get_dict_val": {
  "type": "int",
  "definition": "int av_opt_get_dict_val",
  "argsstring": "(void *obj, const char *name, int search_flags, AVDictionary **out_val)",
  "name": "av_opt_get_dict_val",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "search_flags"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "out_val"
   }
  ],
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": {
        "#text": "out_val",
        "@_direction": "out"
       }
      },
      "parameterdescription": {
       "para": {
        "ref": {
         "#text": "av_dict_free()",
         "@_refid": "group__lavu__dict_1ga1bafd682b1fbb90e48a4cc3814b820f7",
         "@_kindref": "member"
        },
        "#text": "The returned dictionary is a copy of the actual value and must be freed withby the caller"
       }
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "855",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "855",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__get__funcs_1ga6ed0b77def62321ff995843211405338",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @param[out] out_val The returned dictionary is a copy of the actual value and must\n * be freed with av_dict_free() by the caller\n */"
 },
 "av_opt_eval_flags": {
  "type": "int",
  "definition": "int av_opt_eval_flags",
  "argsstring": "(void *obj, const AVOption *o, const char *val, int *flags_out)",
  "name": "av_opt_eval_flags",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": {
     "ref": {
      "#text": "AVOption",
      "@_refid": "structAVOption",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "o"
   },
   {
    "type": "const char *",
    "declname": "val"
   },
   {
    "type": "int *",
    "declname": "flags_out"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "874",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "874",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__eval__funcs_1gae245940b870e13b759354d570decf3dc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_eval_funcs Evaluating option strings\n * @{\n * This group of functions can be used to evaluate option strings\n * and get numbers out of them. They do the same thing as av_opt_set(),\n * except the result is written into the caller-supplied pointer.\n *\n * @param obj a struct whose first element is a pointer to AVClass.\n * @param o an option for which the string is to be evaluated.\n * @param val string to be evaluated.\n * @param *_out value of the string will be written here.\n *\n * @return 0 on success, a negative number on failure.\n */"
 },
 "av_opt_eval_int": {
  "type": "int",
  "definition": "int av_opt_eval_int",
  "argsstring": "(void *obj, const AVOption *o, const char *val, int *int_out)",
  "name": "av_opt_eval_int",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": {
     "ref": {
      "#text": "AVOption",
      "@_refid": "structAVOption",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "o"
   },
   {
    "type": "const char *",
    "declname": "val"
   },
   {
    "type": "int *",
    "declname": "int_out"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "875",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "875",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__eval__funcs_1ga8bcee89d4a51400092e2d653c842bfa8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_eval_funcs Evaluating option strings\n * @{\n * This group of functions can be used to evaluate option strings\n * and get numbers out of them. They do the same thing as av_opt_set(),\n * except the result is written into the caller-supplied pointer.\n *\n * @param obj a struct whose first element is a pointer to AVClass.\n * @param o an option for which the string is to be evaluated.\n * @param val string to be evaluated.\n * @param *_out value of the string will be written here.\n *\n * @return 0 on success, a negative number on failure.\n */"
 },
 "av_opt_eval_int64": {
  "type": "int",
  "definition": "int av_opt_eval_int64",
  "argsstring": "(void *obj, const AVOption *o, const char *val, int64_t *int64_out)",
  "name": "av_opt_eval_int64",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": {
     "ref": {
      "#text": "AVOption",
      "@_refid": "structAVOption",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "o"
   },
   {
    "type": "const char *",
    "declname": "val"
   },
   {
    "type": "int64_t *",
    "declname": "int64_out"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "876",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "876",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__eval__funcs_1gae2285d602e2079f0df141826fc00c666",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_eval_funcs Evaluating option strings\n * @{\n * This group of functions can be used to evaluate option strings\n * and get numbers out of them. They do the same thing as av_opt_set(),\n * except the result is written into the caller-supplied pointer.\n *\n * @param obj a struct whose first element is a pointer to AVClass.\n * @param o an option for which the string is to be evaluated.\n * @param val string to be evaluated.\n * @param *_out value of the string will be written here.\n *\n * @return 0 on success, a negative number on failure.\n */"
 },
 "av_opt_eval_float": {
  "type": "int",
  "definition": "int av_opt_eval_float",
  "argsstring": "(void *obj, const AVOption *o, const char *val, float *float_out)",
  "name": "av_opt_eval_float",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": {
     "ref": {
      "#text": "AVOption",
      "@_refid": "structAVOption",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "o"
   },
   {
    "type": "const char *",
    "declname": "val"
   },
   {
    "type": "float *",
    "declname": "float_out"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "877",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "877",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__eval__funcs_1ga3c06cf2a2e7efc60d97adbeb7bbb6b44",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_eval_funcs Evaluating option strings\n * @{\n * This group of functions can be used to evaluate option strings\n * and get numbers out of them. They do the same thing as av_opt_set(),\n * except the result is written into the caller-supplied pointer.\n *\n * @param obj a struct whose first element is a pointer to AVClass.\n * @param o an option for which the string is to be evaluated.\n * @param val string to be evaluated.\n * @param *_out value of the string will be written here.\n *\n * @return 0 on success, a negative number on failure.\n */"
 },
 "av_opt_eval_double": {
  "type": "int",
  "definition": "int av_opt_eval_double",
  "argsstring": "(void *obj, const AVOption *o, const char *val, double *double_out)",
  "name": "av_opt_eval_double",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": {
     "ref": {
      "#text": "AVOption",
      "@_refid": "structAVOption",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "o"
   },
   {
    "type": "const char *",
    "declname": "val"
   },
   {
    "type": "double *",
    "declname": "double_out"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "878",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "878",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__eval__funcs_1gac65f3b9753c48616e8dd4dea0c47f9e6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_eval_funcs Evaluating option strings\n * @{\n * This group of functions can be used to evaluate option strings\n * and get numbers out of them. They do the same thing as av_opt_set(),\n * except the result is written into the caller-supplied pointer.\n *\n * @param obj a struct whose first element is a pointer to AVClass.\n * @param o an option for which the string is to be evaluated.\n * @param val string to be evaluated.\n * @param *_out value of the string will be written here.\n *\n * @return 0 on success, a negative number on failure.\n */"
 },
 "av_opt_eval_q": {
  "type": "int",
  "definition": "int av_opt_eval_q",
  "argsstring": "(void *obj, const AVOption *o, const char *val, AVRational *q_out)",
  "name": "av_opt_eval_q",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": {
     "ref": {
      "#text": "AVOption",
      "@_refid": "structAVOption",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "o"
   },
   {
    "type": "const char *",
    "declname": "val"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "q_out"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "879",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "879",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__eval__funcs_1gabd95639131aac582a2f7c4bfc5adb4b0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup opt_eval_funcs Evaluating option strings\n * @{\n * This group of functions can be used to evaluate option strings\n * and get numbers out of them. They do the same thing as av_opt_set(),\n * except the result is written into the caller-supplied pointer.\n *\n * @param obj a struct whose first element is a pointer to AVClass.\n * @param o an option for which the string is to be evaluated.\n * @param val string to be evaluated.\n * @param *_out value of the string will be written here.\n *\n * @return 0 on success, a negative number on failure.\n */"
 },
 "av_opt_ptr": {
  "type": "void *",
  "definition": "void * av_opt_ptr",
  "argsstring": "(const AVClass *avclass, void *obj, const char *name)",
  "name": "av_opt_ptr",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVClass",
      "@_refid": "structAVClass",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "avclass"
   },
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   }
  ],
  "briefdescription": {
   "para": "Gets a pointer to the requested field in a struct."
  },
  "detaileddescription": {
   "para": [
    "This function allows accessing a struct even when its fields are moved or renamed since the application making the access has been compiled,",
    {
     "simplesect": {
      "para": "a pointer to the field, it can be cast to the correct type and read or written to.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "892",
   "@_column": "6",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "892",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__opt__read_1ga4196faffe5fe1eee21e08395957693c1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Gets a pointer to the requested field in a struct.\n * This function allows accessing a struct even when its fields are moved or\n * renamed since the application making the access has been compiled,\n *\n * @returns a pointer to the field, it can be cast to the correct type and read\n *          or written to.\n */"
 },
 "av_opt_is_set_to_default": {
  "type": "int",
  "definition": "int av_opt_is_set_to_default",
  "argsstring": "(void *obj, const AVOption *o)",
  "name": "av_opt_is_set_to_default",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": {
     "ref": {
      "#text": "AVOption",
      "@_refid": "structAVOption",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "o"
   }
  ],
  "briefdescription": {
   "para": "Check if given option is set to its default value."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "av_opt_is_set_to_default_by_name()",
        "@_refid": "group__opt__read_1gaa37a02c9d3e6d9f049f2e7174811f5fb",
        "@_kindref": "member"
       },
       "#text": "."
      },
      "@_kind": "see"
     },
     {
      "para": ">0 when option is set to its default, 0 when option is not set its default, <0 on error",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "obj"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "object to check option on"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "o"
       },
       "parameterdescription": {
        "para": "option to be checked"
       }
      }
     ],
     "@_kind": "param"
    },
    "#text": "Options o must belong to the obj. This function must not be called to check child's options state."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "906",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "906",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__read_1ga3ca54258a4c5ac18999dd19b4444c15a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if given option is set to its default value.\n *\n * Options o must belong to the obj. This function must not be called to check child's options state.\n * @see av_opt_is_set_to_default_by_name().\n *\n * @param obj  AVClass object to check option on\n * @param o    option to be checked\n * @return     >0 when option is set to its default,\n *              0 when option is not set its default,\n *             <0 on error\n */"
 },
 "av_opt_is_set_to_default_by_name": {
  "type": "int",
  "definition": "int av_opt_is_set_to_default_by_name",
  "argsstring": "(void *obj, const char *name, int search_flags)",
  "name": "av_opt_is_set_to_default_by_name",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "name"
   },
   {
    "type": "int",
    "declname": "search_flags"
   }
  ],
  "briefdescription": {
   "para": "Check if given option is set to its default value."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "obj"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "object to check option on"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "name"
       },
       "parameterdescription": {
        "para": "option name"
       }
      },
      {
       "parameternamelist": {
        "parametername": "search_flags"
       },
       "parameterdescription": {
        "para": "combination of AV_OPT_SEARCH_*"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">0 when option is set to its default, 0 when option is not set its default, <0 on error",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "918",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "918",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__read_1gaa37a02c9d3e6d9f049f2e7174811f5fb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if given option is set to its default value.\n *\n * @param obj          AVClass object to check option on\n * @param name         option name\n * @param search_flags combination of AV_OPT_SEARCH_*\n * @return             >0 when option is set to its default,\n *                     0 when option is not set its default,\n *                     <0 on error\n */"
 },
 "av_opt_flag_is_set": {
  "type": "int",
  "definition": "int av_opt_flag_is_set",
  "argsstring": "(void *obj, const char *field_name, const char *flag_name)",
  "name": "av_opt_flag_is_set",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "field_name"
   },
   {
    "type": "const char *",
    "declname": "flag_name"
   }
  ],
  "briefdescription": {
   "para": "Check whether a particular flag is set in a flags field."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "field_name"
       },
       "parameterdescription": {
        "para": "the name of the flag field option"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flag_name"
       },
       "parameterdescription": {
        "para": "the name of the flag to check"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "non-zero if the flag is set, zero if the flag isn't set, isn't of the right type, or the flags field doesn't exist.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "928",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "928",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__read_1ga1436a3afc8dbc70ed9e70c8287dcc766",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check whether a particular flag is set in a flags field.\n *\n * @param field_name the name of the flag field option\n * @param flag_name the name of the flag to check\n * @return non-zero if the flag is set, zero if the flag isn't set,\n *         isn't of the right type, or the flags field doesn't exist.\n */"
 },
 "av_opt_serialize": {
  "type": "int",
  "definition": "int av_opt_serialize",
  "argsstring": "(void *obj, int opt_flags, int flags, char **buffer, const char key_val_sep, const char pairs_sep)",
  "name": "av_opt_serialize",
  "param": [
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "int",
    "declname": "opt_flags"
   },
   {
    "type": "int",
    "declname": "flags"
   },
   {
    "type": "char **",
    "declname": "buffer"
   },
   {
    "type": "const char",
    "declname": "key_val_sep"
   },
   {
    "type": "const char",
    "declname": "pairs_sep"
   }
  ],
  "briefdescription": {
   "para": "Serialize object's options."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "av_opt_set_from_string()",
       "@_refid": "group__opt__write_1gaa936b1aa7caca67b21cd50819c2b9fb1",
       "@_kindref": "member"
      },
      {
       "#text": "av_escape()",
       "@_refid": "group__lavu__string_1ga3c5e00d3f0575f2a3858f837656c08e9",
       "@_kindref": "member"
      }
     ],
     "#text": "Create a string containing object's serialized options. Such string may be passed back toin order to restore option values. A key/value or pairs separator occurring in the serialized value or name string are escaped through thefunction."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "obj",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVClass",
           "@_refid": "structAVClass",
           "@_kindref": "compound"
          },
          "#text": "object to serialize"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "opt_flags",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "serialize options with all the specified flags set (AV_OPT_FLAG)"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "flags",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "combination of AV_OPT_SERIALIZE_* flags"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "buffer",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "Pointer to buffer that will be allocated with string containg serialized options. Buffer must be freed by the caller when is no longer needed."
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "key_val_sep",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "character used to separate key from value"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "pairs_sep",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "character used to separate two pairs from each other"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": ">= 0 on success, negative on error",
       "@_kind": "return"
      },
      {
       "para": "Separators cannot be neither '\\' nor '\\0'. They also cannot be the same.",
       "@_kind": "warning"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "951",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "951",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__opt__read_1ga523122ff19a79f2867a9da29bbafa33b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Serialize object's options.\n *\n * Create a string containing object's serialized options.\n * Such string may be passed back to av_opt_set_from_string() in order to restore option values.\n * A key/value or pairs separator occurring in the serialized value or\n * name string are escaped through the av_escape() function.\n *\n * @param[in]  obj           AVClass object to serialize\n * @param[in]  opt_flags     serialize options with all the specified flags set (AV_OPT_FLAG)\n * @param[in]  flags         combination of AV_OPT_SERIALIZE_* flags\n * @param[out] buffer        Pointer to buffer that will be allocated with string containg serialized options.\n *                           Buffer must be freed by the caller when is no longer needed.\n * @param[in]  key_val_sep   character used to separate key from value\n * @param[in]  pairs_sep     character used to separate two pairs from each other\n * @return                   >= 0 on success, negative on error\n * @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same.\n */"
 },
 "av_opt_freep_ranges": {
  "type": "void",
  "definition": "void av_opt_freep_ranges",
  "argsstring": "(AVOptionRanges **ranges)",
  "name": "av_opt_freep_ranges",
  "param": {
   "type": {
    "ref": {
     "#text": "AVOptionRanges",
     "@_refid": "structAVOptionRanges",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "ranges"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVOptionRanges",
     "@_refid": "structAVOptionRanges",
     "@_kindref": "compound"
    },
    "#text": "Free anstruct and set it to NULL."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "961",
   "@_column": "6",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "961",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__avoptions_1ga880756f24644ff66c806ed2d9ab3d790",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free an AVOptionRanges struct and set it to NULL.\n */"
 },
 "av_opt_query_ranges": {
  "type": "int",
  "definition": "int av_opt_query_ranges",
  "argsstring": "(AVOptionRanges **, void *obj, const char *key, int flags)",
  "name": "av_opt_query_ranges",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVOptionRanges",
      "@_refid": "structAVOptionRanges",
      "@_kindref": "compound"
     },
     "#text": "**"
    }
   },
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "key"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Get a list of allowed ranges for the given option."
  },
  "detaileddescription": {
   "para": [
    "The returned list may depend on other fields in obj like for example profile.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "is a bitmask of flags, undefined flags should not be set and should be ignored AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to ainstead of a full instance AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component,"
        }
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVOptionRanges",
        "@_refid": "structAVOptionRanges",
        "@_kindref": "compound"
       }
      },
      "@_kind": "see"
     },
     "#text": "The result must be freed with av_opt_freep_ranges."
    },
    {
     "simplesect": {
      "para": "number of compontents returned on success, a negative errro code otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "976",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "976",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__avoptions_1ga9751db4da3e0facd522f5b345f4001ef",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a list of allowed ranges for the given option.\n *\n * The returned list may depend on other fields in obj like for example profile.\n *\n * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored\n *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance\n *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges\n *\n * The result must be freed with av_opt_freep_ranges.\n *\n * @return number of compontents returned on success, a negative errro code otherwise\n */"
 },
 "av_opt_query_ranges_default": {
  "type": "int",
  "definition": "int av_opt_query_ranges_default",
  "argsstring": "(AVOptionRanges **, void *obj, const char *key, int flags)",
  "name": "av_opt_query_ranges_default",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVOptionRanges",
      "@_refid": "structAVOptionRanges",
      "@_kindref": "compound"
     },
     "#text": "**"
    }
   },
   {
    "type": "void *",
    "declname": "obj"
   },
   {
    "type": "const char *",
    "declname": "key"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Get a default list of allowed ranges for the given option."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "AVClass.query_ranges()",
      "@_refid": "structAVClass_1a1f25d6b76f5a8b474cc1cb16aa5ed5df",
      "@_kindref": "member"
     },
     "#text": "This list is constructed without using thecallback and can be used as fallback from within the callback."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "is a bitmask of flags, undefined flags should not be set and should be ignored AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to ainstead of a full instance AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component,"
        }
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVOptionRanges",
        "@_refid": "structAVOptionRanges",
        "@_kindref": "compound"
       }
      },
      "@_kind": "see"
     },
     "#text": "The result must be freed with av_opt_free_ranges."
    },
    {
     "simplesect": {
      "para": "number of compontents returned on success, a negative errro code otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/opt.h",
   "@_line": "992",
   "@_column": "5",
   "@_declfile": "libavutil/opt.h",
   "@_declline": "992",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__avoptions_1ga4e50bee09b6a374cc54237314892c001",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a default list of allowed ranges for the given option.\n *\n * This list is constructed without using the AVClass.query_ranges() callback\n * and can be used as fallback from within the callback.\n *\n * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored\n *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance\n *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges\n *\n * The result must be freed with av_opt_free_ranges.\n *\n * @return number of compontents returned on success, a negative errro code otherwise\n */"
 },
 "av_packet_side_data_new": {
  "type": {
   "ref": {
    "#text": "AVPacketSideData",
    "@_refid": "structAVPacketSideData",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVPacketSideData * av_packet_side_data_new",
  "argsstring": "(AVPacketSideData **psd, int *pnb_sd, enum AVPacketSideDataType type, size_t size, int flags)",
  "name": "av_packet_side_data_new",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideData",
      "@_refid": "structAVPacketSideData",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "psd"
   },
   {
    "type": "int *",
    "declname": "pnb_sd"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideDataType",
      "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "size_t",
    "declname": "size"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Allocate a new packet side data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "sd"
       },
       "parameterdescription": {
        "para": "pointer to an array of side data to which the side data should be added. *sd may be NULL, in which case the array will be initialized."
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_sd"
       },
       "parameterdescription": {
        "para": "pointer to an integer containing the number of entries in the array. The integer value will be increased by 1 on success."
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "side data type"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "desired side data size"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "currently unused. Must be zero"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "pointer to freshly allocated side data on success, or NULL otherwise.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "393",
   "@_column": "18",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "393",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet__side__data_1ga2219eb0b5a6ca929d564efb7d7c22a36",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a new packet side data.\n *\n * @param sd    pointer to an array of side data to which the side data should\n *              be added. *sd may be NULL, in which case the array will be\n *              initialized.\n * @param nb_sd pointer to an integer containing the number of entries in\n *              the array. The integer value will be increased by 1 on success.\n * @param type  side data type\n * @param size  desired side data size\n * @param flags currently unused. Must be zero\n *\n * @return pointer to freshly allocated side data on success, or NULL otherwise.\n */"
 },
 "av_packet_side_data_add": {
  "type": {
   "ref": {
    "#text": "AVPacketSideData",
    "@_refid": "structAVPacketSideData",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVPacketSideData * av_packet_side_data_add",
  "argsstring": "(AVPacketSideData **sd, int *nb_sd, enum AVPacketSideDataType type, void *data, size_t size, int flags)",
  "name": "av_packet_side_data_add",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideData",
      "@_refid": "structAVPacketSideData",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "sd"
   },
   {
    "type": "int *",
    "declname": "nb_sd"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideDataType",
      "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "void *",
    "declname": "data"
   },
   {
    "type": "size_t",
    "declname": "size"
   },
   {
    "type": "int",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Wrap existing data as packet side data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "sd"
       },
       "parameterdescription": {
        "para": "pointer to an array of side data to which the side data should be added. *sd may be NULL, in which case the array will be initialized"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_sd"
       },
       "parameterdescription": {
        "para": "pointer to an integer containing the number of entries in the array. The integer value will be increased by 1 on success."
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "side data type"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_malloc()",
          "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
          "@_kindref": "member"
         },
         "#text": "a data array. It must be allocated with thefamily of functions. The ownership of the data is transferred to the side data array on success"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "size of the data array"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "currently unused. Must be zero"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "pointer to freshly allocated side data on success, or NULL otherwise On failure, the side data array is unchanged and the data remains owned by the caller.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "416",
   "@_column": "18",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "416",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet__side__data_1ga7a0fb092dc581c328a296281332d0c8c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Wrap existing data as packet side data.\n *\n * @param sd    pointer to an array of side data to which the side data should\n *              be added. *sd may be NULL, in which case the array will be\n *              initialized\n * @param nb_sd pointer to an integer containing the number of entries in\n *              the array. The integer value will be increased by 1 on success.\n * @param type  side data type\n * @param data  a data array. It must be allocated with the av_malloc() family\n *              of functions. The ownership of the data is transferred to the\n *              side data array on success\n * @param size  size of the data array\n * @param flags currently unused. Must be zero\n *\n * @return pointer to freshly allocated side data on success, or NULL otherwise\n *         On failure, the side data array is unchanged and the data remains\n *         owned by the caller.\n */"
 },
 "av_packet_side_data_get": {
  "type": {
   "ref": {
    "#text": "AVPacketSideData",
    "@_refid": "structAVPacketSideData",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVPacketSideData * av_packet_side_data_get",
  "argsstring": "(const AVPacketSideData *sd, int nb_sd, enum AVPacketSideDataType type)",
  "name": "av_packet_side_data_get",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideData",
      "@_refid": "structAVPacketSideData",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "sd"
   },
   {
    "type": "int",
    "declname": "nb_sd"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideDataType",
      "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   }
  ],
  "briefdescription": {
   "para": "Get side information from a side data array."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "sd"
       },
       "parameterdescription": {
        "para": "the array from which the side data should be fetched"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_sd"
       },
       "parameterdescription": {
        "para": "value containing the number of entries in the array."
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "desired side information type"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "pointer to side data if present or NULL otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "429",
   "@_column": "24",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "429",
   "@_declcolumn": "24"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet__side__data_1gabe0dea475f687842cf31a9e967be1692",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get side information from a side data array.\n *\n * @param sd    the array from which the side data should be fetched\n * @param nb_sd value containing the number of entries in the array.\n * @param type  desired side information type\n *\n * @return pointer to side data if present or NULL otherwise\n */"
 },
 "av_packet_side_data_remove": {
  "type": "void",
  "definition": "void av_packet_side_data_remove",
  "argsstring": "(AVPacketSideData *sd, int *nb_sd, enum AVPacketSideDataType type)",
  "name": "av_packet_side_data_remove",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideData",
      "@_refid": "structAVPacketSideData",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "sd"
   },
   {
    "type": "int *",
    "declname": "nb_sd"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideDataType",
      "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   }
  ],
  "briefdescription": {
   "para": "Remove side data of the given type from a side data array."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "sd"
       },
       "parameterdescription": {
        "para": "the array from which the side data should be removed"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_sd"
       },
       "parameterdescription": {
        "para": "pointer to an integer containing the number of entries in the array. Will be reduced by the amount of entries removed upon return"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "side information type"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "442",
   "@_column": "6",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "442",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet__side__data_1ga713f80b3e5f26154f13e9c9bb228811f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Remove side data of the given type from a side data array.\n *\n * @param sd    the array from which the side data should be removed\n * @param nb_sd pointer to an integer containing the number of entries in\n *              the array. Will be reduced by the amount of entries removed\n *              upon return\n * @param type  side information type\n */"
 },
 "av_packet_side_data_free": {
  "type": "void",
  "definition": "void av_packet_side_data_free",
  "argsstring": "(AVPacketSideData **sd, int *nb_sd)",
  "name": "av_packet_side_data_free",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideData",
      "@_refid": "structAVPacketSideData",
      "@_kindref": "compound"
     },
     "#text": "**"
    },
    "declname": "sd"
   },
   {
    "type": "int *",
    "declname": "nb_sd"
   }
  ],
  "briefdescription": {
   "para": "Convenience function to free all the side data stored in an array, and the array itself."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "sd"
       },
       "parameterdescription": {
        "para": "pointer to array of side data to free. Will be set to NULL upon return."
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_sd"
       },
       "parameterdescription": {
        "para": "pointer to an integer containing the number of entries in the array. Will be set to 0 upon return."
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "454",
   "@_column": "6",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "454",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet__side__data_1ga0ec4f0dc213b3bc6cbd611ea04e0427f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convenience function to free all the side data stored in an array, and\n * the array itself.\n *\n * @param sd    pointer to array of side data to free. Will be set to NULL\n *              upon return.\n * @param nb_sd pointer to an integer containing the number of entries in\n *              the array. Will be set to 0 upon return.\n */"
 },
 "av_packet_side_data_name": {
  "type": "const char *",
  "definition": "const char * av_packet_side_data_name",
  "argsstring": "(enum AVPacketSideDataType type)",
  "name": "av_packet_side_data_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPacketSideDataType",
     "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "type"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "456",
   "@_column": "12",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "456",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet__side__data_1ga3684055b06b6b0824953870914e5b958",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convenience function to free all the side data stored in an array, and\n * the array itself.\n *\n * @param sd    pointer to array of side data to free. Will be set to NULL\n *              upon return.\n * @param nb_sd pointer to an integer containing the number of entries in\n *              the array. Will be set to 0 upon return.\n */"
 },
 "av_packet_alloc": {
  "type": {
   "ref": {
    "#text": "AVPacket",
    "@_refid": "structAVPacket",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVPacket * av_packet_alloc",
  "argsstring": "(void)",
  "name": "av_packet_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVPacket",
     "@_refid": "structAVPacket",
     "@_kindref": "compound"
    },
    "#text": "Allocate anand set its fields to default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_packet_free()",
      "@_refid": "group__lavc__packet_1ga1066464e7cdd1f215df6940db94e5d8e",
      "@_kindref": "member"
     },
     "#text": "The resulting struct must be freed using."
    },
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "AVPacket",
         "@_refid": "structAVPacket",
         "@_kindref": "compound"
        },
        "#text": "Anfilled with default values or NULL on failure."
       },
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "AVPacket",
         "@_refid": "structAVPacket",
         "@_kindref": "compound"
        },
        "#text": "this only allocates theitself, not the data buffers. Those must be allocated through other means such as av_new_packet."
       },
       "@_kind": "note"
      },
      {
       "para": {
        "ref": {
         "#text": "av_new_packet",
         "@_refid": "group__lavc__packet_1gadfa708660b85a56749c753124de2da7d",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "614",
   "@_column": "10",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "614",
   "@_declcolumn": "10"
  },
  "referencedby": [
   {
    "#text": "add_stream",
    "@_refid": "mux_8c_1a22968a15b922fd8c0c37b49beec06dbe",
    "@_compoundref": "mux_8c",
    "@_startline": "125",
    "@_endline": "211"
   },
   {
    "#text": "init_filters",
    "@_refid": "transcode_8c_1a05c93a3c60f2fc12e3fb7884be1128d6",
    "@_compoundref": "transcode_8c",
    "@_startline": "394",
    "@_endline": "430"
   },
   {
    "#text": "init_packet",
    "@_refid": "transcode__aac_8c_1a6ad4cd9865e873e215b89903bea43ab4",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "253",
    "@_endline": "260"
   },
   {
    "#text": "main",
    "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "106",
    "@_endline": "237"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__packet_1gad56057568fb51504e5b4aafcb44f9a03",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVPacket and set its fields to default values.  The resulting\n * struct must be freed using av_packet_free().\n *\n * @return An AVPacket filled with default values or NULL on failure.\n *\n * @note this only allocates the AVPacket itself, not the data buffers. Those\n * must be allocated through other means such as av_new_packet.\n *\n * @see av_new_packet\n */"
 },
 "av_packet_clone": {
  "type": {
   "ref": {
    "#text": "AVPacket",
    "@_refid": "structAVPacket",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVPacket * av_packet_clone",
  "argsstring": "(const AVPacket *src)",
  "name": "av_packet_clone",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPacket",
     "@_refid": "structAVPacket",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "src"
  },
  "briefdescription": {
   "para": "Create a new packet that references the same data as src."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "av_packet_alloc()",
       "@_refid": "group__lavc__packet_1gad56057568fb51504e5b4aafcb44f9a03",
       "@_kindref": "member"
      },
      {
       "#text": "av_packet_ref()",
       "@_refid": "group__lavc__packet_1gadb05d71fa2ea7b7fd3e8cfc6d9065a47",
       "@_kindref": "member"
      }
     ],
     "#text": "This is a shortcut for+."
    },
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "AVPacket",
         "@_refid": "structAVPacket",
         "@_kindref": "compound"
        },
        "#text": "newly createdon success, NULL on error."
       },
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_packet_alloc",
         "@_refid": "group__lavc__packet_1gad56057568fb51504e5b4aafcb44f9a03",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      },
      {
       "para": {
        "ref": {
         "#text": "av_packet_ref",
         "@_refid": "group__lavc__packet_1gadb05d71fa2ea7b7fd3e8cfc6d9065a47",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "626",
   "@_column": "10",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "626",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1ga839594f86c1f1dcefa28eae5db93c655",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create a new packet that references the same data as src.\n *\n * This is a shortcut for av_packet_alloc()+av_packet_ref().\n *\n * @return newly created AVPacket on success, NULL on error.\n *\n * @see av_packet_alloc\n * @see av_packet_ref\n */"
 },
 "av_packet_free": {
  "type": "void",
  "definition": "void av_packet_free",
  "argsstring": "(AVPacket **pkt)",
  "name": "av_packet_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPacket",
     "@_refid": "structAVPacket",
     "@_kindref": "compound"
    },
    "#text": "**"
   },
   "declname": "pkt"
  },
  "briefdescription": {
   "para": "Free the packet, if the packet is reference counted, it will be unreferenced first."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "pkt"
      },
      "parameterdescription": {
       "para": "packet to be freed. The pointer will be set to NULL."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "passing NULL is a no-op.",
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "635",
   "@_column": "6",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "635",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "close_stream",
    "@_refid": "mux_8c_1a92d8b2751255677797d807161fae9d19",
    "@_compoundref": "mux_8c",
    "@_startline": "521",
    "@_endline": "529"
   },
   {
    "#text": "decode_audio_frame",
    "@_refid": "transcode__aac_8c_1a5c320cc89448244f68daee53092da98c",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "369",
    "@_endline": "429"
   },
   {
    "#text": "encode_audio_frame",
    "@_refid": "transcode__aac_8c_1a3d408f21612691f8c93a7aa24ea554ef",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "654",
    "@_endline": "716"
   },
   {
    "#text": "main",
    "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "106",
    "@_endline": "237"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__packet_1ga1066464e7cdd1f215df6940db94e5d8e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the packet, if the packet is reference counted, it will be\n * unreferenced first.\n *\n * @param pkt packet to be freed. The pointer will be set to NULL.\n * @note passing NULL is a no-op.\n */"
 },
 "av_new_packet": {
  "type": "int",
  "definition": "int av_new_packet",
  "argsstring": "(AVPacket *pkt, int size)",
  "name": "av_new_packet",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Allocate the payload of a packet and initialize its fields with default values."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "wanted payload size"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 if OK, AVERROR_xxx otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "664",
   "@_column": "5",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "664",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1gadfa708660b85a56749c753124de2da7d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate the payload of a packet and initialize its fields with\n * default values.\n *\n * @param pkt packet\n * @param size wanted payload size\n * @return 0 if OK, AVERROR_xxx otherwise\n */"
 },
 "av_shrink_packet": {
  "type": "void",
  "definition": "void av_shrink_packet",
  "argsstring": "(AVPacket *pkt, int size)",
  "name": "av_shrink_packet",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Reduce packet size, correctly zeroing padding."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "new size"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "672",
   "@_column": "6",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "672",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1gaceba1c21e5718f87abdf61cf21500485",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reduce packet size, correctly zeroing padding\n *\n * @param pkt packet\n * @param size new size\n */"
 },
 "av_grow_packet": {
  "type": "int",
  "definition": "int av_grow_packet",
  "argsstring": "(AVPacket *pkt, int grow_by)",
  "name": "av_grow_packet",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   },
   {
    "type": "int",
    "declname": "grow_by"
   }
  ],
  "briefdescription": {
   "para": "Increase packet size, correctly zeroing padding."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet"
       }
      },
      {
       "parameternamelist": {
        "parametername": "grow_by"
       },
       "parameterdescription": {
        "para": "number of bytes by which to increase the size of the packet"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "680",
   "@_column": "5",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "680",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1ga74f66e072998b8ce81ef3aba8d617a58",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Increase packet size, correctly zeroing padding\n *\n * @param pkt packet\n * @param grow_by number of bytes by which to increase the size of the packet\n */"
 },
 "av_packet_from_data": {
  "type": "int",
  "definition": "int av_packet_from_data",
  "argsstring": "(AVPacket *pkt, uint8_t *data, int size)",
  "name": "av_packet_from_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   },
   {
    "type": "uint8_t *",
    "declname": "data"
   },
   {
    "type": "int",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_malloc()",
     "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
     "@_kindref": "member"
    },
    "#text": "Initialize a reference-counted packet fromed data."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet to be initialized. This function will set the data, size, and buf fields, all others are left untouched."
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_malloc()",
          "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
          "@_kindref": "member"
         },
         "#text": "Data allocated byto be used as packet data. If this function returns successfully, the data is owned by the underlying AVBuffer. The caller may not access the data through other means."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "size of data in bytes, without the padding. I.e. the full buffer size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative AVERROR on error",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "695",
   "@_column": "5",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "695",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1ga7ca877e1f0ded89a27199b65e9a077dc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize a reference-counted packet from av_malloc()ed data.\n *\n * @param pkt packet to be initialized. This function will set the data, size,\n *        and buf fields, all others are left untouched.\n * @param data Data allocated by av_malloc() to be used as packet data. If this\n *        function returns successfully, the data is owned by the underlying AVBuffer.\n *        The caller may not access the data through other means.\n * @param size size of data in bytes, without the padding. I.e. the full buffer\n *        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.\n *\n * @return 0 on success, a negative AVERROR on error\n */"
 },
 "av_packet_new_side_data": {
  "type": "uint8_t *",
  "definition": "uint8_t * av_packet_new_side_data",
  "argsstring": "(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)",
  "name": "av_packet_new_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideDataType",
      "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Allocate new information of a packet."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "side information type"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "side information size"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "pointer to fresh allocated data or NULL otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "705",
   "@_column": "9",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "705",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1ga6c320d8a4bf8693fa2e0da3ee50d98e7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate new information of a packet.\n *\n * @param pkt packet\n * @param type side information type\n * @param size side information size\n * @return pointer to fresh allocated data or NULL otherwise\n */"
 },
 "av_packet_add_side_data": {
  "type": "int",
  "definition": "int av_packet_add_side_data",
  "argsstring": "(AVPacket *pkt, enum AVPacketSideDataType type, uint8_t *data, size_t size)",
  "name": "av_packet_add_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideDataType",
      "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "uint8_t *",
    "declname": "data"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Wrap an existing array as a packet side data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "side information type"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_malloc()",
          "@_refid": "group__lavu__mem__funcs_1gaafef95f25208665371057f89fb5a11b8",
          "@_kindref": "member"
         },
         "#text": "the side data array. It must be allocated with thefamily of functions. The ownership of the data is transferred to pkt."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "side information size"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "a non-negative number on success, a negative AVERROR code on failure. On failure, the packet is unchanged and the data remains owned by the caller.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "721",
   "@_column": "5",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "721",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1ga8ac567e12e7637fa5cba87c1b9841f49",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Wrap an existing array as a packet side data.\n *\n * @param pkt packet\n * @param type side information type\n * @param data the side data array. It must be allocated with the av_malloc()\n *             family of functions. The ownership of the data is transferred to\n *             pkt.\n * @param size side information size\n * @return a non-negative number on success, a negative AVERROR code on\n *         failure. On failure, the packet is unchanged and the data remains\n *         owned by the caller.\n */"
 },
 "av_packet_shrink_side_data": {
  "type": "int",
  "definition": "int av_packet_shrink_side_data",
  "argsstring": "(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)",
  "name": "av_packet_shrink_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideDataType",
      "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "size_t",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Shrink the already allocated side data buffer."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "side information type"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "new side information size"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, < 0 on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "732",
   "@_column": "5",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "732",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1ga3d815115e1f842932aef3e8e5cdfafff",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Shrink the already allocated side data buffer\n *\n * @param pkt packet\n * @param type side information type\n * @param size new side information size\n * @return 0 on success, < 0 on failure\n */"
 },
 "av_packet_get_side_data": {
  "type": "uint8_t *",
  "definition": "uint8_t * av_packet_get_side_data",
  "argsstring": "(const AVPacket *pkt, enum AVPacketSideDataType type, size_t *size)",
  "name": "av_packet_get_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "pkt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacketSideDataType",
      "@_refid": "group__lavc__packet__side__data_1ga9a80bfcacc586b483a973272800edb97",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "size_t *",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Get side information from packet."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "desired side information type"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "If supplied, *size will be set to the size of the side data or to zero if the desired side data is not present."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "pointer to data if present or NULL otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "744",
   "@_column": "9",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "744",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1gab28b5f89648fb20f49e30aa258d119b1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get side information from packet.\n *\n * @param pkt packet\n * @param type desired side information type\n * @param size If supplied, *size will be set to the size of the side data\n *             or to zero if the desired side data is not present.\n * @return pointer to data if present or NULL otherwise\n */"
 },
 "av_packet_pack_dictionary": {
  "type": "uint8_t *",
  "definition": "uint8_t * av_packet_pack_dictionary",
  "argsstring": "(AVDictionary *dict, size_t *size)",
  "name": "av_packet_pack_dictionary",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "dict"
   },
   {
    "type": "size_t *",
    "declname": "size"
   }
  ],
  "briefdescription": {
   "para": "Pack a dictionary for use in side_data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "dict"
       },
       "parameterdescription": {
        "para": "The dictionary to pack."
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "pointer to store the size of the returned data"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "pointer to data if successful, NULL otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "754",
   "@_column": "9",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "754",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1gabb1aa49bdbea2f3a586ea48f1082e898",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Pack a dictionary for use in side_data.\n *\n * @param dict The dictionary to pack.\n * @param size pointer to store the size of the returned data\n * @return pointer to data if successful, NULL otherwise\n */"
 },
 "av_packet_unpack_dictionary": {
  "type": "int",
  "definition": "int av_packet_unpack_dictionary",
  "argsstring": "(const uint8_t *data, size_t size, AVDictionary **dict)",
  "name": "av_packet_unpack_dictionary",
  "param": [
   {
    "type": "const uint8_t *",
    "declname": "data"
   },
   {
    "type": "size_t",
    "declname": "size"
   },
   {
    "type": {
     "ref": {
      "#text": "AVDictionary",
      "@_refid": "group__lavu__dict_1ga1d7cc0833bee918994a600556410315f",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "dict"
   }
  ],
  "briefdescription": {
   "para": "Unpack a dictionary from side_data."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "data from side_data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "size"
       },
       "parameterdescription": {
        "para": "size of the data"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dict"
       },
       "parameterdescription": {
        "para": "the metadata storage dictionary"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, < 0 on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "763",
   "@_column": "5",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "763",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1gaae45c29cb3a29dc80b0b8f4ee9724492",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Unpack a dictionary from side_data.\n *\n * @param data data from side_data\n * @param size size of the data\n * @param dict the metadata storage dictionary\n * @return 0 on success, < 0 on failure\n */"
 },
 "av_packet_free_side_data": {
  "type": "void",
  "definition": "void av_packet_free_side_data",
  "argsstring": "(AVPacket *pkt)",
  "name": "av_packet_free_side_data",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPacket",
     "@_refid": "structAVPacket",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "pkt"
  },
  "briefdescription": {
   "para": "Convenience function to free all the side data stored."
  },
  "detaileddescription": {
   "para": [
    "All the other fields stay untouched.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "packet"
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "772",
   "@_column": "6",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "772",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1ga5cf4ba712aca9b300daf1eea1b8a9ebb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convenience function to free all the side data stored.\n * All the other fields stay untouched.\n *\n * @param pkt packet\n */"
 },
 "av_packet_ref": {
  "type": "int",
  "definition": "int av_packet_ref",
  "argsstring": "(AVPacket *dst, const AVPacket *src)",
  "name": "av_packet_ref",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Setup a new reference to the data described by a given packet."
  },
  "detaileddescription": {
   "para": [
    "If src is reference-counted, setup dst as a new reference to the buffer in src. Otherwise allocate a new buffer in dst and copy the data from src into it.",
    "All the other fields are copied from src.",
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "av_packet_unref",
         "@_refid": "group__lavc__packet_1ga63d5a489b419bd5d45cfd09091cbcbc2",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      },
      {
       "para": {
        "ref": {
         "#text": "av_packet_alloc()",
         "@_refid": "group__lavc__packet_1gad56057568fb51504e5b4aafcb44f9a03",
         "@_kindref": "member"
        },
        "#text": "0 on success, a negative AVERROR on error. On error, dst will be blank (as if returned by)."
       },
       "@_kind": "return"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "Destination packet. Will be completely overwritten."
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "Source packet"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "791",
   "@_column": "5",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "791",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1gadb05d71fa2ea7b7fd3e8cfc6d9065a47",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Setup a new reference to the data described by a given packet\n *\n * If src is reference-counted, setup dst as a new reference to the\n * buffer in src. Otherwise allocate a new buffer in dst and copy the\n * data from src into it.\n *\n * All the other fields are copied from src.\n *\n * @see av_packet_unref\n *\n * @param dst Destination packet. Will be completely overwritten.\n * @param src Source packet\n *\n * @return 0 on success, a negative AVERROR on error. On error, dst\n *         will be blank (as if returned by av_packet_alloc()).\n */"
 },
 "av_packet_unref": {
  "type": "void",
  "definition": "void av_packet_unref",
  "argsstring": "(AVPacket *pkt)",
  "name": "av_packet_unref",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPacket",
     "@_refid": "structAVPacket",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "pkt"
  },
  "briefdescription": {
   "para": "Wipe the packet."
  },
  "detaileddescription": {
   "para": [
    "Unreference the buffer referenced by the packet and reset the remaining packet fields to their default values.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "pkt"
       },
       "parameterdescription": {
        "para": "The packet to be unreferenced."
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "801",
   "@_column": "6",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "801",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "encode",
    "@_refid": "encode__audio_8c_1a4883bd84aced552588972551e86d8575",
    "@_compoundref": "encode__audio_8c",
    "@_startline": "94",
    "@_endline": "120"
   },
   {
    "#text": "encode_write_frame",
    "@_refid": "transcode_8c_1a0911d751b11fdf9780825b79badfae91",
    "@_compoundref": "transcode_8c",
    "@_startline": "432",
    "@_endline": "471"
   },
   {
    "#text": "main",
    "@_refid": "decode__filter__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "217",
    "@_endline": "296"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__packet_1ga63d5a489b419bd5d45cfd09091cbcbc2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Wipe the packet.\n *\n * Unreference the buffer referenced by the packet and reset the\n * remaining packet fields to their default values.\n *\n * @param pkt The packet to be unreferenced.\n */"
 },
 "av_packet_move_ref": {
  "type": "void",
  "definition": "void av_packet_move_ref",
  "argsstring": "(AVPacket *dst, AVPacket *src)",
  "name": "av_packet_move_ref",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Move every field in src to dst and reset src."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "av_packet_unref",
       "@_refid": "group__lavc__packet_1ga63d5a489b419bd5d45cfd09091cbcbc2",
       "@_kindref": "member"
      }
     },
     "@_kind": "see"
    },
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "Source packet, will be reset"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "Destination packet"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "811",
   "@_column": "6",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "811",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1ga91dbb1359f99547adb544ee96a406b21",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Move every field in src to dst and reset src.\n *\n * @see av_packet_unref\n *\n * @param src Source packet, will be reset\n * @param dst Destination packet\n */"
 },
 "av_packet_copy_props": {
  "type": "int",
  "definition": "int av_packet_copy_props",
  "argsstring": "(AVPacket *dst, const AVPacket *src)",
  "name": "av_packet_copy_props",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Copy only \"properties\" fields from src to dst."
  },
  "detaileddescription": {
   "para": [
    "Properties for the purpose of this function are all the fields beside those related to the packet data (buf, data, size)",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "Destination packet"
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "Source packet"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success AVERROR on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "824",
   "@_column": "5",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "824",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1gade00f67930f4e2a3401b67b701d5b3a2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy only \"properties\" fields from src to dst.\n *\n * Properties for the purpose of this function are all the fields\n * beside those related to the packet data (buf, data, size)\n *\n * @param dst Destination packet\n * @param src Source packet\n *\n * @return 0 on success AVERROR on failure.\n */"
 },
 "av_packet_make_refcounted": {
  "type": "int",
  "definition": "int av_packet_make_refcounted",
  "argsstring": "(AVPacket *pkt)",
  "name": "av_packet_make_refcounted",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPacket",
     "@_refid": "structAVPacket",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "pkt"
  },
  "briefdescription": {
   "para": "Ensure the data described by a given packet is reference counted."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": "This function does not ensure that the reference will be writable. Use av_packet_make_writable instead for that purpose.",
      "@_kind": "note"
     },
     {
      "para": {
       "ref": {
        "#text": "av_packet_ref",
        "@_refid": "group__lavc__packet_1gadb05d71fa2ea7b7fd3e8cfc6d9065a47",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     },
     {
      "para": {
       "ref": {
        "#text": "av_packet_make_writable",
        "@_refid": "group__lavc__packet_1gaaa304ffdab83984ac995d134e4298d4b",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     },
     {
      "para": "0 on success, a negative AVERROR on error. On failure, the packet is unchanged.",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "pkt"
      },
      "parameterdescription": {
       "para": "packet whose data should be made reference counted."
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "840",
   "@_column": "5",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "840",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1ga8a6deff6c1809029037ffd760db3e0d4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Ensure the data described by a given packet is reference counted.\n *\n * @note This function does not ensure that the reference will be writable.\n *       Use av_packet_make_writable instead for that purpose.\n *\n * @see av_packet_ref\n * @see av_packet_make_writable\n *\n * @param pkt packet whose data should be made reference counted.\n *\n * @return 0 on success, a negative AVERROR on error. On failure, the\n *         packet is unchanged.\n */"
 },
 "av_packet_make_writable": {
  "type": "int",
  "definition": "int av_packet_make_writable",
  "argsstring": "(AVPacket *pkt)",
  "name": "av_packet_make_writable",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPacket",
     "@_refid": "structAVPacket",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "pkt"
  },
  "briefdescription": {
   "para": "Create a writable reference for the data described by a given packet, avoiding data copy if possible."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "pkt"
      },
      "parameterdescription": {
       "para": "Packet whose data should be made writable."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, a negative AVERROR on failure. On failure, the packet is unchanged.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "851",
   "@_column": "5",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "851",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__packet_1gaaa304ffdab83984ac995d134e4298d4b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create a writable reference for the data described by a given packet,\n * avoiding data copy if possible.\n *\n * @param pkt Packet whose data should be made writable.\n *\n * @return 0 on success, a negative AVERROR on failure. On failure, the\n *         packet is unchanged.\n */"
 },
 "av_packet_rescale_ts": {
  "type": "void",
  "definition": "void av_packet_rescale_ts",
  "argsstring": "(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)",
  "name": "av_packet_rescale_ts",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPacket",
      "@_refid": "structAVPacket",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "pkt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "tb_src"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "tb_dst"
   }
  ],
  "briefdescription": {
   "para": "Convert valid timing fields (timestamps / durations) in a packet from one timebase to another."
  },
  "detaileddescription": {
   "para": [
    "Timestamps with unknown values (AV_NOPTS_VALUE) will be ignored.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "pkt"
        },
        "parameterdescription": {
         "para": "packet on which the conversion will be performed"
        }
       },
       {
        "parameternamelist": {
         "parametername": "tb_src"
        },
        "parameterdescription": {
         "para": "source timebase, in which the timing fields in pkt are expressed"
        }
       },
       {
        "parameternamelist": {
         "parametername": "tb_dst"
        },
        "parameterdescription": {
         "para": "destination timebase, to which the timing fields will be converted"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/packet.h",
   "@_line": "864",
   "@_column": "6",
   "@_declfile": "libavcodec/packet.h",
   "@_declline": "864",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "encode_write_frame",
    "@_refid": "transcode_8c_1a0911d751b11fdf9780825b79badfae91",
    "@_compoundref": "transcode_8c",
    "@_startline": "432",
    "@_endline": "471"
   },
   {
    "#text": "main",
    "@_refid": "remux_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "remux_8c",
    "@_startline": "46",
    "@_endline": "198"
   },
   {
    "#text": "write_frame",
    "@_refid": "mux_8c_1a7bdbb3cdac2b8aeadf731768bb193c38",
    "@_compoundref": "mux_8c",
    "@_startline": "83",
    "@_endline": "122"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavc__packet_1gae5c86e4d93f6e7aa62ef2c60763ea67e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert valid timing fields (timestamps / durations) in a packet from one\n * timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be\n * ignored.\n *\n * @param pkt packet on which the conversion will be performed\n * @param tb_src source timebase, in which the timing fields in pkt are\n *               expressed\n * @param tb_dst destination timebase, to which the timing fields will be\n *               converted\n */"
 },
 "av_parse_ratio": {
  "type": "int",
  "definition": "int av_parse_ratio",
  "argsstring": "(AVRational *q, const char *str, int max, int log_offset, void *log_ctx)",
  "name": "av_parse_ratio",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "q"
   },
   {
    "type": "const char *",
    "declname": "str"
   },
   {
    "type": "int",
    "declname": "max"
   },
   {
    "type": "int",
    "declname": "log_offset"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Parse str and store the parsed ratio in q."
  },
  "detaileddescription": {
   "para": [
    "Note that a ratio with infinite (1/0) or negative value is considered valid, so you should check on the returned value if you want to exclude those values.",
    "The undefined value can be expressed using the \"0:0\" string.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "q",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVRational",
           "@_refid": "structAVRational",
           "@_kindref": "compound"
          },
          "#text": "pointer to thewhich will contain the ratio"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "str",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "the string to parse: it has to be a string in the format num:den, a float number or an expression"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "max",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "the maximum allowed numerator and denominator"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "log_offset",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "log level offset which is applied to the log level of log_ctx"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "log_ctx",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "parent logging context"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">= 0 on success, a negative error code otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/parseutils.h",
   "@_line": "49",
   "@_column": "5",
   "@_declfile": "libavutil/parseutils.h",
   "@_declline": "49",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "parseutils_8h_1a8535b8693aa5a188cfb1356133c0e94e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse str and store the parsed ratio in q.\n *\n * Note that a ratio with infinite (1/0) or negative value is\n * considered valid, so you should check on the returned value if you\n * want to exclude those values.\n *\n * The undefined value can be expressed using the \"0:0\" string.\n *\n * @param[in,out] q pointer to the AVRational which will contain the ratio\n * @param[in] str the string to parse: it has to be a string in the format\n * num:den, a float number or an expression\n * @param[in] max the maximum allowed numerator and denominator\n * @param[in] log_offset log level offset which is applied to the log\n * level of log_ctx\n * @param[in] log_ctx parent logging context\n * @return >= 0 on success, a negative error code otherwise\n */"
 },
 "av_parse_video_size": {
  "type": "int",
  "definition": "int av_parse_video_size",
  "argsstring": "(int *width_ptr, int *height_ptr, const char *str)",
  "name": "av_parse_video_size",
  "param": [
   {
    "type": "int *",
    "declname": "width_ptr"
   },
   {
    "type": "int *",
    "declname": "height_ptr"
   },
   {
    "type": "const char *",
    "declname": "str"
   }
  ],
  "briefdescription": {
   "para": "Parse str and put in width_ptr and height_ptr the detected values."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "width_ptr",
         "@_direction": "inout"
        }
       },
       "parameterdescription": {
        "para": "pointer to the variable which will contain the detected width value"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "height_ptr",
         "@_direction": "inout"
        }
       },
       "parameterdescription": {
        "para": "pointer to the variable which will contain the detected height value"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "str",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "the string to parse: it has to be a string in the format width x height or a valid video size abbreviation."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 on success, a negative error code otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/parseutils.h",
   "@_line": "66",
   "@_column": "5",
   "@_declfile": "libavutil/parseutils.h",
   "@_declline": "66",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "scale__video_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "scale__video_8c",
   "@_startline": "53",
   "@_endline": "141"
  },
  "@_kind": "function",
  "@_id": "parseutils_8h_1a4dcdb8a2792f2074ca4a1e1f4ddce2bf",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse str and put in width_ptr and height_ptr the detected values.\n *\n * @param[in,out] width_ptr pointer to the variable which will contain the detected\n * width value\n * @param[in,out] height_ptr pointer to the variable which will contain the detected\n * height value\n * @param[in] str the string to parse: it has to be a string in the format\n * width x height or a valid video size abbreviation.\n * @return >= 0 on success, a negative error code otherwise\n */"
 },
 "av_parse_video_rate": {
  "type": "int",
  "definition": "int av_parse_video_rate",
  "argsstring": "(AVRational *rate, const char *str)",
  "name": "av_parse_video_rate",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "rate"
   },
   {
    "type": "const char *",
    "declname": "str"
   }
  ],
  "briefdescription": {
   "para": "Parse str and store the detected values in *rate."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "rate",
         "@_direction": "inout"
        }
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVRational",
          "@_refid": "structAVRational",
          "@_kindref": "compound"
         },
         "#text": "pointer to thewhich will contain the detected frame rate"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "str",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "the string to parse: it has to be a string in the format rate_num / rate_den, a float number or a valid video rate abbreviation"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 on success, a negative error code otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/parseutils.h",
   "@_line": "77",
   "@_column": "5",
   "@_declfile": "libavutil/parseutils.h",
   "@_declline": "77",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "parseutils_8h_1abbc4de8c071538f5bbde8e5b7466b676",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse str and store the detected values in *rate.\n *\n * @param[in,out] rate pointer to the AVRational which will contain the detected\n * frame rate\n * @param[in] str the string to parse: it has to be a string in the format\n * rate_num / rate_den, a float number or a valid video rate abbreviation\n * @return >= 0 on success, a negative error code otherwise\n */"
 },
 "av_parse_color": {
  "type": "int",
  "definition": "int av_parse_color",
  "argsstring": "(uint8_t *rgba_color, const char *color_string, int slen, void *log_ctx)",
  "name": "av_parse_color",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "rgba_color"
   },
   {
    "type": "const char *",
    "declname": "color_string"
   },
   {
    "type": "int",
    "declname": "slen"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Put the RGBA values that correspond to color_string in rgba_color."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "rgba_color"
       },
       "parameterdescription": {
        "para": "4-elements array of uint8_t values, where the respective red, green, blue and alpha component values are written."
       }
      },
      {
       "parameternamelist": {
        "parametername": "color_string"
       },
       "parameterdescription": {
        "para": "a string specifying a color. It can be the name of a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence, possibly followed by \"@\" and a string representing the alpha component. The alpha component may be a string composed by \"0x\" followed by an hexadecimal number or a decimal number between 0.0 and 1.0, which represents the opacity value (0x00/0.0 means completely transparent, 0xff/1.0 completely opaque). If the alpha component is not specified then 0xff is assumed. The string \"random\" will result in a random color."
       }
      },
      {
       "parameternamelist": {
        "parametername": "slen"
       },
       "parameterdescription": {
        "para": "length of the initial part of color_string containing the color. It can be set to -1 if color_string is a null terminated string containing nothing else than the color."
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": [
          {
           "#text": "AVClass",
           "@_refid": "structAVClass",
           "@_kindref": "compound"
          },
          {
           "#text": "av_log()",
           "@_refid": "group__lavu__log_1gabd386ffd4b27637cf34e98d5d1a6e8ae",
           "@_kindref": "member"
          }
         ],
         "#text": "a pointer to an arbitrary struct of which the first field is a pointer to anstruct (used for). Can be NULL."
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 in case of success, a negative value in case of failure (for example if color_string cannot be parsed).",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/parseutils.h",
   "@_line": "102",
   "@_column": "5",
   "@_declfile": "libavutil/parseutils.h",
   "@_declline": "102",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "parseutils_8h_1a4be8779c7c2afd9c57c8b962bea76d03",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Put the RGBA values that correspond to color_string in rgba_color.\n *\n * @param rgba_color 4-elements array of uint8_t values, where the respective\n * red, green, blue and alpha component values are written.\n * @param color_string a string specifying a color. It can be the name of\n * a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,\n * possibly followed by \"@\" and a string representing the alpha\n * component.\n * The alpha component may be a string composed by \"0x\" followed by an\n * hexadecimal number or a decimal number between 0.0 and 1.0, which\n * represents the opacity value (0x00/0.0 means completely transparent,\n * 0xff/1.0 completely opaque).\n * If the alpha component is not specified then 0xff is assumed.\n * The string \"random\" will result in a random color.\n * @param slen length of the initial part of color_string containing the\n * color. It can be set to -1 if color_string is a null terminated string\n * containing nothing else than the color.\n * @param log_ctx a pointer to an arbitrary struct of which the first field\n * is a pointer to an AVClass struct (used for av_log()). Can be NULL.\n * @return >= 0 in case of success, a negative value in case of\n * failure (for example if color_string cannot be parsed).\n */"
 },
 "av_get_known_color_name": {
  "type": "const char *",
  "definition": "const char * av_get_known_color_name",
  "argsstring": "(int color_idx, const uint8_t **rgb)",
  "name": "av_get_known_color_name",
  "param": [
   {
    "type": "int",
    "declname": "color_idx"
   },
   {
    "type": "const uint8_t **",
    "declname": "rgb"
   }
  ],
  "briefdescription": {
   "para": "Get the name of a color from the internal table of hard-coded named colors."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_parse_color()",
      "@_refid": "parseutils_8h_1a4be8779c7c2afd9c57c8b962bea76d03",
      "@_kindref": "member"
     },
     "#text": "This function is meant to enumerate the color names recognized by."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "color_idx"
        },
        "parameterdescription": {
         "para": "index of the requested color, starting from 0"
        }
       },
       {
        "parameternamelist": {
         "parametername": "rgb"
        },
        "parameterdescription": {
         "para": "if not NULL, will point to a 3-elements array with the color value in RGB"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the color name string or NULL if color_idx is not in the array",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/parseutils.h",
   "@_line": "116",
   "@_column": "12",
   "@_declfile": "libavutil/parseutils.h",
   "@_declline": "116",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "parseutils_8h_1a6d8cfb62989c8dc657954b33214f599d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the name of a color from the internal table of hard-coded named\n * colors.\n *\n * This function is meant to enumerate the color names recognized by\n * av_parse_color().\n *\n * @param color_idx index of the requested color, starting from 0\n * @param rgb      if not NULL, will point to a 3-elements array with the color value in RGB\n * @return the color name string or NULL if color_idx is not in the array\n */"
 },
 "av_parse_time": {
  "type": "int",
  "definition": "int av_parse_time",
  "argsstring": "(int64_t *timeval, const char *timestr, int duration)",
  "name": "av_parse_time",
  "param": [
   {
    "type": "int64_t *",
    "declname": "timeval"
   },
   {
    "type": "const char *",
    "declname": "timestr"
   },
   {
    "type": "int",
    "declname": "duration"
   }
  ],
  "briefdescription": {
   "para": "Parse timestr and return in *time a corresponding number of microseconds."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "timeval"
       },
       "parameterdescription": {
        "para": "puts here the number of microseconds corresponding to the string in timestr. If the string represents a duration, it is the number of microseconds contained in the time interval. If the string is a date, is the number of microseconds since 1st of January, 1970 up to the time of the parsed date. If timestr cannot be successfully parsed, set *time to INT64_MIN."
       }
      },
      {
       "parameternamelist": {
        "parametername": "timestr"
       },
       "parameterdescription": {
        "para": {
         "itemizedlist": {
          "listitem": [
           {
            "para": {
             "programlisting": {
              "codeline": [
               {
                "highlight": {
                 "sp": "",
                 "#text": "[{YYYY-MM-DD|YYYYMMDD}[T|t|]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]",
                 "@_class": "normal"
                }
               },
               {
                "highlight": {
                 "#text": "now",
                 "@_class": "normal"
                }
               }
              ]
             },
             "#text": "If a date the syntax is:If the value is \"now\" it takes the current time. Time is local time unless Z is appended, in which case it is interpreted as UTC. If the year-month-day part is not specified it takes the current year-month-day."
            }
           },
           {
            "para": {
             "programlisting": {
              "codeline": [
               {
                "highlight": {
                 "#text": "[-][HH:]MM:SS[.m...]",
                 "@_class": "normal"
                }
               },
               {
                "highlight": {
                 "#text": "[-]S+[.m...]",
                 "@_class": "normal"
                }
               }
              ]
             },
             "#text": "If a duration the syntax is:"
            }
           }
          ]
         },
         "#text": "a string representing a date or a duration."
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "duration"
       },
       "parameterdescription": {
        "para": "flag which tells how to interpret timestr, if not zero timestr is interpreted as a duration, otherwise as a date"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 in case of success, a negative value corresponding to an AVERROR code otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/parseutils.h",
   "@_line": "150",
   "@_column": "5",
   "@_declfile": "libavutil/parseutils.h",
   "@_declline": "150",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "parseutils_8h_1a98590feafe82e074f61f38c8faaa4cef",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse timestr and return in *time a corresponding number of\n * microseconds.\n *\n * @param timeval puts here the number of microseconds corresponding\n * to the string in timestr. If the string represents a duration, it\n * is the number of microseconds contained in the time interval.  If\n * the string is a date, is the number of microseconds since 1st of\n * January, 1970 up to the time of the parsed date.  If timestr cannot\n * be successfully parsed, set *time to INT64_MIN.\n\n * @param timestr a string representing a date or a duration.\n * - If a date the syntax is:\n * @code\n * [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]\n * now\n * @endcode\n * If the value is \"now\" it takes the current time.\n * Time is local time unless Z is appended, in which case it is\n * interpreted as UTC.\n * If the year-month-day part is not specified it takes the current\n * year-month-day.\n * - If a duration the syntax is:\n * @code\n * [-][HH:]MM:SS[.m...]\n * [-]S+[.m...]\n * @endcode\n * @param duration flag which tells how to interpret timestr, if not\n * zero timestr is interpreted as a duration, otherwise as a date\n * @return >= 0 in case of success, a negative value corresponding to an\n * AVERROR code otherwise\n */"
 },
 "av_find_info_tag": {
  "type": "int",
  "definition": "int av_find_info_tag",
  "argsstring": "(char *arg, int arg_size, const char *tag1, const char *info)",
  "name": "av_find_info_tag",
  "param": [
   {
    "type": "char *",
    "declname": "arg"
   },
   {
    "type": "int",
    "declname": "arg_size"
   },
   {
    "type": "const char *",
    "declname": "tag1"
   },
   {
    "type": "const char *",
    "declname": "info"
   }
  ],
  "briefdescription": {
   "para": "Attempt to find a specific tag in a URL."
  },
  "detaileddescription": {
   "para": "syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done. Return 1 if found."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/parseutils.h",
   "@_line": "158",
   "@_column": "5",
   "@_declfile": "libavutil/parseutils.h",
   "@_declline": "158",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "parseutils_8h_1ad97f06e907c14c253c2bf3e775f51ccb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Attempt to find a specific tag in a URL.\n *\n * syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done.\n * Return 1 if found.\n */"
 },
 "av_small_strptime": {
  "type": "char *",
  "definition": "char * av_small_strptime",
  "argsstring": "(const char *p, const char *fmt, struct tm *dt)",
  "name": "av_small_strptime",
  "param": [
   {
    "type": "const char *",
    "declname": "p"
   },
   {
    "type": "const char *",
    "declname": "fmt"
   },
   {
    "type": "struct tm *",
    "declname": "dt"
   }
  ],
  "briefdescription": {
   "para": "Simplified version of strptime."
  },
  "detaileddescription": {
   "para": [
    "Parse the input string p according to the format string fmt and store its results in the structure dt. This implementation supports only a subset of the formats supported by the standard strptime().",
    {
     "itemizedlist": {
      "listitem": [
       {
        "para": {
         "computeroutput": "%H",
         "#text": ": the hour as a decimal number, using a 24-hour clock, in the range '00' through '23'"
        }
       },
       {
        "para": {
         "computeroutput": "%J",
         "#text": ": hours as a decimal number, in the range '0' through INT_MAX"
        }
       },
       {
        "para": {
         "computeroutput": "%M",
         "#text": ": the minute as a decimal number, using a 24-hour clock, in the range '00' through '59'"
        }
       },
       {
        "para": {
         "computeroutput": "%S",
         "#text": ": the second as a decimal number, using a 24-hour clock, in the range '00' through '59'"
        }
       },
       {
        "para": {
         "computeroutput": "%Y",
         "#text": ": the year as a decimal number, using the Gregorian calendar"
        }
       },
       {
        "para": {
         "computeroutput": "%m",
         "#text": ": the month as a decimal number, in the range '1' through '12'"
        }
       },
       {
        "para": {
         "computeroutput": "%d",
         "#text": ": the day of the month as a decimal number, in the range '1' through '31'"
        }
       },
       {
        "para": {
         "computeroutput": [
          "%T",
          "%H:%M:%S"
         ],
         "#text": ": alias for"
        }
       },
       {
        "para": {
         "computeroutput": [
          "%%",
          "%"
         ],
         "#text": ": a literal"
        }
       }
      ]
     },
     "#text": "The supported input field descriptors are listed below."
    },
    {
     "simplesect": {
      "para": "a pointer to the first character not processed in this function call. In case the input string contains more characters than required by the format string the return value points right after the last consumed input character. In case the whole input string is consumed the return value points to the null byte at the end of the string. On failure NULL is returned.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/parseutils.h",
   "@_line": "190",
   "@_column": "6",
   "@_declfile": "libavutil/parseutils.h",
   "@_declline": "190",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "parseutils_8h_1aa9fc9ede1311e05ea453a1de0ec4dafd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Simplified version of strptime\n *\n * Parse the input string p according to the format string fmt and\n * store its results in the structure dt.\n * This implementation supports only a subset of the formats supported\n * by the standard strptime().\n *\n * The supported input field descriptors are listed below.\n * - `%%H`: the hour as a decimal number, using a 24-hour clock, in the\n *   range '00' through '23'\n * - `%%J`: hours as a decimal number, in the range '0' through INT_MAX\n * - `%%M`: the minute as a decimal number, using a 24-hour clock, in the\n *   range '00' through '59'\n * - `%%S`: the second as a decimal number, using a 24-hour clock, in the\n *   range '00' through '59'\n * - `%%Y`: the year as a decimal number, using the Gregorian calendar\n * - `%%m`: the month as a decimal number, in the range '1' through '12'\n * - `%%d`: the day of the month as a decimal number, in the range '1'\n *   through '31'\n * - `%%T`: alias for `%%H:%%M:%%S`\n * - `%%`: a literal `%`\n *\n * @return a pointer to the first character not processed in this function\n *         call. In case the input string contains more characters than\n *         required by the format string the return value points right after\n *         the last consumed input character. In case the whole input string\n *         is consumed the return value points to the null byte at the end of\n *         the string. On failure NULL is returned.\n */"
 },
 "av_timegm": {
  "type": "time_t",
  "definition": "time_t av_timegm",
  "argsstring": "(struct tm *tm)",
  "name": "av_timegm",
  "param": {
   "type": "struct tm *",
   "declname": "tm"
  },
  "briefdescription": {
   "para": "Convert the decomposed UTC time in tm to a time_t value."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/parseutils.h",
   "@_line": "195",
   "@_column": "8",
   "@_declfile": "libavutil/parseutils.h",
   "@_declline": "195",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "parseutils_8h_1ae9bf34b50b9762f3c733721d5210b52d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert the decomposed UTC time in tm to a time_t value.\n */"
 },
 "av_get_bits_per_pixel": {
  "type": "int",
  "definition": "int av_get_bits_per_pixel",
  "argsstring": "(const AVPixFmtDescriptor *pixdesc)",
  "name": "av_get_bits_per_pixel",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixFmtDescriptor",
     "@_refid": "structAVPixFmtDescriptor",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "pixdesc"
  },
  "briefdescription": {
   "para": "Return the number of bits per pixel used by the pixel format described by pixdesc."
  },
  "detaileddescription": {
   "para": [
    "Note that this is not the same as the number of bits per sample.",
    "The returned number of bits refers to the number of bits actually used for storing the pixel information, that is padding bits are not counted."
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "174",
   "@_column": "5",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "174",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a7b24a65f6bf07585396da3bd301799b2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the number of bits per pixel used by the pixel format\n * described by pixdesc. Note that this is not the same as the number\n * of bits per sample.\n *\n * The returned number of bits refers to the number of bits actually\n * used for storing the pixel information, that is padding bits are\n * not counted.\n */"
 },
 "av_get_padded_bits_per_pixel": {
  "type": "int",
  "definition": "int av_get_padded_bits_per_pixel",
  "argsstring": "(const AVPixFmtDescriptor *pixdesc)",
  "name": "av_get_padded_bits_per_pixel",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixFmtDescriptor",
     "@_refid": "structAVPixFmtDescriptor",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "pixdesc"
  },
  "briefdescription": {
   "para": "Return the number of bits per pixel for the pixel format described by pixdesc, including any padding or unused bits."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "180",
   "@_column": "5",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "180",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a89cf35c5ef18c9e996c7784e1a893b9e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the number of bits per pixel for the pixel format\n * described by pixdesc, including any padding or unused bits.\n */"
 },
 "av_pix_fmt_desc_get": {
  "type": {
   "ref": {
    "#text": "AVPixFmtDescriptor",
    "@_refid": "structAVPixFmtDescriptor",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVPixFmtDescriptor * av_pix_fmt_desc_get",
  "argsstring": "(enum AVPixelFormat pix_fmt)",
  "name": "av_pix_fmt_desc_get",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixelFormat",
     "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "pix_fmt"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "a pixel format descriptor for provided pixel format or NULL if this pixel format is unknown.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "186",
   "@_column": "26",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "186",
   "@_declcolumn": "26"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1ac95c2231a5facc3c6e9d5e9358f62d51",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return a pixel format descriptor for provided pixel format or NULL if\n * this pixel format is unknown.\n */"
 },
 "av_pix_fmt_desc_next": {
  "type": {
   "ref": {
    "#text": "AVPixFmtDescriptor",
    "@_refid": "structAVPixFmtDescriptor",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVPixFmtDescriptor * av_pix_fmt_desc_next",
  "argsstring": "(const AVPixFmtDescriptor *prev)",
  "name": "av_pix_fmt_desc_next",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixFmtDescriptor",
     "@_refid": "structAVPixFmtDescriptor",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "prev"
  },
  "briefdescription": {
   "para": "Iterate over all pixel format descriptors known to libavutil."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "prev"
      },
      "parameterdescription": {
       "para": "previous descriptor. NULL to get the first descriptor."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "next descriptor or NULL after the last descriptor",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "195",
   "@_column": "26",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "195",
   "@_declcolumn": "26"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a306ca99958727a7c45fab6131261f0b1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Iterate over all pixel format descriptors known to libavutil.\n *\n * @param prev previous descriptor. NULL to get the first descriptor.\n *\n * @return next descriptor or NULL after the last descriptor\n */"
 },
 "av_pix_fmt_desc_get_id": {
  "type": {
   "ref": {
    "#text": "AVPixelFormat",
    "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVPixelFormat av_pix_fmt_desc_get_id",
  "argsstring": "(const AVPixFmtDescriptor *desc)",
  "name": "av_pix_fmt_desc_get_id",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixFmtDescriptor",
     "@_refid": "structAVPixFmtDescriptor",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "desc"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc is not a valid pointer to a pixel format descriptor.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "201",
   "@_column": "19",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "201",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a01dfb93fb0e28e789922e9199a4fdb14",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc\n * is not a valid pointer to a pixel format descriptor.\n */"
 },
 "av_pix_fmt_get_chroma_sub_sample": {
  "type": "int",
  "definition": "int av_pix_fmt_get_chroma_sub_sample",
  "argsstring": "(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift)",
  "name": "av_pix_fmt_get_chroma_sub_sample",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   },
   {
    "type": "int *",
    "declname": "h_shift"
   },
   {
    "type": "int *",
    "declname": "v_shift"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVPixFmtDescriptor",
     "@_refid": "structAVPixFmtDescriptor",
     "@_kindref": "compound"
    },
    "#text": "Utility function to access log2_chroma_w log2_chroma_h from the pixel format."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "pix_fmt",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "the pixel format"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "h_shift",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "store log2_chroma_w (horizontal/width shift)"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "v_shift",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "store log2_chroma_h (vertical/height shift)"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVERROR(ENOSYS)",
       "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
       "@_kindref": "member"
      },
      "#text": "0 on success,on invalid or unknown pixel format"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "213",
   "@_column": "5",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "213",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a76e011cf53b51ea14a002a206f6ca05d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Utility function to access log2_chroma_w log2_chroma_h from\n * the pixel format AVPixFmtDescriptor.\n *\n * @param[in]  pix_fmt the pixel format\n * @param[out] h_shift store log2_chroma_w (horizontal/width shift)\n * @param[out] v_shift store log2_chroma_h (vertical/height shift)\n *\n * @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format\n */"
 },
 "av_pix_fmt_count_planes": {
  "type": "int",
  "definition": "int av_pix_fmt_count_planes",
  "argsstring": "(enum AVPixelFormat pix_fmt)",
  "name": "av_pix_fmt_count_planes",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixelFormat",
     "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "pix_fmt"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a valid pixel format.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "220",
   "@_column": "5",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "220",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a118df1d607abd7484f874b3d7ea8823a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a\n * valid pixel format.\n */"
 },
 "av_color_range_name": {
  "type": "const char *",
  "definition": "const char * av_color_range_name",
  "argsstring": "(enum AVColorRange range)",
  "name": "av_color_range_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorRange",
     "@_refid": "pixfmt_8h_1a3da0bf691418bc22c4bcbe6583ad589a",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "range"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the name for provided color range or NULL if unknown.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "225",
   "@_column": "12",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "225",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a5061f4d8e192876cbb6f67cb40563f0f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the name for provided color range or NULL if unknown.\n */"
 },
 "av_color_range_from_name": {
  "type": "int",
  "definition": "int av_color_range_from_name",
  "argsstring": "(const char *name)",
  "name": "av_color_range_from_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the AVColorRange value for name or an AVError if not found.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "230",
   "@_column": "5",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "230",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1aad2f67625f55b7b4cb69ddf36f491892",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the AVColorRange value for name or an AVError if not found.\n */"
 },
 "av_color_primaries_name": {
  "type": "const char *",
  "definition": "const char * av_color_primaries_name",
  "argsstring": "(enum AVColorPrimaries primaries)",
  "name": "av_color_primaries_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorPrimaries",
     "@_refid": "pixfmt_8h_1ad384ee5a840bafd73daef08e6d9cafe7",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "primaries"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the name for provided color primaries or NULL if unknown.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "235",
   "@_column": "12",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "235",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1abe891f0e7303e21b29a45b459c666588",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the name for provided color primaries or NULL if unknown.\n */"
 },
 "av_color_primaries_from_name": {
  "type": "int",
  "definition": "int av_color_primaries_from_name",
  "argsstring": "(const char *name)",
  "name": "av_color_primaries_from_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the AVColorPrimaries value for name or an AVError if not found.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "240",
   "@_column": "5",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "240",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1ac0b9aef4e5964c08aff0158a011d3ac0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the AVColorPrimaries value for name or an AVError if not found.\n */"
 },
 "av_color_transfer_name": {
  "type": "const char *",
  "definition": "const char * av_color_transfer_name",
  "argsstring": "(enum AVColorTransferCharacteristic transfer)",
  "name": "av_color_transfer_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorTransferCharacteristic",
     "@_refid": "pixfmt_8h_1ad4791ea14975f098b649db7fcd731ce6",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "transfer"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the name for provided color transfer or NULL if unknown.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "245",
   "@_column": "12",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "245",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1ab49ea9645d7f49ec12c1a37ab6419cbc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the name for provided color transfer or NULL if unknown.\n */"
 },
 "av_color_transfer_from_name": {
  "type": "int",
  "definition": "int av_color_transfer_from_name",
  "argsstring": "(const char *name)",
  "name": "av_color_transfer_from_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the AVColorTransferCharacteristic value for name or an AVError if not found.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "250",
   "@_column": "5",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "250",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a2edac6eeb4fd282c26f79d78f242ef3c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the AVColorTransferCharacteristic value for name or an AVError if not found.\n */"
 },
 "av_color_space_name": {
  "type": "const char *",
  "definition": "const char * av_color_space_name",
  "argsstring": "(enum AVColorSpace space)",
  "name": "av_color_space_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVColorSpace",
     "@_refid": "pixfmt_8h_1aff71a069509a1ad3ff54d53a1c894c85",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "space"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the name for provided color space or NULL if unknown.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "255",
   "@_column": "12",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "255",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a45f45b7c4285c7202173aafbc2273371",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the name for provided color space or NULL if unknown.\n */"
 },
 "av_color_space_from_name": {
  "type": "int",
  "definition": "int av_color_space_from_name",
  "argsstring": "(const char *name)",
  "name": "av_color_space_from_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the AVColorSpace value for name or an AVError if not found.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "260",
   "@_column": "5",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "260",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a0c7d0a9d7470c49397a72e1169d2a8e3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the AVColorSpace value for name or an AVError if not found.\n */"
 },
 "av_chroma_location_name": {
  "type": "const char *",
  "definition": "const char * av_chroma_location_name",
  "argsstring": "(enum AVChromaLocation location)",
  "name": "av_chroma_location_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVChromaLocation",
     "@_refid": "pixfmt_8h_1a1f86ed1b6a420faccacf77c98db6c1ff",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "location"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the name for provided chroma location or NULL if unknown.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "265",
   "@_column": "12",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "265",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a94a7fd3dfa60ba3460377803ef94dcc1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the name for provided chroma location or NULL if unknown.\n */"
 },
 "av_chroma_location_from_name": {
  "type": "int",
  "definition": "int av_chroma_location_from_name",
  "argsstring": "(const char *name)",
  "name": "av_chroma_location_from_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the AVChromaLocation value for name or an AVError if not found.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "270",
   "@_column": "5",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "270",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a1c3d987e885a212e0d122de27af43d67",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return the AVChromaLocation value for name or an AVError if not found.\n */"
 },
 "av_chroma_location_enum_to_pos": {
  "type": "int",
  "definition": "int av_chroma_location_enum_to_pos",
  "argsstring": "(int *xpos, int *ypos, enum AVChromaLocation pos)",
  "name": "av_chroma_location_enum_to_pos",
  "param": [
   {
    "type": "int *",
    "declname": "xpos"
   },
   {
    "type": "int *",
    "declname": "ypos"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChromaLocation",
      "@_refid": "pixfmt_8h_1a1f86ed1b6a420faccacf77c98db6c1ff",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pos"
   }
  ],
  "briefdescription": {
   "para": "Converts AVChromaLocation to swscale x/y chroma position."
  },
  "detaileddescription": {
   "para": [
    "The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "xpos"
        },
        "parameterdescription": {
         "para": "horizontal chroma sample position"
        }
       },
       {
        "parameternamelist": {
         "parametername": "ypos"
        },
        "parameterdescription": {
         "para": "vertical chroma sample position"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "281",
   "@_column": "5",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "281",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1ad635455b0dc0c4885e530968a83aeb04",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Converts AVChromaLocation to swscale x/y chroma position.\n *\n * The positions represent the chroma (0,0) position in a coordinates system\n * with luma (0,0) representing the origin and luma(1,1) representing 256,256\n *\n * @param xpos  horizontal chroma sample position\n * @param ypos  vertical   chroma sample position\n */"
 },
 "av_chroma_location_pos_to_enum": {
  "type": {
   "ref": {
    "#text": "AVChromaLocation",
    "@_refid": "pixfmt_8h_1a1f86ed1b6a420faccacf77c98db6c1ff",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVChromaLocation av_chroma_location_pos_to_enum",
  "argsstring": "(int xpos, int ypos)",
  "name": "av_chroma_location_pos_to_enum",
  "param": [
   {
    "type": "int",
    "declname": "xpos"
   },
   {
    "type": "int",
    "declname": "ypos"
   }
  ],
  "briefdescription": {
   "para": "Converts swscale x/y chroma position to AVChromaLocation."
  },
  "detaileddescription": {
   "para": [
    "The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "xpos"
        },
        "parameterdescription": {
         "para": "horizontal chroma sample position"
        }
       },
       {
        "parameternamelist": {
         "parametername": "ypos"
        },
        "parameterdescription": {
         "para": "vertical chroma sample position"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "292",
   "@_column": "22",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "292",
   "@_declcolumn": "22"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1abcd918671f73cb59a733d6842a527221",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Converts swscale x/y chroma position to AVChromaLocation.\n *\n * The positions represent the chroma (0,0) position in a coordinates system\n * with luma (0,0) representing the origin and luma(1,1) representing 256,256\n *\n * @param xpos  horizontal chroma sample position\n * @param ypos  vertical   chroma sample position\n */"
 },
 "av_get_pix_fmt": {
  "type": {
   "ref": {
    "#text": "AVPixelFormat",
    "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVPixelFormat av_get_pix_fmt",
  "argsstring": "(const char *name)",
  "name": "av_get_pix_fmt",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": {
   "para": "Return the pixel format corresponding to name."
  },
  "detaileddescription": {
   "para": [
    "If there is no pixel format with name name, then looks for a pixel format with the name corresponding to the native endian format of name. For example in a little-endian system, first looks for \"gray16\", then for \"gray16le\".",
    "Finally if no pixel format has been found, returns AV_PIX_FMT_NONE."
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "305",
   "@_column": "19",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "305",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a925ef18d69c24c3be8c53d5a7dc0660e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the pixel format corresponding to name.\n *\n * If there is no pixel format with name name, then looks for a\n * pixel format with the name corresponding to the native endian\n * format of name.\n * For example in a little-endian system, first looks for \"gray16\",\n * then for \"gray16le\".\n *\n * Finally if no pixel format has been found, returns AV_PIX_FMT_NONE.\n */"
 },
 "av_get_pix_fmt_name": {
  "type": "const char *",
  "definition": "const char * av_get_pix_fmt_name",
  "argsstring": "(enum AVPixelFormat pix_fmt)",
  "name": "av_get_pix_fmt_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixelFormat",
     "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "pix_fmt"
  },
  "briefdescription": {
   "para": "Return the short name for a pixel format, NULL in case pix_fmt is unknown."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": [
       {
        "#text": "av_get_pix_fmt()",
        "@_refid": "pixdesc_8h_1a925ef18d69c24c3be8c53d5a7dc0660e",
        "@_kindref": "member"
       },
       {
        "#text": "av_get_pix_fmt_string()",
        "@_refid": "pixdesc_8h_1ac348f19512365a8bc7234c1b5e4f1e7a",
        "@_kindref": "member"
       }
      ],
      "#text": ","
     },
     "@_kind": "see"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "313",
   "@_column": "12",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "313",
   "@_declcolumn": "12"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "demux__decode_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "demux__decode_8c",
    "@_startline": "226",
    "@_endline": "380"
   },
   {
    "#text": "output_video_frame",
    "@_refid": "demux__decode_8c_1a62690f6eca6ce700ad0d17121eb50a57",
    "@_compoundref": "demux__decode_8c",
    "@_startline": "59",
    "@_endline": "88"
   }
  ],
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a8526f80ba2f0bb50e3606e5866df522c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the short name for a pixel format, NULL in case pix_fmt is\n * unknown.\n *\n * @see av_get_pix_fmt(), av_get_pix_fmt_string()\n */"
 },
 "av_get_pix_fmt_string": {
  "type": "char *",
  "definition": "char * av_get_pix_fmt_string",
  "argsstring": "(char *buf, int buf_size, enum AVPixelFormat pix_fmt)",
  "name": "av_get_pix_fmt_string",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buf_size"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "pix_fmt"
   }
  ],
  "briefdescription": {
   "para": "Print in buf the string corresponding to the pixel format with number pix_fmt, or a header if pix_fmt is negative."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "the buffer where to write the string"
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf_size"
       },
       "parameterdescription": {
        "para": "the size of buf"
       }
      },
      {
       "parameternamelist": {
        "parametername": "pix_fmt"
       },
       "parameterdescription": {
        "para": "the number of the pixel format to print the corresponding info string, or a negative value to print the corresponding header."
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "325",
   "@_column": "6",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "325",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1ac348f19512365a8bc7234c1b5e4f1e7a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Print in buf the string corresponding to the pixel format with\n * number pix_fmt, or a header if pix_fmt is negative.\n *\n * @param buf the buffer where to write the string\n * @param buf_size the size of buf\n * @param pix_fmt the number of the pixel format to print the\n * corresponding info string, or a negative value to print the\n * corresponding header.\n */"
 },
 "av_read_image_line2": {
  "type": "void",
  "definition": "void av_read_image_line2",
  "argsstring": "(void *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component, int dst_element_size)",
  "name": "av_read_image_line2",
  "param": [
   {
    "type": "void *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "data",
    "array": "[4]"
   },
   {
    "type": "const int",
    "declname": "linesize",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixFmtDescriptor",
      "@_refid": "structAVPixFmtDescriptor",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "desc"
   },
   {
    "type": "int",
    "declname": "x"
   },
   {
    "type": "int",
    "declname": "y"
   },
   {
    "type": "int",
    "declname": "c"
   },
   {
    "type": "int",
    "declname": "w"
   },
   {
    "type": "int",
    "declname": "read_pal_component"
   },
   {
    "type": "int",
    "declname": "dst_element_size"
   }
  ],
  "briefdescription": {
   "para": "Read a line from an image, and write the values of the pixel format component c to dst."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "the array containing the pointers to the planes of the image"
       }
      },
      {
       "parameternamelist": {
        "parametername": "linesize"
       },
       "parameterdescription": {
        "para": "the array containing the linesizes of the image"
       }
      },
      {
       "parameternamelist": {
        "parametername": "desc"
       },
       "parameterdescription": {
        "para": "the pixel format descriptor for the image"
       }
      },
      {
       "parameternamelist": {
        "parametername": "x"
       },
       "parameterdescription": {
        "para": "the horizontal coordinate of the first pixel to read"
       }
      },
      {
       "parameternamelist": {
        "parametername": "y"
       },
       "parameterdescription": {
        "para": "the vertical coordinate of the first pixel to read"
       }
      },
      {
       "parameternamelist": {
        "parametername": "w"
       },
       "parameterdescription": {
        "para": "the width of the line to read, that is the number of values to write to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "read_pal_component"
       },
       "parameterdescription": {
        "para": "if not zero and the format is a paletted format writes the values corresponding to the palette component c in data[1] to dst, rather than the palette indexes in data[0]. The behavior is undefined if the format is not paletted."
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst_element_size"
       },
       "parameterdescription": {
        "para": "size of elements in dst array (2 or 4 byte)"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "345",
   "@_column": "6",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "345",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a86f41b8d713918855424c9f7108c59d2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read a line from an image, and write the values of the\n * pixel format component c to dst.\n *\n * @param data the array containing the pointers to the planes of the image\n * @param linesize the array containing the linesizes of the image\n * @param desc the pixel format descriptor for the image\n * @param x the horizontal coordinate of the first pixel to read\n * @param y the vertical coordinate of the first pixel to read\n * @param w the width of the line to read, that is the number of\n * values to write to dst\n * @param read_pal_component if not zero and the format is a paletted\n * format writes the values corresponding to the palette\n * component c in data[1] to dst, rather than the palette indexes in\n * data[0]. The behavior is undefined if the format is not paletted.\n * @param dst_element_size size of elements in dst array (2 or 4 byte)\n */"
 },
 "av_read_image_line": {
  "type": "void",
  "definition": "void av_read_image_line",
  "argsstring": "(uint16_t *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component)",
  "name": "av_read_image_line",
  "param": [
   {
    "type": "uint16_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "data",
    "array": "[4]"
   },
   {
    "type": "const int",
    "declname": "linesize",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixFmtDescriptor",
      "@_refid": "structAVPixFmtDescriptor",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "desc"
   },
   {
    "type": "int",
    "declname": "x"
   },
   {
    "type": "int",
    "declname": "y"
   },
   {
    "type": "int",
    "declname": "c"
   },
   {
    "type": "int",
    "declname": "w"
   },
   {
    "type": "int",
    "declname": "read_pal_component"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "350",
   "@_column": "6",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "350",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a8f9e6735f65eec892931823f55280bd3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Read a line from an image, and write the values of the\n * pixel format component c to dst.\n *\n * @param data the array containing the pointers to the planes of the image\n * @param linesize the array containing the linesizes of the image\n * @param desc the pixel format descriptor for the image\n * @param x the horizontal coordinate of the first pixel to read\n * @param y the vertical coordinate of the first pixel to read\n * @param w the width of the line to read, that is the number of\n * values to write to dst\n * @param read_pal_component if not zero and the format is a paletted\n * format writes the values corresponding to the palette\n * component c in data[1] to dst, rather than the palette indexes in\n * data[0]. The behavior is undefined if the format is not paletted.\n * @param dst_element_size size of elements in dst array (2 or 4 byte)\n */"
 },
 "av_write_image_line2": {
  "type": "void",
  "definition": "void av_write_image_line2",
  "argsstring": "(const void *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int src_element_size)",
  "name": "av_write_image_line2",
  "param": [
   {
    "type": "const void *",
    "declname": "src"
   },
   {
    "type": "uint8_t *",
    "declname": "data",
    "array": "[4]"
   },
   {
    "type": "const int",
    "declname": "linesize",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixFmtDescriptor",
      "@_refid": "structAVPixFmtDescriptor",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "desc"
   },
   {
    "type": "int",
    "declname": "x"
   },
   {
    "type": "int",
    "declname": "y"
   },
   {
    "type": "int",
    "declname": "c"
   },
   {
    "type": "int",
    "declname": "w"
   },
   {
    "type": "int",
    "declname": "src_element_size"
   }
  ],
  "briefdescription": {
   "para": "Write the values from src to the pixel format component c of an image line."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "array containing the values to write"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "the array containing the pointers to the planes of the image to write into. It is supposed to be zeroed."
       }
      },
      {
       "parameternamelist": {
        "parametername": "linesize"
       },
       "parameterdescription": {
        "para": "the array containing the linesizes of the image"
       }
      },
      {
       "parameternamelist": {
        "parametername": "desc"
       },
       "parameterdescription": {
        "para": "the pixel format descriptor for the image"
       }
      },
      {
       "parameternamelist": {
        "parametername": "x"
       },
       "parameterdescription": {
        "para": "the horizontal coordinate of the first pixel to write"
       }
      },
      {
       "parameternamelist": {
        "parametername": "y"
       },
       "parameterdescription": {
        "para": "the vertical coordinate of the first pixel to write"
       }
      },
      {
       "parameternamelist": {
        "parametername": "w"
       },
       "parameterdescription": {
        "para": "the width of the line to write, that is the number of values to write to the image line"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src_element_size"
       },
       "parameterdescription": {
        "para": "size of elements in src array (2 or 4 byte)"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "369",
   "@_column": "6",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "369",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a0e53c808eaaa9985269c0ede96415dc5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write the values from src to the pixel format component c of an\n * image line.\n *\n * @param src array containing the values to write\n * @param data the array containing the pointers to the planes of the\n * image to write into. It is supposed to be zeroed.\n * @param linesize the array containing the linesizes of the image\n * @param desc the pixel format descriptor for the image\n * @param x the horizontal coordinate of the first pixel to write\n * @param y the vertical coordinate of the first pixel to write\n * @param w the width of the line to write, that is the number of\n * values to write to the image line\n * @param src_element_size size of elements in src array (2 or 4 byte)\n */"
 },
 "av_write_image_line": {
  "type": "void",
  "definition": "void av_write_image_line",
  "argsstring": "(const uint16_t *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w)",
  "name": "av_write_image_line",
  "param": [
   {
    "type": "const uint16_t *",
    "declname": "src"
   },
   {
    "type": "uint8_t *",
    "declname": "data",
    "array": "[4]"
   },
   {
    "type": "const int",
    "declname": "linesize",
    "array": "[4]"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixFmtDescriptor",
      "@_refid": "structAVPixFmtDescriptor",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "desc"
   },
   {
    "type": "int",
    "declname": "x"
   },
   {
    "type": "int",
    "declname": "y"
   },
   {
    "type": "int",
    "declname": "c"
   },
   {
    "type": "int",
    "declname": "w"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "373",
   "@_column": "6",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "373",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a899e2c005100bb2169096bb672e46310",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Write the values from src to the pixel format component c of an\n * image line.\n *\n * @param src array containing the values to write\n * @param data the array containing the pointers to the planes of the\n * image to write into. It is supposed to be zeroed.\n * @param linesize the array containing the linesizes of the image\n * @param desc the pixel format descriptor for the image\n * @param x the horizontal coordinate of the first pixel to write\n * @param y the vertical coordinate of the first pixel to write\n * @param w the width of the line to write, that is the number of\n * values to write to the image line\n * @param src_element_size size of elements in src array (2 or 4 byte)\n */"
 },
 "av_pix_fmt_swap_endianness": {
  "type": {
   "ref": {
    "#text": "AVPixelFormat",
    "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVPixelFormat av_pix_fmt_swap_endianness",
  "argsstring": "(enum AVPixelFormat pix_fmt)",
  "name": "av_pix_fmt_swap_endianness",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixelFormat",
     "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "pix_fmt"
  },
  "briefdescription": {
   "para": "Utility function to swap the endianness of a pixel format."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": {
        "#text": "pix_fmt",
        "@_direction": "in"
       }
      },
      "parameterdescription": {
       "para": "the pixel format"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "pixel format with swapped endianness if it exists, otherwise AV_PIX_FMT_NONE",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "385",
   "@_column": "19",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "385",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1ac2e098ff3b5373af99be8ea954c4f72e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Utility function to swap the endianness of a pixel format.\n *\n * @param[in]  pix_fmt the pixel format\n *\n * @return pixel format with swapped endianness if it exists,\n * otherwise AV_PIX_FMT_NONE\n */"
 },
 "av_get_pix_fmt_loss": {
  "type": "int",
  "definition": "int av_get_pix_fmt_loss",
  "argsstring": "(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt, int has_alpha)",
  "name": "av_get_pix_fmt_loss",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "dst_pix_fmt"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "src_pix_fmt"
   },
   {
    "type": "int",
    "declname": "has_alpha"
   }
  ],
  "briefdescription": {
   "para": "Compute what kind of losses will occur when converting from one specific pixel format to another."
  },
  "detaileddescription": {
   "para": [
    "When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. These losses can involve loss of chroma, but also loss of resolution, loss of color depth, loss due to the color space conversion, loss of the alpha bits or loss due to color quantization. av_get_fix_fmt_loss() informs you about the various types of losses which will occur when converting from one pixel format to another.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "dst_pix_fmt",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "destination pixel format"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "src_pix_fmt",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "source pixel format"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "has_alpha",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Whether the source pixel format alpha channel is used."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "Combination of flags informing you what kind of losses will occur (maximum loss for an invalid dst_pix_fmt).",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "415",
   "@_column": "5",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "415",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a69ba6ef97543b19a15236a513e56dffe",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Compute what kind of losses will occur when converting from one specific\n * pixel format to another.\n * When converting from one pixel format to another, information loss may occur.\n * For example, when converting from RGB24 to GRAY, the color information will\n * be lost. Similarly, other losses occur when converting from some formats to\n * other formats. These losses can involve loss of chroma, but also loss of\n * resolution, loss of color depth, loss due to the color space conversion, loss\n * of the alpha bits or loss due to color quantization.\n * av_get_fix_fmt_loss() informs you about the various types of losses\n * which will occur when converting from one pixel format to another.\n *\n * @param[in] dst_pix_fmt destination pixel format\n * @param[in] src_pix_fmt source pixel format\n * @param[in] has_alpha Whether the source pixel format alpha channel is used.\n * @return Combination of flags informing you what kind of losses will occur\n * (maximum loss for an invalid dst_pix_fmt).\n */"
 },
 "av_find_best_pix_fmt_of_2": {
  "type": {
   "ref": {
    "#text": "AVPixelFormat",
    "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVPixelFormat av_find_best_pix_fmt_of_2",
  "argsstring": "(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)",
  "name": "av_find_best_pix_fmt_of_2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "dst_pix_fmt1"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "dst_pix_fmt2"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "src_pix_fmt"
   },
   {
    "type": "int",
    "declname": "has_alpha"
   },
   {
    "type": "int *",
    "declname": "loss_ptr"
   }
  ],
  "briefdescription": {
   "para": "Compute what kind of losses will occur when converting from one specific pixel format to another."
  },
  "detaileddescription": {
   "para": [
    "When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. These losses can involve loss of chroma, but also loss of resolution, loss of color depth, loss due to the color space conversion, loss of the alpha bits or loss due to color quantization. av_get_fix_fmt_loss() informs you about the various types of losses which will occur when converting from one pixel format to another.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "dst_pix_fmt",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "destination pixel format"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "src_pix_fmt",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "source pixel format"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "has_alpha",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Whether the source pixel format alpha channel is used."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "Combination of flags informing you what kind of losses will occur (maximum loss for an invalid dst_pix_fmt).",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixdesc.h",
   "@_line": "437",
   "@_column": "19",
   "@_declfile": "libavutil/pixdesc.h",
   "@_declline": "437",
   "@_declcolumn": "19"
  },
  "@_kind": "function",
  "@_id": "pixdesc_8h_1a875f1e7a15d882d4cd9d38dde093939b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Compute what kind of losses will occur when converting from one specific\n * pixel format to another.\n * When converting from one pixel format to another, information loss may occur.\n * For example, when converting from RGB24 to GRAY, the color information will\n * be lost. Similarly, other losses occur when converting from some formats to\n * other formats. These losses can involve loss of chroma, but also loss of\n * resolution, loss of color depth, loss due to the color space conversion, loss\n * of the alpha bits or loss due to color quantization.\n * av_get_fix_fmt_loss() informs you about the various types of losses\n * which will occur when converting from one pixel format to another.\n *\n * @param[in] dst_pix_fmt destination pixel format\n * @param[in] src_pix_fmt source pixel format\n * @param[in] has_alpha Whether the source pixel format alpha channel is used.\n * @return Combination of flags informing you what kind of losses will occur\n * (maximum loss for an invalid dst_pix_fmt).\n */"
 },
 "av_pixelutils_sad_fn": {
  "type": "int(*",
  "definition": "typedef int(* av_pixelutils_sad_fn) (const uint8_t *src1, ptrdiff_t stride1, const uint8_t *src2, ptrdiff_t stride2)",
  "argsstring": ")(const uint8_t *src1, ptrdiff_t stride1, const uint8_t *src2, ptrdiff_t stride2)",
  "name": "av_pixelutils_sad_fn",
  "briefdescription": {
   "para": "Sum of abs(src1[x] - src2[x])"
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixelutils.h",
   "@_line": "28",
   "@_column": "9",
   "@_bodyfile": "libavutil/pixelutils.h",
   "@_bodystart": "28",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "pixelutils_8h_1a3a4a3c90f13bcd5d2ae2cfa28c892a57",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Sum of abs(src1[x] - src2[x])\n */"
 },
 "av_pixelutils_get_sad_fn": {
  "type": {
   "ref": {
    "#text": "av_pixelutils_sad_fn",
    "@_refid": "pixelutils_8h_1a3a4a3c90f13bcd5d2ae2cfa28c892a57",
    "@_kindref": "member"
   }
  },
  "definition": "av_pixelutils_sad_fn av_pixelutils_get_sad_fn",
  "argsstring": "(int w_bits, int h_bits, int aligned, void *log_ctx)",
  "name": "av_pixelutils_get_sad_fn",
  "param": [
   {
    "type": "int",
    "declname": "w_bits"
   },
   {
    "type": "int",
    "declname": "h_bits"
   },
   {
    "type": "int",
    "declname": "aligned"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Get a potentially optimized pointer to a Sum-of-absolute-differences function (see the av_pixelutils_sad_fn prototype)."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "w_bits"
       },
       "parameterdescription": {
        "para": "1<<w_bits is the requested width of the block size"
       }
      },
      {
       "parameternamelist": {
        "parametername": "h_bits"
       },
       "parameterdescription": {
        "para": "1<<h_bits is the requested height of the block size"
       }
      },
      {
       "parameternamelist": {
        "parametername": "aligned"
       },
       "parameterdescription": {
        "para": "If set to 2, the returned sad function will assume src1 and src2 addresses are aligned on the block size. If set to 1, the returned sad function will assume src1 is aligned on the block size. If set to 0, the returned sad function assume no particular alignment."
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_ctx"
       },
       "parameterdescription": {
        "para": "context used for logging, can be NULL"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "a pointer to the SAD function or NULL in case of error (because of invalid parameters)",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/pixelutils.h",
   "@_line": "48",
   "@_column": "22",
   "@_declfile": "libavutil/pixelutils.h",
   "@_declline": "48",
   "@_declcolumn": "22"
  },
  "@_kind": "function",
  "@_id": "pixelutils_8h_1ace06a5d0938728661c6416babe1ee0a9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a potentially optimized pointer to a Sum-of-absolute-differences\n * function (see the av_pixelutils_sad_fn prototype).\n *\n * @param w_bits  1<<w_bits is the requested width of the block size\n * @param h_bits  1<<h_bits is the requested height of the block size\n * @param aligned If set to 2, the returned sad function will assume src1 and\n *                src2 addresses are aligned on the block size.\n *                If set to 1, the returned sad function will assume src1 is\n *                aligned on the block size.\n *                If set to 0, the returned sad function assume no particular\n *                alignment.\n * @param log_ctx context used for logging, can be NULL\n *\n * @return a pointer to the SAD function or NULL in case of error (because of\n *         invalid parameters)\n */"
 },
 "av_qsv_alloc_context": {
  "type": {
   "ref": {
    "#text": "AVQSVContext",
    "@_refid": "structAVQSVContext",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVQSVContext * av_qsv_alloc_context",
  "argsstring": "(void)",
  "name": "av_qsv_alloc_context",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate a new context."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "av_free()",
     "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
     "@_kindref": "member"
    },
    "#text": "It must be freed by the caller with."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/qsv.h",
   "@_line": "107",
   "@_column": "14",
   "@_declfile": "libavcodec/qsv.h",
   "@_declline": "107",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "qsv_8h_1a37324c2ff1ceeb47fcf1048fde8dd4fd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a new context.\n *\n * It must be freed by the caller with av_free().\n */"
 },
 "av_get_random_seed": {
  "type": "uint32_t",
  "definition": "uint32_t av_get_random_seed",
  "argsstring": "(void)",
  "name": "av_get_random_seed",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Get a seed to use in conjunction with random functions."
  },
  "detaileddescription": {
   "para": "This function tries to provide a good seed at a best effort bases. Its possible to call this function multiple times if more bits are needed. It can be quite slow, which is why it should only be used as seed for a faster PRNG. The quality of the seed depends on the platform."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/random_seed.h",
   "@_line": "38",
   "@_column": "10",
   "@_declfile": "libavutil/random_seed.h",
   "@_declline": "38",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavu__crypto_1ga4fe662789c7e05a6b63e0c675dbbd7ed",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get a seed to use in conjunction with random functions.\n * This function tries to provide a good seed at a best effort bases.\n * Its possible to call this function multiple times if more bits are needed.\n * It can be quite slow, which is why it should only be used as seed for a faster\n * PRNG. The quality of the seed depends on the platform.\n */"
 },
 "av_random_bytes": {
  "type": "int",
  "definition": "int av_random_bytes",
  "argsstring": "(uint8_t *buf, size_t len)",
  "name": "av_random_bytes",
  "param": [
   {
    "type": "uint8_t *",
    "declname": "buf"
   },
   {
    "type": "size_t",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Generate cryptographically secure random data, i.e."
  },
  "detaileddescription": {
   "para": [
    "suitable for use as encryption keys and similar.",
    {
     "parameterlist": [
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": "buf"
         },
         "parameterdescription": {
          "para": "buffer into which the random data will be written"
         }
        },
        {
         "parameternamelist": {
          "parametername": "len"
         },
         "parameterdescription": {
          "para": "size of buf in bytes"
         }
        }
       ],
       "@_kind": "param"
      },
      {
       "parameteritem": [
        {
         "parameternamelist": {
          "parametername": 0
         },
         "parameterdescription": {
          "para": "success, len bytes of random data was written into buf"
         }
        },
        {
         "parameternamelist": {
          "parametername": "a negative AVERROR code"
         },
         "parameterdescription": {
          "para": "random data could not be generated"
         }
        }
       ],
       "@_kind": "retval"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/random_seed.h",
   "@_line": "51",
   "@_column": "5",
   "@_declfile": "libavutil/random_seed.h",
   "@_declline": "51",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__crypto_1ga89e2cb187d82a2d3b7e4103c77c1d67c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Generate cryptographically secure random data, i.e. suitable for use as\n * encryption keys and similar.\n *\n * @param buf buffer into which the random data will be written\n * @param len size of buf in bytes\n *\n * @retval 0                         success, len bytes of random data was written\n *                                   into buf\n * @retval \"a negative AVERROR code\" random data could not be generated\n */"
 },
 "av_make_q": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "static AVRational av_make_q",
  "argsstring": "(int num, int den)",
  "name": "av_make_q",
  "param": [
   {
    "type": "int",
    "declname": "num"
   },
   {
    "type": "int",
    "declname": "den"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVRational",
     "@_refid": "structAVRational",
     "@_kindref": "compound"
    },
    "#text": "Create an."
   }
  },
  "detaileddescription": {
   "para": [
    "Useful for compilers that do not support compound literals.",
    {
     "simplesect": [
      {
       "para": "The return value is not reduced.",
       "@_kind": "note"
      },
      {
       "para": {
        "ref": {
         "#text": "av_reduce()",
         "@_refid": "group__lavu__math__rational_1ga4fd9c0b8e663cf3d55e89fbc6ce71602",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "71",
   "@_column": "26",
   "@_bodyfile": "libavutil/rational.h",
   "@_bodystart": "71",
   "@_bodyend": "75"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1ga7778b1d209ceb3e4bf34e40150d3b882",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Create an AVRational.\n *\n * Useful for compilers that do not support compound literals.\n *\n * @note The return value is not reduced.\n * @see av_reduce()\n */"
 },
 "av_cmp_q": {
  "type": "int",
  "definition": "static int av_cmp_q",
  "argsstring": "(AVRational a, AVRational b)",
  "name": "av_cmp_q",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "a"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "b"
   }
  ],
  "briefdescription": {
   "para": "Compare two rationals."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "a"
       },
       "parameterdescription": {
        "para": "First rational"
       }
      },
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "Second rational"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "itemizedlist": {
       "listitem": [
        {
         "para": {
          "computeroutput": "a == b",
          "#text": "0 if"
         }
        },
        {
         "para": {
          "computeroutput": "a > b",
          "#text": "1 if"
         }
        },
        {
         "para": {
          "computeroutput": "a < b",
          "#text": "-1 if"
         }
        },
        {
         "para": {
          "computeroutput": [
           "INT_MIN",
           "0 / 0"
          ],
          "#text": "if one of the values is of the form"
         }
        }
       ]
      },
      "#text": "One of the following values:"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "89",
   "@_column": "19",
   "@_bodyfile": "libavutil/rational.h",
   "@_bodystart": "89",
   "@_bodyend": "96"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1gaa440bf42ede128219a571ae4ce0f90b8",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Compare two rationals.\n *\n * @param a First rational\n * @param b Second rational\n *\n * @return One of the following values:\n *         - 0 if `a == b`\n *         - 1 if `a > b`\n *         - -1 if `a < b`\n *         - `INT_MIN` if one of the values is of the form `0 / 0`\n */"
 },
 "av_q2d": {
  "type": "double",
  "definition": "static double av_q2d",
  "argsstring": "(AVRational a)",
  "name": "av_q2d",
  "param": {
   "type": {
    "ref": {
     "#text": "AVRational",
     "@_refid": "structAVRational",
     "@_kindref": "compound"
    }
   },
   "declname": "a"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVRational",
     "@_refid": "structAVRational",
     "@_kindref": "compound"
    },
    "computeroutput": "double",
    "#text": "Convert anto a."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "a"
      },
      "parameterdescription": {
       "para": {
        "ref": {
         "#text": "AVRational",
         "@_refid": "structAVRational",
         "@_kindref": "compound"
        },
        "#text": "to convert"
       }
      }
     },
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": {
       "computeroutput": "a",
       "#text": "in floating-point form"
      },
      "@_kind": "return"
     },
     {
      "para": {
       "ref": {
        "#text": "av_d2q()",
        "@_refid": "group__lavu__math__rational_1ga7dfd5ba1eb1edf5845ac32b338de9e76",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "104",
   "@_column": "22",
   "@_bodyfile": "libavutil/rational.h",
   "@_bodystart": "104",
   "@_bodyend": "106"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1ga935dbbf6bde8dfe5fa7ddb1da582eb07",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert an AVRational to a `double`.\n * @param a AVRational to convert\n * @return `a` in floating-point form\n * @see av_d2q()\n */"
 },
 "av_reduce": {
  "type": "int",
  "definition": "int av_reduce",
  "argsstring": "(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)",
  "name": "av_reduce",
  "param": [
   {
    "type": "int *",
    "declname": "dst_num"
   },
   {
    "type": "int *",
    "declname": "dst_den"
   },
   {
    "type": "int64_t",
    "declname": "num"
   },
   {
    "type": "int64_t",
    "declname": "den"
   },
   {
    "type": "int64_t",
    "declname": "max"
   }
  ],
  "briefdescription": {
   "para": "Reduce a fraction."
  },
  "detaileddescription": {
   "para": [
    "This is useful for framerate calculations.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "dst_num",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "Destination numerator"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "dst_den",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "Destination denominator"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "num",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Source numerator"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "den",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Source denominator"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "max",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": [
           "dst_num",
           "dst_den"
          ],
          "#text": "Maximum allowed values for&"
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "1 if the operation is exact, 0 otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "120",
   "@_column": "5",
   "@_declfile": "libavutil/rational.h",
   "@_declline": "120",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1ga4fd9c0b8e663cf3d55e89fbc6ce71602",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Reduce a fraction.\n *\n * This is useful for framerate calculations.\n *\n * @param[out] dst_num Destination numerator\n * @param[out] dst_den Destination denominator\n * @param[in]      num Source numerator\n * @param[in]      den Source denominator\n * @param[in]      max Maximum allowed values for `dst_num` & `dst_den`\n * @return 1 if the operation is exact, 0 otherwise\n */"
 },
 "av_mul_q": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_mul_q",
  "argsstring": "(AVRational b, AVRational c) av_const",
  "name": "av_mul_q",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "b"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "c"
   }
  ],
  "briefdescription": {
   "para": "Multiply two rationals."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "First rational"
       }
      },
      {
       "parameternamelist": {
        "parametername": "c"
       },
       "parameterdescription": {
        "para": "Second rational"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "b*c",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "128",
   "@_column": "12",
   "@_declfile": "libavutil/rational.h",
   "@_declline": "128",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1ga3f9c69432582e2857147bcba3c75dc32",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Multiply two rationals.\n * @param b First rational\n * @param c Second rational\n * @return b*c\n */"
 },
 "av_div_q": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_div_q",
  "argsstring": "(AVRational b, AVRational c) av_const",
  "name": "av_div_q",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "b"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "c"
   }
  ],
  "briefdescription": {
   "para": "Divide one rational by another."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "First rational"
       }
      },
      {
       "parameternamelist": {
        "parametername": "c"
       },
       "parameterdescription": {
        "para": "Second rational"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "b/c",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "136",
   "@_column": "12",
   "@_declfile": "libavutil/rational.h",
   "@_declline": "136",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1gaffa24e7bd38e12dbac540d8b66461f97",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Divide one rational by another.\n * @param b First rational\n * @param c Second rational\n * @return b/c\n */"
 },
 "av_add_q": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_add_q",
  "argsstring": "(AVRational b, AVRational c) av_const",
  "name": "av_add_q",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "b"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "c"
   }
  ],
  "briefdescription": {
   "para": "Add two rationals."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "First rational"
       }
      },
      {
       "parameternamelist": {
        "parametername": "c"
       },
       "parameterdescription": {
        "para": "Second rational"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "b+c",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "144",
   "@_column": "12",
   "@_declfile": "libavutil/rational.h",
   "@_declline": "144",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1ga2eb3a275aabacd8421f140a12bab4a91",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Add two rationals.\n * @param b First rational\n * @param c Second rational\n * @return b+c\n */"
 },
 "av_sub_q": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_sub_q",
  "argsstring": "(AVRational b, AVRational c) av_const",
  "name": "av_sub_q",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "b"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "c"
   }
  ],
  "briefdescription": {
   "para": "Subtract one rational from another."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "b"
       },
       "parameterdescription": {
        "para": "First rational"
       }
      },
      {
       "parameternamelist": {
        "parametername": "c"
       },
       "parameterdescription": {
        "para": "Second rational"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "b-c",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "152",
   "@_column": "12",
   "@_declfile": "libavutil/rational.h",
   "@_declline": "152",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1gac66c6198ce5e8a8caf88dfc20782fa59",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Subtract one rational from another.\n * @param b First rational\n * @param c Second rational\n * @return b-c\n */"
 },
 "av_inv_q": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "AVRational",
     "@_refid": "structAVRational",
     "@_kindref": "compound"
    }
   ]
  },
  "definition": "static av_always_inline AVRational av_inv_q",
  "argsstring": "(AVRational q)",
  "name": "av_inv_q",
  "param": {
   "type": {
    "ref": {
     "#text": "AVRational",
     "@_refid": "structAVRational",
     "@_kindref": "compound"
    }
   },
   "declname": "q"
  },
  "briefdescription": {
   "para": "Invert a rational."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "q"
      },
      "parameterdescription": {
       "para": "value"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "1 / q",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "159",
   "@_column": "36",
   "@_bodyfile": "libavutil/rational.h",
   "@_bodystart": "159",
   "@_bodyend": "163"
  },
  "referencedby": {
   "#text": "open_output_file",
   "@_refid": "transcode_8c_1ab6c33edf9a42e2f71594a7cdc6276407",
   "@_compoundref": "transcode_8c",
   "@_startline": "128",
   "@_endline": "242"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1gab646f0a7cc30af543ba4a91b37f9de6e",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Invert a rational.\n * @param q value\n * @return 1 / q\n */"
 },
 "av_d2q": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_d2q",
  "argsstring": "(double d, int max) av_const",
  "name": "av_d2q",
  "param": [
   {
    "type": "double",
    "declname": "d"
   },
   {
    "type": "int",
    "declname": "max"
   }
  ],
  "briefdescription": {
   "para": "Convert a double precision floating point number to a rational."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": [
      "{1, 0}",
      "{-1, 0}"
     ],
     "#text": "In case of infinity, the returned value is expressed asordepending on the sign."
    },
    "In general rational numbers with |num| <= 1<<26 && |den| <= 1<<26 can be recovered exactly from their double representation. (no exceptions were found within 1B random ones)",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "d"
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "double",
          "#text": "to convert"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "max"
        },
        "parameterdescription": {
         "para": "Maximum allowed numerator and denominator"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "computeroutput": "d",
        "ref": {
         "#text": "AVRational",
         "@_refid": "structAVRational",
         "@_kindref": "compound"
        },
        "#text": "inform"
       },
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_q2d()",
         "@_refid": "group__lavu__math__rational_1ga935dbbf6bde8dfe5fa7ddb1da582eb07",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "180",
   "@_column": "12",
   "@_declfile": "libavutil/rational.h",
   "@_declline": "180",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1ga7dfd5ba1eb1edf5845ac32b338de9e76",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert a double precision floating point number to a rational.\n *\n * In case of infinity, the returned value is expressed as `{1, 0}` or\n * `{-1, 0}` depending on the sign.\n *\n * In general rational numbers with |num| <= 1<<26 && |den| <= 1<<26\n * can be recovered exactly from their double representation.\n * (no exceptions were found within 1B random ones)\n *\n * @param d   `double` to convert\n * @param max Maximum allowed numerator and denominator\n * @return `d` in AVRational form\n * @see av_q2d()\n */"
 },
 "av_nearer_q": {
  "type": "int",
  "definition": "int av_nearer_q",
  "argsstring": "(AVRational q, AVRational q1, AVRational q2)",
  "name": "av_nearer_q",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "q"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "q1"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "q2"
   }
  ],
  "briefdescription": {
   "para": "Find which of the two rationals is closer to another rational."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "q"
       },
       "parameterdescription": {
        "para": "Rational to be compared against"
       }
      },
      {
       "parameternamelist": {
        "parametername": "q1"
       },
       "parameterdescription": {
        "para": "Rational to be tested"
       }
      },
      {
       "parameternamelist": {
        "parametername": "q2"
       },
       "parameterdescription": {
        "para": "Rational to be tested"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "itemizedlist": {
       "listitem": [
        {
         "para": {
          "computeroutput": [
           "q1",
           "q",
           "q2"
          ],
          "#text": "1 ifis nearer tothan"
         }
        },
        {
         "para": {
          "computeroutput": [
           "q2",
           "q",
           "q1"
          ],
          "#text": "-1 ifis nearer tothan"
         }
        },
        {
         "para": "0 if they have the same distance"
        }
       ]
      },
      "#text": "One of the following values:"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "193",
   "@_column": "5",
   "@_declfile": "libavutil/rational.h",
   "@_declline": "193",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1ga111810c563749cd3081aaa19004f44df",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find which of the two rationals is closer to another rational.\n *\n * @param q     Rational to be compared against\n * @param q1    Rational to be tested\n * @param q2    Rational to be tested\n * @return One of the following values:\n *         - 1 if `q1` is nearer to `q` than `q2`\n *         - -1 if `q2` is nearer to `q` than `q1`\n *         - 0 if they have the same distance\n */"
 },
 "av_find_nearest_q_idx": {
  "type": "int",
  "definition": "int av_find_nearest_q_idx",
  "argsstring": "(AVRational q, const AVRational *q_list)",
  "name": "av_find_nearest_q_idx",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "q"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "q_list"
   }
  ],
  "briefdescription": {
   "para": "Find the value in a list of rationals nearest a given reference rational."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "q"
       },
       "parameterdescription": {
        "para": "Reference rational"
       }
      },
      {
       "parameternamelist": {
        "parametername": "q_list"
       },
       "parameterdescription": {
        "para": {
         "computeroutput": "{0, 0}",
         "#text": "Array of rationals terminated by"
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "Index of the nearest value found in the array",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "202",
   "@_column": "5",
   "@_declfile": "libavutil/rational.h",
   "@_declline": "202",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1ga63d5ef1c2f77a5fdccb2b3a1c8cc77f5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find the value in a list of rationals nearest a given reference rational.\n *\n * @param q      Reference rational\n * @param q_list Array of rationals terminated by `{0, 0}`\n * @return Index of the nearest value found in the array\n */"
 },
 "av_q2intfloat": {
  "type": "uint32_t",
  "definition": "uint32_t av_q2intfloat",
  "argsstring": "(AVRational q)",
  "name": "av_q2intfloat",
  "param": {
   "type": {
    "ref": {
     "#text": "AVRational",
     "@_refid": "structAVRational",
     "@_kindref": "compound"
    }
   },
   "declname": "q"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVRational",
     "@_refid": "structAVRational",
     "@_kindref": "compound"
    },
    "computeroutput": "float",
    "#text": "Convert anto a IEEE 32-bitexpressed in fixed-point format."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "q"
      },
      "parameterdescription": {
       "para": "Rational to be converted"
      }
     },
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "Equivalent floating-point value, expressed as an unsigned 32-bit integer.",
      "@_kind": "return"
     },
     {
      "para": "The returned value is platform-indepedant.",
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "213",
   "@_column": "10",
   "@_declfile": "libavutil/rational.h",
   "@_declline": "213",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1gafbcd96878344ade957d5bccc6bc705b2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point\n * format.\n *\n * @param q Rational to be converted\n * @return Equivalent floating-point value, expressed as an unsigned 32-bit\n *         integer.\n * @note The returned value is platform-indepedant.\n */"
 },
 "av_gcd_q": {
  "type": {
   "ref": {
    "#text": "AVRational",
    "@_refid": "structAVRational",
    "@_kindref": "compound"
   }
  },
  "definition": "AVRational av_gcd_q",
  "argsstring": "(AVRational a, AVRational b, int max_den, AVRational def)",
  "name": "av_gcd_q",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "a"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "b"
   },
   {
    "type": "int",
    "declname": "max_den"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "def"
   }
  ],
  "briefdescription": {
   "para": "Return the best rational so that a and b are multiple of it."
  },
  "detaileddescription": {
   "para": "If the resulting denominator is larger than max_den, return def."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rational.h",
   "@_line": "219",
   "@_column": "12",
   "@_declfile": "libavutil/rational.h",
   "@_declline": "219",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__math__rational_1ga699c7d603ff3cf185bf1f846e0707b7d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the best rational so that a and b are multiple of it.\n * If the resulting denominator is larger than max_den, return def.\n */"
 },
 "av_rc4_alloc": {
  "type": {
   "ref": {
    "#text": "AVRC4",
    "@_refid": "structAVRC4",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVRC4 * av_rc4_alloc",
  "argsstring": "(void)",
  "name": "av_rc4_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVRC4",
     "@_refid": "structAVRC4",
     "@_kindref": "compound"
    },
    "#text": "Allocate ancontext."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rc4.h",
   "@_line": "40",
   "@_column": "7",
   "@_declfile": "libavutil/rc4.h",
   "@_declline": "40",
   "@_declcolumn": "7"
  },
  "@_kind": "function",
  "@_id": "group__lavu__rc4_1gaa7749ea2b449eb96cca3a49f92ca9f41",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVRC4 context.\n */"
 },
 "av_rc4_init": {
  "type": "int",
  "definition": "int av_rc4_init",
  "argsstring": "(struct AVRC4 *d, const uint8_t *key, int key_bits, int decrypt)",
  "name": "av_rc4_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRC4",
      "@_refid": "structAVRC4",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "d"
   },
   {
    "type": "const uint8_t *",
    "declname": "key"
   },
   {
    "type": "int",
    "declname": "key_bits"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVRC4",
     "@_refid": "structAVRC4",
     "@_kindref": "compound"
    },
    "#text": "Initializes ancontext."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "d"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVRC4",
          "@_refid": "structAVRC4",
          "@_kindref": "compound"
         },
         "#text": "pointer to thecontext"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "buffer containig the key"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key_bits"
       },
       "parameterdescription": {
        "para": "must be a multiple of 8"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption, currently has no effect"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "zero on success, negative value otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rc4.h",
   "@_line": "51",
   "@_column": "5",
   "@_declfile": "libavutil/rc4.h",
   "@_declline": "51",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__rc4_1ga2afd06d2962795cc240cde5c18c0d7f9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @brief Initializes an AVRC4 context.\n *\n * @param d pointer to the AVRC4 context\n * @param key buffer containig the key\n * @param key_bits must be a multiple of 8\n * @param decrypt 0 for encryption, 1 for decryption, currently has no effect\n * @return zero on success, negative value otherwise\n */"
 },
 "av_rc4_crypt": {
  "type": "void",
  "definition": "void av_rc4_crypt",
  "argsstring": "(struct AVRC4 *d, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt)",
  "name": "av_rc4_crypt",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRC4",
      "@_refid": "structAVRC4",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "d"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "uint8_t *",
    "declname": "iv"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypts / decrypts using the RC4 algorithm."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "d"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVRC4",
          "@_refid": "structAVRC4",
          "@_kindref": "compound"
         },
         "#text": "pointer to thecontext"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of bytes"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst, may be NULL"
       }
      },
      {
       "parameternamelist": {
        "parametername": "iv"
       },
       "parameterdescription": {
        "para": "not (yet) used for RC4, should be NULL"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption, not (yet) used"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/rc4.h",
   "@_line": "63",
   "@_column": "6",
   "@_declfile": "libavutil/rc4.h",
   "@_declline": "63",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__rc4_1gadb5dd2b518df0e71479b52310e16c5ad",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @brief Encrypts / decrypts using the RC4 algorithm.\n *\n * @param d pointer to the AVRC4 context\n * @param count number of bytes\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst, may be NULL\n * @param iv not (yet) used for RC4, should be NULL\n * @param decrypt 0 for encryption, 1 for decryption, not (yet) used\n */"
 },
 "av_ripemd_size": {
  "type": "const int",
  "definition": "const int av_ripemd_size",
  "argsstring": "",
  "name": "av_ripemd_size",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/ripemd.h",
   "@_line": "44",
   "@_column": "18",
   "@_declfile": "libavutil/ripemd.h",
   "@_declline": "44",
   "@_declcolumn": "18"
  },
  "@_kind": "variable",
  "@_id": "group__lavu__ripemd_1gad5e60759f7ece82caf50ea4e8623649c",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * @defgroup lavu_ripemd RIPEMD\n * @ingroup lavu_hash\n * RIPEMD hash function implementation.\n *\n * @{\n */"
 },
 "av_ripemd_alloc": {
  "type": "struct AVRIPEMD *",
  "definition": "struct AVRIPEMD * av_ripemd_alloc",
  "argsstring": "(void)",
  "name": "av_ripemd_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVRIPEMD context."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/ripemd.h",
   "@_line": "51",
   "@_column": "15",
   "@_declfile": "libavutil/ripemd.h",
   "@_declline": "51",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavu__ripemd_1gace81c9f726f8dc8fed0cae3588b3ff24",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVRIPEMD context.\n */"
 },
 "av_ripemd_init": {
  "type": "int",
  "definition": "int av_ripemd_init",
  "argsstring": "(struct AVRIPEMD *context, int bits)",
  "name": "av_ripemd_init",
  "param": [
   {
    "type": "struct AVRIPEMD *",
    "declname": "context"
   },
   {
    "type": "int",
    "declname": "bits"
   }
  ],
  "briefdescription": {
   "para": "Initialize RIPEMD hashing."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "context"
       },
       "parameterdescription": {
        "para": "pointer to the function context (of size av_ripemd_size)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "bits"
       },
       "parameterdescription": {
        "para": "number of bits in digest (128, 160, 256 or 320 bits)"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "zero if initialization succeeded, -1 otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/ripemd.h",
   "@_line": "60",
   "@_column": "5",
   "@_declfile": "libavutil/ripemd.h",
   "@_declline": "60",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__ripemd_1ga4629925d978ee6975daecfad6921b799",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize RIPEMD hashing.\n *\n * @param context pointer to the function context (of size av_ripemd_size)\n * @param bits    number of bits in digest (128, 160, 256 or 320 bits)\n * @return        zero if initialization succeeded, -1 otherwise\n */"
 },
 "av_ripemd_update": {
  "type": "void",
  "definition": "void av_ripemd_update",
  "argsstring": "(struct AVRIPEMD *context, const uint8_t *data, size_t len)",
  "name": "av_ripemd_update",
  "param": [
   {
    "type": "struct AVRIPEMD *",
    "declname": "context"
   },
   {
    "type": "const uint8_t *",
    "declname": "data"
   },
   {
    "type": "size_t",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Update hash value."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "context"
       },
       "parameterdescription": {
        "para": "hash function context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "input data to update hash with"
       }
      },
      {
       "parameternamelist": {
        "parametername": "len"
       },
       "parameterdescription": {
        "para": "input data length"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/ripemd.h",
   "@_line": "69",
   "@_column": "6",
   "@_declfile": "libavutil/ripemd.h",
   "@_declline": "69",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__ripemd_1gaa3505fa3911fc9da02b1306654e93623",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Update hash value.\n *\n * @param context hash function context\n * @param data    input data to update hash with\n * @param len     input data length\n */"
 },
 "av_ripemd_final": {
  "type": "void",
  "definition": "void av_ripemd_final",
  "argsstring": "(struct AVRIPEMD *context, uint8_t *digest)",
  "name": "av_ripemd_final",
  "param": [
   {
    "type": "struct AVRIPEMD *",
    "declname": "context"
   },
   {
    "type": "uint8_t *",
    "declname": "digest"
   }
  ],
  "briefdescription": {
   "para": "Finish hashing and output digest value."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "context"
       },
       "parameterdescription": {
        "para": "hash function context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "digest"
       },
       "parameterdescription": {
        "para": "buffer where output digest value is stored"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/ripemd.h",
   "@_line": "77",
   "@_column": "6",
   "@_declfile": "libavutil/ripemd.h",
   "@_declline": "77",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__ripemd_1ga10a142f6a13c54e0b12e29eb6bcd75be",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finish hashing and output digest value.\n *\n * @param context hash function context\n * @param digest  buffer where output digest value is stored\n */"
 },
 "av_get_sample_fmt_name": {
  "type": "const char *",
  "definition": "const char * av_get_sample_fmt_name",
  "argsstring": "(enum AVSampleFormat sample_fmt)",
  "name": "av_get_sample_fmt_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVSampleFormat",
     "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "sample_fmt"
  },
  "briefdescription": {
   "para": "Return the name of sample_fmt, or NULL if sample_fmt is not recognized."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "78",
   "@_column": "12",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "78",
   "@_declcolumn": "12"
  },
  "referencedby": [
   {
    "#text": "get_format_from_sample_fmt",
    "@_refid": "decode__audio_8c_1a5e068fc5e6dc5c59638ec235f7f6db89",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "43",
    "@_endline": "70"
   },
   {
    "#text": "init_filter",
    "@_refid": "transcode_8c_1a54ad76df48ef886861a2f12bc7a9e7e4",
    "@_compoundref": "transcode_8c",
    "@_startline": "244",
    "@_endline": "392"
   },
   {
    "#text": "init_filter_graph",
    "@_refid": "filter__audio_8c_1a73cf1c341378e03c975e1f9f03a71870",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "60",
    "@_endline": "208"
   },
   {
    "#text": "init_filters",
    "@_refid": "decode__filter__audio_8c_1ac25a104c80c6a7d21fb06a438a6965ba",
    "@_compoundref": "decode__filter__audio_8c",
    "@_startline": "90",
    "@_endline": "201"
   },
   {
    "#text": "main",
    "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "106",
    "@_endline": "237"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__sampfmts_1gadc5fce5ceabec01026645c7c160ca82f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the name of sample_fmt, or NULL if sample_fmt is not\n * recognized.\n */"
 },
 "av_get_sample_fmt": {
  "type": {
   "ref": {
    "#text": "AVSampleFormat",
    "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVSampleFormat av_get_sample_fmt",
  "argsstring": "(const char *name)",
  "name": "av_get_sample_fmt",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": {
   "para": "Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE on error."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "84",
   "@_column": "20",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "84",
   "@_declcolumn": "20"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sampfmts_1ga655c989b749667468e5e839e26fe63db",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE\n * on error.\n */"
 },
 "av_get_alt_sample_fmt": {
  "type": {
   "ref": {
    "#text": "AVSampleFormat",
    "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVSampleFormat av_get_alt_sample_fmt",
  "argsstring": "(enum AVSampleFormat sample_fmt, int planar)",
  "name": "av_get_alt_sample_fmt",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "sample_fmt"
   },
   {
    "type": "int",
    "declname": "planar"
   }
  ],
  "briefdescription": {
   "para": "Return the planar<->packed alternative form of the given sample format, or AV_SAMPLE_FMT_NONE on error."
  },
  "detaileddescription": {
   "para": "If the passed sample_fmt is already in the requested planar/packed format, the format returned is the same as the input."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "92",
   "@_column": "20",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "92",
   "@_declcolumn": "20"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sampfmts_1ga8e66c3f813ea02afcaa56a8a964c749a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the planar<->packed alternative form of the given sample format, or\n * AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the\n * requested planar/packed format, the format returned is the same as the\n * input.\n */"
 },
 "av_get_packed_sample_fmt": {
  "type": {
   "ref": {
    "#text": "AVSampleFormat",
    "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVSampleFormat av_get_packed_sample_fmt",
  "argsstring": "(enum AVSampleFormat sample_fmt)",
  "name": "av_get_packed_sample_fmt",
  "param": {
   "type": {
    "ref": {
     "#text": "AVSampleFormat",
     "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "sample_fmt"
  },
  "briefdescription": {
   "para": "Get the packed alternative form of the given sample format."
  },
  "detaileddescription": {
   "para": [
    "If the passed sample_fmt is already in packed format, the format returned is the same as the input.",
    {
     "simplesect": {
      "para": "the packed alternative form of the given sample format or AV_SAMPLE_FMT_NONE on error.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "103",
   "@_column": "20",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "103",
   "@_declcolumn": "20"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "decode__audio_8c",
   "@_startline": "106",
   "@_endline": "237"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sampfmts_1ga7817ec0eff4dc6fc0962f31e6d138bca",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the packed alternative form of the given sample format.\n *\n * If the passed sample_fmt is already in packed format, the format returned is\n * the same as the input.\n *\n * @return  the packed alternative form of the given sample format or\n            AV_SAMPLE_FMT_NONE on error.\n */"
 },
 "av_get_planar_sample_fmt": {
  "type": {
   "ref": {
    "#text": "AVSampleFormat",
    "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
    "@_kindref": "member"
   },
   "#text": "enum"
  },
  "definition": "enum AVSampleFormat av_get_planar_sample_fmt",
  "argsstring": "(enum AVSampleFormat sample_fmt)",
  "name": "av_get_planar_sample_fmt",
  "param": {
   "type": {
    "ref": {
     "#text": "AVSampleFormat",
     "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "sample_fmt"
  },
  "briefdescription": {
   "para": "Get the planar alternative form of the given sample format."
  },
  "detaileddescription": {
   "para": [
    "If the passed sample_fmt is already in planar format, the format returned is the same as the input.",
    {
     "simplesect": {
      "para": "the planar alternative form of the given sample format or AV_SAMPLE_FMT_NONE on error.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "114",
   "@_column": "20",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "114",
   "@_declcolumn": "20"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sampfmts_1ga82caf838259d95cc6c4fd87633bb0e19",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the planar alternative form of the given sample format.\n *\n * If the passed sample_fmt is already in planar format, the format returned is\n * the same as the input.\n *\n * @return  the planar alternative form of the given sample format or\n            AV_SAMPLE_FMT_NONE on error.\n */"
 },
 "av_get_sample_fmt_string": {
  "type": "char *",
  "definition": "char * av_get_sample_fmt_string",
  "argsstring": "(char *buf, int buf_size, enum AVSampleFormat sample_fmt)",
  "name": "av_get_sample_fmt_string",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buf_size"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "sample_fmt"
   }
  ],
  "briefdescription": {
   "para": "Generate a string corresponding to the sample format with sample_fmt, or a header if sample_fmt is negative."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "the buffer where to write the string"
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf_size"
       },
       "parameterdescription": {
        "para": "the size of buf"
       }
      },
      {
       "parameternamelist": {
        "parametername": "sample_fmt"
       },
       "parameterdescription": {
        "para": "the number of the sample format to print the corresponding info string, or a negative value to print the corresponding header."
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the pointer to the filled buffer or NULL if sample_fmt is unknown or in case of other errors",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "128",
   "@_column": "6",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "128",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sampfmts_1gacf7a32f84e3508ee52ab30d85b8237bf",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Generate a string corresponding to the sample format with\n * sample_fmt, or a header if sample_fmt is negative.\n *\n * @param buf the buffer where to write the string\n * @param buf_size the size of buf\n * @param sample_fmt the number of the sample format to print the\n * corresponding info string, or a negative value to print the\n * corresponding header.\n * @return the pointer to the filled buffer or NULL if sample_fmt is\n * unknown or in case of other errors\n */"
 },
 "av_get_bytes_per_sample": {
  "type": "int",
  "definition": "int av_get_bytes_per_sample",
  "argsstring": "(enum AVSampleFormat sample_fmt)",
  "name": "av_get_bytes_per_sample",
  "param": {
   "type": {
    "ref": {
     "#text": "AVSampleFormat",
     "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "sample_fmt"
  },
  "briefdescription": {
   "para": "Return number of bytes per sample."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "sample_fmt"
      },
      "parameterdescription": {
       "para": "the sample format"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "number of bytes per sample or zero if unknown for the given sample format",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "137",
   "@_column": "5",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "137",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "decode",
    "@_refid": "decode__audio_8c_1a1704ae53d7f426e1b67341785b5b2b58",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "72",
    "@_endline": "104"
   },
   {
    "#text": "output_audio_frame",
    "@_refid": "demux__decode_8c_1a2dadb97c4c6e23923373204870deda3f",
    "@_compoundref": "demux__decode_8c",
    "@_startline": "90",
    "@_endline": "108"
   },
   {
    "#text": "process_output",
    "@_refid": "filter__audio_8c_1a6a52930eb2ed533366ebb43a038baa36",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "212",
    "@_endline": "235"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__sampfmts_1ga0c3c218e1dd570ad4917c69a35a6c77d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return number of bytes per sample.\n *\n * @param sample_fmt the sample format\n * @return number of bytes per sample or zero if unknown for the given\n * sample format\n */"
 },
 "av_sample_fmt_is_planar": {
  "type": "int",
  "definition": "int av_sample_fmt_is_planar",
  "argsstring": "(enum AVSampleFormat sample_fmt)",
  "name": "av_sample_fmt_is_planar",
  "param": {
   "type": {
    "ref": {
     "#text": "AVSampleFormat",
     "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "sample_fmt"
  },
  "briefdescription": {
   "para": "Check if the sample format is planar."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "sample_fmt"
      },
      "parameterdescription": {
       "para": "the sample format to inspect"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "1 if the sample format is planar, 0 if it is interleaved",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "145",
   "@_column": "5",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "145",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "decode__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "decode__audio_8c",
    "@_startline": "106",
    "@_endline": "237"
   },
   {
    "#text": "process_output",
    "@_refid": "filter__audio_8c_1a6a52930eb2ed533366ebb43a038baa36",
    "@_compoundref": "filter__audio_8c",
    "@_startline": "212",
    "@_endline": "235"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__sampfmts_1ga06ba8a64dc4382c422789a5d0b6bf592",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if the sample format is planar.\n *\n * @param sample_fmt the sample format to inspect\n * @return 1 if the sample format is planar, 0 if it is interleaved\n */"
 },
 "av_samples_get_buffer_size": {
  "type": "int",
  "definition": "int av_samples_get_buffer_size",
  "argsstring": "(int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)",
  "name": "av_samples_get_buffer_size",
  "param": [
   {
    "type": "int *",
    "declname": "linesize"
   },
   {
    "type": "int",
    "declname": "nb_channels"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "sample_fmt"
   },
   {
    "type": "int",
    "declname": "align"
   }
  ],
  "briefdescription": {
   "para": "Get the required buffer size for the given audio parameters."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "linesize",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "calculated linesize, may be NULL"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_channels"
       },
       "parameterdescription": {
        "para": "the number of channels"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_samples"
       },
       "parameterdescription": {
        "para": "the number of samples in a single channel"
       }
      },
      {
       "parameternamelist": {
        "parametername": "sample_fmt"
       },
       "parameterdescription": {
        "para": "the sample format"
       }
      },
      {
       "parameternamelist": {
        "parametername": "align"
       },
       "parameterdescription": {
        "para": "buffer size alignment (0 = default, 1 = no alignment)"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "required buffer size, or negative error code on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "157",
   "@_column": "5",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "157",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "resample__audio_8c",
   "@_startline": "85",
   "@_endline": "220"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sampfmts_1gaa7368bc4e3a366b688e81938ed55eb06",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the required buffer size for the given audio parameters.\n *\n * @param[out] linesize calculated linesize, may be NULL\n * @param nb_channels   the number of channels\n * @param nb_samples    the number of samples in a single channel\n * @param sample_fmt    the sample format\n * @param align         buffer size alignment (0 = default, 1 = no alignment)\n * @return              required buffer size, or negative error code on failure\n */"
 },
 "av_samples_fill_arrays": {
  "type": "int",
  "definition": "int av_samples_fill_arrays",
  "argsstring": "(uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)",
  "name": "av_samples_fill_arrays",
  "param": [
   {
    "type": "uint8_t **",
    "declname": "audio_data"
   },
   {
    "type": "int *",
    "declname": "linesize"
   },
   {
    "type": "const uint8_t *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "nb_channels"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "sample_fmt"
   },
   {
    "type": "int",
    "declname": "align"
   }
  ],
  "briefdescription": {
   "para": "Fill plane data pointers and linesize for samples with sample format sample_fmt."
  },
  "detaileddescription": {
   "para": [
    "The audio_data array is filled with the pointers to the samples data planes: for planar, set the start point of each channel's data within the buffer, for packed, set the start point of the entire buffer only.",
    "The value pointed to by linesize is set to the aligned size of each channel's data buffer for planar layout, or to the aligned size of the buffer for all channels for packed layout.",
    {
     "ref": {
      "#text": "av_samples_get_buffer_size()",
      "@_refid": "group__lavu__sampfmts_1gaa7368bc4e3a366b688e81938ed55eb06",
      "@_kindref": "member"
     },
     "#text": "The buffer in buf must be big enough to contain all the samples (useto compute its minimum size), otherwise the audio_data pointers will point to invalid data."
    },
    {
     "simplesect": [
      {
       "para": {
        "ref": [
         {
          "#text": "AVSampleFormat",
          "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
          "@_kindref": "member"
         },
         {
          "#text": "AVSampleFormat",
          "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
          "@_kindref": "member"
         }
        ],
        "#text": "enumThe documentation fordescribes the data layout."
       },
       "@_kind": "see"
      },
      {
       "para": "minimum size in bytes required for the buffer on success, or a negative error code on failure",
       "@_kind": "return"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "audio_data",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "array to be filled with the pointer for each channel"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "linesize",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "calculated linesize, may be NULL"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "the pointer to a buffer containing the samples"
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_channels"
        },
        "parameterdescription": {
         "para": "the number of channels"
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_samples"
        },
        "parameterdescription": {
         "para": "the number of samples in a single channel"
        }
       },
       {
        "parameternamelist": {
         "parametername": "sample_fmt"
        },
        "parameterdescription": {
         "para": "the sample format"
        }
       },
       {
        "parameternamelist": {
         "parametername": "align"
        },
        "parameterdescription": {
         "para": "buffer size alignment (0 = default, 1 = no alignment)"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "198",
   "@_column": "5",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "198",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sampmanip_1ga673254a62fa75dab3211caf17c73c6eb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill plane data pointers and linesize for samples with sample\n * format sample_fmt.\n *\n * The audio_data array is filled with the pointers to the samples data planes:\n * for planar, set the start point of each channel's data within the buffer,\n * for packed, set the start point of the entire buffer only.\n *\n * The value pointed to by linesize is set to the aligned size of each\n * channel's data buffer for planar layout, or to the aligned size of the\n * buffer for all channels for packed layout.\n *\n * The buffer in buf must be big enough to contain all the samples\n * (use av_samples_get_buffer_size() to compute its minimum size),\n * otherwise the audio_data pointers will point to invalid data.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param[out] audio_data  array to be filled with the pointer for each channel\n * @param[out] linesize    calculated linesize, may be NULL\n * @param buf              the pointer to a buffer containing the samples\n * @param nb_channels      the number of channels\n * @param nb_samples       the number of samples in a single channel\n * @param sample_fmt       the sample format\n * @param align            buffer size alignment (0 = default, 1 = no alignment)\n * @return                 minimum size in bytes required for the buffer on success,\n *                         or a negative error code on failure\n */"
 },
 "av_samples_alloc": {
  "type": "int",
  "definition": "int av_samples_alloc",
  "argsstring": "(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)",
  "name": "av_samples_alloc",
  "param": [
   {
    "type": "uint8_t **",
    "declname": "audio_data"
   },
   {
    "type": "int *",
    "declname": "linesize"
   },
   {
    "type": "int",
    "declname": "nb_channels"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "sample_fmt"
   },
   {
    "type": "int",
    "declname": "align"
   }
  ],
  "briefdescription": {
   "para": "Allocate a samples buffer for nb_samples samples, and fill data pointers and linesize accordingly."
  },
  "detaileddescription": {
   "para": [
    "The allocated samples buffer can be freed by using av_freep(&audio_data[0]) Allocated data will be initialized to silence.",
    {
     "simplesect": [
      {
       "para": {
        "ref": [
         {
          "#text": "AVSampleFormat",
          "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
          "@_kindref": "member"
         },
         {
          "#text": "AVSampleFormat",
          "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
          "@_kindref": "member"
         }
        ],
        "#text": "enumThe documentation fordescribes the data layout."
       },
       "@_kind": "see"
      },
      {
       "para": ">=0 on success or a negative error code on failure",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "av_samples_fill_arrays()",
         "@_refid": "group__lavu__sampmanip_1ga673254a62fa75dab3211caf17c73c6eb",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      },
      {
       "para": {
        "ref": {
         "#text": "av_samples_alloc_array_and_samples()",
         "@_refid": "group__lavu__sampmanip_1gae8b9f22f2f659d023f111390d9545273",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "audio_data",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "array to be filled with the pointer for each channel"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "linesize",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "aligned size for audio buffer(s), may be NULL"
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_channels"
        },
        "parameterdescription": {
         "para": "number of audio channels"
        }
       },
       {
        "parameternamelist": {
         "parametername": "nb_samples"
        },
        "parameterdescription": {
         "para": "number of samples per channel"
        }
       },
       {
        "parameternamelist": {
         "parametername": "sample_fmt"
        },
        "parameterdescription": {
         "para": "the sample format"
        }
       },
       {
        "parameternamelist": {
         "parametername": "align"
        },
        "parameterdescription": {
         "para": "buffer size alignment (0 = default, 1 = no alignment)"
        }
       }
      ],
      "@_kind": "param"
     },
     "xrefsect": {
      "xreftitle": "Todo",
      "xrefdescription": {
       "para": "return the size of the allocated buffer in case of success at the next bump"
      },
      "@_id": "todo_1_todo000004"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "223",
   "@_column": "5",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "223",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "main",
   "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
   "@_compoundref": "resample__audio_8c",
   "@_startline": "85",
   "@_endline": "220"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sampmanip_1ga4db4c77f928d32c7d8854732f50b8c04",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a samples buffer for nb_samples samples, and fill data pointers and\n * linesize accordingly.\n * The allocated samples buffer can be freed by using av_freep(&audio_data[0])\n * Allocated data will be initialized to silence.\n *\n * @see enum AVSampleFormat\n * The documentation for AVSampleFormat describes the data layout.\n *\n * @param[out] audio_data  array to be filled with the pointer for each channel\n * @param[out] linesize    aligned size for audio buffer(s), may be NULL\n * @param nb_channels      number of audio channels\n * @param nb_samples       number of samples per channel\n * @param sample_fmt       the sample format\n * @param align            buffer size alignment (0 = default, 1 = no alignment)\n * @return                 >=0 on success or a negative error code on failure\n * @todo return the size of the allocated buffer in case of success at the next bump\n * @see av_samples_fill_arrays()\n * @see av_samples_alloc_array_and_samples()\n */"
 },
 "av_samples_alloc_array_and_samples": {
  "type": "int",
  "definition": "int av_samples_alloc_array_and_samples",
  "argsstring": "(uint8_t ***audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)",
  "name": "av_samples_alloc_array_and_samples",
  "param": [
   {
    "type": "uint8_t ***",
    "declname": "audio_data"
   },
   {
    "type": "int *",
    "declname": "linesize"
   },
   {
    "type": "int",
    "declname": "nb_channels"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "sample_fmt"
   },
   {
    "type": "int",
    "declname": "align"
   }
  ],
  "briefdescription": {
   "para": "Allocate a data pointers array, samples buffer for nb_samples samples, and fill data pointers and linesize accordingly."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_samples_alloc()",
      "@_refid": "group__lavu__sampmanip_1ga4db4c77f928d32c7d8854732f50b8c04",
      "@_kindref": "member"
     },
     "#text": "This is the same as, but also allocates the data pointers array."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_samples_alloc()",
        "@_refid": "group__lavu__sampmanip_1ga4db4c77f928d32c7d8854732f50b8c04",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "235",
   "@_column": "5",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "235",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "init_converted_samples",
    "@_refid": "transcode__aac_8c_1af79f075aaf578455b0d2d435e395f1ff",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "443",
    "@_endline": "464"
   },
   {
    "#text": "main",
    "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "resample__audio_8c",
    "@_startline": "85",
    "@_endline": "220"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lavu__sampmanip_1gae8b9f22f2f659d023f111390d9545273",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a data pointers array, samples buffer for nb_samples\n * samples, and fill data pointers and linesize accordingly.\n *\n * This is the same as av_samples_alloc(), but also allocates the data\n * pointers array.\n *\n * @see av_samples_alloc()\n */"
 },
 "av_samples_copy": {
  "type": "int",
  "definition": "int av_samples_copy",
  "argsstring": "(uint8_t *const *dst, uint8_t *const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)",
  "name": "av_samples_copy",
  "param": [
   {
    "type": "uint8_t *const *",
    "declname": "dst"
   },
   {
    "type": "uint8_t *const *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "dst_offset"
   },
   {
    "type": "int",
    "declname": "src_offset"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   },
   {
    "type": "int",
    "declname": "nb_channels"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "sample_fmt"
   }
  ],
  "briefdescription": {
   "para": "Copy samples from src to dst."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array of pointers to data planes"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array of pointers to data planes"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst_offset"
       },
       "parameterdescription": {
        "para": "offset in samples at which the data will be written to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src_offset"
       },
       "parameterdescription": {
        "para": "offset in samples at which the data will be read from src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_samples"
       },
       "parameterdescription": {
        "para": "number of samples to be copied"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_channels"
       },
       "parameterdescription": {
        "para": "number of audio channels"
       }
      },
      {
       "parameternamelist": {
        "parametername": "sample_fmt"
       },
       "parameterdescription": {
        "para": "audio sample format"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "249",
   "@_column": "5",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "249",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sampmanip_1gabd511e1a989de02e7cb174a1169f2951",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copy samples from src to dst.\n *\n * @param dst destination array of pointers to data planes\n * @param src source array of pointers to data planes\n * @param dst_offset offset in samples at which the data will be written to dst\n * @param src_offset offset in samples at which the data will be read from src\n * @param nb_samples number of samples to be copied\n * @param nb_channels number of audio channels\n * @param sample_fmt audio sample format\n */"
 },
 "av_samples_set_silence": {
  "type": "int",
  "definition": "int av_samples_set_silence",
  "argsstring": "(uint8_t *const *audio_data, int offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)",
  "name": "av_samples_set_silence",
  "param": [
   {
    "type": "uint8_t *const *",
    "declname": "audio_data"
   },
   {
    "type": "int",
    "declname": "offset"
   },
   {
    "type": "int",
    "declname": "nb_samples"
   },
   {
    "type": "int",
    "declname": "nb_channels"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "sample_fmt"
   }
  ],
  "briefdescription": {
   "para": "Fill an audio buffer with silence."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "audio_data"
       },
       "parameterdescription": {
        "para": "array of pointers to data planes"
       }
      },
      {
       "parameternamelist": {
        "parametername": "offset"
       },
       "parameterdescription": {
        "para": "offset in samples at which to start filling"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_samples"
       },
       "parameterdescription": {
        "para": "number of samples to fill"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nb_channels"
       },
       "parameterdescription": {
        "para": "number of audio channels"
       }
      },
      {
       "parameternamelist": {
        "parametername": "sample_fmt"
       },
       "parameterdescription": {
        "para": "audio sample format"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/samplefmt.h",
   "@_line": "262",
   "@_column": "5",
   "@_declfile": "libavutil/samplefmt.h",
   "@_declline": "262",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sampmanip_1gabcb166e22938c7d93c2d609529c458bb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill an audio buffer with silence.\n *\n * @param audio_data  array of pointers to data planes\n * @param offset      offset in samples at which to start filling\n * @param nb_samples  number of samples to fill\n * @param nb_channels number of audio channels\n * @param sample_fmt  audio sample format\n */"
 },
 "av_sha512_size": {
  "type": "const int",
  "definition": "const int av_sha512_size",
  "argsstring": "",
  "name": "av_sha512_size",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/sha512.h",
   "@_line": "53",
   "@_column": "18",
   "@_declfile": "libavutil/sha512.h",
   "@_declline": "53",
   "@_declcolumn": "18"
  },
  "@_kind": "variable",
  "@_id": "group__lavu__sha512_1gaa90af4540d2b03a1a122e1d6a8678efe",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * @defgroup lavu_sha512 SHA-512\n * @ingroup lavu_hash\n * SHA-512 (Secure Hash Algorithm) hash function implementations.\n *\n * This module supports the following SHA-2 hash functions:\n *\n * - SHA-512/224: 224 bits\n * - SHA-512/256: 256 bits\n * - SHA-384: 384 bits\n * - SHA-512: 512 bits\n *\n * @see For SHA-1, SHA-256, and variants thereof, see @ref lavu_sha.\n *\n * @{\n */"
 },
 "av_sha512_alloc": {
  "type": "struct AVSHA512 *",
  "definition": "struct AVSHA512 * av_sha512_alloc",
  "argsstring": "(void)",
  "name": "av_sha512_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVSHA512 context."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/sha512.h",
   "@_line": "60",
   "@_column": "15",
   "@_declfile": "libavutil/sha512.h",
   "@_declline": "60",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sha512_1ga19bf6cb027437b17b4af1f0dbb3957e0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVSHA512 context.\n */"
 },
 "av_sha512_init": {
  "type": "int",
  "definition": "int av_sha512_init",
  "argsstring": "(struct AVSHA512 *context, int bits)",
  "name": "av_sha512_init",
  "param": [
   {
    "type": "struct AVSHA512 *",
    "declname": "context"
   },
   {
    "type": "int",
    "declname": "bits"
   }
  ],
  "briefdescription": {
   "para": "Initialize SHA-2 512 hashing."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "context"
       },
       "parameterdescription": {
        "para": "pointer to the function context (of size av_sha512_size)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "bits"
       },
       "parameterdescription": {
        "para": "number of bits in digest (224, 256, 384 or 512 bits)"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "zero if initialization succeeded, -1 otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/sha512.h",
   "@_line": "69",
   "@_column": "5",
   "@_declfile": "libavutil/sha512.h",
   "@_declline": "69",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sha512_1ga3cd6e2e5e591440905380dd345058516",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize SHA-2 512 hashing.\n *\n * @param context pointer to the function context (of size av_sha512_size)\n * @param bits    number of bits in digest (224, 256, 384 or 512 bits)\n * @return        zero if initialization succeeded, -1 otherwise\n */"
 },
 "av_sha512_update": {
  "type": "void",
  "definition": "void av_sha512_update",
  "argsstring": "(struct AVSHA512 *context, const uint8_t *data, size_t len)",
  "name": "av_sha512_update",
  "param": [
   {
    "type": "struct AVSHA512 *",
    "declname": "context"
   },
   {
    "type": "const uint8_t *",
    "declname": "data"
   },
   {
    "type": "size_t",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Update hash value."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "context"
       },
       "parameterdescription": {
        "para": "hash function context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "input data to update hash with"
       }
      },
      {
       "parameternamelist": {
        "parametername": "len"
       },
       "parameterdescription": {
        "para": "input data length"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/sha512.h",
   "@_line": "78",
   "@_column": "6",
   "@_declfile": "libavutil/sha512.h",
   "@_declline": "78",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sha512_1gabe477fe98668457a66b177062bb98d63",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Update hash value.\n *\n * @param context hash function context\n * @param data    input data to update hash with\n * @param len     input data length\n */"
 },
 "av_sha512_final": {
  "type": "void",
  "definition": "void av_sha512_final",
  "argsstring": "(struct AVSHA512 *context, uint8_t *digest)",
  "name": "av_sha512_final",
  "param": [
   {
    "type": "struct AVSHA512 *",
    "declname": "context"
   },
   {
    "type": "uint8_t *",
    "declname": "digest"
   }
  ],
  "briefdescription": {
   "para": "Finish hashing and output digest value."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "context"
       },
       "parameterdescription": {
        "para": "hash function context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "digest"
       },
       "parameterdescription": {
        "para": "buffer where output digest value is stored"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/sha512.h",
   "@_line": "86",
   "@_column": "6",
   "@_declfile": "libavutil/sha512.h",
   "@_declline": "86",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sha512_1ga445bbd692a0e005d30a09d85f2ffbc69",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finish hashing and output digest value.\n *\n * @param context hash function context\n * @param digest  buffer where output digest value is stored\n */"
 },
 "av_sha_size": {
  "type": "const int",
  "definition": "const int av_sha_size",
  "argsstring": "",
  "name": "av_sha_size",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/sha.h",
   "@_line": "51",
   "@_column": "18",
   "@_declfile": "libavutil/sha.h",
   "@_declline": "51",
   "@_declcolumn": "18"
  },
  "@_kind": "variable",
  "@_id": "group__lavu__sha_1ga622be70e89326cc46029bf4f130be825",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * @defgroup lavu_sha SHA\n * @ingroup lavu_hash\n * SHA-1 and SHA-256 (Secure Hash Algorithm) hash function implementations.\n *\n * This module supports the following SHA hash functions:\n *\n * - SHA-1: 160 bits\n * - SHA-224: 224 bits, as a variant of SHA-2\n * - SHA-256: 256 bits, as a variant of SHA-2\n *\n * @see For SHA-384, SHA-512, and variants thereof, see @ref lavu_sha512.\n *\n * @{\n */"
 },
 "av_sha_alloc": {
  "type": "struct AVSHA *",
  "definition": "struct AVSHA * av_sha_alloc",
  "argsstring": "(void)",
  "name": "av_sha_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVSHA context."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/sha.h",
   "@_line": "58",
   "@_column": "12",
   "@_declfile": "libavutil/sha.h",
   "@_declline": "58",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sha_1gad0ba006332a7818c046c55d41f79f038",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVSHA context.\n */"
 },
 "av_sha_init": {
  "type": "int",
  "definition": "int av_sha_init",
  "argsstring": "(struct AVSHA *context, int bits)",
  "name": "av_sha_init",
  "param": [
   {
    "type": "struct AVSHA *",
    "declname": "context"
   },
   {
    "type": "int",
    "declname": "bits"
   }
  ],
  "briefdescription": {
   "para": "Initialize SHA-1 or SHA-2 hashing."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "context"
       },
       "parameterdescription": {
        "para": "pointer to the function context (of size av_sha_size)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "bits"
       },
       "parameterdescription": {
        "para": "number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "zero if initialization succeeded, -1 otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/sha.h",
   "@_line": "67",
   "@_column": "5",
   "@_declfile": "libavutil/sha.h",
   "@_declline": "67",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sha_1gaf53a37af454b04d4974861e931593e1a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize SHA-1 or SHA-2 hashing.\n *\n * @param context pointer to the function context (of size av_sha_size)\n * @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)\n * @return        zero if initialization succeeded, -1 otherwise\n */"
 },
 "av_sha_update": {
  "type": "void",
  "definition": "void av_sha_update",
  "argsstring": "(struct AVSHA *ctx, const uint8_t *data, size_t len)",
  "name": "av_sha_update",
  "param": [
   {
    "type": "struct AVSHA *",
    "declname": "ctx"
   },
   {
    "type": "const uint8_t *",
    "declname": "data"
   },
   {
    "type": "size_t",
    "declname": "len"
   }
  ],
  "briefdescription": {
   "para": "Update hash value."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "hash function context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "data"
       },
       "parameterdescription": {
        "para": "input data to update hash with"
       }
      },
      {
       "parameternamelist": {
        "parametername": "len"
       },
       "parameterdescription": {
        "para": "input data length"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/sha.h",
   "@_line": "76",
   "@_column": "6",
   "@_declfile": "libavutil/sha.h",
   "@_declline": "76",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sha_1ga0072b11c4cacdb4fb3e7bfddd82021fc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Update hash value.\n *\n * @param ctx     hash function context\n * @param data    input data to update hash with\n * @param len     input data length\n */"
 },
 "av_sha_final": {
  "type": "void",
  "definition": "void av_sha_final",
  "argsstring": "(struct AVSHA *context, uint8_t *digest)",
  "name": "av_sha_final",
  "param": [
   {
    "type": "struct AVSHA *",
    "declname": "context"
   },
   {
    "type": "uint8_t *",
    "declname": "digest"
   }
  ],
  "briefdescription": {
   "para": "Finish hashing and output digest value."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "context"
       },
       "parameterdescription": {
        "para": "hash function context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "digest"
       },
       "parameterdescription": {
        "para": "buffer where output digest value is stored"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/sha.h",
   "@_line": "84",
   "@_column": "6",
   "@_declfile": "libavutil/sha.h",
   "@_declline": "84",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__sha_1gadc0f2ed085f24f10cacfcdfcfc2e0127",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finish hashing and output digest value.\n *\n * @param context hash function context\n * @param digest  buffer where output digest value is stored\n */"
 },
 "av_spherical_alloc": {
  "type": {
   "ref": {
    "#text": "AVSphericalMapping",
    "@_refid": "structAVSphericalMapping",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVSphericalMapping * av_spherical_alloc",
  "argsstring": "(size_t *size)",
  "name": "av_spherical_alloc",
  "param": {
   "type": "size_t *",
   "declname": "size"
  },
  "briefdescription": {
   "para": "Allocate a AVSphericalVideo structure and initialize its fields to default values."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the newly allocated struct or NULL on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/spherical.h",
   "@_line": "187",
   "@_column": "20",
   "@_declfile": "libavutil/spherical.h",
   "@_declline": "187",
   "@_declcolumn": "20"
  },
  "@_kind": "function",
  "@_id": "group__lavu__video__spherical_1ga2c987049465600d3a50e760fdaee9c60",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a AVSphericalVideo structure and initialize its fields to default\n * values.\n *\n * @return the newly allocated struct or NULL on failure\n */"
 },
 "av_spherical_tile_bounds": {
  "type": "void",
  "definition": "void av_spherical_tile_bounds",
  "argsstring": "(const AVSphericalMapping *map, size_t width, size_t height, size_t *left, size_t *top, size_t *right, size_t *bottom)",
  "name": "av_spherical_tile_bounds",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVSphericalMapping",
      "@_refid": "structAVSphericalMapping",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "map"
   },
   {
    "type": "size_t",
    "declname": "width"
   },
   {
    "type": "size_t",
    "declname": "height"
   },
   {
    "type": "size_t *",
    "declname": "left"
   },
   {
    "type": "size_t *",
    "declname": "top"
   },
   {
    "type": "size_t *",
    "declname": "right"
   },
   {
    "type": "size_t *",
    "declname": "bottom"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "bounding",
     "@_refid": "structAVSphericalMapping_1bounding",
     "@_kindref": "member"
    },
    "#text": "Convert thefields from an AVSphericalVideo from 0.32 fixed point to pixels."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "map"
       },
       "parameterdescription": {
        "para": "The AVSphericalVideo map to read bound values from."
       }
      },
      {
       "parameternamelist": {
        "parametername": "width"
       },
       "parameterdescription": {
        "para": "Width of the current frame or stream."
       }
      },
      {
       "parameternamelist": {
        "parametername": "height"
       },
       "parameterdescription": {
        "para": "Height of the current frame or stream."
       }
      },
      {
       "parameternamelist": {
        "parametername": "left"
       },
       "parameterdescription": {
        "para": "Pixels from the left edge."
       }
      },
      {
       "parameternamelist": {
        "parametername": "top"
       },
       "parameterdescription": {
        "para": "Pixels from the top edge."
       }
      },
      {
       "parameternamelist": {
        "parametername": "right"
       },
       "parameterdescription": {
        "para": "Pixels from the right edge."
       }
      },
      {
       "parameternamelist": {
        "parametername": "bottom"
       },
       "parameterdescription": {
        "para": "Pixels from the bottom edge."
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/spherical.h",
   "@_line": "201",
   "@_column": "6",
   "@_declfile": "libavutil/spherical.h",
   "@_declline": "201",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__video__spherical_1ga9c9a5f996f41bd0fe6f4c9908a70f98e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert the @ref bounding fields from an AVSphericalVideo\n * from 0.32 fixed point to pixels.\n *\n * @param map    The AVSphericalVideo map to read bound values from.\n * @param width  Width of the current frame or stream.\n * @param height Height of the current frame or stream.\n * @param left   Pixels from the left edge.\n * @param top    Pixels from the top edge.\n * @param right  Pixels from the right edge.\n * @param bottom Pixels from the bottom edge.\n */"
 },
 "av_spherical_projection_name": {
  "type": "const char *",
  "definition": "const char * av_spherical_projection_name",
  "argsstring": "(enum AVSphericalProjection projection)",
  "name": "av_spherical_projection_name",
  "param": {
   "type": {
    "ref": {
     "#text": "AVSphericalProjection",
     "@_refid": "group__lavu__video__spherical_1ga689eeb8cf9b453f3619f3cf626e03a08",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "projection"
  },
  "briefdescription": {
   "para": "Provide a human-readable name of a given AVSphericalProjection."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "projection"
      },
      "parameterdescription": {
       "para": "The input AVSphericalProjection."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "The name of the AVSphericalProjection, or \"unknown\".",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/spherical.h",
   "@_line": "213",
   "@_column": "12",
   "@_declfile": "libavutil/spherical.h",
   "@_declline": "213",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__video__spherical_1ga9b1f15e9eed3750144ec8322b9777c6b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Provide a human-readable name of a given AVSphericalProjection.\n *\n * @param projection The input AVSphericalProjection.\n *\n * @return The name of the AVSphericalProjection, or \"unknown\".\n */"
 },
 "av_spherical_from_name": {
  "type": "int",
  "definition": "int av_spherical_from_name",
  "argsstring": "(const char *name)",
  "name": "av_spherical_from_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": {
   "para": "Get the AVSphericalProjection form a human-readable name."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "name"
      },
      "parameterdescription": {
       "para": "The input string."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "The AVSphericalProjection value, or -1 if not found.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/spherical.h",
   "@_line": "222",
   "@_column": "5",
   "@_declfile": "libavutil/spherical.h",
   "@_declline": "222",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__video__spherical_1ga539173e8b22176710e1e0b728e4bd22f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVSphericalProjection form a human-readable name.\n *\n * @param name The input string.\n *\n * @return The AVSphericalProjection value, or -1 if not found.\n */"
 },
 "av_stereo3d_alloc": {
  "type": {
   "ref": {
    "#text": "AVStereo3D",
    "@_refid": "structAVStereo3D",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVStereo3D * av_stereo3d_alloc",
  "argsstring": "(void)",
  "name": "av_stereo3d_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVStereo3D",
     "@_refid": "structAVStereo3D",
     "@_kindref": "compound"
    },
    "#text": "Allocate anstructure and set its fields to default values."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_freep()",
      "@_refid": "group__lavu__mem__funcs_1ga0cc84043ea2167ad005c86e11d0bcdba",
      "@_kindref": "member"
     },
     "#text": "The resulting struct can be freed using."
    },
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "AVStereo3D",
        "@_refid": "structAVStereo3D",
        "@_kindref": "compound"
       },
       "#text": "Anfilled with default values or NULL on failure."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/stereo3d.h",
   "@_line": "196",
   "@_column": "12",
   "@_declfile": "libavutil/stereo3d.h",
   "@_declline": "196",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__video__stereo3d_1ga15529aca5812275dfc7db4fa38900a04",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVStereo3D structure and set its fields to default values.\n * The resulting struct can be freed using av_freep().\n *\n * @return An AVStereo3D filled with default values or NULL on failure.\n */"
 },
 "av_stereo3d_create_side_data": {
  "type": {
   "ref": {
    "#text": "AVStereo3D",
    "@_refid": "structAVStereo3D",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVStereo3D * av_stereo3d_create_side_data",
  "argsstring": "(AVFrame *frame)",
  "name": "av_stereo3d_create_side_data",
  "param": {
   "type": {
    "ref": {
     "#text": "AVFrame",
     "@_refid": "structAVFrame",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "frame"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVFrameSideData",
     "@_refid": "structAVFrameSideData",
     "@_kindref": "compound"
    },
    "#text": "Allocate a completeand add it to the frame."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "frame"
      },
      "parameterdescription": {
       "para": "The frame which side data is added to."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVStereo3D",
       "@_refid": "structAVStereo3D",
       "@_kindref": "compound"
      },
      "#text": "Thestructure to be filled by caller."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/stereo3d.h",
   "@_line": "205",
   "@_column": "12",
   "@_declfile": "libavutil/stereo3d.h",
   "@_declline": "205",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__video__stereo3d_1ga8c67e19b28bfbc2f74416c70637fbb3b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a complete AVFrameSideData and add it to the frame.\n *\n * @param frame The frame which side data is added to.\n *\n * @return The AVStereo3D structure to be filled by caller.\n */"
 },
 "av_stereo3d_type_name": {
  "type": "const char *",
  "definition": "const char * av_stereo3d_type_name",
  "argsstring": "(unsigned int type)",
  "name": "av_stereo3d_type_name",
  "param": {
   "type": "unsigned int",
   "declname": "type"
  },
  "briefdescription": {
   "para": "Provide a human-readable name of a given stereo3d type."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "type"
      },
      "parameterdescription": {
       "para": "The input stereo3d type value."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "The name of the stereo3d value, or \"unknown\".",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/stereo3d.h",
   "@_line": "214",
   "@_column": "12",
   "@_declfile": "libavutil/stereo3d.h",
   "@_declline": "214",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__video__stereo3d_1ga426618ed05efd22af0a963f2d4754246",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Provide a human-readable name of a given stereo3d type.\n *\n * @param type The input stereo3d type value.\n *\n * @return The name of the stereo3d value, or \"unknown\".\n */"
 },
 "av_stereo3d_from_name": {
  "type": "int",
  "definition": "int av_stereo3d_from_name",
  "argsstring": "(const char *name)",
  "name": "av_stereo3d_from_name",
  "param": {
   "type": "const char *",
   "declname": "name"
  },
  "briefdescription": {
   "para": "Get the AVStereo3DType form a human-readable name."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "name"
      },
      "parameterdescription": {
       "para": "The input string."
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "The AVStereo3DType value, or -1 if not found.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/stereo3d.h",
   "@_line": "223",
   "@_column": "5",
   "@_declfile": "libavutil/stereo3d.h",
   "@_declline": "223",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavu__video__stereo3d_1ga6a48f4c80b275d74d1e4ba760802a070",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVStereo3DType form a human-readable name.\n *\n * @param name The input string.\n *\n * @return The AVStereo3DType value, or -1 if not found.\n */"
 },
 "p": {
  "type": "uint32_t",
  "definition": "uint32_t AVBlowfish::p[AV_BF_ROUNDS+2]",
  "argsstring": "[AV_BF_ROUNDS+2]",
  "name": "p",
  "qualifiedname": "AVBlowfish::p",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/blowfish.h",
   "@_line": "36",
   "@_column": "14",
   "@_bodyfile": "libavutil/blowfish.h",
   "@_bodystart": "36",
   "@_bodyend": "-1"
  },
  "@_kind": "variable",
  "@_id": "structAVBlowfish_1a8ceacf7fa493d6822c08aa465462606f",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * @defgroup lavu_blowfish Blowfish\n * @ingroup lavu_crypto\n * @{\n */"
 },
 "s": {
  "type": "uint32_t",
  "definition": "uint32_t AVBlowfish::s[4][256]",
  "argsstring": "[4][256]",
  "name": "s",
  "qualifiedname": "AVBlowfish::s",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/blowfish.h",
   "@_line": "37",
   "@_column": "14",
   "@_bodyfile": "libavutil/blowfish.h",
   "@_bodystart": "37",
   "@_bodyend": "-1"
  },
  "@_kind": "variable",
  "@_id": "structAVBlowfish_1abf6f8773f7f25b320439df6a75cd909c",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * @defgroup lavu_blowfish Blowfish\n * @ingroup lavu_crypto\n * @{\n */"
 },
 "av_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass* AVFilterGraph::av_class",
  "argsstring": "",
  "name": "av_class",
  "qualifiedname": "AVFilterGraph::av_class",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "814",
   "@_column": "19",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "814",
   "@_bodyend": "-1"
  },
  "@_kind": "variable",
  "@_id": "structAVFilterGraph_1af00925dd69b474fac48887efc0e1ac94",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * A function executing multiple jobs, possibly in parallel.\n *\n * @param ctx the filter context to which the jobs belong\n * @param func the function to be called multiple times\n * @param arg the argument to be passed to func\n * @param ret a nb_jobs-sized array to be filled with return values from each\n *            invocation of func\n * @param nb_jobs the number of jobs to execute\n *\n * @return 0 on success, a negative AVERROR on error\n */"
 },
 "filters": {
  "type": {
   "ref": {
    "#text": "AVFilterContext",
    "@_refid": "structAVFilterContext",
    "@_kindref": "compound"
   },
   "#text": "**"
  },
  "definition": "AVFilterContext** AVFilterGraph::filters",
  "argsstring": "",
  "name": "filters",
  "qualifiedname": "AVFilterGraph::filters",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "815",
   "@_column": "21",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "815",
   "@_bodyend": "-1"
  },
  "@_kind": "variable",
  "@_id": "structAVFilterGraph_1a1dafd3d239f7c2f5e3ac109578ef926d",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * A function executing multiple jobs, possibly in parallel.\n *\n * @param ctx the filter context to which the jobs belong\n * @param func the function to be called multiple times\n * @param arg the argument to be passed to func\n * @param ret a nb_jobs-sized array to be filled with return values from each\n *            invocation of func\n * @param nb_jobs the number of jobs to execute\n *\n * @return 0 on success, a negative AVERROR on error\n */"
 },
 "nb_filters": {
  "type": "unsigned",
  "definition": "unsigned AVFilterGraph::nb_filters",
  "argsstring": "",
  "name": "nb_filters",
  "qualifiedname": "AVFilterGraph::nb_filters",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "816",
   "@_column": "14",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "816",
   "@_bodyend": "-1"
  },
  "@_kind": "variable",
  "@_id": "structAVFilterGraph_1a0ba5c820c760788ea5f8e40c476f9704",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * A function executing multiple jobs, possibly in parallel.\n *\n * @param ctx the filter context to which the jobs belong\n * @param func the function to be called multiple times\n * @param arg the argument to be passed to func\n * @param ret a nb_jobs-sized array to be filled with return values from each\n *            invocation of func\n * @param nb_jobs the number of jobs to execute\n *\n * @return 0 on success, a negative AVERROR on error\n */"
 },
 "scale_sws_opts": {
  "type": "char *",
  "definition": "char* AVFilterGraph::scale_sws_opts",
  "argsstring": "",
  "name": "scale_sws_opts",
  "qualifiedname": "AVFilterGraph::scale_sws_opts",
  "briefdescription": {
   "para": "sws options to use for the auto-inserted scale filters"
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "818",
   "@_column": "10",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "818",
   "@_bodyend": "-1"
  },
  "@_kind": "variable",
  "@_id": "structAVFilterGraph_1a17ced656602d33101ec4f46f6a9bdc53",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * A function executing multiple jobs, possibly in parallel.\n *\n * @param ctx the filter context to which the jobs belong\n * @param func the function to be called multiple times\n * @param arg the argument to be passed to func\n * @param ret a nb_jobs-sized array to be filled with return values from each\n *            invocation of func\n * @param nb_jobs the number of jobs to execute\n *\n * @return 0 on success, a negative AVERROR on error\n */"
 },
 "thread_type": {
  "type": "int",
  "definition": "int AVFilterGraph::thread_type",
  "argsstring": "",
  "name": "thread_type",
  "qualifiedname": "AVFilterGraph::thread_type",
  "briefdescription": {
   "para": "Type of multithreading allowed for filters in this graph."
  },
  "detaileddescription": {
   "para": [
    "A combination of AVFILTER_THREAD_* flags.",
    "May be set by the caller at any point, the setting will apply to all filters initialized after that. The default is allowing everything.",
    {
     "ref": {
      "#text": "AVFilterContext.thread_type",
      "@_refid": "structAVFilterContext_1a07b5e1a4c3cbde993e54bcc4873401a9",
      "@_kindref": "member"
     },
     "#text": "When a filter in this graph is initialized, this field is combined using bit AND withto get the final mask used for determining allowed threading types. I.e. a threading type needs to be set in both to be allowed."
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "832",
   "@_column": "9",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "832",
   "@_bodyend": "-1"
  },
  "@_kind": "variable",
  "@_id": "structAVFilterGraph_1a7fd96bbd6d1a3b730681dc0bf5107a5e",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "    /**\n     * Type of multithreading allowed for filters in this graph. A combination\n     * of AVFILTER_THREAD_* flags.\n     *\n     * May be set by the caller at any point, the setting will apply to all\n     * filters initialized after that. The default is allowing everything.\n     *\n     * When a filter in this graph is initialized, this field is combined using\n     * bit AND with AVFilterContext.thread_type to get the final mask used for\n     * determining allowed threading types. I.e. a threading type needs to be\n     * set in both to be allowed.\n     */"
 },
 "nb_threads": {
  "type": "int",
  "definition": "int AVFilterGraph::nb_threads",
  "argsstring": "",
  "name": "nb_threads",
  "qualifiedname": "AVFilterGraph::nb_threads",
  "briefdescription": {
   "para": "Maximum number of threads used by filters in this graph."
  },
  "detaileddescription": {
   "para": "May be set by the caller before adding any filters to the filtergraph. Zero (the default) means that the number of threads is determined automatically."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "839",
   "@_column": "9",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "839",
   "@_bodyend": "-1"
  },
  "@_kind": "variable",
  "@_id": "structAVFilterGraph_1ac28dcbf76e6fdd800295a2738d41660e",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "    /**\n     * Maximum number of threads used by filters in this graph. May be set by\n     * the caller before adding any filters to the filtergraph. Zero (the\n     * default) means that the number of threads is determined automatically.\n     */"
 },
 "opaque": {
  "type": "void *",
  "definition": "void* AVFilterGraph::opaque",
  "argsstring": "",
  "name": "opaque",
  "qualifiedname": "AVFilterGraph::opaque",
  "briefdescription": {
   "para": "Opaque user data."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "AVFilterGraph::execute",
     "@_refid": "structAVFilterGraph_1abbabdacc9b11e239ec24c969549d62ec",
     "@_kindref": "member"
    },
    "#text": "May be set by the caller to an arbitrary value, e.g. to be used from callbacks like. Libavfilter will not touch this field in any way."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "846",
   "@_column": "10",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "846",
   "@_bodyend": "-1"
  },
  "@_kind": "variable",
  "@_id": "structAVFilterGraph_1a2e9ac166e2d259bdd0b0c6b1a21f702c",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "    /**\n     * Opaque user data. May be set by the caller to an arbitrary value, e.g. to\n     * be used from callbacks like @ref AVFilterGraph.execute.\n     * Libavfilter will not touch this field in any way.\n     */"
 },
 "execute": {
  "type": {
   "ref": {
    "#text": "avfilter_execute_func",
    "@_refid": "group__lavfi_1gaa110ebfed4a342f88cd86da1b0037ab7",
    "@_kindref": "member"
   },
   "#text": "*"
  },
  "definition": "avfilter_execute_func* AVFilterGraph::execute",
  "argsstring": "",
  "name": "execute",
  "qualifiedname": "AVFilterGraph::execute",
  "briefdescription": {
   "para": "This callback may be set by the caller immediately after allocating the graph and before adding any filters to it, to provide a custom multithreading implementation."
  },
  "detaileddescription": {
   "para": [
    "If set, filters with slice threading capability will call this callback to execute multiple jobs in parallel.",
    "If this field is left unset, libavfilter will use its internal implementation, which may or may not be multithreaded depending on the platform and build options."
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "860",
   "@_column": "27",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "860",
   "@_bodyend": "-1"
  },
  "@_kind": "variable",
  "@_id": "structAVFilterGraph_1abbabdacc9b11e239ec24c969549d62ec",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "    /**\n     * This callback may be set by the caller immediately after allocating the\n     * graph and before adding any filters to it, to provide a custom\n     * multithreading implementation.\n     *\n     * If set, filters with slice threading capability will call this callback\n     * to execute multiple jobs in parallel.\n     *\n     * If this field is left unset, libavfilter will use its internal\n     * implementation, which may or may not be multithreaded depending on the\n     * platform and build options.\n     */"
 },
 "aresample_swr_opts": {
  "type": "char *",
  "definition": "char* AVFilterGraph::aresample_swr_opts",
  "argsstring": "",
  "name": "aresample_swr_opts",
  "qualifiedname": "AVFilterGraph::aresample_swr_opts",
  "briefdescription": {
   "para": "swr options to use for the auto-inserted aresample filters, Access ONLY through AVOptions"
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavfilter/avfilter.h",
   "@_line": "862",
   "@_column": "10",
   "@_bodyfile": "libavfilter/avfilter.h",
   "@_bodystart": "862",
   "@_bodyend": "-1"
  },
  "@_kind": "variable",
  "@_id": "structAVFilterGraph_1a34c3bdd638ffba56d89ad7f5e84601e1",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "    /**\n     * This callback may be set by the caller immediately after allocating the\n     * graph and before adding any filters to it, to provide a custom\n     * multithreading implementation.\n     *\n     * If set, filters with slice threading capability will call this callback\n     * to execute multiple jobs in parallel.\n     *\n     * If this field is left unset, libavfilter will use its internal\n     * implementation, which may or may not be multithreaded depending on the\n     * platform and build options.\n     */"
 },
 "swr_alloc": {
  "type": {
   "ref": {
    "#text": "SwrContext",
    "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
    "@_kindref": "member"
   },
   "#text": "struct*"
  },
  "definition": "struct SwrContext * swr_alloc",
  "argsstring": "(void)",
  "name": "swr_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate SwrContext."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "swr_alloc_set_opts2()",
       "@_refid": "group__lswr_1ga803ae19bc1c32a20a691996b4e530f22",
       "@_kindref": "member"
      },
      {
       "#text": "swr_init()",
       "@_refid": "group__lswr_1gae173e8ed91717700471a1dcd06f00f67",
       "@_kindref": "member"
      }
     ],
     "#text": "If you use this function you will need to set the parameters (manually or with) before calling."
    },
    {
     "simplesect": [
      {
       "para": {
        "ref": [
         {
          "#text": "swr_alloc_set_opts2()",
          "@_refid": "group__lswr_1ga803ae19bc1c32a20a691996b4e530f22",
          "@_kindref": "member"
         },
         {
          "#text": "swr_init()",
          "@_refid": "group__lswr_1gae173e8ed91717700471a1dcd06f00f67",
          "@_kindref": "member"
         },
         {
          "#text": "swr_free()",
          "@_refid": "group__lswr_1ga818f7d78b1ad7d8d5b70de374b668c34",
          "@_kindref": "member"
         }
        ],
        "#text": ",,"
       },
       "@_kind": "see"
      },
      {
       "para": "NULL on error, allocated context otherwise",
       "@_kind": "return"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "214",
   "@_column": "17",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "214",
   "@_declcolumn": "17"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "resample__audio_8c",
    "@_startline": "85",
    "@_endline": "220"
   },
   {
    "#text": "open_audio",
    "@_refid": "mux_8c_1a5de64c6730f86a2a0c7cc3ca2bab3717",
    "@_compoundref": "mux_8c",
    "@_startline": "241",
    "@_endline": "303"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lswr_1ga17283a2547f79f4013ba32820ec86ca8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate SwrContext.\n *\n * If you use this function you will need to set the parameters (manually or\n * with swr_alloc_set_opts2()) before calling swr_init().\n *\n * @see swr_alloc_set_opts2(), swr_init(), swr_free()\n * @return NULL on error, allocated context otherwise\n */"
 },
 "swr_init": {
  "type": "int",
  "definition": "int swr_init",
  "argsstring": "(struct SwrContext *s)",
  "name": "swr_init",
  "param": {
   "type": {
    "ref": {
     "#text": "SwrContext",
     "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
     "@_kindref": "member"
    },
    "#text": "struct*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Initialize context after user parameters have been set."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "AVOption",
        "@_refid": "structAVOption",
        "@_kindref": "compound"
       },
       "#text": "The context must be configured using theAPI."
      },
      "@_kind": "note"
     },
     {
      "para": {
       "ref": {
        "#text": "av_opt_set_int()",
        "@_refid": "group__opt__set__funcs_1ga3adf7185c21cc080890a5ec02c2e56b2",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     },
     {
      "para": {
       "ref": {
        "#text": "av_opt_set_dict()",
        "@_refid": "group__opt__write_1gaf1a88e8f152d7835f111b1ef8813fb2e",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     },
     {
      "para": "AVERROR error code in case of failure.",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": {
        "#text": "s",
        "@_direction": "inout"
       }
      },
      "parameterdescription": {
       "para": "Swr context to initialize"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "226",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "226",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "init_resampler",
    "@_refid": "transcode__aac_8c_1a68b32c4f40838cc56a7f45d33286d039",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "285",
    "@_endline": "321"
   },
   {
    "#text": "main",
    "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "resample__audio_8c",
    "@_startline": "85",
    "@_endline": "220"
   },
   {
    "#text": "open_audio",
    "@_refid": "mux_8c_1a5de64c6730f86a2a0c7cc3ca2bab3717",
    "@_compoundref": "mux_8c",
    "@_startline": "241",
    "@_endline": "303"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lswr_1gae173e8ed91717700471a1dcd06f00f67",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize context after user parameters have been set.\n * @note The context must be configured using the AVOption API.\n *\n * @see av_opt_set_int()\n * @see av_opt_set_dict()\n *\n * @param[in,out]   s Swr context to initialize\n * @return AVERROR error code in case of failure.\n */"
 },
 "swr_is_initialized": {
  "type": "int",
  "definition": "int swr_is_initialized",
  "argsstring": "(struct SwrContext *s)",
  "name": "swr_is_initialized",
  "param": {
   "type": {
    "ref": {
     "#text": "SwrContext",
     "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
     "@_kindref": "member"
    },
    "#text": "struct*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Check whether an swr context has been initialized or not."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": {
        "#text": "s",
        "@_direction": "in"
       }
      },
      "parameterdescription": {
       "para": "Swr context to check"
      }
     },
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "swr_init()",
        "@_refid": "group__lswr_1gae173e8ed91717700471a1dcd06f00f67",
        "@_kindref": "member"
       }
      },
      "@_kind": "see"
     },
     {
      "para": "positive if it has been initialized, 0 if not initialized",
      "@_kind": "return"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "235",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "235",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1gab11b02705e97404b6d74b18b2fcfdfcf",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check whether an swr context has been initialized or not.\n *\n * @param[in]       s Swr context to check\n * @see swr_init()\n * @return positive if it has been initialized, 0 if not initialized\n */"
 },
 "swr_alloc_set_opts2": {
  "type": "int",
  "definition": "int swr_alloc_set_opts2",
  "argsstring": "(struct SwrContext **ps, const AVChannelLayout *out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate, const AVChannelLayout *in_ch_layout, enum AVSampleFormat in_sample_fmt, int in_sample_rate, int log_offset, void *log_ctx)",
  "name": "swr_alloc_set_opts2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "struct**"
    },
    "declname": "ps"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "out_ch_layout"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "out_sample_fmt"
   },
   {
    "type": "int",
    "declname": "out_sample_rate"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "in_ch_layout"
   },
   {
    "type": {
     "ref": {
      "#text": "AVSampleFormat",
      "@_refid": "group__lavu__sampfmts_1gaf9a51ca15301871723577c730b5865c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "in_sample_fmt"
   },
   {
    "type": "int",
    "declname": "in_sample_rate"
   },
   {
    "type": "int",
    "declname": "log_offset"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Allocate SwrContext if needed and set/reset common parameters."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "swr_alloc()",
       "@_refid": "group__lswr_1ga17283a2547f79f4013ba32820ec86ca8",
       "@_kindref": "member"
      },
      {
       "#text": "swr_alloc()",
       "@_refid": "group__lswr_1ga17283a2547f79f4013ba32820ec86ca8",
       "@_kindref": "member"
      },
      {
       "#text": "swr_alloc_set_opts2()",
       "@_refid": "group__lswr_1ga803ae19bc1c32a20a691996b4e530f22",
       "@_kindref": "member"
      }
     ],
     "#text": "This function does not require *ps to be allocated with. On the other hand,can useto set the parameters on the allocated context."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "ps"
        },
        "parameterdescription": {
         "para": "Pointer to an existing Swr context if available, or to NULL if not. On success, *ps will be set to the allocated context."
        }
       },
       {
        "parameternamelist": {
         "parametername": "out_ch_layout"
        },
        "parameterdescription": {
         "para": "output channel layout (e.g. AV_CHANNEL_LAYOUT_*)"
        }
       },
       {
        "parameternamelist": {
         "parametername": "out_sample_fmt"
        },
        "parameterdescription": {
         "para": "output sample format (AV_SAMPLE_FMT_*)."
        }
       },
       {
        "parameternamelist": {
         "parametername": "out_sample_rate"
        },
        "parameterdescription": {
         "para": "output sample rate (frequency in Hz)"
        }
       },
       {
        "parameternamelist": {
         "parametername": "in_ch_layout"
        },
        "parameterdescription": {
         "para": "input channel layout (e.g. AV_CHANNEL_LAYOUT_*)"
        }
       },
       {
        "parameternamelist": {
         "parametername": "in_sample_fmt"
        },
        "parameterdescription": {
         "para": "input sample format (AV_SAMPLE_FMT_*)."
        }
       },
       {
        "parameternamelist": {
         "parametername": "in_sample_rate"
        },
        "parameterdescription": {
         "para": "input sample rate (frequency in Hz)"
        }
       },
       {
        "parameternamelist": {
         "parametername": "log_offset"
        },
        "parameterdescription": {
         "para": "logging level offset"
        }
       },
       {
        "parameternamelist": {
         "parametername": "log_ctx"
        },
        "parameterdescription": {
         "para": "parent logging context, can be NULL"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "ref": [
         {
          "#text": "swr_init()",
          "@_refid": "group__lswr_1gae173e8ed91717700471a1dcd06f00f67",
          "@_kindref": "member"
         },
         {
          "#text": "swr_free()",
          "@_refid": "group__lswr_1ga818f7d78b1ad7d8d5b70de374b668c34",
          "@_kindref": "member"
         }
        ],
        "#text": ","
       },
       "@_kind": "see"
      },
      {
       "para": "0 on success, a negative AVERROR code on error. On error, the Swr context is freed and *ps set to NULL.",
       "@_kind": "return"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "259",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "259",
   "@_declcolumn": "5"
  },
  "referencedby": {
   "#text": "init_resampler",
   "@_refid": "transcode__aac_8c_1a68b32c4f40838cc56a7f45d33286d039",
   "@_compoundref": "transcode__aac_8c",
   "@_startline": "285",
   "@_endline": "321"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1ga803ae19bc1c32a20a691996b4e530f22",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate SwrContext if needed and set/reset common parameters.\n *\n * This function does not require *ps to be allocated with swr_alloc(). On the\n * other hand, swr_alloc() can use swr_alloc_set_opts2() to set the parameters\n * on the allocated context.\n *\n * @param ps              Pointer to an existing Swr context if available, or to NULL if not.\n *                        On success, *ps will be set to the allocated context.\n * @param out_ch_layout   output channel layout (e.g. AV_CHANNEL_LAYOUT_*)\n * @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).\n * @param out_sample_rate output sample rate (frequency in Hz)\n * @param in_ch_layout    input channel layout (e.g. AV_CHANNEL_LAYOUT_*)\n * @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).\n * @param in_sample_rate  input sample rate (frequency in Hz)\n * @param log_offset      logging level offset\n * @param log_ctx         parent logging context, can be NULL\n *\n * @see swr_init(), swr_free()\n * @return 0 on success, a negative AVERROR code on error.\n *         On error, the Swr context is freed and *ps set to NULL.\n */"
 },
 "swr_free": {
  "type": "void",
  "definition": "void swr_free",
  "argsstring": "(struct SwrContext **s)",
  "name": "swr_free",
  "param": {
   "type": {
    "ref": {
     "#text": "SwrContext",
     "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
     "@_kindref": "member"
    },
    "#text": "struct**"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Free the given SwrContext and set the pointer to NULL."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": {
        "#text": "s",
        "@_direction": "in"
       }
      },
      "parameterdescription": {
       "para": "a pointer to a pointer to Swr context"
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "275",
   "@_column": "6",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "275",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "close_stream",
    "@_refid": "mux_8c_1a92d8b2751255677797d807161fae9d19",
    "@_compoundref": "mux_8c",
    "@_startline": "521",
    "@_endline": "529"
   },
   {
    "#text": "init_resampler",
    "@_refid": "transcode__aac_8c_1a68b32c4f40838cc56a7f45d33286d039",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "285",
    "@_endline": "321"
   },
   {
    "#text": "main",
    "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "resample__audio_8c",
    "@_startline": "85",
    "@_endline": "220"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lswr_1ga818f7d78b1ad7d8d5b70de374b668c34",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the given SwrContext and set the pointer to NULL.\n *\n * @param[in] s a pointer to a pointer to Swr context\n */"
 },
 "swr_close": {
  "type": "void",
  "definition": "void swr_close",
  "argsstring": "(struct SwrContext *s)",
  "name": "swr_close",
  "param": {
   "type": {
    "ref": {
     "#text": "SwrContext",
     "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
     "@_kindref": "member"
    },
    "#text": "struct*"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "swr_is_initialized()",
     "@_refid": "group__lswr_1gab11b02705e97404b6d74b18b2fcfdfcf",
     "@_kindref": "member"
    },
    "#text": "Closes the context so thatreturns 0."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "swr_init()",
       "@_refid": "group__lswr_1gae173e8ed91717700471a1dcd06f00f67",
       "@_kindref": "member"
      },
      {
       "#text": "swr_init()",
       "@_refid": "group__lswr_1gae173e8ed91717700471a1dcd06f00f67",
       "@_kindref": "member"
      },
      {
       "#text": "swr_close()",
       "@_refid": "group__lswr_1gaa4bf1048740dfc08d68aba9f1b4db22e",
       "@_kindref": "member"
      }
     ],
     "#text": "The context can be brought back to life by running,can also be used without. This function is mainly provided for simplifying the usecase where one tries to support libavresample and libswresample."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": {
         "#text": "s",
         "@_direction": "inout"
        }
       },
       "parameterdescription": {
        "para": "Swr context to be closed"
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "287",
   "@_column": "6",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "287",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1gaa4bf1048740dfc08d68aba9f1b4db22e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Closes the context so that swr_is_initialized() returns 0.\n *\n * The context can be brought back to life by running swr_init(),\n * swr_init() can also be used without swr_close().\n * This function is mainly provided for simplifying the usecase\n * where one tries to support libavresample and libswresample.\n *\n * @param[in,out] s Swr context to be closed\n */"
 },
 "swr_convert": {
  "type": "int",
  "definition": "int swr_convert",
  "argsstring": "(struct SwrContext *s, uint8_t *const *out, int out_count, const uint8_t *const *in, int in_count)",
  "name": "swr_convert",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": "uint8_t *const *",
    "declname": "out"
   },
   {
    "type": "int",
    "declname": "out_count"
   },
   {
    "type": "const uint8_t *const *",
    "declname": "in"
   },
   {
    "type": "int",
    "declname": "in_count"
   }
  ],
  "briefdescription": {
   "para": "Convert audio."
  },
  "detaileddescription": {
   "para": [
    "in and in_count can be set to 0 to flush the last few samples out at the end.",
    {
     "ref": {
      "#text": "swr_get_out_samples()",
      "@_refid": "group__lswr_1ga97a8d5f6abe3bcdfb6072412f17285a4",
      "@_kindref": "member"
     },
     "#text": "If more input is provided than output space, then the input will be buffered. You can avoid this buffering by usingto retrieve an upper bound on the required number of output samples for the given number of input samples. Conversion will run directly without copying whenever possible."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "allocated Swr context, with parameters set"
        }
       },
       {
        "parameternamelist": {
         "parametername": "out"
        },
        "parameterdescription": {
         "para": "output buffers, only the first one need be set in case of packed audio"
        }
       },
       {
        "parameternamelist": {
         "parametername": "out_count"
        },
        "parameterdescription": {
         "para": "amount of space available for output in samples per channel"
        }
       },
       {
        "parameternamelist": {
         "parametername": "in"
        },
        "parameterdescription": {
         "para": "input buffers, only the first one need to be set in case of packed audio"
        }
       },
       {
        "parameternamelist": {
         "parametername": "in_count"
        },
        "parameterdescription": {
         "para": "number of input samples available in one channel"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "number of samples output per channel, negative value on error",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "314",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "314",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "convert_samples",
    "@_refid": "transcode__aac_8c_1af01916898adcdf3776690407bd1e2b82",
    "@_compoundref": "transcode__aac_8c",
    "@_startline": "478",
    "@_endline": "494"
   },
   {
    "#text": "main",
    "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "resample__audio_8c",
    "@_startline": "85",
    "@_endline": "220"
   },
   {
    "#text": "write_audio_frame",
    "@_refid": "mux_8c_1a789f35413429ab70610c90c22fc7a4d3",
    "@_compoundref": "mux_8c",
    "@_startline": "336",
    "@_endline": "376"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lswr_1gad16a8308503be52a7e2d460983e81460",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/** Convert audio.\n *\n * in and in_count can be set to 0 to flush the last few samples out at the\n * end.\n *\n * If more input is provided than output space, then the input will be buffered.\n * You can avoid this buffering by using swr_get_out_samples() to retrieve an\n * upper bound on the required number of output samples for the given number of\n * input samples. Conversion will run directly without copying whenever possible.\n *\n * @param s         allocated Swr context, with parameters set\n * @param out       output buffers, only the first one need be set in case of packed audio\n * @param out_count amount of space available for output in samples per channel\n * @param in        input buffers, only the first one need to be set in case of packed audio\n * @param in_count  number of input samples available in one channel\n *\n * @return number of samples output per channel, negative value on error\n */"
 },
 "swr_next_pts": {
  "type": "int64_t",
  "definition": "int64_t swr_next_pts",
  "argsstring": "(struct SwrContext *s, int64_t pts)",
  "name": "swr_next_pts",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": "int64_t",
    "declname": "pts"
   }
  ],
  "briefdescription": {
   "para": "Convert the next timestamp from input to output timestamps are in 1/(in_sample_rate * out_sample_rate) units."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "itemizedlist": {
        "listitem": [
         {
          "para": "When automatic timestamp compensation is not used, (min_compensation >= FLT_MAX) in this case timestamps will be passed through with delays compensated"
         },
         {
          "para": "When automatic timestamp compensation is used, (min_compensation < FLT_MAX) in this case the output timestamps will match output sample numbers. See ffmpeg-resampler(1) for the two modes of compensation."
         }
        ]
       },
       "#text": "There are 2 slightly differently behaving modes."
      },
      "@_kind": "note"
     },
     {
      "para": {
       "ref": [
        {
         "#text": "swr_set_compensation()",
         "@_refid": "group__lswr_1gab7f21690522b85d7757e13fa9853d4d8",
         "@_kindref": "member"
        },
        {
         "#text": "swr_drop_output()",
         "@_refid": "group__lswr_1ga43d7ba4507891fc25aacbbea5cdfb065",
         "@_kindref": "member"
        },
        {
         "#text": "swr_inject_silence()",
         "@_refid": "group__lswr_1ga4733ed4779ed3e30379de2a6ef8de837",
         "@_kindref": "member"
        }
       ],
       "#text": ",, andare function used internally for timestamp compensation."
      },
      "@_kind": "see"
     },
     {
      "para": "the output timestamp for the next output sample",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "s",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "initialized Swr context"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "pts",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "timestamp for the next input sample, INT64_MIN if unknown"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "334",
   "@_column": "9",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "334",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1gaad9811626c6c01a241f6bf46aff27333",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert the next timestamp from input to output\n * timestamps are in 1/(in_sample_rate * out_sample_rate) units.\n *\n * @note There are 2 slightly differently behaving modes.\n *       @li When automatic timestamp compensation is not used, (min_compensation >= FLT_MAX)\n *              in this case timestamps will be passed through with delays compensated\n *       @li When automatic timestamp compensation is used, (min_compensation < FLT_MAX)\n *              in this case the output timestamps will match output sample numbers.\n *              See ffmpeg-resampler(1) for the two modes of compensation.\n *\n * @param[in] s     initialized Swr context\n * @param[in] pts   timestamp for the next input sample, INT64_MIN if unknown\n * @see swr_set_compensation(), swr_drop_output(), and swr_inject_silence() are\n *      function used internally for timestamp compensation.\n * @return the output timestamp for the next output sample\n */"
 },
 "swr_set_compensation": {
  "type": "int",
  "definition": "int swr_set_compensation",
  "argsstring": "(struct SwrContext *s, int sample_delta, int compensation_distance)",
  "name": "swr_set_compensation",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "sample_delta"
   },
   {
    "type": "int",
    "declname": "compensation_distance"
   }
  ],
  "briefdescription": {
   "para": "Activate resampling compensation (\"soft\" compensation)."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "swr_next_pts()",
      "@_refid": "group__lswr_1gaad9811626c6c01a241f6bf46aff27333",
      "@_kindref": "member"
     },
     "#text": "This function is internally called when needed in."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "s",
          "@_direction": "inout"
         }
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "swr_init()",
           "@_refid": "group__lswr_1gae173e8ed91717700471a1dcd06f00f67",
           "@_kindref": "member"
          },
          "#text": "allocated Swr context. If it is not initialized, or SWR_FLAG_RESAMPLE is not set,is called with the flag set."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "sample_delta",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "delta in PTS per sample"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "compensation_distance",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "number of samples to compensate for"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "itemizedlist": {
        "listitem": [
         {
          "para": {
           "computeroutput": "s",
           "#text": "is NULL,"
          }
         },
         {
          "para": {
           "computeroutput": "compensation_distance",
           "#text": "is less than 0,"
          }
         },
         {
          "para": {
           "computeroutput": "compensation_distance",
           "#text": "is 0 but sample_delta is not,"
          }
         },
         {
          "para": "compensation unsupported by resampler, or"
         },
         {
          "para": {
           "ref": {
            "#text": "swr_init()",
            "@_refid": "group__lswr_1gae173e8ed91717700471a1dcd06f00f67",
            "@_kindref": "member"
           },
           "#text": "fails when called."
          }
         }
        ]
       },
       "#text": ">= 0 on success, AVERROR error codes if:"
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "361",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "361",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1gab7f21690522b85d7757e13fa9853d4d8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Activate resampling compensation (\"soft\" compensation). This function is\n * internally called when needed in swr_next_pts().\n *\n * @param[in,out] s             allocated Swr context. If it is not initialized,\n *                              or SWR_FLAG_RESAMPLE is not set, swr_init() is\n *                              called with the flag set.\n * @param[in]     sample_delta  delta in PTS per sample\n * @param[in]     compensation_distance number of samples to compensate for\n * @return    >= 0 on success, AVERROR error codes if:\n *            @li @c s is NULL,\n *            @li @c compensation_distance is less than 0,\n *            @li @c compensation_distance is 0 but sample_delta is not,\n *            @li compensation unsupported by resampler, or\n *            @li swr_init() fails when called.\n */"
 },
 "swr_set_channel_mapping": {
  "type": "int",
  "definition": "int swr_set_channel_mapping",
  "argsstring": "(struct SwrContext *s, const int *channel_map)",
  "name": "swr_set_channel_mapping",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": "const int *",
    "declname": "channel_map"
   }
  ],
  "briefdescription": {
   "para": "Set a customized input channel mapping."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "s",
         "@_direction": "inout"
        }
       },
       "parameterdescription": {
        "para": "allocated Swr context, not yet initialized"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "channel_map",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "customized input channel mapping (array of channel indexes, -1 for a muted channel)"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 on success, or AVERROR error code in case of failure.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "371",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "371",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1ga1b528050b5f5b704aecbfbc257a17ef0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set a customized input channel mapping.\n *\n * @param[in,out] s           allocated Swr context, not yet initialized\n * @param[in]     channel_map customized input channel mapping (array of channel\n *                            indexes, -1 for a muted channel)\n * @return >= 0 on success, or AVERROR error code in case of failure.\n */"
 },
 "swr_build_matrix2": {
  "type": "int",
  "definition": "int swr_build_matrix2",
  "argsstring": "(const AVChannelLayout *in_layout, const AVChannelLayout *out_layout, double center_mix_level, double surround_mix_level, double lfe_mix_level, double maxval, double rematrix_volume, double *matrix, ptrdiff_t stride, enum AVMatrixEncoding matrix_encoding, void *log_context)",
  "name": "swr_build_matrix2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "in_layout"
   },
   {
    "type": {
     "ref": {
      "#text": "AVChannelLayout",
      "@_refid": "structAVChannelLayout",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "out_layout"
   },
   {
    "type": "double",
    "declname": "center_mix_level"
   },
   {
    "type": "double",
    "declname": "surround_mix_level"
   },
   {
    "type": "double",
    "declname": "lfe_mix_level"
   },
   {
    "type": "double",
    "declname": "maxval"
   },
   {
    "type": "double",
    "declname": "rematrix_volume"
   },
   {
    "type": "double *",
    "declname": "matrix"
   },
   {
    "type": "ptrdiff_t",
    "declname": "stride"
   },
   {
    "type": {
     "ref": {
      "#text": "AVMatrixEncoding",
      "@_refid": "group__channel__mask__c_1gabd576ea664e3ac5d31f3362064fe13e6",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "matrix_encoding"
   },
   {
    "type": "void *",
    "declname": "log_context"
   }
  ],
  "briefdescription": {
   "para": "Generate a channel mixing matrix."
  },
  "detaileddescription": {
   "para": [
    "This function is the one used internally by libswresample for building the default mixing matrix. It is made public just as a utility function for building custom matrices.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "in_layout"
        },
        "parameterdescription": {
         "para": "input channel layout"
        }
       },
       {
        "parameternamelist": {
         "parametername": "out_layout"
        },
        "parameterdescription": {
         "para": "output channel layout"
        }
       },
       {
        "parameternamelist": {
         "parametername": "center_mix_level"
        },
        "parameterdescription": {
         "para": "mix level for the center channel"
        }
       },
       {
        "parameternamelist": {
         "parametername": "surround_mix_level"
        },
        "parameterdescription": {
         "para": "mix level for the surround channel(s)"
        }
       },
       {
        "parameternamelist": {
         "parametername": "lfe_mix_level"
        },
        "parameterdescription": {
         "para": "mix level for the low-frequency effects channel"
        }
       },
       {
        "parameternamelist": {
         "parametername": "rematrix_maxval"
        },
        "parameterdescription": {
         "para": "if 1.0, coefficients will be normalized to prevent overflow. if INT_MAX, coefficients will not be normalized."
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "matrix",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "mixing coefficients; matrix[i + stride * o] is the weight of input channel i in output channel o."
        }
       },
       {
        "parameternamelist": {
         "parametername": "stride"
        },
        "parameterdescription": {
         "para": "distance between adjacent input channels in the matrix array"
        }
       },
       {
        "parameternamelist": {
         "parametername": "matrix_encoding"
        },
        "parameterdescription": {
         "para": "matrixed stereo downmix mode (e.g. dplii)"
        }
       },
       {
        "parameternamelist": {
         "parametername": "log_ctx"
        },
        "parameterdescription": {
         "para": "parent logging context, can be NULL"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, negative AVERROR code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "396",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "396",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1ga6a9f82de302424551f8af5b91d229394",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Generate a channel mixing matrix.\n *\n * This function is the one used internally by libswresample for building the\n * default mixing matrix. It is made public just as a utility function for\n * building custom matrices.\n *\n * @param in_layout           input channel layout\n * @param out_layout          output channel layout\n * @param center_mix_level    mix level for the center channel\n * @param surround_mix_level  mix level for the surround channel(s)\n * @param lfe_mix_level       mix level for the low-frequency effects channel\n * @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent\n *                            overflow. if INT_MAX, coefficients will not be\n *                            normalized.\n * @param[out] matrix         mixing coefficients; matrix[i + stride * o] is\n *                            the weight of input channel i in output channel o.\n * @param stride              distance between adjacent input channels in the\n *                            matrix array\n * @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)\n * @param log_ctx             parent logging context, can be NULL\n * @return                    0 on success, negative AVERROR code on failure\n */"
 },
 "swr_set_matrix": {
  "type": "int",
  "definition": "int swr_set_matrix",
  "argsstring": "(struct SwrContext *s, const double *matrix, int stride)",
  "name": "swr_set_matrix",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": "const double *",
    "declname": "matrix"
   },
   {
    "type": "int",
    "declname": "stride"
   }
  ],
  "briefdescription": {
   "para": "Set a customized remix matrix."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "allocated Swr context, not yet initialized"
       }
      },
      {
       "parameternamelist": {
        "parametername": "matrix"
       },
       "parameterdescription": {
        "para": "remix coefficients; matrix[i + stride * o] is the weight of input channel i in output channel o"
       }
      },
      {
       "parameternamelist": {
        "parametername": "stride"
       },
       "parameterdescription": {
        "para": "offset between lines of the matrix"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": ">= 0 on success, or AVERROR error code in case of failure.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "412",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "412",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1gaf9064d65b1e654dc78f7d6bcd2e8c747",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set a customized remix matrix.\n *\n * @param s       allocated Swr context, not yet initialized\n * @param matrix  remix coefficients; matrix[i + stride * o] is\n *                the weight of input channel i in output channel o\n * @param stride  offset between lines of the matrix\n * @return  >= 0 on success, or AVERROR error code in case of failure.\n */"
 },
 "swr_drop_output": {
  "type": "int",
  "definition": "int swr_drop_output",
  "argsstring": "(struct SwrContext *s, int count)",
  "name": "swr_drop_output",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "count"
   }
  ],
  "briefdescription": {
   "para": "Drops the specified number of output samples."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "swr_inject_silence()",
       "@_refid": "group__lswr_1ga4733ed4779ed3e30379de2a6ef8de837",
       "@_kindref": "member"
      },
      {
       "#text": "swr_next_pts()",
       "@_refid": "group__lswr_1gaad9811626c6c01a241f6bf46aff27333",
       "@_kindref": "member"
      }
     ],
     "#text": "This function, along with, is called byif needed for \"hard\" compensation."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "allocated Swr context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "count"
        },
        "parameterdescription": {
         "para": "number of samples to be dropped"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">= 0 on success, or a negative AVERROR code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "432",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "432",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1ga43d7ba4507891fc25aacbbea5cdfb065",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Drops the specified number of output samples.\n *\n * This function, along with swr_inject_silence(), is called by swr_next_pts()\n * if needed for \"hard\" compensation.\n *\n * @param s     allocated Swr context\n * @param count number of samples to be dropped\n *\n * @return >= 0 on success, or a negative AVERROR code on failure\n */"
 },
 "swr_inject_silence": {
  "type": "int",
  "definition": "int swr_inject_silence",
  "argsstring": "(struct SwrContext *s, int count)",
  "name": "swr_inject_silence",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "count"
   }
  ],
  "briefdescription": {
   "para": "Injects the specified number of silence samples."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "swr_drop_output()",
       "@_refid": "group__lswr_1ga43d7ba4507891fc25aacbbea5cdfb065",
       "@_kindref": "member"
      },
      {
       "#text": "swr_next_pts()",
       "@_refid": "group__lswr_1gaad9811626c6c01a241f6bf46aff27333",
       "@_kindref": "member"
      }
     ],
     "#text": "This function, along with, is called byif needed for \"hard\" compensation."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "allocated Swr context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "count"
        },
        "parameterdescription": {
         "para": "number of samples to be dropped"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": ">= 0 on success, or a negative AVERROR code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "445",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "445",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1ga4733ed4779ed3e30379de2a6ef8de837",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Injects the specified number of silence samples.\n *\n * This function, along with swr_drop_output(), is called by swr_next_pts()\n * if needed for \"hard\" compensation.\n *\n * @param s     allocated Swr context\n * @param count number of samples to be dropped\n *\n * @return >= 0 on success, or a negative AVERROR code on failure\n */"
 },
 "swr_get_delay": {
  "type": "int64_t",
  "definition": "int64_t swr_get_delay",
  "argsstring": "(struct SwrContext *s, int64_t base)",
  "name": "swr_get_delay",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": "int64_t",
    "declname": "base"
   }
  ],
  "briefdescription": {
   "para": "Gets the delay the next input sample will experience relative to the next output sample."
  },
  "detaileddescription": {
   "para": [
    "Swresample can buffer data if more input has been provided than available output space, also converting between sample rates needs a delay. This function returns the sum of all such delays. The exact delay is not necessarily an integer value in either input or output sample rate. Especially when downsampling by a large value, the output sample rate may be a poor choice to represent the delay, similarly for upsampling and the input sample rate.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "swr context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "base"
        },
        "parameterdescription": {
         "para": {
          "itemizedlist": {
           "listitem": [
            {
             "para": "if it's set to 1 the returned delay is in seconds"
            },
            {
             "para": "if it's set to 1000 the returned delay is in milliseconds"
            },
            {
             "para": "if it's set to the input sample rate then the returned delay is in input samples"
            },
            {
             "para": "if it's set to the output sample rate then the returned delay is in output samples"
            },
            {
             "para": "if it's the least common multiple of in_sample_rate and out_sample_rate then an exact rounding-free delay will be returned"
            }
           ]
          },
          "#text": "timebase in which the returned delay will be:"
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "computeroutput": "base",
       "#text": "the delay in 1 /units."
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "471",
   "@_column": "9",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "471",
   "@_declcolumn": "9"
  },
  "referencedby": [
   {
    "#text": "main",
    "@_refid": "resample__audio_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "resample__audio_8c",
    "@_startline": "85",
    "@_endline": "220"
   },
   {
    "#text": "write_audio_frame",
    "@_refid": "mux_8c_1a789f35413429ab70610c90c22fc7a4d3",
    "@_compoundref": "mux_8c",
    "@_startline": "336",
    "@_endline": "376"
   }
  ],
  "@_kind": "function",
  "@_id": "group__lswr_1ga5121a5a7890a2d23b72dc871dd0ebb06",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Gets the delay the next input sample will experience relative to the next output sample.\n *\n * Swresample can buffer data if more input has been provided than available\n * output space, also converting between sample rates needs a delay.\n * This function returns the sum of all such delays.\n * The exact delay is not necessarily an integer value in either input or\n * output sample rate. Especially when downsampling by a large value, the\n * output sample rate may be a poor choice to represent the delay, similarly\n * for upsampling and the input sample rate.\n *\n * @param s     swr context\n * @param base  timebase in which the returned delay will be:\n *              @li if it's set to 1 the returned delay is in seconds\n *              @li if it's set to 1000 the returned delay is in milliseconds\n *              @li if it's set to the input sample rate then the returned\n *                  delay is in input samples\n *              @li if it's set to the output sample rate then the returned\n *                  delay is in output samples\n *              @li if it's the least common multiple of in_sample_rate and\n *                  out_sample_rate then an exact rounding-free delay will be\n *                  returned\n * @returns     the delay in 1 / @c base units.\n */"
 },
 "swr_get_out_samples": {
  "type": "int",
  "definition": "int swr_get_out_samples",
  "argsstring": "(struct SwrContext *s, int in_samples)",
  "name": "swr_get_out_samples",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "struct*"
    },
    "declname": "s"
   },
   {
    "type": "int",
    "declname": "in_samples"
   }
  ],
  "briefdescription": {
   "para": "Find an upper bound on the number of samples that the next swr_convert call will output, if called with in_samples of input samples."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "swr_convert()",
       "@_refid": "group__lswr_1gad16a8308503be52a7e2d460983e81460",
       "@_kindref": "member"
      },
      {
       "#text": "swr_get_out_samples()",
       "@_refid": "group__lswr_1ga97a8d5f6abe3bcdfb6072412f17285a4",
       "@_kindref": "member"
      }
     ],
     "#text": "This depends on the internal state, and anything changing the internal state (like furthercalls) will may change the number of samplesreturns for the same number of input samples."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "in_samples"
       },
       "parameterdescription": {
        "para": "number of input samples."
       }
      },
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": {
        "ref": [
         {
          "#text": "swr_inject_silence()",
          "@_refid": "group__lswr_1ga4733ed4779ed3e30379de2a6ef8de837",
          "@_kindref": "member"
         },
         {
          "#text": "swr_convert()",
          "@_refid": "group__lswr_1gad16a8308503be52a7e2d460983e81460",
          "@_kindref": "member"
         },
         {
          "#text": "swr_next_pts()",
          "@_refid": "group__lswr_1gaad9811626c6c01a241f6bf46aff27333",
          "@_kindref": "member"
         },
         {
          "#text": "swr_set_compensation()",
          "@_refid": "group__lswr_1gab7f21690522b85d7757e13fa9853d4d8",
          "@_kindref": "member"
         }
        ],
        "#text": "any call to,,orinvalidates this limit"
       },
       "@_kind": "note"
      },
      {
       "para": {
        "ref": [
         {
          "#text": "swr_convert()",
          "@_refid": "group__lswr_1gad16a8308503be52a7e2d460983e81460",
          "@_kindref": "member"
         },
         {
          "#text": "swr_get_out_samples()",
          "@_refid": "group__lswr_1ga97a8d5f6abe3bcdfb6072412f17285a4",
          "@_kindref": "member"
         }
        ],
        "#text": "it is recommended to pass the correct available buffer size to all functions likeeven ifindicates that less would be used."
       },
       "@_kind": "note"
      },
      {
       "para": "an upper bound on the number of samples that the next swr_convert will output or a negative value to indicate an error",
       "@_kind": "return"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "489",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "489",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1ga97a8d5f6abe3bcdfb6072412f17285a4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find an upper bound on the number of samples that the next swr_convert\n * call will output, if called with in_samples of input samples. This\n * depends on the internal state, and anything changing the internal state\n * (like further swr_convert() calls) will may change the number of samples\n * swr_get_out_samples() returns for the same number of input samples.\n *\n * @param in_samples    number of input samples.\n * @note any call to swr_inject_silence(), swr_convert(), swr_next_pts()\n *       or swr_set_compensation() invalidates this limit\n * @note it is recommended to pass the correct available buffer size\n *       to all functions like swr_convert() even if swr_get_out_samples()\n *       indicates that less would be used.\n * @returns an upper bound on the number of samples that the next swr_convert\n *          will output or a negative value to indicate an error\n */"
 },
 "swresample_version": {
  "type": "unsigned",
  "definition": "unsigned swresample_version",
  "argsstring": "(void)",
  "name": "swresample_version",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "LIBSWRESAMPLE_VERSION_INT",
     "@_refid": "libswresample_2version_8h_1a6172452a08ba6386e2265bd34769982b",
     "@_kindref": "member"
    },
    "#text": "Return theconstant."
   }
  },
  "detaileddescription": {
   "para": [
    "This is useful to check if the build-time libswresample has the same version as the run-time one.",
    {
     "simplesect": {
      "para": "the unsigned int-typed version",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "506",
   "@_column": "10",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "506",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1gaed39c2153a1e26b4ef656ec8c765a2e3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the @ref LIBSWRESAMPLE_VERSION_INT constant.\n *\n * This is useful to check if the build-time libswresample has the same version\n * as the run-time one.\n *\n * @returns     the unsigned int-typed version\n */"
 },
 "swresample_configuration": {
  "type": "const char *",
  "definition": "const char * swresample_configuration",
  "argsstring": "(void)",
  "name": "swresample_configuration",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the swr build-time configuration."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "computeroutput": "",
      "#text": "the build-time./configure flags"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "513",
   "@_column": "12",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "513",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1gacb05ad2022842645a473d46212461be7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the swr build-time configuration.\n *\n * @returns     the build-time @c ./configure flags\n */"
 },
 "swresample_license": {
  "type": "const char *",
  "definition": "const char * swresample_license",
  "argsstring": "(void)",
  "name": "swresample_license",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the swr license."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "the license of libswresample, determined at build-time",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "520",
   "@_column": "12",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "520",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1ga138666c7d154a3b3a10cfe490b752266",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the swr license.\n *\n * @returns     the license of libswresample, determined at build-time\n */"
 },
 "swr_convert_frame": {
  "type": "int",
  "definition": "int swr_convert_frame",
  "argsstring": "(SwrContext *swr, AVFrame *output, const AVFrame *input)",
  "name": "swr_convert_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "swr"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "output"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "input"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     }
    ],
    "#text": "Convert the samples in the inputand write them to the output."
   }
  },
  "detaileddescription": {
   "para": [
    "Input and output AVFrames must have channel_layout, sample_rate and format set.",
    {
     "ref": [
      {
       "#text": "AVFrame",
       "@_refid": "structAVFrame",
       "@_kindref": "compound"
      },
      {
       "#text": "av_frame_get_buffer()",
       "@_refid": "group__lavu__frame_1ga6b1acbfa82c79bf7fd78d868572f0ceb",
       "@_kindref": "member"
      }
     ],
     "#text": "If the outputdoes not have the data pointers allocated the nb_samples field will be set usingis called to allocate the frame."
    },
    {
     "ref": [
      {
       "#text": "AVFrame",
       "@_refid": "structAVFrame",
       "@_kindref": "compound"
      },
      {
       "#text": "swr_convert()",
       "@_refid": "group__lswr_1gad16a8308503be52a7e2d460983e81460",
       "@_kindref": "member"
      }
     ],
     "#text": "The outputcan be NULL or have fewer allocated samples than required. In this case, any remaining samples not written to the output will be added to an internal FIFO buffer, to be returned at the next call to this function or to."
    },
    {
     "ref": [
      {
       "#text": "swr_get_delay()",
       "@_refid": "group__lswr_1ga5121a5a7890a2d23b72dc871dd0ebb06",
       "@_kindref": "member"
      },
      {
       "#text": "swr_convert()",
       "@_refid": "group__lswr_1gad16a8308503be52a7e2d460983e81460",
       "@_kindref": "member"
      }
     ],
     "#text": "If converting sample rate, there may be data remaining in the internal resampling delay buffer.tells the number of remaining samples. To get this data as output, call this function orwith NULL input."
    },
    {
     "ref": [
      {
       "#text": "AVFrame",
       "@_refid": "structAVFrame",
       "@_kindref": "compound"
      },
      {
       "#text": "AVFrame",
       "@_refid": "structAVFrame",
       "@_kindref": "compound"
      }
     ],
     "#text": "If the SwrContext configuration does not match the output and inputsettings the conversion does not take place and depending on whichis not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED or the result of a bitwise-OR of them is returned."
    },
    {
     "simplesect": [
      {
       "para": "swr_delay()",
       "@_kind": "see"
      },
      {
       "para": {
        "ref": {
         "#text": "swr_convert()",
         "@_refid": "group__lswr_1gad16a8308503be52a7e2d460983e81460",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      },
      {
       "para": {
        "ref": {
         "#text": "swr_get_delay()",
         "@_refid": "group__lswr_1ga5121a5a7890a2d23b72dc871dd0ebb06",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      },
      {
       "para": "0 on success, AVERROR on failure or nonmatching configuration.",
       "@_kind": "return"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "swr"
        },
        "parameterdescription": {
         "para": "audio resample context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "output"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVFrame",
           "@_refid": "structAVFrame",
           "@_kindref": "compound"
          },
          "#text": "output"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "input"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVFrame",
           "@_refid": "structAVFrame",
           "@_kindref": "compound"
          },
          "#text": "input"
         }
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "563",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "563",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1gac482028c01d95580106183aa84b0930c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert the samples in the input AVFrame and write them to the output AVFrame.\n *\n * Input and output AVFrames must have channel_layout, sample_rate and format set.\n *\n * If the output AVFrame does not have the data pointers allocated the nb_samples\n * field will be set using av_frame_get_buffer()\n * is called to allocate the frame.\n *\n * The output AVFrame can be NULL or have fewer allocated samples than required.\n * In this case, any remaining samples not written to the output will be added\n * to an internal FIFO buffer, to be returned at the next call to this function\n * or to swr_convert().\n *\n * If converting sample rate, there may be data remaining in the internal\n * resampling delay buffer. swr_get_delay() tells the number of\n * remaining samples. To get this data as output, call this function or\n * swr_convert() with NULL input.\n *\n * If the SwrContext configuration does not match the output and\n * input AVFrame settings the conversion does not take place and depending on\n * which AVFrame is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED\n * or the result of a bitwise-OR of them is returned.\n *\n * @see swr_delay()\n * @see swr_convert()\n * @see swr_get_delay()\n *\n * @param swr             audio resample context\n * @param output          output AVFrame\n * @param input           input AVFrame\n * @return                0 on success, AVERROR on failure or nonmatching\n *                        configuration.\n */"
 },
 "swr_config_frame": {
  "type": "int",
  "definition": "int swr_config_frame",
  "argsstring": "(SwrContext *swr, const AVFrame *out, const AVFrame *in)",
  "name": "swr_config_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwrContext",
      "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "swr"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "out"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "in"
   }
  ],
  "briefdescription": {
   "para": "Configure or reconfigure the SwrContext using the information provided by the AVFrames."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "swr_close()",
      "@_refid": "group__lswr_1gaa4bf1048740dfc08d68aba9f1b4db22e",
      "@_kindref": "member"
     },
     "#text": "The original resampling context is reset even on failure. The function callsinternally if the context is open."
    },
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "swr_close()",
         "@_refid": "group__lswr_1gaa4bf1048740dfc08d68aba9f1b4db22e",
         "@_kindref": "member"
        },
        "#text": ";"
       },
       "@_kind": "see"
      },
      {
       "para": "0 on success, AVERROR on failure.",
       "@_kind": "return"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "swr"
        },
        "parameterdescription": {
         "para": "audio resample context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "out"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVFrame",
           "@_refid": "structAVFrame",
           "@_kindref": "compound"
          },
          "#text": "output"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "in"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVFrame",
           "@_refid": "structAVFrame",
           "@_kindref": "compound"
          },
          "#text": "input"
         }
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "580",
   "@_column": "5",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "580",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1ga73ade2cf6934765cf518c6c917b77c76",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Configure or reconfigure the SwrContext using the information\n * provided by the AVFrames.\n *\n * The original resampling context is reset even on failure.\n * The function calls swr_close() internally if the context is open.\n *\n * @see swr_close();\n *\n * @param swr             audio resample context\n * @param out             output AVFrame\n * @param in              input AVFrame\n * @return                0 on success, AVERROR on failure.\n */"
 },
 "SwrContext": {
  "type": {
   "ref": {
    "#text": "SwrContext",
    "@_refid": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct SwrContext SwrContext",
  "argsstring": "",
  "name": "SwrContext",
  "briefdescription": {
   "para": "The libswresample context."
  },
  "detaileddescription": {
   "para": {
    "ref": {
     "#text": "AVOptions",
     "@_refid": "group__avoptions",
     "@_kindref": "compound"
    },
    "#text": "Unlike libavcodec and libavformat, this structure is opaque. This means that if you would like to set options, you must use theAPI and cannot directly set values to members of the structure."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "189",
   "@_column": "25",
   "@_bodyfile": "libswresample/swresample.h",
   "@_bodystart": "189",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lswr_1ga4aa775b7fba31d2c8dc14c7b7e282863",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * The libswresample context. Unlike libavcodec and libavformat, this structure\n * is opaque. This means that if you would like to set options, you must use\n * the @ref avoptions API and cannot directly set values to members of the\n * structure.\n */"
 },
 "swr_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * swr_get_class",
  "argsstring": "(void)",
  "name": "swr_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVClass",
     "@_refid": "structAVClass",
     "@_kindref": "compound"
    },
    "#text": "Get thefor SwrContext."
   }
  },
  "detaileddescription": {
   "para": [
    "It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.",
    {
     "simplesect": [
      {
       "para": {
        "ref": {
         "#text": "av_opt_find()",
         "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
         "@_kindref": "member"
        },
        "#text": "."
       },
       "@_kind": "see"
      },
      {
       "para": {
        "ref": {
         "#text": "AVClass",
         "@_refid": "structAVClass",
         "@_kindref": "compound"
        },
        "#text": "theof SwrContext"
       },
       "@_kind": "return"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswresample/swresample.h",
   "@_line": "198",
   "@_column": "15",
   "@_declfile": "libswresample/swresample.h",
   "@_declline": "198",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__lswr_1gaabeac14d6aa684de193c65b6e34c4901",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVClass for SwrContext. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n * @return the AVClass of SwrContext\n */"
 },
 "swscale_version": {
  "type": "unsigned",
  "definition": "unsigned swscale_version",
  "argsstring": "(void)",
  "name": "swscale_version",
  "param": {
   "type": "void"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "52",
   "@_column": "10",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "52",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1gac879a3ada8130d32ba02a9265bfef253",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @defgroup libsws libswscale\n * Color conversion and scaling library.\n *\n * @{\n *\n * Return the LIBSWSCALE_VERSION_INT constant.\n */"
 },
 "swscale_configuration": {
  "type": "const char *",
  "definition": "const char * swscale_configuration",
  "argsstring": "(void)",
  "name": "swscale_configuration",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libswscale build-time configuration."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "57",
   "@_column": "12",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "57",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1gab2d9cdff8aba8e5bb9e3691de864dc52",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libswscale build-time configuration.\n */"
 },
 "swscale_license": {
  "type": "const char *",
  "definition": "const char * swscale_license",
  "argsstring": "(void)",
  "name": "swscale_license",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Return the libswscale license."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "62",
   "@_column": "12",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "62",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga5bc0b8f0d5c6702635fc93105208a0f9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the libswscale license.\n */"
 },
 "sws_getCoefficients": {
  "type": "const int *",
  "definition": "const int * sws_getCoefficients",
  "argsstring": "(int colorspace)",
  "name": "sws_getCoefficients",
  "param": {
   "type": "int",
   "declname": "colorspace"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "sws_setColorspaceDetails()",
     "@_refid": "group__libsws_1ga541bdffa8149f5f9203664f955faa040",
     "@_kindref": "member"
    },
    "#text": "Return a pointer to yuv<->rgb coefficients for the given colorspace suitable for."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "colorspace"
      },
      "parameterdescription": {
       "para": "One of the SWS_CS_* macros. If invalid, SWS_CS_DEFAULT is used."
      }
     },
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "112",
   "@_column": "11",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "112",
   "@_declcolumn": "11"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga8c2a7d79bda5281ee2acdda359379f9e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return a pointer to yuv<->rgb coefficients for the given colorspace\n * suitable for sws_setColorspaceDetails().\n *\n * @param colorspace One of the SWS_CS_* macros. If invalid,\n * SWS_CS_DEFAULT is used.\n */"
 },
 "sws_isSupportedInput": {
  "type": "int",
  "definition": "int sws_isSupportedInput",
  "argsstring": "(enum AVPixelFormat pix_fmt)",
  "name": "sws_isSupportedInput",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixelFormat",
     "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "pix_fmt"
  },
  "briefdescription": {
   "para": "Return a positive value if pix_fmt is a supported input format, 0 otherwise."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "135",
   "@_column": "5",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "135",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1gab5e631b602510bd3fa3a5a7d509e573d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return a positive value if pix_fmt is a supported input format, 0\n * otherwise.\n */"
 },
 "sws_isSupportedOutput": {
  "type": "int",
  "definition": "int sws_isSupportedOutput",
  "argsstring": "(enum AVPixelFormat pix_fmt)",
  "name": "sws_isSupportedOutput",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixelFormat",
     "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "pix_fmt"
  },
  "briefdescription": {
   "para": "Return a positive value if pix_fmt is a supported output format, 0 otherwise."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "141",
   "@_column": "5",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "141",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga6885dc8ec36e8f2e701924263aa92cb0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return a positive value if pix_fmt is a supported output format, 0\n * otherwise.\n */"
 },
 "sws_isSupportedEndiannessConversion": {
  "type": "int",
  "definition": "int sws_isSupportedEndiannessConversion",
  "argsstring": "(enum AVPixelFormat pix_fmt)",
  "name": "sws_isSupportedEndiannessConversion",
  "param": {
   "type": {
    "ref": {
     "#text": "AVPixelFormat",
     "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
     "@_kindref": "member"
    },
    "#text": "enum"
   },
   "declname": "pix_fmt"
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": {
        "#text": "pix_fmt",
        "@_direction": "in"
       }
      },
      "parameterdescription": {
       "para": "the pixel format"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "a positive value if an endianness conversion for pix_fmt is supported, 0 otherwise.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "148",
   "@_column": "5",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "148",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga67f865ce22ae986ea84f4d7ce60ef182",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @param[in]  pix_fmt the pixel format\n * @return a positive value if an endianness conversion for pix_fmt is\n * supported, 0 otherwise.\n */"
 },
 "sws_alloc_context": {
  "type": "struct SwsContext *",
  "definition": "struct SwsContext * sws_alloc_context",
  "argsstring": "(void)",
  "name": "sws_alloc_context",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an empty SwsContext."
  },
  "detaileddescription": {
   "para": {
    "ref": [
     {
      "#text": "sws_init_context()",
      "@_refid": "group__libsws_1ga2120f2a4fb3aa075cb0aff06eb5b55cb",
      "@_kindref": "member"
     },
     {
      "#text": "sws_setColorspaceDetails()",
      "@_refid": "group__libsws_1ga541bdffa8149f5f9203664f955faa040",
      "@_kindref": "member"
     }
    ],
    "#text": "This must be filled and passed to. For filling see AVOptions, options.c and."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "155",
   "@_column": "17",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "155",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1gaa01c5d817e4edae0691df48dba612cb8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an empty SwsContext. This must be filled and passed to\n * sws_init_context(). For filling see AVOptions, options.c and\n * sws_setColorspaceDetails().\n */"
 },
 "sws_init_context": {
  "type": {
   "ref": {
    "#text": "av_warn_unused_result",
    "@_refid": "attributes_8h_1a93f17e0f0b53a66e7b5eceb3dff2918f",
    "@_kindref": "member"
   },
   "#text": "int"
  },
  "definition": "av_warn_unused_result int sws_init_context",
  "argsstring": "(struct SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)",
  "name": "sws_init_context",
  "param": [
   {
    "type": "struct SwsContext *",
    "declname": "sws_context"
   },
   {
    "type": {
     "ref": {
      "#text": "SwsFilter",
      "@_refid": "structSwsFilter",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "srcFilter"
   },
   {
    "type": {
     "ref": {
      "#text": "SwsFilter",
      "@_refid": "structSwsFilter",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dstFilter"
   }
  ],
  "briefdescription": {
   "para": "Initialize the swscaler context sws_context."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "zero or positive value on success, a negative value on error",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "164",
   "@_column": "5",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "164",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga2120f2a4fb3aa075cb0aff06eb5b55cb",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize the swscaler context sws_context.\n *\n * @return zero or positive value on success, a negative value on\n * error\n */"
 },
 "sws_freeContext": {
  "type": "void",
  "definition": "void sws_freeContext",
  "argsstring": "(struct SwsContext *swsContext)",
  "name": "sws_freeContext",
  "param": {
   "type": "struct SwsContext *",
   "declname": "swsContext"
  },
  "briefdescription": {
   "para": "Free the swscaler context swsContext."
  },
  "detaileddescription": {
   "para": "If swsContext is NULL, then does nothing."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "170",
   "@_column": "6",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "170",
   "@_declcolumn": "6"
  },
  "referencedby": [
   {
    "#text": "close_stream",
    "@_refid": "mux_8c_1a92d8b2751255677797d807161fae9d19",
    "@_compoundref": "mux_8c",
    "@_startline": "521",
    "@_endline": "529"
   },
   {
    "#text": "main",
    "@_refid": "scale__video_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "scale__video_8c",
    "@_startline": "53",
    "@_endline": "141"
   }
  ],
  "@_kind": "function",
  "@_id": "group__libsws_1gad3af0ca76f071dbe0173444db9882932",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the swscaler context swsContext.\n * If swsContext is NULL, then does nothing.\n */"
 },
 "sws_getContext": {
  "type": "struct SwsContext *",
  "definition": "struct SwsContext * sws_getContext",
  "argsstring": "(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)",
  "name": "sws_getContext",
  "param": [
   {
    "type": "int",
    "declname": "srcW"
   },
   {
    "type": "int",
    "declname": "srcH"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "srcFormat"
   },
   {
    "type": "int",
    "declname": "dstW"
   },
   {
    "type": "int",
    "declname": "dstH"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "dstFormat"
   },
   {
    "type": "int",
    "declname": "flags"
   },
   {
    "type": {
     "ref": {
      "#text": "SwsFilter",
      "@_refid": "structSwsFilter",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "srcFilter"
   },
   {
    "type": {
     "ref": {
      "#text": "SwsFilter",
      "@_refid": "structSwsFilter",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dstFilter"
   },
   {
    "type": "const double *",
    "declname": "param"
   }
  ],
  "briefdescription": {
   "para": "Allocate and return an SwsContext."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "sws_scale()",
      "@_refid": "group__libsws_1gae531c9754c9205d90ad6800015046d74",
      "@_kindref": "member"
     },
     "#text": "You need it to perform scaling/conversion operations using."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "srcW"
        },
        "parameterdescription": {
         "para": "the width of the source image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "srcH"
        },
        "parameterdescription": {
         "para": "the height of the source image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "srcFormat"
        },
        "parameterdescription": {
         "para": "the source image format"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dstW"
        },
        "parameterdescription": {
         "para": "the width of the destination image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dstH"
        },
        "parameterdescription": {
         "para": "the height of the destination image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dstFormat"
        },
        "parameterdescription": {
         "para": "the destination image format"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "specify which algorithm and options to use for rescaling"
        }
       },
       {
        "parameternamelist": {
         "parametername": "param"
        },
        "parameterdescription": {
         "para": "extra parameters to tune the used scaler For SWS_BICUBIC param[0] and [1] tune the shape of the basis function, param[0] tunes f(1) and param[1] f(1) For SWS_GAUSS param[0] tunes the exponent and thus cutoff frequency For SWS_LANCZOS param[0] tunes the width of the window function"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "a pointer to an allocated context, or NULL in case of error",
       "@_kind": "return"
      },
      {
       "para": "this function is to be removed after a saner alternative is written",
       "@_kind": "note"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "193",
   "@_column": "17",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "193",
   "@_declcolumn": "17"
  },
  "referencedby": [
   {
    "#text": "get_video_frame",
    "@_refid": "mux_8c_1a21ef8534b79178d738919f5b1b14c37f",
    "@_compoundref": "mux_8c",
    "@_startline": "470",
    "@_endline": "510"
   },
   {
    "#text": "main",
    "@_refid": "scale__video_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "scale__video_8c",
    "@_startline": "53",
    "@_endline": "141"
   }
  ],
  "@_kind": "function",
  "@_id": "group__libsws_1ga638914a845d4e4fe683cec3caaff734e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate and return an SwsContext. You need it to perform\n * scaling/conversion operations using sws_scale().\n *\n * @param srcW the width of the source image\n * @param srcH the height of the source image\n * @param srcFormat the source image format\n * @param dstW the width of the destination image\n * @param dstH the height of the destination image\n * @param dstFormat the destination image format\n * @param flags specify which algorithm and options to use for rescaling\n * @param param extra parameters to tune the used scaler\n *              For SWS_BICUBIC param[0] and [1] tune the shape of the basis\n *              function, param[0] tunes f(1) and param[1] f(1)\n *              For SWS_GAUSS param[0] tunes the exponent and thus cutoff\n *              frequency\n *              For SWS_LANCZOS param[0] tunes the width of the window function\n * @return a pointer to an allocated context, or NULL in case of error\n * @note this function is to be removed after a saner alternative is\n *       written\n */"
 },
 "sws_scale": {
  "type": "int",
  "definition": "int sws_scale",
  "argsstring": "(struct SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])",
  "name": "sws_scale",
  "param": [
   {
    "type": "struct SwsContext *",
    "declname": "c"
   },
   {
    "type": "const uint8_t *const",
    "declname": "srcSlice",
    "array": "[]"
   },
   {
    "type": "const int",
    "declname": "srcStride",
    "array": "[]"
   },
   {
    "type": "int",
    "declname": "srcSliceY"
   },
   {
    "type": "int",
    "declname": "srcSliceH"
   },
   {
    "type": "uint8_t *const",
    "declname": "dst",
    "array": "[]"
   },
   {
    "type": "const int",
    "declname": "dstStride",
    "array": "[]"
   }
  ],
  "briefdescription": {
   "para": "Scale the image slice in srcSlice and put the resulting scaled slice in the image in dst."
  },
  "detaileddescription": {
   "para": [
    "A slice is a sequence of consecutive rows in an image.",
    "Slices have to be provided in sequential order, either in top-bottom or bottom-top order. If slices are provided in non-sequential order the behavior of the function is undefined.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "c"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "sws_getContext()",
           "@_refid": "group__libsws_1ga638914a845d4e4fe683cec3caaff734e",
           "@_kindref": "member"
          },
          "#text": "the scaling context previously created with"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "srcSlice"
        },
        "parameterdescription": {
         "para": "the array containing the pointers to the planes of the source slice"
        }
       },
       {
        "parameternamelist": {
         "parametername": "srcStride"
        },
        "parameterdescription": {
         "para": "the array containing the strides for each plane of the source image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "srcSliceY"
        },
        "parameterdescription": {
         "para": "the position in the source image of the slice to process, that is the number (counted starting from zero) in the image of the first row of the slice"
        }
       },
       {
        "parameternamelist": {
         "parametername": "srcSliceH"
        },
        "parameterdescription": {
         "para": "the height of the source slice, that is the number of rows in the slice"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "the array containing the pointers to the planes of the destination image"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dstStride"
        },
        "parameterdescription": {
         "para": "the array containing the strides for each plane of the destination image"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the height of the output slice",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "224",
   "@_column": "5",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "224",
   "@_declcolumn": "5"
  },
  "referencedby": [
   {
    "#text": "get_video_frame",
    "@_refid": "mux_8c_1a21ef8534b79178d738919f5b1b14c37f",
    "@_compoundref": "mux_8c",
    "@_startline": "470",
    "@_endline": "510"
   },
   {
    "#text": "main",
    "@_refid": "scale__video_8c_1a3c04138a5bfe5d72780bb7e82a18e627",
    "@_compoundref": "scale__video_8c",
    "@_startline": "53",
    "@_endline": "141"
   }
  ],
  "@_kind": "function",
  "@_id": "group__libsws_1gae531c9754c9205d90ad6800015046d74",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Scale the image slice in srcSlice and put the resulting scaled\n * slice in the image in dst. A slice is a sequence of consecutive\n * rows in an image.\n *\n * Slices have to be provided in sequential order, either in\n * top-bottom or bottom-top order. If slices are provided in\n * non-sequential order the behavior of the function is undefined.\n *\n * @param c         the scaling context previously created with\n *                  sws_getContext()\n * @param srcSlice  the array containing the pointers to the planes of\n *                  the source slice\n * @param srcStride the array containing the strides for each plane of\n *                  the source image\n * @param srcSliceY the position in the source image of the slice to\n *                  process, that is the number (counted starting from\n *                  zero) in the image of the first row of the slice\n * @param srcSliceH the height of the source slice, that is the number\n *                  of rows in the slice\n * @param dst       the array containing the pointers to the planes of\n *                  the destination image\n * @param dstStride the array containing the strides for each plane of\n *                  the destination image\n * @return          the height of the output slice\n */"
 },
 "sws_scale_frame": {
  "type": "int",
  "definition": "int sws_scale_frame",
  "argsstring": "(struct SwsContext *c, AVFrame *dst, const AVFrame *src)",
  "name": "sws_scale_frame",
  "param": [
   {
    "type": "struct SwsContext *",
    "declname": "c"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Scale source data from src and write the output to dst."
  },
  "detaileddescription": {
   "para": [
    {
     "itemizedlist": {
      "listitem": [
       {
        "para": {
         "ref": {
          "#text": "sws_frame_start()",
          "@_refid": "group__libsws_1gac044560a3a0738bb4b42071f00c1dd72",
          "@_kindref": "member"
         }
        }
       },
       {
        "para": "sws_send_slice(0, src->height)"
       },
       {
        "para": "sws_receive_slice(0, dst->height)"
       },
       {
        "para": {
         "ref": {
          "#text": "sws_frame_end()",
          "@_refid": "group__libsws_1ga47d466aec2f09637e113ceec2fbaaf22",
          "@_kindref": "member"
         }
        }
       }
      ]
     },
     "#text": "This is merely a convenience wrapper around"
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "c"
        },
        "parameterdescription": {
         "para": "The scaling context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "sws_frame_start()",
           "@_refid": "group__libsws_1gac044560a3a0738bb4b42071f00c1dd72",
           "@_kindref": "member"
          },
          "#text": "The destination frame. See documentation forfor more details."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "The source frame."
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, a negative AVERROR code on failure",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "244",
   "@_column": "5",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "244",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga1c72fcf83bd57aea72cf3dadfcf02541",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Scale source data from src and write the output to dst.\n *\n * This is merely a convenience wrapper around\n * - sws_frame_start()\n * - sws_send_slice(0, src->height)\n * - sws_receive_slice(0, dst->height)\n * - sws_frame_end()\n *\n * @param c   The scaling context\n * @param dst The destination frame. See documentation for sws_frame_start() for\n *            more details.\n * @param src The source frame.\n *\n * @return 0 on success, a negative AVERROR code on failure\n */"
 },
 "sws_frame_start": {
  "type": "int",
  "definition": "int sws_frame_start",
  "argsstring": "(struct SwsContext *c, AVFrame *dst, const AVFrame *src)",
  "name": "sws_frame_start",
  "param": [
   {
    "type": "struct SwsContext *",
    "declname": "c"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dst"
   },
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Initialize the scaling process for a given pair of source/destination frames."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "sws_send_slice()",
       "@_refid": "group__libsws_1ga1b3865c22752942617d5003b25337695",
       "@_kindref": "member"
      },
      {
       "#text": "sws_receive_slice()",
       "@_refid": "group__libsws_1ga81800047411d2adb822a6f0f4642336c",
       "@_kindref": "member"
      }
     ],
     "#text": "Must be called before any calls toand."
    },
    "This function will retain references to src and dst, so they must both use refcounted buffers (if allocated by the caller, in case of dst).",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "c"
        },
        "parameterdescription": {
         "para": "The scaling context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": {
          "verbatim": "The data buffers may either be already allocated by the caller or\n       left clear, in which case they will be allocated by the scaler.\n       The latter may have performance advantages - e.g. in certain cases\n       some output planes may be references to input planes, rather than\n       copies.\n\n       Output data will be written into this frame in successful\n       sws_receive_slice() calls.",
          "#text": "The destination frame."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "sws_send_slice()",
           "@_refid": "group__libsws_1ga1b3865c22752942617d5003b25337695",
           "@_kindref": "member"
          },
          "#text": "The source frame. The data buffers must be allocated, but the frame data does not have to be ready at this point. Data availability is then signalled by."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": [
      {
       "para": "0 on success, a negative AVERROR code on failure",
       "@_kind": "return"
      },
      {
       "para": {
        "ref": {
         "#text": "sws_frame_end()",
         "@_refid": "group__libsws_1ga47d466aec2f09637e113ceec2fbaaf22",
         "@_kindref": "member"
        }
       },
       "@_kind": "see"
      }
     ]
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "271",
   "@_column": "5",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "271",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1gac044560a3a0738bb4b42071f00c1dd72",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize the scaling process for a given pair of source/destination frames.\n * Must be called before any calls to sws_send_slice() and sws_receive_slice().\n *\n * This function will retain references to src and dst, so they must both use\n * refcounted buffers (if allocated by the caller, in case of dst).\n *\n * @param c   The scaling context\n * @param dst The destination frame.\n *\n *            The data buffers may either be already allocated by the caller or\n *            left clear, in which case they will be allocated by the scaler.\n *            The latter may have performance advantages - e.g. in certain cases\n *            some output planes may be references to input planes, rather than\n *            copies.\n *\n *            Output data will be written into this frame in successful\n *            sws_receive_slice() calls.\n * @param src The source frame. The data buffers must be allocated, but the\n *            frame data does not have to be ready at this point. Data\n *            availability is then signalled by sws_send_slice().\n * @return 0 on success, a negative AVERROR code on failure\n *\n * @see sws_frame_end()\n */"
 },
 "sws_frame_end": {
  "type": "void",
  "definition": "void sws_frame_end",
  "argsstring": "(struct SwsContext *c)",
  "name": "sws_frame_end",
  "param": {
   "type": "struct SwsContext *",
   "declname": "c"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "sws_frame_start()",
     "@_refid": "group__libsws_1gac044560a3a0738bb4b42071f00c1dd72",
     "@_kindref": "member"
    },
    "#text": "Finish the scaling process for a pair of source/destination frames previously submitted with."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": [
      {
       "#text": "sws_send_slice()",
       "@_refid": "group__libsws_1ga1b3865c22752942617d5003b25337695",
       "@_kindref": "member"
      },
      {
       "#text": "sws_receive_slice()",
       "@_refid": "group__libsws_1ga81800047411d2adb822a6f0f4642336c",
       "@_kindref": "member"
      },
      {
       "#text": "sws_frame_start()",
       "@_refid": "group__libsws_1gac044560a3a0738bb4b42071f00c1dd72",
       "@_kindref": "member"
      }
     ],
     "#text": "Must be called after allandcalls are done, before any newcalls."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "c"
       },
       "parameterdescription": {
        "para": "The scaling context"
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "281",
   "@_column": "6",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "281",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga47d466aec2f09637e113ceec2fbaaf22",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Finish the scaling process for a pair of source/destination frames previously\n * submitted with sws_frame_start(). Must be called after all sws_send_slice()\n * and sws_receive_slice() calls are done, before any new sws_frame_start()\n * calls.\n *\n * @param c   The scaling context\n */"
 },
 "sws_send_slice": {
  "type": "int",
  "definition": "int sws_send_slice",
  "argsstring": "(struct SwsContext *c, unsigned int slice_start, unsigned int slice_height)",
  "name": "sws_send_slice",
  "param": [
   {
    "type": "struct SwsContext *",
    "declname": "c"
   },
   {
    "type": "unsigned int",
    "declname": "slice_start"
   },
   {
    "type": "unsigned int",
    "declname": "slice_height"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "sws_frame_start()",
     "@_refid": "group__libsws_1gac044560a3a0738bb4b42071f00c1dd72",
     "@_kindref": "member"
    },
    "#text": "Indicate that a horizontal slice of input data is available in the source frame previously provided to."
   }
  },
  "detaileddescription": {
   "para": [
    "The slices may be provided in any order, but may not overlap. For vertically subsampled pixel formats, the slices must be aligned according to subsampling.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "c"
        },
        "parameterdescription": {
         "para": "The scaling context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "slice_start"
        },
        "parameterdescription": {
         "para": "first row of the slice"
        }
       },
       {
        "parameternamelist": {
         "parametername": "slice_height"
        },
        "parameterdescription": {
         "para": "number of rows in the slice"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "a non-negative number on success, a negative AVERROR code on failure.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "295",
   "@_column": "5",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "295",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga1b3865c22752942617d5003b25337695",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Indicate that a horizontal slice of input data is available in the source\n * frame previously provided to sws_frame_start(). The slices may be provided in\n * any order, but may not overlap. For vertically subsampled pixel formats, the\n * slices must be aligned according to subsampling.\n *\n * @param c   The scaling context\n * @param slice_start first row of the slice\n * @param slice_height number of rows in the slice\n *\n * @return a non-negative number on success, a negative AVERROR code on failure.\n */"
 },
 "sws_receive_slice": {
  "type": "int",
  "definition": "int sws_receive_slice",
  "argsstring": "(struct SwsContext *c, unsigned int slice_start, unsigned int slice_height)",
  "name": "sws_receive_slice",
  "param": [
   {
    "type": "struct SwsContext *",
    "declname": "c"
   },
   {
    "type": "unsigned int",
    "declname": "slice_start"
   },
   {
    "type": "unsigned int",
    "declname": "slice_height"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "sws_frame_start()",
     "@_refid": "group__libsws_1gac044560a3a0738bb4b42071f00c1dd72",
     "@_kindref": "member"
    },
    "#text": "Request a horizontal slice of the output data to be written into the frame previously provided to."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "c"
       },
       "parameterdescription": {
        "para": "The scaling context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "slice_start"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "sws_receive_slice_alignment()",
          "@_refid": "group__libsws_1ga212314a1424ec5cbaf4d7b8988b73961",
          "@_kindref": "member"
         },
         "#text": "first row of the slice; must be a multiple of"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "slice_height"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "sws_receive_slice_alignment()",
          "@_refid": "group__libsws_1ga212314a1424ec5cbaf4d7b8988b73961",
          "@_kindref": "member"
         },
         "#text": "number of rows in the slice; must be a multiple of, except for the last slice (i.e. when slice_start+slice_height is equal to output frame height)"
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVERROR(EAGAIN)",
       "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
       "@_kindref": "member"
      },
      "#text": "a non-negative number if the data was successfully written into the outputif more input data needs to be provided before the output can be produced another negative AVERROR code on other kinds of scaling failure"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "315",
   "@_column": "5",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "315",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga81800047411d2adb822a6f0f4642336c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Request a horizontal slice of the output data to be written into the frame\n * previously provided to sws_frame_start().\n *\n * @param c   The scaling context\n * @param slice_start first row of the slice; must be a multiple of\n *                    sws_receive_slice_alignment()\n * @param slice_height number of rows in the slice; must be a multiple of\n *                     sws_receive_slice_alignment(), except for the last slice\n *                     (i.e. when slice_start+slice_height is equal to output\n *                     frame height)\n *\n * @return a non-negative number if the data was successfully written into the output\n *         AVERROR(EAGAIN) if more input data needs to be provided before the\n *                         output can be produced\n *         another negative AVERROR code on other kinds of scaling failure\n */"
 },
 "sws_receive_slice_alignment": {
  "type": "unsigned int",
  "definition": "unsigned int sws_receive_slice_alignment",
  "argsstring": "(const struct SwsContext *c)",
  "name": "sws_receive_slice_alignment",
  "param": {
   "type": "const struct SwsContext *",
   "declname": "c"
  },
  "briefdescription": {
   "para": "Get the alignment required for slices."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "c"
      },
      "parameterdescription": {
       "para": "The scaling context"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": [
       {
        "#text": "sws_receive_slice()",
        "@_refid": "group__libsws_1ga81800047411d2adb822a6f0f4642336c",
        "@_kindref": "member"
       },
       {
        "#text": "sws_receive_slice()",
        "@_refid": "group__libsws_1ga81800047411d2adb822a6f0f4642336c",
        "@_kindref": "member"
       }
      ],
      "#text": "alignment required for output slices requested with. Slice offsets and sizes passed tomust be multiples of the value returned from this function."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "326",
   "@_column": "14",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "326",
   "@_declcolumn": "14"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga212314a1424ec5cbaf4d7b8988b73961",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the alignment required for slices\n *\n * @param c   The scaling context\n * @return alignment required for output slices requested with sws_receive_slice().\n *         Slice offsets and sizes passed to sws_receive_slice() must be\n *         multiples of the value returned from this function.\n */"
 },
 "sws_setColorspaceDetails": {
  "type": "int",
  "definition": "int sws_setColorspaceDetails",
  "argsstring": "(struct SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)",
  "name": "sws_setColorspaceDetails",
  "param": [
   {
    "type": "struct SwsContext *",
    "declname": "c"
   },
   {
    "type": "const int",
    "declname": "inv_table",
    "array": "[4]"
   },
   {
    "type": "int",
    "declname": "srcRange"
   },
   {
    "type": "const int",
    "declname": "table",
    "array": "[4]"
   },
   {
    "type": "int",
    "declname": "dstRange"
   },
   {
    "type": "int",
    "declname": "brightness"
   },
   {
    "type": "int",
    "declname": "contrast"
   },
   {
    "type": "int",
    "declname": "saturation"
   }
  ],
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "c"
       },
       "parameterdescription": {
        "para": "the scaling context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dstRange"
       },
       "parameterdescription": {
        "para": "flag indicating the while-black range of the output (1=jpeg / 0=mpeg)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "srcRange"
       },
       "parameterdescription": {
        "para": "flag indicating the while-black range of the input (1=jpeg / 0=mpeg)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "table"
       },
       "parameterdescription": {
        "para": "the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]"
       }
      },
      {
       "parameternamelist": {
        "parametername": "inv_table"
       },
       "parameterdescription": {
        "para": "the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]"
       }
      },
      {
       "parameternamelist": {
        "parametername": "brightness"
       },
       "parameterdescription": {
        "para": "16.16 fixed point brightness correction"
       }
      },
      {
       "parameternamelist": {
        "parametername": "contrast"
       },
       "parameterdescription": {
        "para": "16.16 fixed point contrast correction"
       }
      },
      {
       "parameternamelist": {
        "parametername": "saturation"
       },
       "parameterdescription": {
        "para": "16.16 fixed point saturation correction"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "computeroutput": "LIBSWSCALE_VERSION_MAJOR < 7",
      "#text": "A negative error code on error, non negative otherwise. If, returns -1 if not supported."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "341",
   "@_column": "5",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "341",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga541bdffa8149f5f9203664f955faa040",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @param c the scaling context\n * @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)\n * @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)\n * @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]\n * @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]\n * @param brightness 16.16 fixed point brightness correction\n * @param contrast 16.16 fixed point contrast correction\n * @param saturation 16.16 fixed point saturation correction\n *\n * @return A negative error code on error, non negative otherwise.\n *         If `LIBSWSCALE_VERSION_MAJOR < 7`, returns -1 if not supported.\n */"
 },
 "sws_getColorspaceDetails": {
  "type": "int",
  "definition": "int sws_getColorspaceDetails",
  "argsstring": "(struct SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)",
  "name": "sws_getColorspaceDetails",
  "param": [
   {
    "type": "struct SwsContext *",
    "declname": "c"
   },
   {
    "type": "int **",
    "declname": "inv_table"
   },
   {
    "type": "int *",
    "declname": "srcRange"
   },
   {
    "type": "int **",
    "declname": "table"
   },
   {
    "type": "int *",
    "declname": "dstRange"
   },
   {
    "type": "int *",
    "declname": "brightness"
   },
   {
    "type": "int *",
    "declname": "contrast"
   },
   {
    "type": "int *",
    "declname": "saturation"
   }
  ],
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "computeroutput": "LIBSWSCALE_VERSION_MAJOR < 7",
      "#text": "A negative error code on error, non negative otherwise. If, returns -1 if not supported."
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "349",
   "@_column": "5",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "349",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga098dc4b69a97b616fc35791aec249ff1",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @return A negative error code on error, non negative otherwise.\n *         If `LIBSWSCALE_VERSION_MAJOR < 7`, returns -1 if not supported.\n */"
 },
 "sws_allocVec": {
  "type": {
   "ref": {
    "#text": "SwsVector",
    "@_refid": "structSwsVector",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "SwsVector * sws_allocVec",
  "argsstring": "(int length)",
  "name": "sws_allocVec",
  "param": {
   "type": "int",
   "declname": "length"
  },
  "briefdescription": {
   "para": "Allocate and return an uninitialized vector with length coefficients."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "356",
   "@_column": "11",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "356",
   "@_declcolumn": "11"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga7dfc79582bea9aaf0bcf4bb308c0f3f0",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate and return an uninitialized vector with length coefficients.\n */"
 },
 "sws_getGaussianVec": {
  "type": {
   "ref": {
    "#text": "SwsVector",
    "@_refid": "structSwsVector",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "SwsVector * sws_getGaussianVec",
  "argsstring": "(double variance, double quality)",
  "name": "sws_getGaussianVec",
  "param": [
   {
    "type": "double",
    "declname": "variance"
   },
   {
    "type": "double",
    "declname": "quality"
   }
  ],
  "briefdescription": {
   "para": "Return a normalized Gaussian curve used to filter stuff quality = 3 is high quality, lower is lower quality."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "362",
   "@_column": "11",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "362",
   "@_declcolumn": "11"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga873f630c7ae479fee1597924a2409fcd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return a normalized Gaussian curve used to filter stuff\n * quality = 3 is high quality, lower is lower quality.\n */"
 },
 "sws_scaleVec": {
  "type": "void",
  "definition": "void sws_scaleVec",
  "argsstring": "(SwsVector *a, double scalar)",
  "name": "sws_scaleVec",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwsVector",
      "@_refid": "structSwsVector",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "a"
   },
   {
    "type": "double",
    "declname": "scalar"
   }
  ],
  "briefdescription": {
   "para": "Scale all the coefficients of a by the scalar value."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "367",
   "@_column": "6",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "367",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1gaf79fd6cabde06a0f2d118eb373bf83c6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Scale all the coefficients of a by the scalar value.\n */"
 },
 "sws_normalizeVec": {
  "type": "void",
  "definition": "void sws_normalizeVec",
  "argsstring": "(SwsVector *a, double height)",
  "name": "sws_normalizeVec",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "SwsVector",
      "@_refid": "structSwsVector",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "a"
   },
   {
    "type": "double",
    "declname": "height"
   }
  ],
  "briefdescription": {
   "para": "Scale all the coefficients of a so that their sum equals height."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "372",
   "@_column": "6",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "372",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1gab40ce33fa0a432f1ba57dda9f740380d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Scale all the coefficients of a so that their sum equals height.\n */"
 },
 "sws_freeVec": {
  "type": "void",
  "definition": "void sws_freeVec",
  "argsstring": "(SwsVector *a)",
  "name": "sws_freeVec",
  "param": {
   "type": {
    "ref": {
     "#text": "SwsVector",
     "@_refid": "structSwsVector",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "a"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "374",
   "@_column": "6",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "374",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga5745e8384365fd5c6b0a3241d6ab767b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Scale all the coefficients of a so that their sum equals height.\n */"
 },
 "sws_getDefaultFilter": {
  "type": {
   "ref": {
    "#text": "SwsFilter",
    "@_refid": "structSwsFilter",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "SwsFilter * sws_getDefaultFilter",
  "argsstring": "(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)",
  "name": "sws_getDefaultFilter",
  "param": [
   {
    "type": "float",
    "declname": "lumaGBlur"
   },
   {
    "type": "float",
    "declname": "chromaGBlur"
   },
   {
    "type": "float",
    "declname": "lumaSharpen"
   },
   {
    "type": "float",
    "declname": "chromaSharpen"
   },
   {
    "type": "float",
    "declname": "chromaHShift"
   },
   {
    "type": "float",
    "declname": "chromaVShift"
   },
   {
    "type": "int",
    "declname": "verbose"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "376",
   "@_column": "11",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "376",
   "@_declcolumn": "11"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga62206af736294f8cd90716877223d2af",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Scale all the coefficients of a so that their sum equals height.\n */"
 },
 "sws_freeFilter": {
  "type": "void",
  "definition": "void sws_freeFilter",
  "argsstring": "(SwsFilter *filter)",
  "name": "sws_freeFilter",
  "param": {
   "type": {
    "ref": {
     "#text": "SwsFilter",
     "@_refid": "structSwsFilter",
     "@_kindref": "compound"
    },
    "#text": "*"
   },
   "declname": "filter"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "380",
   "@_column": "6",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "380",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga17b762761f7a53d596841ac0f2d4a2b5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Scale all the coefficients of a so that their sum equals height.\n */"
 },
 "sws_getCachedContext": {
  "type": "struct SwsContext *",
  "definition": "struct SwsContext * sws_getCachedContext",
  "argsstring": "(struct SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)",
  "name": "sws_getCachedContext",
  "param": [
   {
    "type": "struct SwsContext *",
    "declname": "context"
   },
   {
    "type": "int",
    "declname": "srcW"
   },
   {
    "type": "int",
    "declname": "srcH"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "srcFormat"
   },
   {
    "type": "int",
    "declname": "dstW"
   },
   {
    "type": "int",
    "declname": "dstH"
   },
   {
    "type": {
     "ref": {
      "#text": "AVPixelFormat",
      "@_refid": "pixfmt_8h_1a9a8e335cf3be472042bc9f0cf80cd4c5",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "dstFormat"
   },
   {
    "type": "int",
    "declname": "flags"
   },
   {
    "type": {
     "ref": {
      "#text": "SwsFilter",
      "@_refid": "structSwsFilter",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "srcFilter"
   },
   {
    "type": {
     "ref": {
      "#text": "SwsFilter",
      "@_refid": "structSwsFilter",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "dstFilter"
   },
   {
    "type": "const double *",
    "declname": "param"
   }
  ],
  "briefdescription": {
   "para": "Check if context can be reused, otherwise reallocate a new one."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "sws_getContext()",
      "@_refid": "group__libsws_1ga638914a845d4e4fe683cec3caaff734e",
      "@_kindref": "member"
     },
     "#text": "If context is NULL, just callsto get a new context. Otherwise, checks if the parameters are the ones already saved in context. If that is the case, returns the current context. Otherwise, frees context and gets a new context with the new parameters."
    },
    "Be warned that srcFilter and dstFilter are not checked, they are assumed to remain the same."
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "394",
   "@_column": "17",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "394",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga11e2a5826833e5cfe41be62d1a6338ed",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if context can be reused, otherwise reallocate a new one.\n *\n * If context is NULL, just calls sws_getContext() to get a new\n * context. Otherwise, checks if the parameters are the ones already\n * saved in context. If that is the case, returns the current\n * context. Otherwise, frees context and gets a new context with\n * the new parameters.\n *\n * Be warned that srcFilter and dstFilter are not checked, they\n * are assumed to remain the same.\n */"
 },
 "sws_convertPalette8ToPacked32": {
  "type": "void",
  "definition": "void sws_convertPalette8ToPacked32",
  "argsstring": "(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)",
  "name": "sws_convertPalette8ToPacked32",
  "param": [
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "int",
    "declname": "num_pixels"
   },
   {
    "type": "const uint8_t *",
    "declname": "palette"
   }
  ],
  "briefdescription": {
   "para": "Convert an 8-bit paletted frame into a frame with a color depth of 32 bits."
  },
  "detaileddescription": {
   "para": [
    "The output frame will have the same packed format as the palette.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "source frame buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "destination frame buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "num_pixels"
        },
        "parameterdescription": {
         "para": "number of pixels to convert"
        }
       },
       {
        "parameternamelist": {
         "parametername": "palette"
        },
        "parameterdescription": {
         "para": "array with [256] entries, which must match color arrangement (RGB or BGR) of src"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "410",
   "@_column": "6",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "410",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga2a140989dfed29dd91065352b6a52840",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.\n *\n * The output frame will have the same packed format as the palette.\n *\n * @param src        source frame buffer\n * @param dst        destination frame buffer\n * @param num_pixels number of pixels to convert\n * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src\n */"
 },
 "sws_convertPalette8ToPacked24": {
  "type": "void",
  "definition": "void sws_convertPalette8ToPacked24",
  "argsstring": "(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)",
  "name": "sws_convertPalette8ToPacked24",
  "param": [
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "int",
    "declname": "num_pixels"
   },
   {
    "type": "const uint8_t *",
    "declname": "palette"
   }
  ],
  "briefdescription": {
   "para": "Convert an 8-bit paletted frame into a frame with a color depth of 24 bits."
  },
  "detaileddescription": {
   "para": [
    "With the palette format \"ABCD\", the destination frame ends up with the format \"ABC\".",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "src"
        },
        "parameterdescription": {
         "para": "source frame buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "dst"
        },
        "parameterdescription": {
         "para": "destination frame buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "num_pixels"
        },
        "parameterdescription": {
         "para": "number of pixels to convert"
        }
       },
       {
        "parameternamelist": {
         "parametername": "palette"
        },
        "parameterdescription": {
         "para": "array with [256] entries, which must match color arrangement (RGB or BGR) of src"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "422",
   "@_column": "6",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "422",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga3c3d094eb840e10fbc3a37c20a6c8585",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.\n *\n * With the palette format \"ABCD\", the destination frame ends up with the format \"ABC\".\n *\n * @param src        source frame buffer\n * @param dst        destination frame buffer\n * @param num_pixels number of pixels to convert\n * @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src\n */"
 },
 "sws_get_class": {
  "type": {
   "ref": {
    "#text": "AVClass",
    "@_refid": "structAVClass",
    "@_kindref": "compound"
   },
   "#text": "const*"
  },
  "definition": "const AVClass * sws_get_class",
  "argsstring": "(void)",
  "name": "sws_get_class",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVClass",
     "@_refid": "structAVClass",
     "@_kindref": "compound"
    },
    "#text": "Get thefor swsContext."
   }
  },
  "detaileddescription": {
   "para": [
    "It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.",
    {
     "simplesect": {
      "para": {
       "ref": {
        "#text": "av_opt_find()",
        "@_refid": "group__opt__mng_1ga9ad3a0b722a9815f15e3df512290d618",
        "@_kindref": "member"
       },
       "#text": "."
      },
      "@_kind": "see"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libswscale/swscale.h",
   "@_line": "430",
   "@_column": "15",
   "@_declfile": "libswscale/swscale.h",
   "@_declline": "430",
   "@_declcolumn": "15"
  },
  "@_kind": "function",
  "@_id": "group__libsws_1ga9952d942bbc700df8b9913a854ae36a3",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the AVClass for swsContext. It can be used in combination with\n * AV_OPT_SEARCH_FAKE_OBJ for examining options.\n *\n * @see av_opt_find().\n */"
 },
 "av_tea_size": {
  "type": "const int",
  "definition": "const int av_tea_size",
  "argsstring": "",
  "name": "av_tea_size",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tea.h",
   "@_line": "35",
   "@_column": "18",
   "@_declfile": "libavutil/tea.h",
   "@_declline": "35",
   "@_declcolumn": "18"
  },
  "@_kind": "variable",
  "@_id": "group__lavu__tea_1ga7c9222593c131d944e546df088753f8b",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * @file\n * @brief Public header for libavutil TEA algorithm\n * @defgroup lavu_tea TEA\n * @ingroup lavu_crypto\n * @{\n */"
 },
 "av_tea_alloc": {
  "type": "struct AVTEA *",
  "definition": "struct AVTEA * av_tea_alloc",
  "argsstring": "(void)",
  "name": "av_tea_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVTEA context To free the struct: av_free(ptr)"
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tea.h",
   "@_line": "43",
   "@_column": "12",
   "@_declfile": "libavutil/tea.h",
   "@_declline": "43",
   "@_declcolumn": "12"
  },
  "@_kind": "function",
  "@_id": "group__lavu__tea_1ga909165ed537bf05e749eb4a32f1e9b4b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n  * Allocate an AVTEA context\n  * To free the struct: av_free(ptr)\n  */"
 },
 "av_tea_init": {
  "type": "void",
  "definition": "void av_tea_init",
  "argsstring": "(struct AVTEA *ctx, const uint8_t key[16], int rounds)",
  "name": "av_tea_init",
  "param": [
   {
    "type": "struct AVTEA *",
    "declname": "ctx"
   },
   {
    "type": "const uint8_t",
    "declname": "key",
    "array": "[16]"
   },
   {
    "type": "int",
    "declname": "rounds"
   }
  ],
  "briefdescription": {
   "para": "Initialize an AVTEA context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "an AVTEA context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "a key of 16 bytes used for encryption/decryption"
       }
      },
      {
       "parameternamelist": {
        "parametername": "rounds"
       },
       "parameterdescription": {
        "para": "the number of rounds in TEA (64 is the \"standard\")"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tea.h",
   "@_line": "52",
   "@_column": "6",
   "@_declfile": "libavutil/tea.h",
   "@_declline": "52",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__tea_1ga8fe0c9dabc9db1b88480f58e0d598c44",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize an AVTEA context.\n *\n * @param ctx an AVTEA context\n * @param key a key of 16 bytes used for encryption/decryption\n * @param rounds the number of rounds in TEA (64 is the \"standard\")\n */"
 },
 "av_tea_crypt": {
  "type": "void",
  "definition": "void av_tea_crypt",
  "argsstring": "(struct AVTEA *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt)",
  "name": "av_tea_crypt",
  "param": [
   {
    "type": "struct AVTEA *",
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "uint8_t *",
    "declname": "iv"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypt or decrypt a buffer using a previously initialized context."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "an AVTEA context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of 8 byte blocks"
       }
      },
      {
       "parameternamelist": {
        "parametername": "iv"
       },
       "parameterdescription": {
        "para": "initialization vector for CBC mode, if NULL then ECB will be used"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tea.h",
   "@_line": "64",
   "@_column": "6",
   "@_declfile": "libavutil/tea.h",
   "@_declline": "64",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__tea_1gaf6a071e471a2a7aabae0ec62dc3ec717",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Encrypt or decrypt a buffer using a previously initialized context.\n *\n * @param ctx an AVTEA context\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param count number of 8 byte blocks\n * @param iv initialization vector for CBC mode, if NULL then ECB will be used\n * @param decrypt 0 for encryption, 1 for decryption\n */"
 },
 "AVThreadMessageQueue": {
  "type": {
   "ref": {
    "#text": "AVThreadMessageQueue",
    "@_refid": "threadmessage_8h_1afe2b529ed869d4b672f1a4547dd160af",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVThreadMessageQueue AVThreadMessageQueue",
  "argsstring": "",
  "name": "AVThreadMessageQueue",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/threadmessage.h",
   "@_line": "22",
   "@_column": "35",
   "@_bodyfile": "libavutil/threadmessage.h",
   "@_bodystart": "22",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "threadmessage_8h_1afe2b529ed869d4b672f1a4547dd160af",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with FFmpeg; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */"
 },
 "av_thread_message_queue_alloc": {
  "type": "int",
  "definition": "int av_thread_message_queue_alloc",
  "argsstring": "(AVThreadMessageQueue **mq, unsigned nelem, unsigned elsize)",
  "name": "av_thread_message_queue_alloc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVThreadMessageQueue",
      "@_refid": "threadmessage_8h_1afe2b529ed869d4b672f1a4547dd160af",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "mq"
   },
   {
    "type": "unsigned",
    "declname": "nelem"
   },
   {
    "type": "unsigned",
    "declname": "elsize"
   }
  ],
  "briefdescription": {
   "para": "Allocate a new message queue."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "mq"
       },
       "parameterdescription": {
        "para": "pointer to the message queue"
       }
      },
      {
       "parameternamelist": {
        "parametername": "nelem"
       },
       "parameterdescription": {
        "para": "maximum number of elements in the queue"
       }
      },
      {
       "parameternamelist": {
        "parametername": "elsize"
       },
       "parameterdescription": {
        "para": "size of each element in the queue"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVERROR(ENOSYS)",
       "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
       "@_kindref": "member"
      },
      "#text": ">=0 for success; <0 for error, in particularif lavu was built without thread support"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/threadmessage.h",
   "@_line": "44",
   "@_column": "5",
   "@_declfile": "libavutil/threadmessage.h",
   "@_declline": "44",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "threadmessage_8h_1a1734b65da48a88e7c78e8a29b1eee139",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate a new message queue.\n *\n * @param mq      pointer to the message queue\n * @param nelem   maximum number of elements in the queue\n * @param elsize  size of each element in the queue\n * @return  >=0 for success; <0 for error, in particular AVERROR(ENOSYS) if\n *          lavu was built without thread support\n */"
 },
 "av_thread_message_queue_free": {
  "type": "void",
  "definition": "void av_thread_message_queue_free",
  "argsstring": "(AVThreadMessageQueue **mq)",
  "name": "av_thread_message_queue_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVThreadMessageQueue",
     "@_refid": "threadmessage_8h_1afe2b529ed869d4b672f1a4547dd160af",
     "@_kindref": "member"
    },
    "#text": "**"
   },
   "declname": "mq"
  },
  "briefdescription": {
   "para": "Free a message queue."
  },
  "detaileddescription": {
   "para": "The message queue must no longer be in use by another thread."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/threadmessage.h",
   "@_line": "53",
   "@_column": "6",
   "@_declfile": "libavutil/threadmessage.h",
   "@_declline": "53",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "threadmessage_8h_1a95727669f1ebba16a6a49ea8b9f2276e",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free a message queue.\n *\n * The message queue must no longer be in use by another thread.\n */"
 },
 "av_thread_message_queue_send": {
  "type": "int",
  "definition": "int av_thread_message_queue_send",
  "argsstring": "(AVThreadMessageQueue *mq, void *msg, unsigned flags)",
  "name": "av_thread_message_queue_send",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVThreadMessageQueue",
      "@_refid": "threadmessage_8h_1afe2b529ed869d4b672f1a4547dd160af",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "mq"
   },
   {
    "type": "void *",
    "declname": "msg"
   },
   {
    "type": "unsigned",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Send a message on the queue."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/threadmessage.h",
   "@_line": "58",
   "@_column": "5",
   "@_declfile": "libavutil/threadmessage.h",
   "@_declline": "58",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "threadmessage_8h_1a873d588ed106d8dde339c4a16411e0b8",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Send a message on the queue.\n */"
 },
 "av_thread_message_queue_recv": {
  "type": "int",
  "definition": "int av_thread_message_queue_recv",
  "argsstring": "(AVThreadMessageQueue *mq, void *msg, unsigned flags)",
  "name": "av_thread_message_queue_recv",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVThreadMessageQueue",
      "@_refid": "threadmessage_8h_1afe2b529ed869d4b672f1a4547dd160af",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "mq"
   },
   {
    "type": "void *",
    "declname": "msg"
   },
   {
    "type": "unsigned",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Receive a message from the queue."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/threadmessage.h",
   "@_line": "65",
   "@_column": "5",
   "@_declfile": "libavutil/threadmessage.h",
   "@_declline": "65",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "threadmessage_8h_1a0fb9f4909ad77c541f8ba4409b253111",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Receive a message from the queue.\n */"
 },
 "av_thread_message_queue_set_err_send": {
  "type": "void",
  "definition": "void av_thread_message_queue_set_err_send",
  "argsstring": "(AVThreadMessageQueue *mq, int err)",
  "name": "av_thread_message_queue_set_err_send",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVThreadMessageQueue",
      "@_refid": "threadmessage_8h_1afe2b529ed869d4b672f1a4547dd160af",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "mq"
   },
   {
    "type": "int",
    "declname": "err"
   }
  ],
  "briefdescription": {
   "para": "Set the sending error code."
  },
  "detaileddescription": {
   "para": {
    "ref": [
     {
      "#text": "av_thread_message_queue_send()",
      "@_refid": "threadmessage_8h_1a873d588ed106d8dde339c4a16411e0b8",
      "@_kindref": "member"
     },
     {
      "#text": "AVERROR(EAGAIN)",
      "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
      "@_kindref": "member"
     }
    ],
    "#text": "If the error code is set to non-zero,will return it immediately. Conventional values, such as AVERROR_EOF or, can be used to cause the sending thread to stop or suspend its operation."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/threadmessage.h",
   "@_line": "77",
   "@_column": "6",
   "@_declfile": "libavutil/threadmessage.h",
   "@_declline": "77",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "threadmessage_8h_1a01981ed85e713e682912ee6e063403ad",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set the sending error code.\n *\n * If the error code is set to non-zero, av_thread_message_queue_send() will\n * return it immediately. Conventional values, such as AVERROR_EOF or\n * AVERROR(EAGAIN), can be used to cause the sending thread to stop or\n * suspend its operation.\n */"
 },
 "av_thread_message_queue_set_err_recv": {
  "type": "void",
  "definition": "void av_thread_message_queue_set_err_recv",
  "argsstring": "(AVThreadMessageQueue *mq, int err)",
  "name": "av_thread_message_queue_set_err_recv",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVThreadMessageQueue",
      "@_refid": "threadmessage_8h_1afe2b529ed869d4b672f1a4547dd160af",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "mq"
   },
   {
    "type": "int",
    "declname": "err"
   }
  ],
  "briefdescription": {
   "para": "Set the receiving error code."
  },
  "detaileddescription": {
   "para": {
    "ref": [
     {
      "#text": "av_thread_message_queue_recv()",
      "@_refid": "threadmessage_8h_1a0fb9f4909ad77c541f8ba4409b253111",
      "@_kindref": "member"
     },
     {
      "#text": "AVERROR(EAGAIN)",
      "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
      "@_kindref": "member"
     }
    ],
    "#text": "If the error code is set to non-zero,will return it immediately when there are no longer available messages. Conventional values, such as AVERROR_EOF or, can be used to cause the receiving thread to stop or suspend its operation."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/threadmessage.h",
   "@_line": "88",
   "@_column": "6",
   "@_declfile": "libavutil/threadmessage.h",
   "@_declline": "88",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "threadmessage_8h_1a6b2b6c47728e7d442b31a49ca8f9f971",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set the receiving error code.\n *\n * If the error code is set to non-zero, av_thread_message_queue_recv() will\n * return it immediately when there are no longer available messages.\n * Conventional values, such as AVERROR_EOF or AVERROR(EAGAIN), can be used\n * to cause the receiving thread to stop or suspend its operation.\n */"
 },
 "av_thread_message_queue_set_free_func": {
  "type": "void",
  "definition": "void av_thread_message_queue_set_free_func",
  "argsstring": "(AVThreadMessageQueue *mq, void(*free_func)(void *msg))",
  "name": "av_thread_message_queue_set_free_func",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVThreadMessageQueue",
      "@_refid": "threadmessage_8h_1afe2b529ed869d4b672f1a4547dd160af",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "mq"
   },
   {
    "type": "void(*)(void *msg)",
    "declname": "free_func"
   }
  ],
  "briefdescription": {
   "para": "Set the optional free message callback function which will be called if an operation is removing messages from the queue."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/threadmessage.h",
   "@_line": "95",
   "@_column": "6",
   "@_declfile": "libavutil/threadmessage.h",
   "@_declline": "95",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "threadmessage_8h_1a55878238c793830dc7de601042873ee6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Set the optional free message callback function which will be called if an\n * operation is removing messages from the queue.\n */"
 },
 "av_thread_message_queue_nb_elems": {
  "type": "int",
  "definition": "int av_thread_message_queue_nb_elems",
  "argsstring": "(AVThreadMessageQueue *mq)",
  "name": "av_thread_message_queue_nb_elems",
  "param": {
   "type": {
    "ref": {
     "#text": "AVThreadMessageQueue",
     "@_refid": "threadmessage_8h_1afe2b529ed869d4b672f1a4547dd160af",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "mq"
  },
  "briefdescription": {
   "para": "Return the current number of messages in the queue."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVERROR(ENOSYS)",
       "@_refid": "group__lavu__error_1gae4bb6f165973d09584e0ec0f335f69ca",
       "@_kindref": "member"
      },
      "#text": "the current number of messages orif lavu was built without thread support"
     },
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/threadmessage.h",
   "@_line": "104",
   "@_column": "5",
   "@_declfile": "libavutil/threadmessage.h",
   "@_declline": "104",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "threadmessage_8h_1a716d595b7b6bf5eeeab63e3400868eb6",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Return the current number of messages in the queue.\n *\n * @return the current number of messages or AVERROR(ENOSYS) if lavu was built\n *         without thread support\n */"
 },
 "av_thread_message_flush": {
  "type": "void",
  "definition": "void av_thread_message_flush",
  "argsstring": "(AVThreadMessageQueue *mq)",
  "name": "av_thread_message_flush",
  "param": {
   "type": {
    "ref": {
     "#text": "AVThreadMessageQueue",
     "@_refid": "threadmessage_8h_1afe2b529ed869d4b672f1a4547dd160af",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "mq"
  },
  "briefdescription": {
   "para": "Flush the message queue."
  },
  "detaileddescription": {
   "para": "This function is mostly equivalent to reading and free-ing every message except that it will be done in a single operation (no lock/unlock between reads)."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/threadmessage.h",
   "@_line": "113",
   "@_column": "6",
   "@_declfile": "libavutil/threadmessage.h",
   "@_declline": "113",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "threadmessage_8h_1a8dc5df5158d3098303cdd48e7e3d4ea4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Flush the message queue\n *\n * This function is mostly equivalent to reading and free-ing every message\n * except that it will be done in a single operation (no lock/unlock between\n * reads).\n */"
 },
 "av_gettime": {
  "type": "int64_t",
  "definition": "int64_t av_gettime",
  "argsstring": "(void)",
  "name": "av_gettime",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Get the current time in microseconds."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/time.h",
   "@_line": "29",
   "@_column": "9",
   "@_declfile": "libavutil/time.h",
   "@_declline": "29",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "time_8h_1aebf7f9c94187487c31d26fa3da816468",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the current time in microseconds.\n */"
 },
 "av_gettime_relative": {
  "type": "int64_t",
  "definition": "int64_t av_gettime_relative",
  "argsstring": "(void)",
  "name": "av_gettime_relative",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Get the current time in microseconds since some unspecified starting point."
  },
  "detaileddescription": {
   "para": "On platforms that support it, the time comes from a monotonic clock This property makes this time source ideal for measuring relative time. The returned values may not be monotonic on platforms where a monotonic clock is not available."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/time.h",
   "@_line": "38",
   "@_column": "9",
   "@_declfile": "libavutil/time.h",
   "@_declline": "38",
   "@_declcolumn": "9"
  },
  "@_kind": "function",
  "@_id": "time_8h_1adf0e36df54426fa167e3cc5a3406f3b7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the current time in microseconds since some unspecified starting point.\n * On platforms that support it, the time comes from a monotonic clock\n * This property makes this time source ideal for measuring relative time.\n * The returned values may not be monotonic on platforms where a monotonic\n * clock is not available.\n */"
 },
 "av_gettime_relative_is_monotonic": {
  "type": "int",
  "definition": "int av_gettime_relative_is_monotonic",
  "argsstring": "(void)",
  "name": "av_gettime_relative_is_monotonic",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "av_gettime_relative()",
     "@_refid": "time_8h_1adf0e36df54426fa167e3cc5a3406f3b7",
     "@_kindref": "member"
    },
    "#text": "Indicates with a boolean result if thetime source is monotonic."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/time.h",
   "@_line": "44",
   "@_column": "5",
   "@_declfile": "libavutil/time.h",
   "@_declline": "44",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "time_8h_1ae0df8c82a87a2eed390e4e7eac5e86bd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Indicates with a boolean result if the av_gettime_relative() time source\n * is monotonic.\n */"
 },
 "av_usleep": {
  "type": "int",
  "definition": "int av_usleep",
  "argsstring": "(unsigned usec)",
  "name": "av_usleep",
  "param": {
   "type": "unsigned",
   "declname": "usec"
  },
  "briefdescription": {
   "para": "Sleep for a period of time."
  },
  "detaileddescription": {
   "para": [
    "Although the duration is expressed in microseconds, the actual delay may be rounded to the precision of the system timer.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "usec"
       },
       "parameterdescription": {
        "para": "Number of microseconds to sleep."
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": "zero on success or (negative) error code.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/time.h",
   "@_line": "54",
   "@_column": "5",
   "@_declfile": "libavutil/time.h",
   "@_declline": "54",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "time_8h_1a4eee9c65835652a808973f4bc1641a51",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Sleep for a period of time.  Although the duration is expressed in\n * microseconds, the actual delay may be rounded to the precision of the\n * system timer.\n *\n * @param  usec Number of microseconds to sleep.\n * @return zero on success or (negative) error code.\n */"
 },
 "av_timecode_adjust_ntsc_framenum2": {
  "type": "int",
  "definition": "int av_timecode_adjust_ntsc_framenum2",
  "argsstring": "(int framenum, int fps)",
  "name": "av_timecode_adjust_ntsc_framenum2",
  "param": [
   {
    "type": "int",
    "declname": "framenum"
   },
   {
    "type": "int",
    "declname": "fps"
   }
  ],
  "briefdescription": {
   "para": "Adjust frame number for NTSC drop frame time code."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "framenum"
       },
       "parameterdescription": {
        "para": "frame number to adjust"
       }
      },
      {
       "parameternamelist": {
        "parametername": "fps"
       },
       "parameterdescription": {
        "para": "frame per second, multiples of 30"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "adjusted frame number",
      "@_kind": "return"
     },
     {
      "para": "adjustment is only valid for multiples of NTSC 29.97",
      "@_kind": "warning"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timecode.h",
   "@_line": "56",
   "@_column": "5",
   "@_declfile": "libavutil/timecode.h",
   "@_declline": "56",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "timecode_8h_1aef6b950d708ea805b970c16e71a97869",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Adjust frame number for NTSC drop frame time code.\n *\n * @param framenum frame number to adjust\n * @param fps      frame per second, multiples of 30\n * @return         adjusted frame number\n * @warning        adjustment is only valid for multiples of NTSC 29.97\n */"
 },
 "av_timecode_get_smpte_from_framenum": {
  "type": "uint32_t",
  "definition": "uint32_t av_timecode_get_smpte_from_framenum",
  "argsstring": "(const AVTimecode *tc, int framenum)",
  "name": "av_timecode_get_smpte_from_framenum",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVTimecode",
      "@_refid": "structAVTimecode",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "tc"
   },
   {
    "type": "int",
    "declname": "framenum"
   }
  ],
  "briefdescription": {
   "para": "Convert frame number to SMPTE 12M binary representation."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "tc"
       },
       "parameterdescription": {
        "para": "timecode data correctly initialized"
       }
      },
      {
       "parameternamelist": {
        "parametername": "framenum"
       },
       "parameterdescription": {
        "para": "frame number"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "the SMPTE binary representation",
      "@_kind": "return"
     },
     {
      "para": "BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens.",
      "@_kind": "note"
     },
     {
      "para": {
       "ref": {
        "#text": "av_timecode_adjust_ntsc_framenum2()",
        "@_refid": "timecode_8h_1aef6b950d708ea805b970c16e71a97869",
        "@_kindref": "member"
       },
       "#text": "Frame number adjustment is automatically done in case of drop timecode, you do NOT have to call."
      },
      "@_kind": "note"
     },
     {
      "para": "The frame number is relative to tc->start.",
      "@_kind": "note"
     },
     {
      "para": "Color frame (CF) and binary group flags (BGF) bits are set to zero.",
      "@_kind": "note"
     }
    ],
    "#text": "See SMPTE ST 314M-2005 Sec 4.4.2.2.1 \"Time code pack (TC)\" the format description as follows: bits 0-5: hours, in BCD(6bits) bits 6: BGF1 bits 7: BGF2 (NTSC) or FIELD (PAL) bits 8-14: minutes, in BCD(7bits) bits 15: BGF0 (NTSC) or BGF2 (PAL) bits 16-22: seconds, in BCD(7bits) bits 23: FIELD (NTSC) or BGF0 (PAL) bits 24-29: frames, in BCD(6bits) bits 30: drop frame flag (0: non drop, 1: drop) bits 31: color frame flag (0: unsync mode, 1: sync mode)"
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timecode.h",
   "@_line": "83",
   "@_column": "10",
   "@_declfile": "libavutil/timecode.h",
   "@_declline": "83",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "timecode_8h_1ae3045b65cc54f72e9d53d3c97a5f4da5",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert frame number to SMPTE 12M binary representation.\n *\n * @param tc       timecode data correctly initialized\n * @param framenum frame number\n * @return         the SMPTE binary representation\n *\n * See SMPTE ST 314M-2005 Sec 4.4.2.2.1 \"Time code pack (TC)\"\n * the format description as follows:\n * bits 0-5:   hours, in BCD(6bits)\n * bits 6:     BGF1\n * bits 7:     BGF2 (NTSC) or FIELD (PAL)\n * bits 8-14:  minutes, in BCD(7bits)\n * bits 15:    BGF0 (NTSC) or BGF2 (PAL)\n * bits 16-22: seconds, in BCD(7bits)\n * bits 23:    FIELD (NTSC) or BGF0 (PAL)\n * bits 24-29: frames, in BCD(6bits)\n * bits 30:    drop  frame flag (0: non drop,    1: drop)\n * bits 31:    color frame flag (0: unsync mode, 1: sync mode)\n * @note BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens.\n * @note Frame number adjustment is automatically done in case of drop timecode,\n *       you do NOT have to call av_timecode_adjust_ntsc_framenum2().\n * @note The frame number is relative to tc->start.\n * @note Color frame (CF) and binary group flags (BGF) bits are set to zero.\n */"
 },
 "av_timecode_get_smpte": {
  "type": "uint32_t",
  "definition": "uint32_t av_timecode_get_smpte",
  "argsstring": "(AVRational rate, int drop, int hh, int mm, int ss, int ff)",
  "name": "av_timecode_get_smpte",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "rate"
   },
   {
    "type": "int",
    "declname": "drop"
   },
   {
    "type": "int",
    "declname": "hh"
   },
   {
    "type": "int",
    "declname": "mm"
   },
   {
    "type": "int",
    "declname": "ss"
   },
   {
    "type": "int",
    "declname": "ff"
   }
  ],
  "briefdescription": {
   "para": "Convert sei info to SMPTE 12M binary representation."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "rate"
       },
       "parameterdescription": {
        "para": "frame rate in rational form"
       }
      },
      {
       "parameternamelist": {
        "parametername": "drop"
       },
       "parameterdescription": {
        "para": "drop flag"
       }
      },
      {
       "parameternamelist": {
        "parametername": "hh"
       },
       "parameterdescription": {
        "para": "hour"
       }
      },
      {
       "parameternamelist": {
        "parametername": "mm"
       },
       "parameterdescription": {
        "para": "minute"
       }
      },
      {
       "parameternamelist": {
        "parametername": "ss"
       },
       "parameterdescription": {
        "para": "second"
       }
      },
      {
       "parameternamelist": {
        "parametername": "ff"
       },
       "parameterdescription": {
        "para": "frame number"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the SMPTE binary representation",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timecode.h",
   "@_line": "96",
   "@_column": "10",
   "@_declfile": "libavutil/timecode.h",
   "@_declline": "96",
   "@_declcolumn": "10"
  },
  "@_kind": "function",
  "@_id": "timecode_8h_1a4b32766367b125c300d043035d06415c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Convert sei info to SMPTE 12M binary representation.\n *\n * @param rate     frame rate in rational form\n * @param drop     drop flag\n * @param hh       hour\n * @param mm       minute\n * @param ss       second\n * @param ff       frame number\n * @return         the SMPTE binary representation\n */"
 },
 "av_timecode_make_string": {
  "type": "char *",
  "definition": "char * av_timecode_make_string",
  "argsstring": "(const AVTimecode *tc, char *buf, int framenum)",
  "name": "av_timecode_make_string",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVTimecode",
      "@_refid": "structAVTimecode",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "tc"
   },
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "framenum"
   }
  ],
  "briefdescription": {
   "para": "Load timecode string in buf."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "tc"
       },
       "parameterdescription": {
        "para": "timecode data correctly initialized"
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "destination buffer, must be at least AV_TIMECODE_STR_SIZE long"
       }
      },
      {
       "parameternamelist": {
        "parametername": "framenum"
       },
       "parameterdescription": {
        "para": "frame number"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": [
     {
      "para": "the buf parameter",
      "@_kind": "return"
     },
     {
      "para": "Timecode representation can be a negative timecode and have more than 24 hours, but will only be honored if the flags are correctly set.",
      "@_kind": "note"
     },
     {
      "para": "The frame number is relative to tc->start.",
      "@_kind": "note"
     }
    ]
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timecode.h",
   "@_line": "110",
   "@_column": "6",
   "@_declfile": "libavutil/timecode.h",
   "@_declline": "110",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "timecode_8h_1a3cf17766b8b4a214cb8ce6b951b4e57f",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Load timecode string in buf.\n *\n * @param tc       timecode data correctly initialized\n * @param buf      destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n * @param framenum frame number\n * @return         the buf parameter\n *\n * @note Timecode representation can be a negative timecode and have more than\n *       24 hours, but will only be honored if the flags are correctly set.\n * @note The frame number is relative to tc->start.\n */"
 },
 "av_timecode_make_smpte_tc_string2": {
  "type": "char *",
  "definition": "char * av_timecode_make_smpte_tc_string2",
  "argsstring": "(char *buf, AVRational rate, uint32_t tcsmpte, int prevent_df, int skip_field)",
  "name": "av_timecode_make_smpte_tc_string2",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "rate"
   },
   {
    "type": "uint32_t",
    "declname": "tcsmpte"
   },
   {
    "type": "int",
    "declname": "prevent_df"
   },
   {
    "type": "int",
    "declname": "skip_field"
   }
  ],
  "briefdescription": {
   "para": "Get the timecode string from the SMPTE timecode format."
  },
  "detaileddescription": {
   "para": [
    "In contrast to av_timecode_make_smpte_tc_string this function supports 50/60 fps timecodes by using the field bit.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "destination buffer, must be at least AV_TIMECODE_STR_SIZE long"
        }
       },
       {
        "parameternamelist": {
         "parametername": "rate"
        },
        "parameterdescription": {
         "para": "frame rate of the timecode"
        }
       },
       {
        "parameternamelist": {
         "parametername": "tcsmpte"
        },
        "parameterdescription": {
         "para": "the 32-bit SMPTE timecode"
        }
       },
       {
        "parameternamelist": {
         "parametername": "prevent_df"
        },
        "parameterdescription": {
         "para": "prevent the use of a drop flag when it is known the DF bit is arbitrary"
        }
       },
       {
        "parameternamelist": {
         "parametername": "skip_field"
        },
        "parameterdescription": {
         "para": "prevent the use of a field flag when it is known the field bit is arbitrary (e.g. because it is used as PC flag)"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "the buf parameter",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timecode.h",
   "@_line": "127",
   "@_column": "6",
   "@_declfile": "libavutil/timecode.h",
   "@_declline": "127",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "timecode_8h_1a4f19602db2372480a7bcdb733f13dcd4",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the timecode string from the SMPTE timecode format.\n *\n * In contrast to av_timecode_make_smpte_tc_string this function supports 50/60\n * fps timecodes by using the field bit.\n *\n * @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n * @param rate       frame rate of the timecode\n * @param tcsmpte    the 32-bit SMPTE timecode\n * @param prevent_df prevent the use of a drop flag when it is known the DF bit\n *                   is arbitrary\n * @param skip_field prevent the use of a field flag when it is known the field\n *                   bit is arbitrary (e.g. because it is used as PC flag)\n * @return           the buf parameter\n */"
 },
 "av_timecode_make_smpte_tc_string": {
  "type": "char *",
  "definition": "char * av_timecode_make_smpte_tc_string",
  "argsstring": "(char *buf, uint32_t tcsmpte, int prevent_df)",
  "name": "av_timecode_make_smpte_tc_string",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "uint32_t",
    "declname": "tcsmpte"
   },
   {
    "type": "int",
    "declname": "prevent_df"
   }
  ],
  "briefdescription": {
   "para": "Get the timecode string from the SMPTE timecode format."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "destination buffer, must be at least AV_TIMECODE_STR_SIZE long"
       }
      },
      {
       "parameternamelist": {
        "parametername": "tcsmpte"
       },
       "parameterdescription": {
        "para": "the 32-bit SMPTE timecode"
       }
      },
      {
       "parameternamelist": {
        "parametername": "prevent_df"
       },
       "parameterdescription": {
        "para": "prevent the use of a drop flag when it is known the DF bit is arbitrary"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the buf parameter",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timecode.h",
   "@_line": "138",
   "@_column": "6",
   "@_declfile": "libavutil/timecode.h",
   "@_declline": "138",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "timecode_8h_1ae149f0f90d8b6a99101faa7287039a57",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the timecode string from the SMPTE timecode format.\n *\n * @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n * @param tcsmpte    the 32-bit SMPTE timecode\n * @param prevent_df prevent the use of a drop flag when it is known the DF bit\n *                   is arbitrary\n * @return           the buf parameter\n */"
 },
 "av_timecode_make_mpeg_tc_string": {
  "type": "char *",
  "definition": "char * av_timecode_make_mpeg_tc_string",
  "argsstring": "(char *buf, uint32_t tc25bit)",
  "name": "av_timecode_make_mpeg_tc_string",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "uint32_t",
    "declname": "tc25bit"
   }
  ],
  "briefdescription": {
   "para": "Get the timecode string from the 25-bit timecode format (MPEG GOP format)."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "destination buffer, must be at least AV_TIMECODE_STR_SIZE long"
       }
      },
      {
       "parameternamelist": {
        "parametername": "tc25bit"
       },
       "parameterdescription": {
        "para": "the 25-bits timecode"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the buf parameter",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timecode.h",
   "@_line": "147",
   "@_column": "6",
   "@_declfile": "libavutil/timecode.h",
   "@_declline": "147",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "timecode_8h_1a57a52c9716f1a772c99bff0b9673b808",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the timecode string from the 25-bit timecode format (MPEG GOP format).\n *\n * @param buf     destination buffer, must be at least AV_TIMECODE_STR_SIZE long\n * @param tc25bit the 25-bits timecode\n * @return        the buf parameter\n */"
 },
 "av_timecode_init": {
  "type": "int",
  "definition": "int av_timecode_init",
  "argsstring": "(AVTimecode *tc, AVRational rate, int flags, int frame_start, void *log_ctx)",
  "name": "av_timecode_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVTimecode",
      "@_refid": "structAVTimecode",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "tc"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "rate"
   },
   {
    "type": "int",
    "declname": "flags"
   },
   {
    "type": "int",
    "declname": "frame_start"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Init a timecode struct with the passed parameters."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "tc"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVTimecode",
          "@_refid": "structAVTimecode",
          "@_kindref": "compound"
         },
         "#text": "pointer to an allocated"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "rate"
       },
       "parameterdescription": {
        "para": "frame rate in rational form"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "miscellaneous flags such as drop frame, +24 hours, ... (see AVTimecodeFlag)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "frame_start"
       },
       "parameterdescription": {
        "para": "the first frame number"
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "a pointer to an arbitrary struct of which the first field is a pointer to anstruct (used for av_log)"
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, AVERROR otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timecode.h",
   "@_line": "161",
   "@_column": "5",
   "@_declfile": "libavutil/timecode.h",
   "@_declline": "161",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "timecode_8h_1ad279cd982964a2f8cc7adfa01533b412",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Init a timecode struct with the passed parameters.\n *\n * @param tc          pointer to an allocated AVTimecode\n * @param rate        frame rate in rational form\n * @param flags       miscellaneous flags such as drop frame, +24 hours, ...\n *                    (see AVTimecodeFlag)\n * @param frame_start the first frame number\n * @param log_ctx     a pointer to an arbitrary struct of which the first field\n *                    is a pointer to an AVClass struct (used for av_log)\n * @return            0 on success, AVERROR otherwise\n */"
 },
 "av_timecode_init_from_components": {
  "type": "int",
  "definition": "int av_timecode_init_from_components",
  "argsstring": "(AVTimecode *tc, AVRational rate, int flags, int hh, int mm, int ss, int ff, void *log_ctx)",
  "name": "av_timecode_init_from_components",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVTimecode",
      "@_refid": "structAVTimecode",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "tc"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "rate"
   },
   {
    "type": "int",
    "declname": "flags"
   },
   {
    "type": "int",
    "declname": "hh"
   },
   {
    "type": "int",
    "declname": "mm"
   },
   {
    "type": "int",
    "declname": "ss"
   },
   {
    "type": "int",
    "declname": "ff"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Init a timecode struct from the passed timecode components."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "tc"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVTimecode",
          "@_refid": "structAVTimecode",
          "@_kindref": "compound"
         },
         "#text": "pointer to an allocated"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "rate"
       },
       "parameterdescription": {
        "para": "frame rate in rational form"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "miscellaneous flags such as drop frame, +24 hours, ... (see AVTimecodeFlag)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "hh"
       },
       "parameterdescription": {
        "para": "hours"
       }
      },
      {
       "parameternamelist": {
        "parametername": "mm"
       },
       "parameterdescription": {
        "para": "minutes"
       }
      },
      {
       "parameternamelist": {
        "parametername": "ss"
       },
       "parameterdescription": {
        "para": "seconds"
       }
      },
      {
       "parameternamelist": {
        "parametername": "ff"
       },
       "parameterdescription": {
        "para": "frames"
       }
      },
      {
       "parameternamelist": {
        "parametername": "log_ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVClass",
          "@_refid": "structAVClass",
          "@_kindref": "compound"
         },
         "#text": "a pointer to an arbitrary struct of which the first field is a pointer to anstruct (used for av_log)"
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, AVERROR otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timecode.h",
   "@_line": "178",
   "@_column": "5",
   "@_declfile": "libavutil/timecode.h",
   "@_declline": "178",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "timecode_8h_1ab02d6146c000b4c58fecc95c21f604d9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Init a timecode struct from the passed timecode components.\n *\n * @param tc          pointer to an allocated AVTimecode\n * @param rate        frame rate in rational form\n * @param flags       miscellaneous flags such as drop frame, +24 hours, ...\n *                    (see AVTimecodeFlag)\n * @param hh          hours\n * @param mm          minutes\n * @param ss          seconds\n * @param ff          frames\n * @param log_ctx     a pointer to an arbitrary struct of which the first field\n *                    is a pointer to an AVClass struct (used for av_log)\n * @return            0 on success, AVERROR otherwise\n */"
 },
 "av_timecode_init_from_string": {
  "type": "int",
  "definition": "int av_timecode_init_from_string",
  "argsstring": "(AVTimecode *tc, AVRational rate, const char *str, void *log_ctx)",
  "name": "av_timecode_init_from_string",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVTimecode",
      "@_refid": "structAVTimecode",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "tc"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "rate"
   },
   {
    "type": "const char *",
    "declname": "str"
   },
   {
    "type": "void *",
    "declname": "log_ctx"
   }
  ],
  "briefdescription": {
   "para": "Parse timecode representation (hh:mm:ss[:;."
  },
  "detaileddescription": {
   "para": [
    "]ff).",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "tc"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVTimecode",
           "@_refid": "structAVTimecode",
           "@_kindref": "compound"
          },
          "#text": "pointer to an allocated"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "rate"
        },
        "parameterdescription": {
         "para": "frame rate in rational form"
        }
       },
       {
        "parameternamelist": {
         "parametername": "str"
        },
        "parameterdescription": {
         "para": "timecode string which will determine the frame start"
        }
       },
       {
        "parameternamelist": {
         "parametername": "log_ctx"
        },
        "parameterdescription": {
         "para": {
          "ref": {
           "#text": "AVClass",
           "@_refid": "structAVClass",
           "@_kindref": "compound"
          },
          "#text": "a pointer to an arbitrary struct of which the first field is a pointer to anstruct (used for av_log)."
         }
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "0 on success, AVERROR otherwise",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timecode.h",
   "@_line": "190",
   "@_column": "5",
   "@_declfile": "libavutil/timecode.h",
   "@_declline": "190",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "timecode_8h_1a02596c9d431329a3acc646c943b1c800",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parse timecode representation (hh:mm:ss[:;.]ff).\n *\n * @param tc      pointer to an allocated AVTimecode\n * @param rate    frame rate in rational form\n * @param str     timecode string which will determine the frame start\n * @param log_ctx a pointer to an arbitrary struct of which the first field is a\n *                pointer to an AVClass struct (used for av_log).\n * @return        0 on success, AVERROR otherwise\n */"
 },
 "av_timecode_check_frame_rate": {
  "type": "int",
  "definition": "int av_timecode_check_frame_rate",
  "argsstring": "(AVRational rate)",
  "name": "av_timecode_check_frame_rate",
  "param": {
   "type": {
    "ref": {
     "#text": "AVRational",
     "@_refid": "structAVRational",
     "@_kindref": "compound"
    }
   },
   "declname": "rate"
  },
  "briefdescription": {
   "para": "Check if the timecode feature is available for the given frame rate."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": "0 if supported, <0 otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timecode.h",
   "@_line": "197",
   "@_column": "5",
   "@_declfile": "libavutil/timecode.h",
   "@_declline": "197",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "timecode_8h_1ae181c7f842ad64c2e75c320e46f4edfc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Check if the timecode feature is available for the given frame rate\n *\n * @return 0 if supported, <0 otherwise\n */"
 },
 "av_ts_make_string": {
  "type": "char *",
  "definition": "static char * av_ts_make_string",
  "argsstring": "(char *buf, int64_t ts)",
  "name": "av_ts_make_string",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int64_t",
    "declname": "ts"
   }
  ],
  "briefdescription": {
   "para": "Fill the provided buffer with a string containing a timestamp representation."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "a buffer with size in bytes of at least AV_TS_MAX_STRING_SIZE"
       }
      },
      {
       "parameternamelist": {
        "parametername": "ts"
       },
       "parameterdescription": {
        "para": "the timestamp to represent"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the buffer in input",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timestamp.h",
   "@_line": "43",
   "@_column": "20",
   "@_bodyfile": "libavutil/timestamp.h",
   "@_bodystart": "43",
   "@_bodyend": "48"
  },
  "@_kind": "function",
  "@_id": "timestamp_8h_1ace65ab40150f436da450c620c0e9839d",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill the provided buffer with a string containing a timestamp\n * representation.\n *\n * @param buf a buffer with size in bytes of at least AV_TS_MAX_STRING_SIZE\n * @param ts the timestamp to represent\n * @return the buffer in input\n */"
 },
 "av_ts_make_time_string2": {
  "type": "char *",
  "definition": "char * av_ts_make_time_string2",
  "argsstring": "(char *buf, int64_t ts, AVRational tb)",
  "name": "av_ts_make_time_string2",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int64_t",
    "declname": "ts"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     }
    },
    "declname": "tb"
   }
  ],
  "briefdescription": {
   "para": "Fill the provided buffer with a string containing a timestamp time representation."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "a buffer with size in bytes of at least AV_TS_MAX_STRING_SIZE"
       }
      },
      {
       "parameternamelist": {
        "parametername": "ts"
       },
       "parameterdescription": {
        "para": "the timestamp to represent"
       }
      },
      {
       "parameternamelist": {
        "parametername": "tb"
       },
       "parameterdescription": {
        "para": "the timebase of the timestamp"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "the buffer in input",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timestamp.h",
   "@_line": "65",
   "@_column": "6",
   "@_declfile": "libavutil/timestamp.h",
   "@_declline": "65",
   "@_declcolumn": "6"
  },
  "referencedby": {
   "#text": "av_ts_make_time_string",
   "@_refid": "timestamp_8h_1a12d3ad0f37f88719bfaeb1bc7f39b63e",
   "@_compoundref": "timestamp_8h",
   "@_startline": "73",
   "@_endline": "77"
  },
  "@_kind": "function",
  "@_id": "timestamp_8h_1aec92f9cbe715e8934ff1597a86731170",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill the provided buffer with a string containing a timestamp time\n * representation.\n *\n * @param buf a buffer with size in bytes of at least AV_TS_MAX_STRING_SIZE\n * @param ts the timestamp to represent\n * @param tb the timebase of the timestamp\n * @return the buffer in input\n */"
 },
 "av_ts_make_time_string": {
  "type": "char *",
  "definition": "static char * av_ts_make_time_string",
  "argsstring": "(char *buf, int64_t ts, const AVRational *tb)",
  "name": "av_ts_make_time_string",
  "param": [
   {
    "type": "char *",
    "declname": "buf"
   },
   {
    "type": "int64_t",
    "declname": "ts"
   },
   {
    "type": {
     "ref": {
      "#text": "AVRational",
      "@_refid": "structAVRational",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "tb"
   }
  ],
  "briefdescription": {
   "para": "Fill the provided buffer with a string containing a timestamp representation."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "av_ts_make_time_string2",
       "@_refid": "timestamp_8h_1aec92f9cbe715e8934ff1597a86731170",
       "@_kindref": "member"
      }
     },
     "@_kind": "see"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/timestamp.h",
   "@_line": "73",
   "@_column": "20",
   "@_bodyfile": "libavutil/timestamp.h",
   "@_bodystart": "73",
   "@_bodyend": "77"
  },
  "@_kind": "function",
  "@_id": "timestamp_8h_1a12d3ad0f37f88719bfaeb1bc7f39b63e",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Fill the provided buffer with a string containing a timestamp\n * representation.\n *\n * @see av_ts_make_time_string2\n */"
 },
 "av_tree_node_size": {
  "type": "const int",
  "definition": "const int av_tree_node_size",
  "argsstring": "",
  "name": "av_tree_node_size",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tree.h",
   "@_line": "45",
   "@_column": "18",
   "@_declfile": "libavutil/tree.h",
   "@_declline": "45",
   "@_declcolumn": "18"
  },
  "@_kind": "variable",
  "@_id": "group__lavu__tree_1gabad004dcf19a9d481793c03cabda5984",
  "@_prot": "public",
  "@_static": "no",
  "@_mutable": "no",
  "raw": "/**\n * @addtogroup lavu_tree AVTree\n * @ingroup lavu_data\n *\n * Low-complexity tree container\n *\n * Insertion, removal, finding equal, largest which is smaller than and\n * smallest which is larger than, all have O(log n) worst-case complexity.\n * @{\n */"
 },
 "av_tree_node_alloc": {
  "type": "struct AVTreeNode *",
  "definition": "struct AVTreeNode * av_tree_node_alloc",
  "argsstring": "(void)",
  "name": "av_tree_node_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": "Allocate an AVTreeNode."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tree.h",
   "@_line": "50",
   "@_column": "17",
   "@_declfile": "libavutil/tree.h",
   "@_declline": "50",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavu__tree_1gafab839218031805b252bc8190c94065b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVTreeNode.\n */"
 },
 "av_tree_find": {
  "type": "void *",
  "definition": "void * av_tree_find",
  "argsstring": "(const struct AVTreeNode *root, void *key, int(*cmp)(const void *key, const void *b), void *next[2])",
  "name": "av_tree_find",
  "param": [
   {
    "type": "const struct AVTreeNode *",
    "declname": "root"
   },
   {
    "type": "void *",
    "declname": "key"
   },
   {
    "type": "int(*)(const void *key, const void *b)",
    "declname": "cmp"
   },
   {
    "type": "void *",
    "declname": "next",
    "array": "[2]"
   }
  ],
  "briefdescription": {
   "para": "Find an element."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "root"
       },
       "parameterdescription": {
        "para": "a pointer to the root node of the tree"
       }
      },
      {
       "parameternamelist": {
        "parametername": "next"
       },
       "parameterdescription": {
        "para": "If next is not NULL, then next[0] will contain the previous element and next[1] the next element. If either does not exist, then the corresponding entry in next is unchanged."
       }
      },
      {
       "parameternamelist": {
        "parametername": "cmp"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "av_tree_find()",
          "@_refid": "group__lavu__tree_1ga1ce07d7fe428946286aad96d77dcdb56",
          "@_kindref": "member"
         },
         "#text": "compare function used to compare elements in the tree, API identical to that of Standard C's qsort It is guaranteed that the first and only the first argument to cmp() will be the key parameter to, thus it could if the user wants, be a different type (like an opaque context)."
        }
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "An element with cmp(key, elem) == 0 or NULL if no such element exists in the tree.",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tree.h",
   "@_line": "66",
   "@_column": "6",
   "@_declfile": "libavutil/tree.h",
   "@_declline": "66",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__tree_1ga1ce07d7fe428946286aad96d77dcdb56",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Find an element.\n * @param root a pointer to the root node of the tree\n * @param next If next is not NULL, then next[0] will contain the previous\n *             element and next[1] the next element. If either does not exist,\n *             then the corresponding entry in next is unchanged.\n * @param cmp compare function used to compare elements in the tree,\n *            API identical to that of Standard C's qsort\n *            It is guaranteed that the first and only the first argument to cmp()\n *            will be the key parameter to av_tree_find(), thus it could if the\n *            user wants, be a different type (like an opaque context).\n * @return An element with cmp(key, elem) == 0 or NULL if no such element\n *         exists in the tree.\n */"
 },
 "av_tree_insert": {
  "type": "void *",
  "definition": "void * av_tree_insert",
  "argsstring": "(struct AVTreeNode **rootp, void *key, int(*cmp)(const void *key, const void *b), struct AVTreeNode **next)",
  "name": "av_tree_insert",
  "param": [
   {
    "type": "struct AVTreeNode **",
    "declname": "rootp"
   },
   {
    "type": "void *",
    "declname": "key"
   },
   {
    "type": "int(*)(const void *key, const void *b)",
    "declname": "cmp"
   },
   {
    "type": "struct AVTreeNode **",
    "declname": "next"
   }
  ],
  "briefdescription": {
   "para": "Insert or remove an element."
  },
  "detaileddescription": {
   "para": [
    "If *next is NULL, then the supplied element will be removed if it exists. If *next is non-NULL, then the supplied element will be inserted, unless it already exists in the tree.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "rootp"
        },
        "parameterdescription": {
         "para": "A pointer to a pointer to the root node of the tree; note that the root node can change during insertions, this is required to keep the tree balanced."
        }
       },
       {
        "parameternamelist": {
         "parametername": "key"
        },
        "parameterdescription": {
         "para": "pointer to the element key to insert in the tree"
        }
       },
       {
        "parameternamelist": {
         "parametername": "next"
        },
        "parameterdescription": {
         "para": {
          "ref": [
           {
            "#text": "av_tree_insert()",
            "@_refid": "group__lavu__tree_1ga38d25f261bb10c12eb5bc0a1e96f2d67",
            "@_kindref": "member"
           },
           {
            "#text": "av_tree_insert()",
            "@_refid": "group__lavu__tree_1ga38d25f261bb10c12eb5bc0a1e96f2d67",
            "@_kindref": "member"
           }
          ],
          "programlisting": {
           "codeline": [
            {
             "highlight": {
              "sp": [
               "",
               "",
               "",
               "",
               ""
              ],
              "#text": "void*tree_insert(structAVTreeNode**rootp,void*key,",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "sp": [
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               ""
              ],
              "#text": "int(*cmp)(void*key,constvoid*b),",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "sp": [
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               ""
              ],
              "#text": "AVTreeNode**next)",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "#text": "{",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "sp": [
               "",
               "",
               "",
               "",
               ""
              ],
              "#text": "if(!*next)",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "sp": [
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               ""
              ],
              "#text": "*next=av_mallocz(av_tree_node_size);",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "sp": [
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               ""
              ],
              "#text": "returnav_tree_insert(rootp,key,cmp,next);",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "#text": "}",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "sp": [
               "",
               "",
               "",
               "",
               ""
              ],
              "#text": "void*tree_remove(structAVTreeNode**rootp,void*key,",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "sp": [
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               ""
              ],
              "#text": "int(*cmp)(void*key,constvoid*b,AVTreeNode**next))",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "#text": "{",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "sp": [
               "",
               "",
               "",
               ""
              ],
              "#text": "av_freep(next);",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "sp": [
               "",
               "",
               "",
               "",
               "",
               "",
               "",
               ""
              ],
              "#text": "returnav_tree_insert(rootp,key,cmp,next);",
              "@_class": "normal"
             }
            },
            {
             "highlight": {
              "#text": "}",
              "@_class": "normal"
             }
            }
           ]
          },
          "#text": "Used to allocate and free AVTreeNodes. For insertion the user must set it to an allocated and zeroed object of at least av_tree_node_size bytes size.will set it to NULL if it has been consumed. For deleting elements *next is set to NULL by the user andwill set it to the AVTreeNode which was used for the removed element. This allows the use of flat arrays, which have lower overhead compared to many malloced elements. You might want to define a function like:"
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": "cmp"
        },
        "parameterdescription": {
         "para": "compare function used to compare elements in the tree, API identical to that of Standard C's qsort"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "If no insertion happened, the found element; if an insertion or removal happened, then either key or NULL will be returned. Which one it is depends on the tree state and the implementation. You should make no assumptions that it's one or the other in the code.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tree.h",
   "@_line": "113",
   "@_column": "6",
   "@_declfile": "libavutil/tree.h",
   "@_declline": "113",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__tree_1ga38d25f261bb10c12eb5bc0a1e96f2d67",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Insert or remove an element.\n *\n * If *next is NULL, then the supplied element will be removed if it exists.\n * If *next is non-NULL, then the supplied element will be inserted, unless\n * it already exists in the tree.\n *\n * @param rootp A pointer to a pointer to the root node of the tree; note that\n *              the root node can change during insertions, this is required\n *              to keep the tree balanced.\n * @param key  pointer to the element key to insert in the tree\n * @param next Used to allocate and free AVTreeNodes. For insertion the user\n *             must set it to an allocated and zeroed object of at least\n *             av_tree_node_size bytes size. av_tree_insert() will set it to\n *             NULL if it has been consumed.\n *             For deleting elements *next is set to NULL by the user and\n *             av_tree_insert() will set it to the AVTreeNode which was\n *             used for the removed element.\n *             This allows the use of flat arrays, which have\n *             lower overhead compared to many malloced elements.\n *             You might want to define a function like:\n *             @code\n *             void *tree_insert(struct AVTreeNode **rootp, void *key,\n *                               int (*cmp)(void *key, const void *b),\n *                               AVTreeNode **next)\n *             {\n *                 if (!*next)\n *                     *next = av_mallocz(av_tree_node_size);\n *                 return av_tree_insert(rootp, key, cmp, next);\n *             }\n *             void *tree_remove(struct AVTreeNode **rootp, void *key,\n *                               int (*cmp)(void *key, const void *b, AVTreeNode **next))\n *             {\n *                 av_freep(next);\n *                 return av_tree_insert(rootp, key, cmp, next);\n *             }\n *             @endcode\n * @param cmp compare function used to compare elements in the tree, API identical\n *            to that of Standard C's qsort\n * @return If no insertion happened, the found element; if an insertion or\n *         removal happened, then either key or NULL will be returned.\n *         Which one it is depends on the tree state and the implementation. You\n *         should make no assumptions that it's one or the other in the code.\n */"
 },
 "av_tree_destroy": {
  "type": "void",
  "definition": "void av_tree_destroy",
  "argsstring": "(struct AVTreeNode *t)",
  "name": "av_tree_destroy",
  "param": {
   "type": "struct AVTreeNode *",
   "declname": "t"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tree.h",
   "@_line": "117",
   "@_column": "6",
   "@_declfile": "libavutil/tree.h",
   "@_declline": "117",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__tree_1gae2f16a7b3895fd776696cd9eccd6c26a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Insert or remove an element.\n *\n * If *next is NULL, then the supplied element will be removed if it exists.\n * If *next is non-NULL, then the supplied element will be inserted, unless\n * it already exists in the tree.\n *\n * @param rootp A pointer to a pointer to the root node of the tree; note that\n *              the root node can change during insertions, this is required\n *              to keep the tree balanced.\n * @param key  pointer to the element key to insert in the tree\n * @param next Used to allocate and free AVTreeNodes. For insertion the user\n *             must set it to an allocated and zeroed object of at least\n *             av_tree_node_size bytes size. av_tree_insert() will set it to\n *             NULL if it has been consumed.\n *             For deleting elements *next is set to NULL by the user and\n *             av_tree_insert() will set it to the AVTreeNode which was\n *             used for the removed element.\n *             This allows the use of flat arrays, which have\n *             lower overhead compared to many malloced elements.\n *             You might want to define a function like:\n *             @code\n *             void *tree_insert(struct AVTreeNode **rootp, void *key,\n *                               int (*cmp)(void *key, const void *b),\n *                               AVTreeNode **next)\n *             {\n *                 if (!*next)\n *                     *next = av_mallocz(av_tree_node_size);\n *                 return av_tree_insert(rootp, key, cmp, next);\n *             }\n *             void *tree_remove(struct AVTreeNode **rootp, void *key,\n *                               int (*cmp)(void *key, const void *b, AVTreeNode **next))\n *             {\n *                 av_freep(next);\n *                 return av_tree_insert(rootp, key, cmp, next);\n *             }\n *             @endcode\n * @param cmp compare function used to compare elements in the tree, API identical\n *            to that of Standard C's qsort\n * @return If no insertion happened, the found element; if an insertion or\n *         removal happened, then either key or NULL will be returned.\n *         Which one it is depends on the tree state and the implementation. You\n *         should make no assumptions that it's one or the other in the code.\n */"
 },
 "av_tree_enumerate": {
  "type": "void",
  "definition": "void av_tree_enumerate",
  "argsstring": "(struct AVTreeNode *t, void *opaque, int(*cmp)(void *opaque, void *elem), int(*enu)(void *opaque, void *elem))",
  "name": "av_tree_enumerate",
  "param": [
   {
    "type": "struct AVTreeNode *",
    "declname": "t"
   },
   {
    "type": "void *",
    "declname": "opaque"
   },
   {
    "type": "int(*)(void *opaque, void *elem)",
    "declname": "cmp"
   },
   {
    "type": "int(*)(void *opaque, void *elem)",
    "declname": "enu"
   }
  ],
  "briefdescription": {
   "para": "Apply enu(opaque, &elem) to all the elements in the tree in a given range."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": {
      "parameternamelist": {
       "parametername": "cmp"
      },
      "parameterdescription": {
       "para": "a comparison function that returns < 0 for an element below the range, > 0 for an element above the range and == 0 for an element inside the range"
      }
     },
     "@_kind": "param"
    },
    "simplesect": {
     "para": "The cmp function should use the same ordering used to construct the tree.",
     "@_kind": "note"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tree.h",
   "@_line": "129",
   "@_column": "6",
   "@_declfile": "libavutil/tree.h",
   "@_declline": "129",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__tree_1ga1c7cce17e3ab55eb07c6ad8739ff58d2",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Apply enu(opaque, &elem) to all the elements in the tree in a given range.\n *\n * @param cmp a comparison function that returns < 0 for an element below the\n *            range, > 0 for an element above the range and == 0 for an\n *            element inside the range\n *\n * @note The cmp function should use the same ordering used to construct the\n *       tree.\n */"
 },
 "AVTXContext": {
  "type": {
   "ref": {
    "#text": "AVTXContext",
    "@_refid": "tx_8h_1ad52e394091e2cfe7115c99868a4ea652",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVTXContext AVTXContext",
  "argsstring": "",
  "name": "AVTXContext",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tx.h",
   "@_line": "25",
   "@_column": "26",
   "@_bodyfile": "libavutil/tx.h",
   "@_bodystart": "25",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "tx_8h_1ad52e394091e2cfe7115c99868a4ea652",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */"
 },
 "av_tx_fn": {
  "type": "void(*",
  "definition": "typedef void(* av_tx_fn) (AVTXContext *s, void *out, void *in, ptrdiff_t stride)",
  "argsstring": ")(AVTXContext *s, void *out, void *in, ptrdiff_t stride)",
  "name": "av_tx_fn",
  "briefdescription": {
   "para": "Function pointer to a function to perform the transform."
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "av_tx_init()",
       "@_refid": "tx_8h_1aa601adb1dc77a099ea416befb62daae7",
       "@_kindref": "member"
      },
      "#text": "Using a different context than the one allocated duringis not allowed."
     },
     "@_kind": "note"
    },
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "the transform context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "out"
       },
       "parameterdescription": {
        "para": "the output array"
       }
      },
      {
       "parameternamelist": {
        "parametername": "in"
       },
       "parameterdescription": {
        "para": "the input array"
       }
      },
      {
       "parameternamelist": {
        "parametername": "stride"
       },
       "parameterdescription": {
        "para": "the input or output stride in bytes"
       }
      }
     ],
     "@_kind": "param"
    },
    "ref": {
     "#text": "av_tx_init()",
     "@_refid": "tx_8h_1aa601adb1dc77a099ea416befb62daae7",
     "@_kindref": "member"
    },
    "#text": "The out and in arrays must be aligned to the maximum required by the CPU architecture unless the AV_TX_UNALIGNED flag was set in. The stride must follow the constraints the transform type has specified."
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tx.h",
   "@_line": "151",
   "@_column": "9",
   "@_bodyfile": "libavutil/tx.h",
   "@_bodystart": "151",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "tx_8h_1ad00328aab6affff0139f065963256550",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * Function pointer to a function to perform the transform.\n *\n * @note Using a different context than the one allocated during av_tx_init()\n * is not allowed.\n *\n * @param s the transform context\n * @param out the output array\n * @param in the input array\n * @param stride the input or output stride in bytes\n *\n * The out and in arrays must be aligned to the maximum required by the CPU\n * architecture unless the AV_TX_UNALIGNED flag was set in av_tx_init().\n * The stride must follow the constraints the transform type has specified.\n */"
 },
 "av_tx_init": {
  "type": "int",
  "definition": "int av_tx_init",
  "argsstring": "(AVTXContext **ctx, av_tx_fn *tx, enum AVTXType type, int inv, int len, const void *scale, uint64_t flags)",
  "name": "av_tx_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVTXContext",
      "@_refid": "tx_8h_1ad52e394091e2cfe7115c99868a4ea652",
      "@_kindref": "member"
     },
     "#text": "**"
    },
    "declname": "ctx"
   },
   {
    "type": {
     "ref": {
      "#text": "av_tx_fn",
      "@_refid": "tx_8h_1ad00328aab6affff0139f065963256550",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "tx"
   },
   {
    "type": {
     "ref": {
      "#text": "AVTXType",
      "@_refid": "tx_8h_1a9e5d60f8411afe2d6045735639cf6fb0",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "int",
    "declname": "inv"
   },
   {
    "type": "int",
    "declname": "len"
   },
   {
    "type": "const void *",
    "declname": "scale"
   },
   {
    "type": "uint64_t",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Initialize a transform context with the given configuration (i)MDCTs with an odd length are currently not supported."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": "the context to allocate, will be NULL on error"
       }
      },
      {
       "parameternamelist": {
        "parametername": "tx"
       },
       "parameterdescription": {
        "para": "pointer to the transform function pointer to set"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "type the type of transform"
       }
      },
      {
       "parameternamelist": {
        "parametername": "inv"
       },
       "parameterdescription": {
        "para": "whether to do an inverse or a forward transform"
       }
      },
      {
       "parameternamelist": {
        "parametername": "len"
       },
       "parameterdescription": {
        "para": "the size of the transform in samples"
       }
      },
      {
       "parameternamelist": {
        "parametername": "scale"
       },
       "parameterdescription": {
        "para": "pointer to the value to scale the output if supported by type"
       }
      },
      {
       "parameternamelist": {
        "parametername": "flags"
       },
       "parameterdescription": {
        "para": "a bitmask of AVTXFlags or 0"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "0 on success, negative error code on failure",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tx.h",
   "@_line": "202",
   "@_column": "5",
   "@_declfile": "libavutil/tx.h",
   "@_declline": "202",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "tx_8h_1aa601adb1dc77a099ea416befb62daae7",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize a transform context with the given configuration\n * (i)MDCTs with an odd length are currently not supported.\n *\n * @param ctx the context to allocate, will be NULL on error\n * @param tx pointer to the transform function pointer to set\n * @param type type the type of transform\n * @param inv whether to do an inverse or a forward transform\n * @param len the size of the transform in samples\n * @param scale pointer to the value to scale the output if supported by type\n * @param flags a bitmask of AVTXFlags or 0\n *\n * @return 0 on success, negative error code on failure\n */"
 },
 "av_tx_uninit": {
  "type": "void",
  "definition": "void av_tx_uninit",
  "argsstring": "(AVTXContext **ctx)",
  "name": "av_tx_uninit",
  "param": {
   "type": {
    "ref": {
     "#text": "AVTXContext",
     "@_refid": "tx_8h_1ad52e394091e2cfe7115c99868a4ea652",
     "@_kindref": "member"
    },
    "#text": "**"
   },
   "declname": "ctx"
  },
  "briefdescription": {
   "para": "Frees a context and sets *ctx to NULL, does nothing when *ctx == NULL."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/tx.h",
   "@_line": "208",
   "@_column": "6",
   "@_declfile": "libavutil/tx.h",
   "@_declline": "208",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "tx_8h_1a73b66589b101e98f383720e220c7c261",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Frees a context and sets *ctx to NULL, does nothing when *ctx == NULL.\n */"
 },
 "AVUUID": {
  "type": "uint8_t",
  "definition": "typedef uint8_t AVUUID[AV_UUID_LEN]",
  "argsstring": "[AV_UUID_LEN]",
  "name": "AVUUID",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/uuid.h",
   "@_line": "60",
   "@_column": "17",
   "@_bodyfile": "libavutil/uuid.h",
   "@_bodystart": "60",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "uuid_8h_1ad5042c764f883e75ad55e217e65a90d5",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/* Binary representation of a UUID */"
 },
 "av_uuid_parse": {
  "type": "int",
  "definition": "int av_uuid_parse",
  "argsstring": "(const char *in, AVUUID uu)",
  "name": "av_uuid_parse",
  "param": [
   {
    "type": "const char *",
    "declname": "in"
   },
   {
    "type": {
     "ref": {
      "#text": "AVUUID",
      "@_refid": "uuid_8h_1ad5042c764f883e75ad55e217e65a90d5",
      "@_kindref": "member"
     }
    },
    "declname": "uu"
   }
  ],
  "briefdescription": {
   "para": "Parses a string representation of a UUID formatted according to IETF RFC 4122 into an AVUUID."
  },
  "detaileddescription": {
   "para": [
    "The parsing is case-insensitive. The string must be 37 characters long, including the terminating NUL character.",
    "Example string representation: \"2fceebd0-7017-433d-bafb-d073a7116696\"",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "in",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "String representation of a UUID, e.g. 2fceebd0-7017-433d-bafb-d073a7116696"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "uu",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "AVUUID"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "A non-zero value in case of an error.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/uuid.h",
   "@_line": "74",
   "@_column": "5",
   "@_declfile": "libavutil/uuid.h",
   "@_declline": "74",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "uuid_8h_1a0a77dd3b850426ad51bae7db059ccb03",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parses a string representation of a UUID formatted according to IETF RFC 4122\n * into an AVUUID. The parsing is case-insensitive. The string must be 37\n * characters long, including the terminating NUL character.\n *\n * Example string representation: \"2fceebd0-7017-433d-bafb-d073a7116696\"\n *\n * @param[in]  in  String representation of a UUID,\n *                 e.g. 2fceebd0-7017-433d-bafb-d073a7116696\n * @param[out] uu  AVUUID\n * @return         A non-zero value in case of an error.\n */"
 },
 "av_uuid_urn_parse": {
  "type": "int",
  "definition": "int av_uuid_urn_parse",
  "argsstring": "(const char *in, AVUUID uu)",
  "name": "av_uuid_urn_parse",
  "param": [
   {
    "type": "const char *",
    "declname": "in"
   },
   {
    "type": {
     "ref": {
      "#text": "AVUUID",
      "@_refid": "uuid_8h_1ad5042c764f883e75ad55e217e65a90d5",
      "@_kindref": "member"
     }
    },
    "declname": "uu"
   }
  ],
  "briefdescription": {
   "para": "Parses a URN representation of a UUID, as specified at IETF RFC 4122, into an AVUUID."
  },
  "detaileddescription": {
   "para": [
    "The parsing is case-insensitive. The string must be 46 characters long, including the terminating NUL character.",
    "Example string representation: \"urn:uuid:2fceebd0-7017-433d-bafb-d073a7116696\"",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "in",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "URN UUID"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "uu",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "AVUUID"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "A non-zero value in case of an error.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/uuid.h",
   "@_line": "87",
   "@_column": "5",
   "@_declfile": "libavutil/uuid.h",
   "@_declline": "87",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "uuid_8h_1a6de4afca7fb4df2aa15505bc40d6f101",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parses a URN representation of a UUID, as specified at IETF RFC 4122,\n * into an AVUUID. The parsing is case-insensitive. The string must be 46\n * characters long, including the terminating NUL character.\n *\n * Example string representation: \"urn:uuid:2fceebd0-7017-433d-bafb-d073a7116696\"\n *\n * @param[in]  in  URN UUID\n * @param[out] uu  AVUUID\n * @return         A non-zero value in case of an error.\n */"
 },
 "av_uuid_parse_range": {
  "type": "int",
  "definition": "int av_uuid_parse_range",
  "argsstring": "(const char *in_start, const char *in_end, AVUUID uu)",
  "name": "av_uuid_parse_range",
  "param": [
   {
    "type": "const char *",
    "declname": "in_start"
   },
   {
    "type": "const char *",
    "declname": "in_end"
   },
   {
    "type": {
     "ref": {
      "#text": "AVUUID",
      "@_refid": "uuid_8h_1ad5042c764f883e75ad55e217e65a90d5",
      "@_kindref": "member"
     }
    },
    "declname": "uu"
   }
  ],
  "briefdescription": {
   "para": "Parses a string representation of a UUID formatted according to IETF RFC 4122 into an AVUUID."
  },
  "detaileddescription": {
   "para": [
    "The parsing is case-insensitive.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "in_start",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "Pointer to the first character of the string representation"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "in_end",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": {
          "computeroutput": "in_end - in_start != 36",
          "#text": "Pointer to the character after the last character of the string representation. That memory location is never accessed. It is an error if."
         }
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "uu",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "AVUUID"
        }
       }
      ],
      "@_kind": "param"
     },
     "simplesect": {
      "para": "A non-zero value in case of an error.",
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/uuid.h",
   "@_line": "100",
   "@_column": "5",
   "@_declfile": "libavutil/uuid.h",
   "@_declline": "100",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "uuid_8h_1ad4f320a323aa62d54aa41979a1117466",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Parses a string representation of a UUID formatted according to IETF RFC 4122\n * into an AVUUID. The parsing is case-insensitive.\n *\n * @param[in]  in_start Pointer to the first character of the string representation\n * @param[in]  in_end   Pointer to the character after the last character of the\n *                      string representation. That memory location is never\n *                      accessed. It is an error if `in_end - in_start != 36`.\n * @param[out] uu       AVUUID\n * @return              A non-zero value in case of an error.\n */"
 },
 "av_uuid_unparse": {
  "type": "void",
  "definition": "void av_uuid_unparse",
  "argsstring": "(const AVUUID uu, char *out)",
  "name": "av_uuid_unparse",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVUUID",
      "@_refid": "uuid_8h_1ad5042c764f883e75ad55e217e65a90d5",
      "@_kindref": "member"
     },
     "#text": "const"
    },
    "declname": "uu"
   },
   {
    "type": "char *",
    "declname": "out"
   }
  ],
  "briefdescription": {
   "para": "Serializes a AVUUID into a string representation according to IETF RFC 4122."
  },
  "detaileddescription": {
   "para": [
    "The string is lowercase and always 37 characters long, including the terminating NUL character.",
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": {
          "#text": "uu",
          "@_direction": "in"
         }
        },
        "parameterdescription": {
         "para": "AVUUID"
        }
       },
       {
        "parameternamelist": {
         "parametername": {
          "#text": "out",
          "@_direction": "out"
         }
        },
        "parameterdescription": {
         "para": "Pointer to an array of no less than 37 characters."
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/uuid.h",
   "@_line": "110",
   "@_column": "6",
   "@_declfile": "libavutil/uuid.h",
   "@_declline": "110",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "uuid_8h_1aad1f80ae641e42983d4be7797ef50260",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Serializes a AVUUID into a string representation according to IETF RFC 4122.\n * The string is lowercase and always 37 characters long, including the\n * terminating NUL character.\n *\n * @param[in]  uu  AVUUID\n * @param[out] out Pointer to an array of no less than 37 characters.\n */"
 },
 "av_uuid_equal": {
  "type": "int",
  "definition": "static int av_uuid_equal",
  "argsstring": "(const AVUUID uu1, const AVUUID uu2)",
  "name": "av_uuid_equal",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVUUID",
      "@_refid": "uuid_8h_1ad5042c764f883e75ad55e217e65a90d5",
      "@_kindref": "member"
     },
     "#text": "const"
    },
    "declname": "uu1"
   },
   {
    "type": {
     "ref": {
      "#text": "AVUUID",
      "@_refid": "uuid_8h_1ad5042c764f883e75ad55e217e65a90d5",
      "@_kindref": "member"
     },
     "#text": "const"
    },
    "declname": "uu2"
   }
  ],
  "briefdescription": {
   "para": "Compares two UUIDs for equality."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "uu1",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "AVUUID"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "uu2",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "AVUUID"
       }
      }
     ],
     "@_kind": "param"
    },
    "simplesect": {
     "para": "Nonzero if uu1 and uu2 are identical, 0 otherwise",
     "@_kind": "return"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/uuid.h",
   "@_line": "119",
   "@_column": "19",
   "@_bodyfile": "libavutil/uuid.h",
   "@_bodystart": "119",
   "@_bodyend": "122"
  },
  "@_kind": "function",
  "@_id": "uuid_8h_1a24285ce51c6f5514a17c93954432ac1c",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Compares two UUIDs for equality.\n *\n * @param[in]  uu1  AVUUID\n * @param[in]  uu2  AVUUID\n * @return          Nonzero if uu1 and uu2 are identical, 0 otherwise\n */"
 },
 "av_uuid_copy": {
  "type": "void",
  "definition": "static void av_uuid_copy",
  "argsstring": "(AVUUID dest, const AVUUID src)",
  "name": "av_uuid_copy",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVUUID",
      "@_refid": "uuid_8h_1ad5042c764f883e75ad55e217e65a90d5",
      "@_kindref": "member"
     }
    },
    "declname": "dest"
   },
   {
    "type": {
     "ref": {
      "#text": "AVUUID",
      "@_refid": "uuid_8h_1ad5042c764f883e75ad55e217e65a90d5",
      "@_kindref": "member"
     },
     "#text": "const"
    },
    "declname": "src"
   }
  ],
  "briefdescription": {
   "para": "Copies the bytes of src into dest."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": {
         "#text": "dest",
         "@_direction": "out"
        }
       },
       "parameterdescription": {
        "para": "AVUUID"
       }
      },
      {
       "parameternamelist": {
        "parametername": {
         "#text": "src",
         "@_direction": "in"
        }
       },
       "parameterdescription": {
        "para": "AVUUID"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/uuid.h",
   "@_line": "130",
   "@_column": "20",
   "@_bodyfile": "libavutil/uuid.h",
   "@_bodystart": "130",
   "@_bodyend": "133"
  },
  "@_kind": "function",
  "@_id": "uuid_8h_1a0b8595a106ebeb8ed28dd485ceefa916",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Copies the bytes of src into dest.\n *\n * @param[out]  dest  AVUUID\n * @param[in]   src   AVUUID\n */"
 },
 "av_uuid_nil": {
  "type": "void",
  "definition": "static void av_uuid_nil",
  "argsstring": "(AVUUID uu)",
  "name": "av_uuid_nil",
  "param": {
   "type": {
    "ref": {
     "#text": "AVUUID",
     "@_refid": "uuid_8h_1ad5042c764f883e75ad55e217e65a90d5",
     "@_kindref": "member"
    }
   },
   "declname": "uu"
  },
  "briefdescription": {
   "para": "Sets a UUID to the nil UUID, i.e."
  },
  "detaileddescription": {
   "para": [
    "a UUID with have all its 128 bits set to zero.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": {
         "#text": "uu",
         "@_direction": "inout"
        }
       },
       "parameterdescription": {
        "para": "UUID to be set to the nil UUID"
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/uuid.h",
   "@_line": "141",
   "@_column": "20",
   "@_bodyfile": "libavutil/uuid.h",
   "@_bodystart": "141",
   "@_bodyend": "144"
  },
  "@_kind": "function",
  "@_id": "uuid_8h_1a71ac410e3785fc3e6261b363c58391eb",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "yes",
  "@_virt": "non-virtual",
  "raw": "/**\n * Sets a UUID to the nil UUID, i.e. a UUID with have all\n * its 128 bits set to zero.\n *\n * @param[in,out]  uu  UUID to be set to the nil UUID\n */"
 },
 "AVVDPAU_Render2": {
  "type": "int(*",
  "definition": "typedef int(* AVVDPAU_Render2) (struct AVCodecContext *, struct AVFrame *, const VdpPictureInfo *, uint32_t, const VdpBitstreamBuffer *)",
  "argsstring": ")(struct AVCodecContext *, struct AVFrame *, const VdpPictureInfo *, uint32_t, const VdpBitstreamBuffer *)",
  "name": "AVVDPAU_Render2",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vdpau.h",
   "@_line": "62",
   "@_column": "9",
   "@_bodyfile": "libavcodec/vdpau.h",
   "@_bodystart": "62",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "group__lavc__codec__hwaccel__vdpau_1ga1f243045ef2673ebe2a50a8431f3dfa7",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * @defgroup lavc_codec_hwaccel_vdpau VDPAU Decoder and Renderer\n * @ingroup lavc_codec_hwaccel\n *\n * VDPAU hardware acceleration has two modules\n * - VDPAU decoding\n * - VDPAU presentation\n *\n * The VDPAU decoding module parses all headers using FFmpeg\n * parsing mechanisms and uses VDPAU for the actual decoding.\n *\n * As per the current implementation, the actual decoding\n * and rendering (API calls) are done as part of the VDPAU\n * presentation (vo_vdpau.c) module.\n *\n * @{\n */"
 },
 "av_alloc_vdpaucontext": {
  "type": {
   "ref": [
    {
     "#text": "attribute_deprecated",
     "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
     "@_kindref": "member"
    },
    {
     "#text": "AVVDPAUContext",
     "@_refid": "structAVVDPAUContext",
     "@_kindref": "compound"
    }
   ],
   "#text": "*"
  },
  "definition": "attribute_deprecated AVVDPAUContext * av_alloc_vdpaucontext",
  "argsstring": "(void)",
  "name": "av_alloc_vdpaucontext",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVVDPAUContext",
     "@_refid": "structAVVDPAUContext",
     "@_kindref": "compound"
    },
    "#text": "allocation function for"
   }
  },
  "detaileddescription": {
   "para": {
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": {
       "ref": {
        "#text": "av_vdpau_bind_context()",
        "@_refid": "group__lavc__codec__hwaccel__vdpau_1gac56d6b1b4478056afc0e0a8f52271afa",
        "@_kindref": "member"
       },
       "#text": "useinstead"
      }
     },
     "@_id": "deprecated_1_deprecated000022"
    },
    "#text": "Allows extending the struct without breaking API/ABI"
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vdpau.h",
   "@_line": "104",
   "@_column": "16",
   "@_declfile": "libavcodec/vdpau.h",
   "@_declline": "104",
   "@_declcolumn": "16"
  },
  "@_kind": "function",
  "@_id": "group__lavc__codec__hwaccel__vdpau_1ga9171bfadb19674c822292fea3039ee17",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @brief allocation function for AVVDPAUContext\n *\n * Allows extending the struct without breaking API/ABI\n * @deprecated use av_vdpau_bind_context() instead\n */"
 },
 "av_vdpau_hwaccel_get_render2": {
  "type": {
   "ref": [
    {
     "#text": "attribute_deprecated",
     "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
     "@_kindref": "member"
    },
    {
     "#text": "AVVDPAU_Render2",
     "@_refid": "group__lavc__codec__hwaccel__vdpau_1ga1f243045ef2673ebe2a50a8431f3dfa7",
     "@_kindref": "member"
    }
   ]
  },
  "definition": "attribute_deprecated AVVDPAU_Render2 av_vdpau_hwaccel_get_render2",
  "argsstring": "(const AVVDPAUContext *)",
  "name": "av_vdpau_hwaccel_get_render2",
  "param": {
   "type": {
    "ref": {
     "#text": "AVVDPAUContext",
     "@_refid": "structAVVDPAUContext",
     "@_kindref": "compound"
    },
    "#text": "const*"
   }
  },
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": "render2 is public and can be accessed directly"
     },
     "@_id": "deprecated_1_deprecated000023"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vdpau.h",
   "@_line": "110",
   "@_column": "17",
   "@_declfile": "libavcodec/vdpau.h",
   "@_declline": "110",
   "@_declcolumn": "17"
  },
  "@_kind": "function",
  "@_id": "group__lavc__codec__hwaccel__vdpau_1ga64c8727fff87ec0b5b2a28dacc49b79b",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @deprecated render2 is public and can be accessed directly\n */"
 },
 "av_vdpau_hwaccel_set_render2": {
  "type": {
   "ref": {
    "#text": "attribute_deprecated",
    "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
    "@_kindref": "member"
   },
   "#text": "void"
  },
  "definition": "attribute_deprecated void av_vdpau_hwaccel_set_render2",
  "argsstring": "(AVVDPAUContext *, AVVDPAU_Render2)",
  "name": "av_vdpau_hwaccel_set_render2",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVVDPAUContext",
      "@_refid": "structAVVDPAUContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    }
   },
   {
    "type": {
     "ref": {
      "#text": "AVVDPAU_Render2",
      "@_refid": "group__lavc__codec__hwaccel__vdpau_1ga1f243045ef2673ebe2a50a8431f3dfa7",
      "@_kindref": "member"
     }
    }
   }
  ],
  "briefdescription": "",
  "detaileddescription": {
   "para": {
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": "render2 is public and can be accessed directly"
     },
     "@_id": "deprecated_1_deprecated000024"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vdpau.h",
   "@_line": "115",
   "@_column": "6",
   "@_declfile": "libavcodec/vdpau.h",
   "@_declline": "115",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavc__codec__hwaccel__vdpau_1ga27730edf014f427380beeaead4bba0ae",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * @deprecated render2 is public and can be accessed directly\n */"
 },
 "av_vdpau_bind_context": {
  "type": "int",
  "definition": "int av_vdpau_bind_context",
  "argsstring": "(AVCodecContext *avctx, VdpDevice device, VdpGetProcAddress *get_proc_address, unsigned flags)",
  "name": "av_vdpau_bind_context",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": "VdpDevice",
    "declname": "device"
   },
   {
    "type": "VdpGetProcAddress *",
    "declname": "get_proc_address"
   },
   {
    "type": "unsigned",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Associate a VDPAU device with a codec context for hardware acceleration."
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "avcodec_flush_buffers()",
      "@_refid": "group__lavc__misc_1gaf60b0e076f822abcb2700eb601d352a6",
      "@_kindref": "member"
     },
     "#text": "This function is meant to be called from the get_format() codec callback, or earlier. It can also be called afterto change the underlying VDPAU device mid-stream (e.g. to recover from non-transparent display preemption)."
    },
    {
     "simplesect": [
      {
       "para": "get_format() must return AV_PIX_FMT_VDPAU if this function completes successfully.",
       "@_kind": "note"
      },
      {
       "para": "0 on success, an AVERROR code on failure.",
       "@_kind": "return"
      }
     ],
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "avctx"
        },
        "parameterdescription": {
         "para": "decoding context whose get_format() callback is invoked"
        }
       },
       {
        "parameternamelist": {
         "parametername": "device"
        },
        "parameterdescription": {
         "para": "VDPAU device handle to use for hardware acceleration"
        }
       },
       {
        "parameternamelist": {
         "parametername": "get_proc_address"
        },
        "parameterdescription": {
         "para": "VDPAU device driver"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "zero of more OR'd AV_HWACCEL_FLAG_* flags"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vdpau.h",
   "@_line": "135",
   "@_column": "5",
   "@_declfile": "libavcodec/vdpau.h",
   "@_declline": "135",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__codec__hwaccel__vdpau_1gac56d6b1b4478056afc0e0a8f52271afa",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Associate a VDPAU device with a codec context for hardware acceleration.\n * This function is meant to be called from the get_format() codec callback,\n * or earlier. It can also be called after avcodec_flush_buffers() to change\n * the underlying VDPAU device mid-stream (e.g. to recover from non-transparent\n * display preemption).\n *\n * @note get_format() must return AV_PIX_FMT_VDPAU if this function completes\n * successfully.\n *\n * @param avctx decoding context whose get_format() callback is invoked\n * @param device VDPAU device handle to use for hardware acceleration\n * @param get_proc_address VDPAU device driver\n * @param flags zero of more OR'd AV_HWACCEL_FLAG_* flags\n *\n * @return 0 on success, an AVERROR code on failure.\n */"
 },
 "av_vdpau_get_surface_parameters": {
  "type": "int",
  "definition": "int av_vdpau_get_surface_parameters",
  "argsstring": "(AVCodecContext *avctx, VdpChromaType *type, uint32_t *width, uint32_t *height)",
  "name": "av_vdpau_get_surface_parameters",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVCodecContext",
      "@_refid": "structAVCodecContext",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "avctx"
   },
   {
    "type": "VdpChromaType *",
    "declname": "type"
   },
   {
    "type": "uint32_t *",
    "declname": "width"
   },
   {
    "type": "uint32_t *",
    "declname": "height"
   }
  ],
  "briefdescription": {
   "para": "Gets the parameters to create an adequate VDPAU video surface for the codec context using VDPAU hardware decoding acceleration."
  },
  "detaileddescription": {
   "para": {
    "simplesect": [
     {
      "para": {
       "ref": {
        "#text": "av_vdpau_bind_context()",
        "@_refid": "group__lavc__codec__hwaccel__vdpau_1gac56d6b1b4478056afc0e0a8f52271afa",
        "@_kindref": "member"
       },
       "#text": "Behavior is undefined if the context was not successfully bound to a VDPAU device using."
      },
      "@_kind": "note"
     },
     {
      "para": "0 on success, a negative AVERROR code on failure.",
      "@_kind": "return"
     }
    ],
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "avctx"
       },
       "parameterdescription": {
        "para": "the codec context being used for decoding the stream"
       }
      },
      {
       "parameternamelist": {
        "parametername": "type"
       },
       "parameterdescription": {
        "para": "storage space for the VDPAU video surface chroma type (or NULL to ignore)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "width"
       },
       "parameterdescription": {
        "para": "storage space for the VDPAU video surface pixel width (or NULL to ignore)"
       }
      },
      {
       "parameternamelist": {
        "parametername": "height"
       },
       "parameterdescription": {
        "para": "storage space for the VDPAU video surface pixel height (or NULL to ignore)"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vdpau.h",
   "@_line": "155",
   "@_column": "5",
   "@_declfile": "libavcodec/vdpau.h",
   "@_declline": "155",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "group__lavc__codec__hwaccel__vdpau_1gad4354a22f2f4d44000515e836b7863af",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Gets the parameters to create an adequate VDPAU video surface for the codec\n * context using VDPAU hardware decoding acceleration.\n *\n * @note Behavior is undefined if the context was not successfully bound to a\n * VDPAU device using av_vdpau_bind_context().\n *\n * @param avctx the codec context being used for decoding the stream\n * @param type storage space for the VDPAU video surface chroma type\n *              (or NULL to ignore)\n * @param width storage space for the VDPAU video surface pixel width\n *              (or NULL to ignore)\n * @param height storage space for the VDPAU video surface pixel height\n *              (or NULL to ignore)\n *\n * @return 0 on success, a negative AVERROR code on failure.\n */"
 },
 "av_vdpau_alloc_context": {
  "type": {
   "ref": [
    {
     "#text": "attribute_deprecated",
     "@_refid": "attributes_8h_1aa6d076561d3a9eea4729ee632652de02",
     "@_kindref": "member"
    },
    {
     "#text": "AVVDPAUContext",
     "@_refid": "structAVVDPAUContext",
     "@_kindref": "compound"
    }
   ],
   "#text": "*"
  },
  "definition": "attribute_deprecated AVVDPAUContext * av_vdpau_alloc_context",
  "argsstring": "(void)",
  "name": "av_vdpau_alloc_context",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVVDPAUContext",
     "@_refid": "structAVVDPAUContext",
     "@_kindref": "compound"
    },
    "#text": "Allocate an."
   }
  },
  "detaileddescription": {
   "para": {
    "simplesect": {
     "para": {
      "ref": {
       "#text": "AVVDPAUContext",
       "@_refid": "structAVVDPAUContext",
       "@_kindref": "compound"
      },
      "#text": "Newly-allocatedor NULL on failure."
     },
     "@_kind": "return"
    },
    "xrefsect": {
     "xreftitle": "Deprecated",
     "xrefdescription": {
      "para": {
       "ref": {
        "#text": "av_vdpau_bind_context()",
        "@_refid": "group__lavc__codec__hwaccel__vdpau_1gac56d6b1b4478056afc0e0a8f52271afa",
        "@_kindref": "member"
       },
       "#text": "useinstead"
      }
     },
     "@_id": "deprecated_1_deprecated000025"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vdpau.h",
   "@_line": "166",
   "@_column": "16",
   "@_declfile": "libavcodec/vdpau.h",
   "@_declline": "166",
   "@_declcolumn": "16"
  },
  "@_kind": "function",
  "@_id": "group__lavc__codec__hwaccel__vdpau_1ga6509c3b2859e3281b9170725847c899a",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVVDPAUContext.\n *\n * @return Newly-allocated AVVDPAUContext or NULL on failure.\n * @deprecated use av_vdpau_bind_context() instead\n */"
 },
 "av_video_enc_params_block": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "AVVideoBlockParams",
     "@_refid": "structAVVideoBlockParams",
     "@_kindref": "compound"
    }
   ],
   "#text": "*"
  },
  "definition": "static av_always_inline AVVideoBlockParams * av_video_enc_params_block",
  "argsstring": "(AVVideoEncParams *par, unsigned int idx)",
  "name": "av_video_enc_params_block",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVVideoEncParams",
      "@_refid": "structAVVideoEncParams",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "par"
   },
   {
    "type": "unsigned int",
    "declname": "idx"
   }
  ],
  "briefdescription": {
   "para": {
    "javadoccode": "idx",
    "#text": "Get the block at the specified."
   }
  },
  "detaileddescription": {
   "para": "Must be between 0 and nb_blocks - 1."
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/video_enc_params.h",
   "@_line": "143",
   "@_column": "1",
   "@_bodyfile": "libavutil/video_enc_params.h",
   "@_bodystart": "143",
   "@_bodyend": "148"
  },
  "@_kind": "function",
  "@_id": "video__enc__params_8h_1a8c60988cd15689aaeffa365d97a82c90",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the block at the specified {@code idx}. Must be between 0 and nb_blocks - 1.\n */"
 },
 "av_video_enc_params_alloc": {
  "type": {
   "ref": {
    "#text": "AVVideoEncParams",
    "@_refid": "structAVVideoEncParams",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVVideoEncParams * av_video_enc_params_alloc",
  "argsstring": "(enum AVVideoEncParamsType type, unsigned int nb_blocks, size_t *out_size)",
  "name": "av_video_enc_params_alloc",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVVideoEncParamsType",
      "@_refid": "video__enc__params_8h_1af50af6452ba562f068d67dd2c0154fea",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "unsigned int",
    "declname": "nb_blocks"
   },
   {
    "type": "size_t *",
    "declname": "out_size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVVideoEncParams",
      "@_refid": "structAVVideoEncParams",
      "@_kindref": "compound"
     },
     {
      "#text": "AVVideoBlockParams",
      "@_refid": "structAVVideoBlockParams",
      "@_kindref": "compound"
     }
    ],
    "javadoccode": "nb_blocks",
    "#text": "Allocates memory forof the given type, plus an array ofand initializes the variables."
   }
  },
  "detaileddescription": {
   "para": [
    {
     "ref": {
      "#text": "av_free()",
      "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
      "@_kindref": "member"
     },
     "#text": "Can be freed with a normalcall."
    },
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "out_size"
       },
       "parameterdescription": {
        "para": "if non-NULL, the size in bytes of the resulting data array is written here."
       }
      },
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/video_enc_params.h",
   "@_line": "158",
   "@_column": "18",
   "@_declfile": "libavutil/video_enc_params.h",
   "@_declline": "158",
   "@_declcolumn": "18"
  },
  "@_kind": "function",
  "@_id": "video__enc__params_8h_1ad545c6225e84060f462e392033fa635c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates memory for AVVideoEncParams of the given type, plus an array of\n * {@code nb_blocks} AVVideoBlockParams and initializes the variables. Can be\n * freed with a normal av_free() call.\n *\n * @param out_size if non-NULL, the size in bytes of the resulting data array is\n * written here.\n */"
 },
 "av_video_enc_params_create_side_data": {
  "type": {
   "ref": {
    "#text": "AVVideoEncParams",
    "@_refid": "structAVVideoEncParams",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVVideoEncParams * av_video_enc_params_create_side_data",
  "argsstring": "(AVFrame *frame, enum AVVideoEncParamsType type, unsigned int nb_blocks)",
  "name": "av_video_enc_params_create_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": {
     "ref": {
      "#text": "AVVideoEncParamsType",
      "@_refid": "video__enc__params_8h_1af50af6452ba562f068d67dd2c0154fea",
      "@_kindref": "member"
     },
     "#text": "enum"
    },
    "declname": "type"
   },
   {
    "type": "unsigned int",
    "declname": "nb_blocks"
   }
  ],
  "briefdescription": {
   "para": {
    "javadoccode": [
     "nb_blocks",
     "frame"
    ],
    "ref": [
     {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     {
      "#text": "AVFrameSideData",
      "@_refid": "structAVFrameSideData",
      "@_kindref": "compound"
     }
    ],
    "#text": "Allocates memory for AVEncodeInfoFrame plus an array ofAVEncodeInfoBlock in the givenasof type AV_FRAME_DATA_VIDEO_ENC_PARAMS and initializes the variables."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/video_enc_params.h",
   "@_line": "168",
   "@_column": "1",
   "@_declfile": "libavutil/video_enc_params.h",
   "@_declline": "168",
   "@_declcolumn": "1"
  },
  "@_kind": "function",
  "@_id": "video__enc__params_8h_1a2a46d2136a349ed1c2664bb180e21c2c",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocates memory for AVEncodeInfoFrame plus an array of\n * {@code nb_blocks} AVEncodeInfoBlock in the given AVFrame {@code frame}\n * as AVFrameSideData of type AV_FRAME_DATA_VIDEO_ENC_PARAMS\n * and initializes the variables.\n */"
 },
 "av_video_hint_rects": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "AVVideoRect",
     "@_refid": "structAVVideoRect",
     "@_kindref": "compound"
    }
   ],
   "#text": "*"
  },
  "definition": "static av_always_inline AVVideoRect * av_video_hint_rects",
  "argsstring": "(const AVVideoHint *hints)",
  "name": "av_video_hint_rects",
  "param": {
   "type": {
    "ref": {
     "#text": "AVVideoHint",
     "@_refid": "structAVVideoHint",
     "@_kindref": "compound"
    },
    "#text": "const*"
   },
   "declname": "hints"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/video_hint.h",
   "@_line": "67",
   "@_column": "1",
   "@_bodyfile": "libavutil/video_hint.h",
   "@_bodystart": "67",
   "@_bodyend": "69"
  },
  "@_kind": "function",
  "@_id": "video__hint_8h_1ac582663b78204aecd0261feeb17f2d50",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "    /**\n     * Size in bytes of AVVideoRect.\n     */"
 },
 "av_video_hint_get_rect": {
  "type": {
   "ref": [
    {
     "#text": "av_always_inline",
     "@_refid": "attributes_8h_1a28f50f4c125959216885f01d56dbe866",
     "@_kindref": "member"
    },
    {
     "#text": "AVVideoRect",
     "@_refid": "structAVVideoRect",
     "@_kindref": "compound"
    }
   ],
   "#text": "*"
  },
  "definition": "static av_always_inline AVVideoRect * av_video_hint_get_rect",
  "argsstring": "(const AVVideoHint *hints, size_t idx)",
  "name": "av_video_hint_get_rect",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVVideoHint",
      "@_refid": "structAVVideoHint",
      "@_kindref": "compound"
     },
     "#text": "const*"
    },
    "declname": "hints"
   },
   {
    "type": "size_t",
    "declname": "idx"
   }
  ],
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/video_hint.h",
   "@_line": "72",
   "@_column": "1",
   "@_bodyfile": "libavutil/video_hint.h",
   "@_bodystart": "72",
   "@_bodyend": "74"
  },
  "@_kind": "function",
  "@_id": "video__hint_8h_1aa2c188a0da1e47ac224556c9ef951e26",
  "@_prot": "public",
  "@_static": "yes",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "    /**\n     * Size in bytes of AVVideoRect.\n     */"
 },
 "av_video_hint_alloc": {
  "type": {
   "ref": {
    "#text": "AVVideoHint",
    "@_refid": "structAVVideoHint",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVVideoHint * av_video_hint_alloc",
  "argsstring": "(size_t nb_rects, size_t *out_size)",
  "name": "av_video_hint_alloc",
  "param": [
   {
    "type": "size_t",
    "declname": "nb_rects"
   },
   {
    "type": "size_t *",
    "declname": "out_size"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "AVVideoHint",
      "@_refid": "structAVVideoHint",
      "@_kindref": "compound"
     },
     {
      "#text": "AVVideoRect",
      "@_refid": "structAVVideoRect",
      "@_kindref": "compound"
     }
    ],
    "#text": "Allocate memory for thestruct along with an nb_rects-sized arrays of."
   }
  },
  "detaileddescription": {
   "para": [
    "The side data contains a list of rectangles for the portions of the frame which changed from the last encoded one (and the remainder are assumed to be changed), or, alternately (depending on the type parameter) the unchanged ones (and the remanining ones are those which changed). Macroblocks will thus be hinted either to be P_SKIP-ped or go through the regular encoding procedure.",
    "It's responsibility of the caller to fill the AVRects accordingly, and to set the proper AVVideoHintType field.",
    {
     "parameterlist": {
      "parameteritem": {
       "parameternamelist": {
        "parametername": "out_size"
       },
       "parameterdescription": {
        "para": "if non-NULL, the size in bytes of the resulting data array is written here"
       }
      },
      "@_kind": "param"
     },
     "simplesect": {
      "para": {
       "ref": [
        {
         "#text": "AVVideoHint",
         "@_refid": "structAVVideoHint",
         "@_kindref": "compound"
        },
        {
         "#text": "av_free()",
         "@_refid": "group__lavu__mem__funcs_1ga0c9096f498624c525aa2315b8a20c411",
         "@_kindref": "member"
        }
       ],
       "#text": "newly allocatedstruct (must be freed by the caller using) on success, NULL on memory allocation failure"
      },
      "@_kind": "return"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/video_hint.h",
   "@_line": "96",
   "@_column": "13",
   "@_declfile": "libavutil/video_hint.h",
   "@_declline": "96",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "video__hint_8h_1ac58afc13f449cc401c0ea164e993a7ca",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate memory for the AVVideoHint struct along with an nb_rects-sized\n * arrays of AVVideoRect.\n *\n * The side data contains a list of rectangles for the portions of the frame\n * which changed from the last encoded one (and the remainder are assumed to be\n * changed), or, alternately (depending on the type parameter) the unchanged\n * ones (and the remanining ones are those which changed).\n * Macroblocks will thus be hinted either to be P_SKIP-ped or go through the\n * regular encoding procedure.\n *\n * It's responsibility of the caller to fill the AVRects accordingly, and to set\n * the proper AVVideoHintType field.\n *\n * @param out_size if non-NULL, the size in bytes of the resulting data array is\n *                 written here\n *\n * @return newly allocated AVVideoHint struct (must be freed by the caller using\n *         av_free()) on success, NULL on memory allocation failure\n */"
 },
 "av_video_hint_create_side_data": {
  "type": {
   "ref": {
    "#text": "AVVideoHint",
    "@_refid": "structAVVideoHint",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVVideoHint * av_video_hint_create_side_data",
  "argsstring": "(AVFrame *frame, size_t nb_rects)",
  "name": "av_video_hint_create_side_data",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVFrame",
      "@_refid": "structAVFrame",
      "@_kindref": "compound"
     },
     "#text": "*"
    },
    "declname": "frame"
   },
   {
    "type": "size_t",
    "declname": "nb_rects"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": [
     {
      "#text": "av_video_hint_alloc()",
      "@_refid": "video__hint_8h_1ac58afc13f449cc401c0ea164e993a7ca",
      "@_kindref": "member"
     },
     {
      "#text": "AVVideoHint",
      "@_refid": "structAVVideoHint",
      "@_kindref": "compound"
     }
    ],
    "#text": "Same as, except newly-allocatedis attached as side data of type AV_FRAME_DATA_VIDEO_HINT_INFO to frame."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/video_hint.h",
   "@_line": "103",
   "@_column": "13",
   "@_declfile": "libavutil/video_hint.h",
   "@_declline": "103",
   "@_declcolumn": "13"
  },
  "@_kind": "function",
  "@_id": "video__hint_8h_1a6ab91db18e71dddd21246f221ddd8f16",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Same as av_video_hint_alloc(), except newly-allocated AVVideoHint is attached\n * as side data of type AV_FRAME_DATA_VIDEO_HINT_INFO to frame.\n */"
 },
 "AVVorbisParseContext": {
  "type": {
   "ref": {
    "#text": "AVVorbisParseContext",
    "@_refid": "vorbis__parser_8h_1afe7b8c3bcf03727e31e1a6bedf4d1846",
    "@_kindref": "member"
   },
   "#text": "struct"
  },
  "definition": "typedef struct AVVorbisParseContext AVVorbisParseContext",
  "argsstring": "",
  "name": "AVVorbisParseContext",
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vorbis_parser.h",
   "@_line": "31",
   "@_column": "35",
   "@_bodyfile": "libavcodec/vorbis_parser.h",
   "@_bodystart": "31",
   "@_bodyend": "-1"
  },
  "@_kind": "typedef",
  "@_id": "vorbis__parser_8h_1afe7b8c3bcf03727e31e1a6bedf4d1846",
  "@_prot": "public",
  "@_static": "no",
  "raw": "/**\n * @file\n * A public API for Vorbis parsing\n *\n * Determines the duration for each packet.\n */"
 },
 "av_vorbis_parse_init": {
  "type": {
   "ref": {
    "#text": "AVVorbisParseContext",
    "@_refid": "vorbis__parser_8h_1afe7b8c3bcf03727e31e1a6bedf4d1846",
    "@_kindref": "member"
   },
   "#text": "*"
  },
  "definition": "AVVorbisParseContext * av_vorbis_parse_init",
  "argsstring": "(const uint8_t *extradata, int extradata_size)",
  "name": "av_vorbis_parse_init",
  "param": [
   {
    "type": "const uint8_t *",
    "declname": "extradata"
   },
   {
    "type": "int",
    "declname": "extradata_size"
   }
  ],
  "briefdescription": {
   "para": "Allocate and initialize the Vorbis parser using headers in the extradata."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vorbis_parser.h",
   "@_line": "36",
   "@_column": "22",
   "@_declfile": "libavcodec/vorbis_parser.h",
   "@_declline": "36",
   "@_declcolumn": "22"
  },
  "@_kind": "function",
  "@_id": "vorbis__parser_8h_1ac55f45db8da490ac8554932e38080124",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate and initialize the Vorbis parser using headers in the extradata.\n */"
 },
 "av_vorbis_parse_free": {
  "type": "void",
  "definition": "void av_vorbis_parse_free",
  "argsstring": "(AVVorbisParseContext **s)",
  "name": "av_vorbis_parse_free",
  "param": {
   "type": {
    "ref": {
     "#text": "AVVorbisParseContext",
     "@_refid": "vorbis__parser_8h_1afe7b8c3bcf03727e31e1a6bedf4d1846",
     "@_kindref": "member"
    },
    "#text": "**"
   },
   "declname": "s"
  },
  "briefdescription": {
   "para": "Free the parser and everything associated with it."
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vorbis_parser.h",
   "@_line": "42",
   "@_column": "6",
   "@_declfile": "libavcodec/vorbis_parser.h",
   "@_declline": "42",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "vorbis__parser_8h_1a09d3132681826153f26ff5a9ee36a30d",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Free the parser and everything associated with it.\n */"
 },
 "av_vorbis_parse_frame_flags": {
  "type": "int",
  "definition": "int av_vorbis_parse_frame_flags",
  "argsstring": "(AVVorbisParseContext *s, const uint8_t *buf, int buf_size, int *flags)",
  "name": "av_vorbis_parse_frame_flags",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVVorbisParseContext",
      "@_refid": "vorbis__parser_8h_1afe7b8c3bcf03727e31e1a6bedf4d1846",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "const uint8_t *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buf_size"
   },
   {
    "type": "int *",
    "declname": "flags"
   }
  ],
  "briefdescription": {
   "para": "Get the duration for a Vorbis packet."
  },
  "detaileddescription": {
   "para": [
    {
     "computeroutput": [
      "flags",
      "NULL"
     ],
     "#text": "Ifis, special frames are considered invalid."
    },
    {
     "parameterlist": {
      "parameteritem": [
       {
        "parameternamelist": {
         "parametername": "s"
        },
        "parameterdescription": {
         "para": "Vorbis parser context"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf"
        },
        "parameterdescription": {
         "para": "buffer containing a Vorbis frame"
        }
       },
       {
        "parameternamelist": {
         "parametername": "buf_size"
        },
        "parameterdescription": {
         "para": "size of the buffer"
        }
       },
       {
        "parameternamelist": {
         "parametername": "flags"
        },
        "parameterdescription": {
         "para": "flags for special frames"
        }
       }
      ],
      "@_kind": "param"
     }
    }
   ]
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vorbis_parser.h",
   "@_line": "59",
   "@_column": "5",
   "@_declfile": "libavcodec/vorbis_parser.h",
   "@_declline": "59",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "vorbis__parser_8h_1a1e1b41858faedc564fc7a01b0eb910d9",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the duration for a Vorbis packet.\n *\n * If @p flags is @c NULL,\n * special frames are considered invalid.\n *\n * @param s        Vorbis parser context\n * @param buf      buffer containing a Vorbis frame\n * @param buf_size size of the buffer\n * @param flags    flags for special frames\n */"
 },
 "av_vorbis_parse_frame": {
  "type": "int",
  "definition": "int av_vorbis_parse_frame",
  "argsstring": "(AVVorbisParseContext *s, const uint8_t *buf, int buf_size)",
  "name": "av_vorbis_parse_frame",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVVorbisParseContext",
      "@_refid": "vorbis__parser_8h_1afe7b8c3bcf03727e31e1a6bedf4d1846",
      "@_kindref": "member"
     },
     "#text": "*"
    },
    "declname": "s"
   },
   {
    "type": "const uint8_t *",
    "declname": "buf"
   },
   {
    "type": "int",
    "declname": "buf_size"
   }
  ],
  "briefdescription": {
   "para": "Get the duration for a Vorbis packet."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "s"
       },
       "parameterdescription": {
        "para": "Vorbis parser context"
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf"
       },
       "parameterdescription": {
        "para": "buffer containing a Vorbis frame"
       }
      },
      {
       "parameternamelist": {
        "parametername": "buf_size"
       },
       "parameterdescription": {
        "para": "size of the buffer"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vorbis_parser.h",
   "@_line": "69",
   "@_column": "5",
   "@_declfile": "libavcodec/vorbis_parser.h",
   "@_declline": "69",
   "@_declcolumn": "5"
  },
  "@_kind": "function",
  "@_id": "vorbis__parser_8h_1a38e589e502d8e826a20de786212de7dd",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the duration for a Vorbis packet.\n *\n * @param s        Vorbis parser context\n * @param buf      buffer containing a Vorbis frame\n * @param buf_size size of the buffer\n */"
 },
 "av_vorbis_parse_reset": {
  "type": "void",
  "definition": "void av_vorbis_parse_reset",
  "argsstring": "(AVVorbisParseContext *s)",
  "name": "av_vorbis_parse_reset",
  "param": {
   "type": {
    "ref": {
     "#text": "AVVorbisParseContext",
     "@_refid": "vorbis__parser_8h_1afe7b8c3bcf03727e31e1a6bedf4d1846",
     "@_kindref": "member"
    },
    "#text": "*"
   },
   "declname": "s"
  },
  "briefdescription": "",
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavcodec/vorbis_parser.h",
   "@_line": "72",
   "@_column": "6",
   "@_declfile": "libavcodec/vorbis_parser.h",
   "@_declline": "72",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "vorbis__parser_8h_1aed1dc9b8a89052c3203469e59b390a92",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Get the duration for a Vorbis packet.\n *\n * @param s        Vorbis parser context\n * @param buf      buffer containing a Vorbis frame\n * @param buf_size size of the buffer\n */"
 },
 "av_xtea_alloc": {
  "type": {
   "ref": {
    "#text": "AVXTEA",
    "@_refid": "structAVXTEA",
    "@_kindref": "compound"
   },
   "#text": "*"
  },
  "definition": "AVXTEA * av_xtea_alloc",
  "argsstring": "(void)",
  "name": "av_xtea_alloc",
  "param": {
   "type": "void"
  },
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVXTEA",
     "@_refid": "structAVXTEA",
     "@_kindref": "compound"
    },
    "#text": "Allocate ancontext."
   }
  },
  "detaileddescription": "",
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/xtea.h",
   "@_line": "42",
   "@_column": "8",
   "@_declfile": "libavutil/xtea.h",
   "@_declline": "42",
   "@_declcolumn": "8"
  },
  "@_kind": "function",
  "@_id": "group__lavu__xtea_1ga26cb58166f22a6eaef74a9fe0437ad42",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Allocate an AVXTEA context.\n */"
 },
 "av_xtea_init": {
  "type": "void",
  "definition": "void av_xtea_init",
  "argsstring": "(struct AVXTEA *ctx, const uint8_t key[16])",
  "name": "av_xtea_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVXTEA",
      "@_refid": "structAVXTEA",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "ctx"
   },
   {
    "type": "const uint8_t",
    "declname": "key",
    "array": "[16]"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVXTEA",
     "@_refid": "structAVXTEA",
     "@_kindref": "compound"
    },
    "#text": "Initialize ancontext."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVXTEA",
          "@_refid": "structAVXTEA",
          "@_kindref": "compound"
         },
         "#text": "ancontext"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "a key of 16 bytes used for encryption/decryption, interpreted as big endian 32 bit numbers"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/xtea.h",
   "@_line": "51",
   "@_column": "6",
   "@_declfile": "libavutil/xtea.h",
   "@_declline": "51",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__xtea_1ga015fbc7f1062f11900dcf1c6352f2156",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize an AVXTEA context.\n *\n * @param ctx an AVXTEA context\n * @param key a key of 16 bytes used for encryption/decryption,\n *            interpreted as big endian 32 bit numbers\n */"
 },
 "av_xtea_le_init": {
  "type": "void",
  "definition": "void av_xtea_le_init",
  "argsstring": "(struct AVXTEA *ctx, const uint8_t key[16])",
  "name": "av_xtea_le_init",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVXTEA",
      "@_refid": "structAVXTEA",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "ctx"
   },
   {
    "type": "const uint8_t",
    "declname": "key",
    "array": "[16]"
   }
  ],
  "briefdescription": {
   "para": {
    "ref": {
     "#text": "AVXTEA",
     "@_refid": "structAVXTEA",
     "@_kindref": "compound"
    },
    "#text": "Initialize ancontext."
   }
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVXTEA",
          "@_refid": "structAVXTEA",
          "@_kindref": "compound"
         },
         "#text": "ancontext"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "key"
       },
       "parameterdescription": {
        "para": "a key of 16 bytes used for encryption/decryption, interpreted as little endian 32 bit numbers"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/xtea.h",
   "@_line": "60",
   "@_column": "6",
   "@_declfile": "libavutil/xtea.h",
   "@_declline": "60",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__xtea_1ga95fcfa52ff3a9974ca6fdae6a0e6a618",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Initialize an AVXTEA context.\n *\n * @param ctx an AVXTEA context\n * @param key a key of 16 bytes used for encryption/decryption,\n *            interpreted as little endian 32 bit numbers\n */"
 },
 "av_xtea_crypt": {
  "type": "void",
  "definition": "void av_xtea_crypt",
  "argsstring": "(struct AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt)",
  "name": "av_xtea_crypt",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVXTEA",
      "@_refid": "structAVXTEA",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "uint8_t *",
    "declname": "iv"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypt or decrypt a buffer using a previously initialized context, in big endian format."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVXTEA",
          "@_refid": "structAVXTEA",
          "@_kindref": "compound"
         },
         "#text": "ancontext"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of 8 byte blocks"
       }
      },
      {
       "parameternamelist": {
        "parametername": "iv"
       },
       "parameterdescription": {
        "para": "initialization vector for CBC mode, if NULL then ECB will be used"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/xtea.h",
   "@_line": "73",
   "@_column": "6",
   "@_declfile": "libavutil/xtea.h",
   "@_declline": "73",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__xtea_1gaeaf213c9d74ba6d6b3769bda4ce283fc",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Encrypt or decrypt a buffer using a previously initialized context,\n * in big endian format.\n *\n * @param ctx an AVXTEA context\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param count number of 8 byte blocks\n * @param iv initialization vector for CBC mode, if NULL then ECB will be used\n * @param decrypt 0 for encryption, 1 for decryption\n */"
 },
 "av_xtea_le_crypt": {
  "type": "void",
  "definition": "void av_xtea_le_crypt",
  "argsstring": "(struct AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt)",
  "name": "av_xtea_le_crypt",
  "param": [
   {
    "type": {
     "ref": {
      "#text": "AVXTEA",
      "@_refid": "structAVXTEA",
      "@_kindref": "compound"
     },
     "#text": "struct*"
    },
    "declname": "ctx"
   },
   {
    "type": "uint8_t *",
    "declname": "dst"
   },
   {
    "type": "const uint8_t *",
    "declname": "src"
   },
   {
    "type": "int",
    "declname": "count"
   },
   {
    "type": "uint8_t *",
    "declname": "iv"
   },
   {
    "type": "int",
    "declname": "decrypt"
   }
  ],
  "briefdescription": {
   "para": "Encrypt or decrypt a buffer using a previously initialized context, in little endian format."
  },
  "detaileddescription": {
   "para": {
    "parameterlist": {
     "parameteritem": [
      {
       "parameternamelist": {
        "parametername": "ctx"
       },
       "parameterdescription": {
        "para": {
         "ref": {
          "#text": "AVXTEA",
          "@_refid": "structAVXTEA",
          "@_kindref": "compound"
         },
         "#text": "ancontext"
        }
       }
      },
      {
       "parameternamelist": {
        "parametername": "dst"
       },
       "parameterdescription": {
        "para": "destination array, can be equal to src"
       }
      },
      {
       "parameternamelist": {
        "parametername": "src"
       },
       "parameterdescription": {
        "para": "source array, can be equal to dst"
       }
      },
      {
       "parameternamelist": {
        "parametername": "count"
       },
       "parameterdescription": {
        "para": "number of 8 byte blocks"
       }
      },
      {
       "parameternamelist": {
        "parametername": "iv"
       },
       "parameterdescription": {
        "para": "initialization vector for CBC mode, if NULL then ECB will be used"
       }
      },
      {
       "parameternamelist": {
        "parametername": "decrypt"
       },
       "parameterdescription": {
        "para": "0 for encryption, 1 for decryption"
       }
      }
     ],
     "@_kind": "param"
    }
   }
  },
  "inbodydescription": "",
  "location": {
   "@_file": "libavutil/xtea.h",
   "@_line": "87",
   "@_column": "6",
   "@_declfile": "libavutil/xtea.h",
   "@_declline": "87",
   "@_declcolumn": "6"
  },
  "@_kind": "function",
  "@_id": "group__lavu__xtea_1gaec55b57021e2b6fd48f9e12a0a3a2724",
  "@_prot": "public",
  "@_static": "no",
  "@_const": "no",
  "@_explicit": "no",
  "@_inline": "no",
  "@_virt": "non-virtual",
  "raw": "/**\n * Encrypt or decrypt a buffer using a previously initialized context,\n * in little endian format.\n *\n * @param ctx an AVXTEA context\n * @param dst destination array, can be equal to src\n * @param src source array, can be equal to dst\n * @param count number of 8 byte blocks\n * @param iv initialization vector for CBC mode, if NULL then ECB will be used\n * @param decrypt 0 for encryption, 1 for decryption\n */"
 }
}